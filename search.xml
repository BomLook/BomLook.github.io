<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二次剩余</title>
      <link href="/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
      <url>/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>还没写好，可能这几天补好</p><hr /><h1 id="二次剩余">二次剩余</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/166123245">算法学习笔记(41): 二次剩余- 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><p><strong>二次剩余</strong>，常被称为模意义开根，是求满足<spanclass="math inline">\(n\equiv x^2(mod\ m)\)</span>的<spanclass="math inline">\(x\)</span>的值。</p><p>首先需要注意，并不是对每个<spanclass="math inline">\(n\)</span>而言上面的方程都有解。如果上面的方程有非零解，我们称<spanclass="math inline">\(n\)</span>是模<spanclass="math inline">\(m\)</span>的<strong>二次剩余</strong>。如果方程无解，则称<spanclass="math inline">\(n\)</span>是模<spanclass="math inline">\(m\)</span>的<strong>二次非剩余</strong>。</p><p>为了方便讨论，我们引入<strong>勒让德符号</strong>：</p>$ ()={<span class="math display">\[\begin{aligned}1     &amp;  \, 如果a是p的二次剩余\\0     &amp;  \, 如果a\ mod\ p=0\\{-1}  &amp;  \, 如果a是p的二次非剩余\end{aligned}\]</span><p>. $</p><p>接下来讨论如何求解二次剩余，一般只考虑奇素数的情况。</p><hr /><h2 id="欧拉准则">欧拉准则</h2><p>当模数是奇素数<span class="math inline">\(p\)</span>且与<spanclass="math inline">\(a\)</span>互质时，由费马小定理，<spanclass="math inline">\(a^{p-1}\equiv1\ (mod\ p)\)</span>，设<spanclass="math inline">\(p=2q+1\)</span>，</p><p>则有<span class="math inline">\(a^{2q}\equiv 1\ (mod\p)\)</span>，于是<span class="math inline">\((a^q-1)(a^q+1)\equiv 0\(mod\ p)\)</span>，故<span class="math inline">\(a^q\equiv \pm1 (mod\p)\)</span>，即<span class="math inline">\(a^{\frac{p-1}{2}}\equiv\pm1\(mod\ p)\)</span>。</p><p>所以只要<span class="math inline">\(a、p\)</span>互质，<spanclass="math inline">\(a^{\frac{p-1}{2}}\)</span>在模<spanclass="math inline">\(p\)</span>意义下就只可能等于<spanclass="math inline">\(1\)</span>或<spanclass="math inline">\({-1}\)</span>。到底是<spanclass="math inline">\(1\)</span>还是<spanclass="math inline">\({-1}\)</span>，这与二次剩余紧密相关，实际上，有以下公式：</p><blockquote><p><span class="math inline">\((\frac{a}{p})\equiva^{\frac{p-1}{2}}(mod\ p)\)</span></p></blockquote><p>以上公式被称为<strong>欧拉准则</strong>，我们只需要计算<spanclass="math inline">\(a^{\frac{p-1}{2}}\)</span>即可判断<spanclass="math inline">\(a\)</span>是否为<spanclass="math inline">\(p\)</span>的二次剩余。</p><hr /><p>这里实际上有一个<strong>证明</strong>：“<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余”是"<spanclass="math inline">\(a^{\frac{p-1}{2}}\equiv 1(mod\p)\)</span>"的充要条件。</p><p>但是目前没时间写，可能过两天再写。咕咕咕</p><hr /><p>由此可以有一个推论：当<spanclass="math inline">\(\frac{p-1}{2}\)</span>是奇数时，如果<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余，则<spanclass="math inline">\({-a}\)</span>是mo<spanclass="math inline">\(p\)</span>的二次非剩余。相反，当<spanclass="math inline">\(\frac{p-1}{2}\)</span>是偶数时，如果<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余，则<spanclass="math inline">\({-a}\)</span>也是模<spanclass="math inline">\(p\)</span>的二次剩余。</p><hr />]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉筛">欧拉筛</h1><p>文章部分内容转载自<ahref="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 -知乎 (zhihu.com)</a>、<ahref="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏(luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr /><p>不想再写一遍原理了qwq（如果忘记原理就去看看大佬们的详细证明吧，感觉注释也说得很清楚了@w@）。</p><p><a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17):素数筛 - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 -洛谷专栏 (luogu.com.cn)</a></p><p>所以我就直接贴上欧拉筛的模板了。</p><hr /><blockquote><h1 id="模板线性筛素数">【模板】线性筛素数</h1><h2 id="题目背景">题目背景</h2><p>本题已更新，从判断素数改为了查询第 <spanclass="math inline">\(k\)</span> 小的素数<br />提示：如果你使用 <code>cin</code> 来读入，建议使用<code>std::ios::sync_with_stdio(0)</code> 来加速。</p><h2 id="题目描述">题目描述</h2><p>如题，给定一个范围 <span class="math inline">\(n\)</span>，有 <spanclass="math inline">\(q\)</span> 个询问，每次输出第 <spanclass="math inline">\(k\)</span> 小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,q\)</span>，分别表示查询的范围和查询的个数。</p><p>接下来 <span class="math inline">\(q\)</span> 行每行一个正整数 <spanclass="math inline">\(k\)</span>，表示查询第 <spanclass="math inline">\(k\)</span> 小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出 <span class="math inline">\(q\)</span>行，每行一个正整数表示答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【数据范围】<br />对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n = 10^8\)</span>，<span class="math inline">\(1\le q \le 10^6\)</span>，保证查询的素数不大于 <spanclass="math inline">\(n\)</span>。</p><p>Data by NaCly_Fish.</p></blockquote><p><strong>学委大佬的代码</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> isPrime[N];<span class="comment">//isPrime[i]==1表示：i是质数</span></span><br><span class="line"><span class="type">int</span> Prime[N], cnt = <span class="number">0</span>;<span class="comment">//Prime存质数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="number">1</span>, <span class="built_in">sizeof</span>(isPrime));</span><br><span class="line"><span class="comment">//以“每个数都是素数”为初始状态，逐个删去</span></span><br><span class="line">isPrime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//1不是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;<span class="comment">//没被筛掉</span></span><br><span class="line">Prime[++cnt] = i;<span class="comment">//i成为下一个素数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span></span><br><span class="line"><span class="comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span></span><br><span class="line">isPrime[i * Prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="built_in">getPrime</span>(n);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; Prime[k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pecco</strong>大佬的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isnp[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 质数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>两者的写法其实很相似了，如果忘记了原理，可以先看看<strong>学委大佬</strong>的，要写题的话，推荐用<strong>pecco</strong>大佬的板子。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="中国剩余定理">中国剩余定理</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/103394468">算法学习笔记(10):中国剩余定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><p><strong>中国剩余定理</strong>，也叫<strong>孙子定理</strong>，之所以叫这个名字，是因为《孙子算经》中有这样一个问题：</p><blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><p>实际上就是求解下面的<strong>同余方程组</strong>： <spanclass="math display">\[\left\{\begin{aligned}x &amp; \equiv b_1 &amp; (mod\ a_1)\\x &amp; \equiv b_2 &amp; (mod\ a_2)\\x &amp; \equiv b_n &amp; (mod\ a_n)\end{aligned}\right.\]</span> 这个方程组有解的一个<strong>充分条件</strong>是：<spanclass="math inline">\(a_1、a_2······a_n\)</span><strong>两两互质</strong>，可以使用构造法得到下面方程的通解，一下面这道模板题为例：</p><p>（<strong>洛谷P1495 曹冲养猪</strong>）</p><blockquote><p><strong>题目描述</strong>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有16头母猪，如果建了3个猪圈，剩下1头猪就没有地方安家了。如果建造了5个猪圈，但是仍然有1头猪没有地方去，然后如果建造了7个猪圈，还有2头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？<strong>输入格式</strong> 第一行包含一个整数<spanclass="math inline">\(n\ (n\leq10)——\)</span>建立猪圈的次数，解下来n行，每行两个整数<spanclass="math inline">\(a_i,b_i\ (b_i\leq a_i\leq1000)\)</span>表示建立了<spanclass="math inline">\(a_i\)</span>个猪圈，有<spanclass="math inline">\(b_i\)</span>头猪没有去处。你可以假定<spanclass="math inline">\(a_i,a_j\)</span>互质. <strong>输出格式</strong>输出包含一个正整数，即为曹冲至少养母猪的数目。</p></blockquote><p>(本质上就是给“物不知数”套了个背景)。</p><hr /><p>我们从“物不知数”这个具体问题出发。<strong>（接下来一大波数学公式，请做好心理再看）</strong></p><p>要想直接找到一个<span class="math inline">\(n\)</span>使得方程组<spanclass="math inline">\(\left\{\begin{aligned}x &amp; \equiv 2 &amp;(mod\ 3)\\y &amp; \equiv 3 &amp;(mod\ 5)\\z &amp; \equiv 2 &amp;(mod\ 7)\end{aligned}\right.\)</span> 成立时不容易的，但是要找到</p><p><span class="math inline">\(n_1,n_2,n_3\)</span>使得<spanclass="math inline">\(\left\{\begin{aligned}n_1 &amp; \equiv 2&amp; (mod\ 3) \\n_2 &amp; \equiv 3&amp; (mod\ 5) \\n_3 &amp; \equiv 2&amp; (mod\ 7)\end{aligned}\right.\)</span>是相对容易的。</p><p>直接令<spanclass="math inline">\(x=n_1+n_2+n_3\)</span>可以吗？恐怕未必。在什么情况下<spanclass="math inline">\(n_1\equiv 2(mod\ 3)\)</span>可以推出<spanclass="math inline">\(n_1+n_2\equiv2(mod\3)\)</span>呢？显然，那只有当<spanclass="math inline">\(n_2\)</span>是3的倍数时成立。同理，要想让<spanclass="math inline">\(n_1+n_2+n_3\)</span>也符合前式，也需要<spanclass="math inline">\(n_2\)</span>和<spanclass="math inline">\(n_3\)</span>都是3的倍数。</p><p>这样推导下来，<spanclass="math inline">\(x=n_1+n_2+n_3\)</span>符合方程组的条件是<spanclass="math inline">\(n_1\)</span>是35的倍数，<spanclass="math inline">\(n_2\)</span>是21的倍数，<spanclass="math inline">\(n_3\)</span>是15的倍数。也就是说，现在我们需要求三个同余方程：</p><p><span class="math inline">\(\left\{\begin{aligned}35m_1 &amp; \equiv 2 &amp; (mod\ 3) \\21m_2 &amp; \equiv 3 &amp; (mod\ 5) \\15m_3 &amp; \equiv 2 &amp; (mod\ 7)\end{aligned}\right.\)</span></p><p>注意到模数两两互质，则<spanclass="math inline">\(gcd(35,3)=gcd(21,5)=gcd(15,7)=1\)</span>，所以我们可以用拓展欧几里得的方法解（我愿称之为最妙的一步<strong>qwq</strong>，这里用的是求逆元的方法）：</p>$ {<span class="math display">\[\begin{aligned}35w_1 &amp; \equiv 1&amp; (mod\ 3) \\21w_2 &amp; \equiv 1&amp; (mod\ 5)\\15w_3 &amp; \equiv 1&amp; (mod\ 7)\end{aligned}\]</span><p>. $</p><p>解得<spanclass="math inline">\(w_1=2,w_2=1,w_3=1\)</span>，然后可得：<spanclass="math inline">\(\left\{\begin{aligned}m_1 &amp; =2w_1=4 \\m_2 &amp; =3w_2=3 \\m_3 &amp; =2w_3=2\end{aligned}\right.\)</span></p><p>于是：<span class="math inline">\(\left\{\begin{aligned}n_1 &amp; = 35m_1=140 \\n_2 &amp; = 21m_2=63 \\n_3 &amp; = 15m_3=30\end{aligned}\right.\)</span>。</p><p>三者相加，即得一<strong>特解233</strong>（这里的233不是网络意义下的233，但我算出来不禁233了）。所有与233在<strong>模</strong>105<strong>意义下同余</strong>的数都是这个方程组的解，要求<strong>最小正数解</strong>只需对105取模即可，这里得出来是<strong>23</strong>。</p><hr /><p>接下来将这个过程一般化（<strong>个人感觉严重劝退qwq</strong>）。设<spanclass="math inline">\(p=\prod_{i=1}^{n}a_i\)</span>（即所有模数的乘积），并设<spanclass="math inline">\(r_i=\frac{p}{a_i}\)</span>（在“物不知数”中即为35、21和15）。于是<spanclass="math inline">\(w_i={inv(r_i)|}_{a_i}\)</span>（表示<spanclass="math inline">\(r_i\)</span>在模<spanclass="math inline">\(a_i\)</span>意义下的逆元），<spanclass="math inline">\(m_i=b_iw_i\)</span>，而<spanclass="math inline">\(n_i=r_im_i\)</span>，所有<spanclass="math inline">\(n_i\)</span>相加得到<spanclass="math inline">\(x\)</span>。</p><p>以上这些综合起来就是：</p><p><span class="math inline">\(x\equiv\sum_{i=1}^nb_ir_i{[r_i]^{-1}|}_{a_i}\ (mod\ p)\)</span></p><p>下面贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span>  <span class="comment">// a是模数数组，b是余数数组，n是数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;   <span class="comment">// 逆元的求法参见上篇文章，或者下面有完整代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的是符合方程组的最小正整数解，一般题目要求的就是这个。</p><p>再附上曹冲养猪的完整AC代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, a[<span class="number">10</span>], b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, a + i, b + i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">CRT</span>(a, b, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>自己的实现（其实就是照抄作者的qwq）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(ll a[],ll b[],ll n)</span></span>&#123;</span><br><span class="line">    ll p=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p*=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll r=p/a[i];</span><br><span class="line">        x+=(b[i]*r*<span class="built_in">inv</span>(r,a[i]))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">CRT</span>(a,b,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元</title>
      <link href="/2024/03/18/%E9%80%86%E5%85%83/"/>
      <url>/2024/03/18/%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="逆元">逆元</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/100587745">算法学习笔记(9)：逆元 -知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><h2 id="逆元的引入">逆元的引入</h2><p>在数论中，如果<span class="math inline">\(ab\equiv1(mod\p)\)</span>，我们就说<span class="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>在模<spanclass="math inline">\(p\)</span>意义下互为乘法逆元，记作<spanclass="math inline">\(a=inv(b)\)</span>。</p><p>为什么要引入逆元？常常会遇到一些题目要求结果对一个大质数<spanclass="math inline">\(p\)</span>取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。<strong>加减法</strong>和<strong>乘法</strong>对取模运算都是<strong>封闭</strong>的，所以你可以处处取模来避免溢出。</p><p><img src="https://img2.imgtp.com/2024/03/18/RqrxFVdZ.png" /></p><p>但是遇到除法时，就麻烦了：</p><p><img src="https://img2.imgtp.com/2024/03/18/AdajgadB.png" /></p><p>为了解决模意义下的除法问题，我们引入了逆元。<spanclass="math inline">\(inv(a)\)</span>其实可以看作是模<spanclass="math inline">\(p\)</span>意义下的<spanclass="math inline">\(\frac{1}{a}\)</span>，那么在模<spanclass="math inline">\(p\)</span>意义下，<spanclass="math inline">\(\frac{a}{b}\)</span>就可以变成<spanclass="math inline">\(a*inv(b)(mod\ p)\)</span>。</p><p>实际上，在模10意义下的<spanclass="math inline">\(inv(3)=7\)</span>，所以上面的式子可以这样计算：</p><p><img src="https://img2.imgtp.com/2024/03/18/mah9Ky6H.png" /></p><p>这里介绍三种计算逆元的方法：<strong>拓展欧几里得</strong>，<strong>费马小定理</strong>，<strong>线性递推</strong>。</p><hr /><h2 id="拓展欧几里得">拓展欧几里得</h2><p>最常用的求逆元方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span><span class="comment">// 拓欧</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exgcd</span>(a, p, x, y) != <span class="number">1</span>) <span class="comment">// 无解的情形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="费马小定理">费马小定理</h2><p>费马小定理叙述如下：</p><blockquote><p>若<span class="math inline">\(p\)</span>是质数，且<spanclass="math inline">\(gcd(a,p)=1\)</span>，则有<spanclass="math inline">\(a^{p-1}\equiv1(mod\ p)\)</span></p></blockquote><p>从逆元的定义可以推导：<span class="math inline">\(a*inv(a)\equiva^{p-1}(mod\ p)\)</span>，于是有<span class="math inline">\(inv(a)\equiva^{p-2}(mod\ p)\)</span>。</p><p>于是对<spanclass="math inline">\(a^{p-2}\)</span>算一下<strong>快速幂</strong>即可。注意：这个方法的前提是：<spanclass="math inline">\(p\)</span>是质数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll p)</span><span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans % p * a % p;</span><br><span class="line">        a = a % p * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="线性递推">线性递推</h2><p>以上两种方法都是常用的求逆元方法，但是，洛谷上的这道毒瘤模板题，必须要用特殊的方法：</p><p>（<strong>洛谷P3811 【模板】乘法逆元</strong>）</p><blockquote><p><strong>题目背景</strong> 这是一道模板题 <strong>题目描述</strong>给定<span class="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span> ，求 <span class="math inline">\(1 \simn\)</span>中所有整数在模<spanclass="math inline">\(p\)</span>意义下的乘法逆元。<strong>输入格式</strong> 一行两个正整数<spanclass="math inline">\(n,p\)</span>。 <strong>输出格式</strong> 输出<spanclass="math inline">\(n\)</span>行，第<spanclass="math inline">\(i\)</span>行表示<spanclass="math inline">\(i\)</span>在模<spanclass="math inline">\(p\)</span>下的乘法逆元。</p></blockquote><p>因为这道题要求一系列的乘法逆元，而且数据范围是$1n*10^{6} $，常规方法是行不通的。这里介绍逆元的<strong>线性递推</strong>求法（需保证<spanclass="math inline">\(p\)</span>是质数）。</p><p>设<span class="math inline">\(p=aq+r\)</span>，即<spanclass="math inline">\(q=\lfloor p/a \rfloor，r=p\ mod\ a\)</span>。</p><p>在模<span class="math inline">\(p\)</span>意义下，有<spanclass="math inline">\(aq+r\equiv 0\ (mod\ p)\)</span>。</p><p>整理可得：<span class="math inline">\(a=-r*inv(q)\ (mod\p)\)</span>。</p><p>那么<span class="math inline">\(inv(a)=-q*inv(r)\ (mod\p)\)</span>。</p><p>即：<span class="math inline">\(inv(a)=-\lfloor p/a \rfloor *inv(p\mod\ a)\ (mod\ p)\)</span>。</p><p>其实和拓展欧几里得还是有不少相似之处的。我们可以用<strong>记忆化搜索</strong>的方法，减少多次查询的时间复杂度（空间换时间）。（<strong>递推</strong>亦可，其实就这题而言递推更好）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多次对不同的p使用需要清空Inv数组</span></span><br><span class="line">ll Inv[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mod</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Inv[a])</span><br><span class="line">        <span class="keyword">return</span> Inv[a];</span><br><span class="line">    Inv[a] = <span class="built_in">mod</span>(-p / a * <span class="built_in">inv</span>(p % a, p), p);</span><br><span class="line">    <span class="keyword">return</span> Inv[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;inv[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得</title>
      <link href="/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧几里得">拓展欧几里得</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a></p><p>如有侵权，请联系作者删除</p><h2 id="辗转相除法">辗转相除法</h2><p>在介绍拓展欧几里得算法之前，先看看<strong>欧几里得算法</strong>（又称<strong>辗转相除法</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除法，求两个数的最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理这里省略，详情请参考原作者的文章：<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a></p><h2 id="拓展欧几里得-1">拓展欧几里得</h2><p>拓展欧几里得是可以在<strong>辗转相除</strong>的途中求出不定方程<spanclass="math inline">\(ax+by=c\)</span>的一组解</p><p><img src="https://img2.imgtp.com/2024/03/17/US3JbpKq.png" /></p><p>可以发现：倒数第二行的<spanclass="math inline">\(3+6*3=21\)</span>，可以改写成<spanclass="math inline">\(3=6*(-3)+21\)</span>，也就是说：3可以被表示为6和21的线性组合。</p><p>倒数第三行，<spanclass="math inline">\(6+21*1=27\)</span>，说明6可以被表示为21和27的线性组合，那么3也可以被表示为21和27的线性组合。具体地：</p><p><spanclass="math inline">\(3=6*(-3)+21=(27-21)*(-3)+21=27*(-3)+21*4\)</span></p><p>这样一路推导下来，可以得到3表示为75和48的线性组合。那么<spanclass="math inline">\(75x+48y=3\)</span>就能找到解了。</p><p>由上文可以得到求解<spanclass="math inline">\(ax+by=gcd(a,b)\)</span>的一种方法。但如果<spanclass="math inline">\(c\)</span>是其他数呢？</p><p>实际上，<span class="math inline">\(c\)</span>必须是 <spanclass="math inline">\(gcd(a,b)\)</span>的倍数，因为我们由方程 <spanclass="math inline">\(ax+by=c\)</span> 两边除以 <spanclass="math inline">\(gcd(a,b)\)</span> 可得 <spanclass="math inline">\(\frac{a}{gcd(a,b)}x+\frac{b}{gcd(a,b)}y=\frac{c}{gcd(a,b)}\)</span>，方程左边当然是整数，那么方程右边也必须是整数。所以<spanclass="math inline">\(c\)</span>是<spanclass="math inline">\(gcd(a,b)\)</span>的倍数。</p><p>这其实上是一个数论定理：</p><blockquote><p><strong>裴蜀定理</strong></p><p>设<span class="math inline">\(a、b\)</span>为正整数，则关于<spanclass="math inline">\(x、y\)</span>的方程<spanclass="math inline">\(ax+by=c\)</span>有整数解当且仅当<spanclass="math inline">\(c\)</span>是<spanclass="math inline">\(gcd(a,b)\)</span>的倍数</p></blockquote><p><img src="https://img2.imgtp.com/2024/03/17/ohJDTt3U.png" /></p><p>可以发现，通过求<span class="math inline">\(bx_0+(a\ mod\b)y_0=c\)</span>的解，可以得出<spanclass="math inline">\(ax+by=c\)</span>的解。</p><p>前者等价于<span class="math inline">\(bx_0+(a-\lfloor a/b\rfloor)y_0=c\)</span>，也就是<spanclass="math inline">\(ay_0+b(x_0-\lfloor a/b \rfloory_0)=c\)</span>，可以对比两者的系数，可以让： <spanclass="math display">\[\left\{\begin{aligned}x &amp; =  y_0 \\y &amp; =  x_0-\lfloor a/b \rfloor y_0 \\\end{aligned}\right.\]</span> 当<spanclass="math inline">\(b==0\)</span>时递归结束即可，简化版如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">//这里交换了x和y</span></span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（这里其实有个普通版的，但是我偷懒了，直接搬了简化版qwq，若谷想看原版的，或者进一步探究原理的可以看看原文章：<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a>）</strong></p><hr /><p>这样我们求出来的<spanclass="math inline">\(ax+by=gcd(a,b)\)</span>的一组特解，那么通解是什么？</p><p>设除了已经求出来的<spanclass="math inline">\(x,y\)</span>之外还有一组解<spanclass="math inline">\(x_1=x+\delta\)</span>和<spanclass="math inline">\(y_1\)</span>，那么由<spanclass="math inline">\(ax_1-a\delta+by==gcd(a,b)\)</span>，可以得到<spanclass="math inline">\(ax_1+b(y-\frac{a\delta}{b})=gcd(a,b)\)</span>，可以得到：</p><p><span class="math inline">\(y_1=y-\frac{a\delta}{b}\)</span>。</p><p>注意：我们还需要保证<spanclass="math inline">\(\delta\)</span>和<spanclass="math inline">\(\frac{a\delta}{b}\)</span>都是整数，后者等于<spanclass="math inline">\(\frac{a&#39;}{b&#39;}\delta\)</span>，其中： <spanclass="math display">\[\left\{\begin{aligned}a&#39; &amp; =  \frac{a}{gcd(a,b)} \\b&#39; &amp; =  \frac{b}{gcd(a,b)} \\\end{aligned}\right.\]</span> 由于<spanclass="math inline">\(a&#39;、b&#39;\)</span>互质，<spanclass="math inline">\(\delta\)</span>应当等于<spanclass="math inline">\(kb&#39;\)</span>（<spanclass="math inline">\(k\)</span>是整数），即： <spanclass="math display">\[\left\{\begin{aligned}x_k &amp; =  x+k*\frac{b}{gcd(a,b)} \\y_k &amp; =  y-k*\frac{a}{gcd(a,b)} \\\end{aligned}\right.\]</span> 这就是该不定方程的解。一般题目求的符合某些条件的解。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 -知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><p><strong>快速幂</strong>（<strong>Exponentiation bysquaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以<spanclass="math inline">\(O(log_2n)\)</span>的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7 * 7=49，49 * 7=343，...一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7 * 7 * 7 * 7 *7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7 * 7得49，则7的5次方为49 * 49 *7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在<span class="math inline">\(O(log_2n)\)</span>时间内计算出幂的算法，也就是快速幂。</p><h2 id="递归快速幂">递归快速幂</h2><p><span class="math display">\[a^n=\left\{\begin{align}a^n*a                               &amp;      &amp;if\ n\ is\ odd\\a^{\frac{n}{2}}*a^{\frac{n}{2}}     &amp;      &amp;if\ n\ is\ even\but\ not\ 0 \\1                                   &amp;      &amp;if\ n\ is\0               \end{align} \right.\]</span></p><p>对应的递归形式写法如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这个temp不能省略，如果写成了qpow(a,n/2) *qpow(a,n/2)，那会计算两次<spanclass="math inline">\(a^\frac{n}{2}\)</span>，时间复杂度会退化成<spanclass="math inline">\(O(n)\)</span></p><p>经常会遇到取模类的问题，这里我们的应对策略是在利用快速幂进行计算时也需要取模，此时应当注意：<strong>原则是步步取模</strong>，如果mod较大，还需开<strong>longlong</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归快速幂的缺点是：产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong></p><h2 id="非递归快速幂">非递归快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<span class="math inline">\(7^{10}\)</span>为例，转换为计算<spanclass="math inline">\(7^{1010_{(2)}}\)</span>，我们可以把它拆成<spanclass="math inline">\(7^{(1000)_2}\)</span>和<spanclass="math inline">\(7^{10_{(2)}}\)</span>，由此类推，任何数都可以拆分成若干个<spanclass="math inline">\(a^{(100···)_{(2)}}\)</span>的形式相乘，恰好对应的就是<spanclass="math inline">\(a^1\)</span>、<spanclass="math inline">\(a^2\)</span>、<spanclass="math inline">\(a^4\)</span>······来计算，只需要<strong>不断地对底数平方即可算出它们</strong></p><p><img src="https://img2.imgtp.com/2024/03/17/HhfSbxa6.png" /></p><p>可以结合代码进行理解（如果实在看不懂只能看看原作者的文章了qwq）</p><h2 id="快速幂的拓展">快速幂的拓展</h2><p>快速幂算法的应用范围实际上不止于此：在计算<spanclass="math inline">\(a^{\frac{n}{2}}\)</span>时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的非递归快速幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">qpow</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a; <span class="comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>此时的时间复杂度不再是<span class="math inline">\(O(log_2\n)\)</span>，此时还与底数的乘法的时间复杂度有关。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法（第一弹）</title>
      <link href="/2024/03/17/Latex%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/17/Latex%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="latex-语法">Latex 语法</h1><p>先简单整理下Latex的语法，以后会经常用到 <ahref="https://blog.csdn.net/ccnice99/article/details/127507471?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Latex语法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127507471.142%5Ev99%5Epc_search_result_base6&amp;spm=1018.2226.3001.4449">【自用】【持续更新】LaTeX常用基础语法大全_latex语法-CSDN博客</a></p><h2 id="基础语法">基础语法</h2><h3 id="段落">段落</h3><h4 id="居中">居中</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">要居中的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure><h4 id="排序列表">排序列表</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 原始模板</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 自定义排序列表的编号形式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(1)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a.]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 实心圆点列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="comment">% 短横杠列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span>[-] 第一小题</span><br><span class="line"><span class="keyword">\item</span>[-] 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本变量">文本、变量</h3><h4 id="加粗">加粗</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\textbf</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;我们&#125;、<span class="keyword">\textbf</span>&#123;我们&#125;、我们</span><br><span class="line">注意：boldsymbol会变斜体（可能仅限英文）</span><br></pre></td></tr></table></figure><p><span class="math display">\[\textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们\]</span></p><h4 id="斜体">斜体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\textit&#123;我们&#125;、\it&#123;我们&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\textit{我们}、\it{我们}\]</span></p><h4 id="向量顶有向量箭头">向量（顶有向量箭头）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\vec</span> v</span><br></pre></td></tr></table></figure><p><span class="math display">\[\vec v\]</span></p><h4 id="估计顶有尖头hat">估计（顶有尖头hat）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;y&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\hat{y}\]</span></p><h4 id="平均顶有横线">平均（顶有横线）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \overline的线稍长，能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\bar</span> x ，<span class="keyword">\overline</span> x，<span class="keyword">\bar</span>&#123;AB&#125; ，<span class="keyword">\overline</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% \overline的线稍长，能覆盖所有字符\bar x ，\overline x，\bar{AB} ，\overline{AB}\]</span></p><h4 id="顶有波浪号">顶有波浪号~</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \widetilde能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\tilde</span> x ，<span class="keyword">\widetilde</span> x，<span class="keyword">\tilde</span>&#123;AB&#125; ，<span class="keyword">\widetilde</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% \widetilde能覆盖所有字符\tilde x ，\widetilde x，\tilde{AB} ，\widetilde{AB}\]</span></p><h4 id="分式">分式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{分子}{分母}\]</span></p><h4 id="个希腊字母">24个希腊字母</h4><p><img src="https://img2.imgtp.com/2024/03/17/9AmVbzpN.png" /></p><h4 id="花体集合手写体">花体、集合手写体</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 花体</span></span><br><span class="line"><span class="keyword">\mathcal</span>&#123;X&#125; ，<span class="keyword">\mathcal</span>&#123;Y&#125; ，<span class="keyword">\mathcal</span>&#123;D&#125;</span><br><span class="line"><span class="comment">% 集合手写体</span></span><br><span class="line"><span class="keyword">\mathbb</span>&#123;N&#125; ，<span class="keyword">\mathbb</span>&#123;Z&#125; ，<span class="keyword">\mathbb</span>&#123;R&#125; ，<span class="keyword">\mathbb</span>&#123;C&#125; ，<span class="keyword">\mathbb</span>&#123;Q&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 花体\mathcal{X} ，\mathcal{Y} ，\mathcal{D}\]</span></p><p><span class="math display">\[% 集合手写体\mathbb{N} ，\mathbb{Z} ，\mathbb{R} ，\mathbb{C} ，\mathbb{Q}\]</span></p><h3 id="大型运算">大型运算</h3><h4 id="求和">求和</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在右边</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在正上、正下</span><br><span class="line"><span class="keyword">\\</span> 换行</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum_{i=1}^{n}x_i   \]</span></p><p><span class="math display">\[\sum\limits_{i=1}^{n}x_i\]</span></p><p>求和符号的上下位置也可以缺省</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>i <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">^</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum\limits_i \sum\limits^n\]</span></p><h3 id="数组矩阵">数组矩阵</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 无括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="comment">% 圆括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="comment">% 单竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="comment">% 双竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="comment">% 方括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="comment">% 花括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 无括号矩阵\begin{matrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{matrix}\\% 圆括号矩阵\begin{pmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{pmatrix}\\% 单竖线矩阵\begin{vmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{vmatrix}\\% 双竖线矩阵\begin{Vmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{Vmatrix}\\% 方括号矩阵\begin{bmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{bmatrix}\\% 花括号矩阵\begin{Bmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{Bmatrix}\]</span></p><h3 id="符号">符号</h3><h4 id="属于">属于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\in\]</span></p><h4 id="集合之间的各种运算关系">集合之间的各种运算关系</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">A<span class="keyword">\subset</span> B</span><br><span class="line">A<span class="keyword">\supset</span> B</span><br><span class="line">A<span class="keyword">\subseteq</span> B</span><br><span class="line">A<span class="keyword">\supseteq</span> B</span><br><span class="line">A<span class="keyword">\cap</span> B</span><br><span class="line">A<span class="keyword">\cup</span> B</span><br><span class="line"><span class="comment">% A减B</span></span><br><span class="line">A<span class="keyword">\setminus</span> B</span><br><span class="line"><span class="keyword">\emptyset</span></span><br></pre></td></tr></table></figure><p><span class="math inline">\(A\subset B\)</span> <spanclass="math inline">\(A\supset B\)</span> <spanclass="math inline">\(A\subseteq B\)</span> <spanclass="math inline">\(A\supseteq B\)</span> <spanclass="math inline">\(A\cap B\)</span> <span class="math inline">\(A\cupB\)</span> <span class="math inline">\(A\setminus B\)</span> <spanclass="math inline">\(\emptyset\)</span></p><h4 id="任意">任意</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\forall</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\forall\]</span></p><h4 id="存在">存在</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\exists</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\exists\]</span></p><h4 id="因为所以">因为、所以</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\because</span> 和 <span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure><p>注意：如果没有编译成功，需要在导言区导入宏包amssymb</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\because 和 \therefore\]</span></p><h4 id="无穷大">无穷大</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\infty</span>+<span class="keyword">\infty</span> -<span class="keyword">\infty</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\infty +\infty -\infty\]</span></p><h4 id="尖括号">尖括号</h4><p>注意与小于号&lt;，大于号&gt; 区别</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\rangle</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\langle\\\rangle\]</span></p><h4id="小于等于大于等于不等于恒等于恒不等于">小于等于、大于等于、不等于、恒等于、恒不等于</h4><p>巧记：等于equation，所以这几个符号都是从 <em>eq</em> 词根出发的</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\le</span> 或者 <span class="keyword">\leq</span></span><br><span class="line"><span class="keyword">\ge</span> 或者 <span class="keyword">\geq</span></span><br><span class="line"><span class="keyword">\ne</span> 或者 <span class="keyword">\neq</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\not</span><span class="keyword">\equiv</span>  <span class="params">#</span> 注意这里只能是拼接<span class="keyword">\not</span>和<span class="keyword">\equiv</span>，<span class="keyword">\nequiv</span>无效</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\le 或者 \leq\)</span> <spanclass="math inline">\(\ge 或者 \geq\)</span> <spanclass="math inline">\(\ne 或者 \neq\)</span> <spanclass="math inline">\(\equiv\)</span> <spanclass="math inline">\(\not\equiv\)</span></p><h4 id="远小于远大于">远小于、远大于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ll</span>，<span class="keyword">\gg</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\ll，\gg\]</span></p><h4 id="约等于">约等于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\approx</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\approx\]</span></p><h4 id="向上取整向下取整">向上取整、向下取整</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lceil</span> x <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> x <span class="keyword">\rfloor</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\lceil x \rceil\\\lfloor x \rfloor\]</span></p><h4 id="绝对值">绝对值</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>|-2<span class="keyword">\right</span>| 或者 <span class="keyword">\vert</span> -2<span class="keyword">\vert</span> 或者  <span class="keyword">\lvert</span> -2<span class="keyword">\rvert</span> </span><br></pre></td></tr></table></figure><p>可以观察一下区别 <span class="math display">\[\left|-2\right| 或者 \vert -2\vert 或者  \lvert -2\rvert\]</span></p><h4 id="双竖线">双竖线</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span> A<span class="keyword">\|</span> 或者 <span class="keyword">\left</span><span class="keyword">\|</span>A<span class="keyword">\right</span><span class="keyword">\|</span> 或者 <span class="keyword">\Vert</span> A<span class="keyword">\Vert</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\| A\| 或者 \left\|A\right\| 或者 \Vert A\Vert\]</span></p><h4 id="花括号">花括号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\&#123;</span> A<span class="keyword">\&#125;</span> 或者 <span class="keyword">\left</span><span class="keyword">\&#123;</span> A <span class="keyword">\right</span><span class="keyword">\&#125;</span> </span><br></pre></td></tr></table></figure><p><span class="math display">\[\{ A\} 或者 \left\{ A \right\}\]</span></p><h4 id="乘号">乘号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\times</span> 或者 ×</span><br></pre></td></tr></table></figure><p><span class="math display">\[\times 或者 ×\]</span></p><h4 id="开n次方">开n次方</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>&#123;2&#125;、<span class="keyword">\sqrt</span>[4]&#123;16&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sqrt{2}、\sqrt[4]{16}\]</span></p><h4 id="导数">导数</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;</span><br><span class="line"><span class="comment">% 高阶导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;<span class="built_in">^</span>&#123;n&#125; y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x<span class="built_in">^</span>&#123;n&#125;&#125;</span><br><span class="line"><span class="comment">% 求偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;Loss&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;w&#125;&#125;</span><br><span class="line"><span class="comment">% 二阶偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="built_in">^</span>&#123;2&#125;&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="keyword">\partial</span>&#123;y&#125;&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 求导\frac{\mathrm{d}y}{\mathrm{d}x}% 高阶导\frac{\mathrm{d}^{n} y}{\mathrm{d}x^{n}}% 求偏导\frac{\partial{Loss}}{\partial{w}}% 二阶偏导\frac{\partial^{2}z}{\partial{x}^{2}}\frac{\partial^{2}z}{\partial{x}\partial{y}}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex多重奏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分、离散化</title>
      <link href="/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="深进1.例1求区间和"><ahref="https://www.luogu.com.cn/problem/P8218">【深进1.例1】求区间和</a></h1><blockquote><h1 id="深进1.例1求区间和-1">【深进1.例1】求区间和</h1><h2 id="题目描述">题目描述</h2><p>给定 <span class="math inline">\(n\)</span> 个正整数组成的数列 <spanclass="math inline">\(a_1, a_2, \cdots, a_n\)</span> 和 <spanclass="math inline">\(m\)</span> 个区间 <spanclass="math inline">\([l_i,r_i]\)</span>，分别求这 <spanclass="math inline">\(m\)</span> 个区间的区间和。</p><p>对于所有测试数据，<span class="math inline">\(n,m\le10^5,a_i\le10^4\)</span></p><h2 id="输入格式">输入格式</h2><p>第一行，为一个正整数 <span class="math inline">\(n\)</span> 。</p><p>第二行，为 <span class="math inline">\(n\)</span> 个正整数 <spanclass="math inline">\(a_1,a_2, \cdots ,a_n\)</span></p><p>第三行，为一个正整数 <span class="math inline">\(m\)</span> 。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行为两个正整数<span class="math inline">\(l_i,r_i\)</span> ，满足<spanclass="math inline">\(1\le l_i\le r_i\le n\)</span></p><h2 id="输出格式">输出格式</h2><p>共 <span class="math inline">\(m\)</span> 行。</p><p>第 <span class="math inline">\(i\)</span> 行为第 <spanclass="math inline">\(i\)</span> 组答案的询问。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>4 4 3 2 1 2 1 4 2 3</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>10 5</code></p><h2 id="提示">提示</h2><p>样例解释：第 <span class="math inline">\(1\)</span> 到第 <spanclass="math inline">\(4\)</span> 个数加起来和为 <spanclass="math inline">\(10\)</span>。第 <spanclass="math inline">\(2\)</span> 个数到第 <spanclass="math inline">\(3\)</span> 个数加起来和为 <spanclass="math inline">\(5\)</span>。</p><p>对于 <span class="math inline">\(50 \%\)</span> 的数据：<spanclass="math inline">\(n,m\le 1000\)</span>；</p><p>对于 <span class="math inline">\(100 \%\)</span> 的数据：<spanclass="math inline">\(1 \le n, m\le 10^5\)</span>，<spanclass="math inline">\(1 \le a_i\le 10^4\)</span></p></blockquote><h2 id="思路分析">思路分析</h2><p>简单的前缀和板子，不多说。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll =<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">200000</span>];</span><br><span class="line">ll pre[<span class="number">200000</span>], sum[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">pre[i] = a[i] + pre[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">sum[i] = pre[r] - pre[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cout &lt;&lt; sum[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大加权矩形"><ahref="https://www.luogu.com.cn/problem/P1719">最大加权矩形</a></h1><h2 id="题目描述-1">题目描述</h2><p>为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。</p><p>校长先给他们一个 <span class="math inline">\(n\times n\)</span>矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大。矩阵的每个元素属于 <span class="math inline">\([-127,127]\)</span>,例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 –2 –7  0 </span><br><span class="line"> 9  2 –6  2</span><br><span class="line">-4  1 –4  1 </span><br><span class="line">-1  8  0 –2</span><br></pre></td></tr></table></figure><p>在左下角：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9  2</span><br><span class="line">-4  1</span><br><span class="line">-1  8</span><br></pre></td></tr></table></figure><p>和为 <span class="math inline">\(15\)</span>。</p><p>几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？</p><h2 id="输入格式-1">输入格式</h2><p>第一行：<span class="math inline">\(n\)</span>，接下来是 <spanclass="math inline">\(n\)</span> 行 <spanclass="math inline">\(n\)</span> 列的矩阵。</p><h2 id="输出格式-1">输出格式</h2><p>最大矩形（子矩阵）的和。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line"> 9 2 -6 2</span><br><span class="line">-4 1 -4  1 </span><br><span class="line">-1 8  0 -2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><p><span class="math inline">\(1 \leq n\le 120\)</span>其实是二维前缀和的板子，这里给出几份代码，看看不同的思路（大多都是细节上处理的方法不同）。</p><h2 id="ac代码">AC代码</h2><h3 id="code1">CODE1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-99999999</span>;</span><br><span class="line"><span class="type">int</span> squ[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> lin[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; squ[i][j];</span><br><span class="line"><span class="comment">//lin[i][j]表示的是第i行前j个（其实也就是第j列）数字的和</span></span><br><span class="line">lin[i][j] = lin[i][j - <span class="number">1</span>] + squ[i][j];</span><br><span class="line"><span class="comment">//sum[i][j]表示的是以第1行第1个数字为左上角，以第i行第j个数字为右下角的矩形的面积。</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + lin[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分别枚举左上角的坐标(x1,y1)和右下角(x2,y2)的坐标。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x1 = <span class="number">1</span>; x1 &lt;= n; x1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y1 = <span class="number">1</span>; y1 &lt;= n; y1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x2 = <span class="number">1</span>; x2 &lt;= n; x2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y2 = <span class="number">1</span>; y2 &lt;= n; y2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x2 &lt; x1||y2&lt;y1) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] +sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人对<span class="math inline">\(sum[x2][y2] - sum[x2][y1 - 1] -sum[x1 - 1][y2] +sum[x1-1][y1-1]\)</span>为什么是以<spanclass="math inline">\((x_1,y_1)\)</span>为左上角，以<spanclass="math inline">\((x_2,y_2)\)</span>为右下角的矩形的面积有点疑惑。画个图解释一下：<imgsrc="https://img-blog.csdnimg.cn/direct/3c6c29a63e80437eaf7b54057daf5860.png#pic_center"alt="在这里插入图片描述" /> 这下应该能看懂了吧qwq。</p><h3 id="code2">CODE2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//还是跟上面的操作一样</span></span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="comment">//预处理出以(i,j)为右下角的矩形的面积，画画图就懂了</span></span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="comment">//枚举左上角(i,j)，右下角(k,m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//注意k&gt;=i,m&gt;=j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=j;m&lt;=n;m++)&#123;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(i,j,k,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="code3">CODE3</h3><p>实际上是在枚举时优化了一下，降低时间复杂度。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>,sum;</span><br><span class="line">    <span class="comment">//这里改成了枚举矩形的上下边i与j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//k枚举的是第几列，从左往右扫描每一列的面积，并加到sum中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(i,k,j,k);</span><br><span class="line">                <span class="comment">//如果sum&gt;ans，说明在以i行为上界，j行为下界的，并且右界限为k的构成的连续矩形面积（即sum）更大，更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;ans)ans=sum;</span><br><span class="line">                <span class="comment">//如果sum&lt;0，那么只能另开一段，置sum为0</span></span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者可以理解成是矩阵压缩，可以看看题解的第一篇，本质其实是一样的。 <ahref="https://www.luogu.com.cn/problem/solution/P1719">P1719最大加权矩形</a></p><h1 id="语文成绩"><ahref="https://www.luogu.com.cn/problem/P2367">语文成绩</a></h1><blockquote><h1 id="语文成绩-1">语文成绩</h1><h2 id="题目背景">题目背景</h2><p>语文考试结束了，成绩还是一如既往地有问题。</p><h2 id="题目描述-2">题目描述</h2><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><h2 id="输入格式-2">输入格式</h2><p>第一行有两个整数 <span class="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span>，代表学生数与增加分数的次数。</p><p>第二行有 <span class="math inline">\(n\)</span> 个数，<spanclass="math inline">\(a_1 \sima_n\)</span>，代表各个学生的初始成绩。</p><p>接下来 <span class="math inline">\(p\)</span> 行，每行有三个数，<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(y\)</span>，<spanclass="math inline">\(z\)</span>，代表给第 <spanclass="math inline">\(x\)</span> 个到第 <spanclass="math inline">\(y\)</span> 个学生每人增加 <spanclass="math inline">\(z\)</span> 分。</p><h2 id="输出格式-2">输出格式</h2><p>输出仅一行，代表更改分数后，全班的最低分。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><p><code>3 2 1 1 1 1 2 1 2 3 1</code></p><h3 id="样例输出-1-2">样例输出 #1</h3><p><code>2</code></p><h2 id="提示-2">提示</h2><p>对于 <span class="math inline">\(40\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^3\)</span>。</p><p>对于 <span class="math inline">\(60\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^4\)</span>。</p><p>对于 <span class="math inline">\(80\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^5\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 5\times 10^6\)</span>，<spanclass="math inline">\(p \le n\)</span>，学生初始成绩 $ <spanclass="math inline">\(，\)</span>z $。</p></blockquote><h2 id="思路分析-1">思路分析</h2><p>差分的板子题，但是我经常忘记怎么操作了，贴上证明。 <imgsrc="https://img-blog.csdnimg.cn/direct/7348fc92b069475784845bf92f234e14.png#pic_center"alt="在这里插入图片描述" /> 这里贴的是<ahref="https://www.luogu.com.cn/blog/156353/solution-p2367">GoldenFishX大佬的博客</a>，可以看看（大佬如果觉得侵权，联系我删除即可qwq）。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll p, n, a[<span class="number">5000500</span>], d[<span class="number">5000500</span>];</span><br><span class="line">ll x, y, z, ans=<span class="number">9999999999</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//求出差分数组</span></span><br><span class="line">d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="comment">//上面讲得很清楚了</span></span><br><span class="line">d[x] += z;</span><br><span class="line">d[y + <span class="number">1</span>] -= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//差分的性质：a[i]=d[i]+d[i-1]+d[i-2]+······+d[1]</span></span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + d[i];</span><br><span class="line">ans = <span class="built_in">min</span>(ans, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地毯"><ahref="https://www.luogu.com.cn/problem/P3397">地毯</a></h1><h2 id="题目描述-3">题目描述</h2><p>在 <span class="math inline">\(n\times n\)</span> 的格子上有 <spanclass="math inline">\(m\)</span> 个地毯。</p><p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p><h2 id="输入格式-3">输入格式</h2><p>第一行，两个正整数 <spanclass="math inline">\(n,m\)</span>。意义如题所述。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行两个坐标 <spanclass="math inline">\((x_1,y_1)\)</span> 和 <spanclass="math inline">\((x_2,y_2)\)</span>，代表一块地毯，左上角是 <spanclass="math inline">\((x_1,y_1)\)</span>，右下角是 <spanclass="math inline">\((x_2,y_2)\)</span>。</p><h2 id="输出格式-3">输出格式</h2><p>输出 <span class="math inline">\(n\)</span> 行，每行 <spanclass="math inline">\(n\)</span> 个正整数。</p><p>第 <span class="math inline">\(i\)</span> 行第 <spanclass="math inline">\(j\)</span> 列的正整数表示 <spanclass="math inline">\((i,j)\)</span> 这个格子被多少个地毯覆盖。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 2 3 3</span><br><span class="line">3 3 5 5</span><br><span class="line">1 2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 0 0</span><br><span class="line">0 1 2 1 1</span><br><span class="line">0 0 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="样例解释">样例解释</h3><p>覆盖第一个地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr></tbody></table><p>覆盖第一、二个地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr></tbody></table><p>覆盖所有地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr></tbody></table><hr /><h3 id="数据范围">数据范围</h3><p>对于 <span class="math inline">\(20\%\)</span> 的数据，有 <spanclass="math inline">\(n\le 50\)</span>，<span class="math inline">\(m\le100\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(n,m\le 1000\)</span>。 ## 思路分析这题其实可以暴力模拟水过去，但实际上正解是二维差分。（补学一下qwq）。设数组<span class="math inline">\(a\)</span>的差分数组为<spanclass="math inline">\(b\)</span>，则： <spanclass="math display">\[b[[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]\]</span>.（偷懒了，直接贴书上的内容qwq）</p><blockquote><figure><imgsrc="https://img-blog.csdnimg.cn/direct/268ddecc2f5c4e04bcbd0ab4d710df40.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure></blockquote><p>可以看到(a)，(b)图中，右下角的矩形中的各点都+1了，可以试着结合一维差分的证明理解一下wsm。(c)，(d)图其实就是相同的操作罢了。</p><h2 id="ac代码-1">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="comment">//上面提到的操作</span></span><br><span class="line">        mat[x1][y1]++;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y1]--;</span><br><span class="line">        mat[x1][y2+<span class="number">1</span>]--;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y2+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//求前缀和，处理出每个点的值</span></span><br><span class="line">            mat[i][j]+=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            cout&lt;&lt;mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="火烧赤壁"><ahref="https://www.luogu.com.cn/problem/P1496">火烧赤壁</a></h1><h2 id="题目背景-1">题目背景</h2><p>曹操平定北方以后，公元 208年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p><p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p><p>隆冬的十一月，天气突然回暖，刮起了东南风。</p><p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p><p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p><h2 id="题目描述-4">题目描述</h2><p>给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。</p><h2 id="输入格式-4">输入格式</h2><p>第一行一个整数，表示起火的信息条数 <spanclass="math inline">\(n\)</span>。<br />接下来 <span class="math inline">\(n\)</span> 行，每行两个整数 <spanclass="math inline">\(a,b\)</span>，表示一个着火位置的起点和终点（<strong>注意：左闭右开</strong>）。</p><h2 id="输出格式-4">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="数据规模与约定">数据规模与约定</h3><p>对于全部的测试点，保证 <span class="math inline">\(1 \leq n \leq 2\times 10^4\)</span>，<span class="math inline">\(-2^{31} \leq a \leq  b\lt 2^{31}\)</span>，且答案小于 <spanclass="math inline">\(2^{31}\)</span>。 ## 思路分析实际上这是一道离散化的题目，但是我当初做的时候还不会离散化qwq，看了题解区大佬的绝妙思路：<a href="https://wxwoo.blog.luogu.org/solution-p1496">大佬的题解</a><imgsrc="https://img-blog.csdnimg.cn/direct/dbcb14ba5ade43389d9fc5e8b3e94590.png#pic_center"alt="在这里插入图片描述" />可以发现，覆盖的范围是一样的，那么我们可以这样操作：1、将起点和终点排个序。 2、将他们按照从小到大的顺序一一匹配，计算长度。3、如果有重复的覆盖范围，减去即可。（也就是当前的终点坐标比下一个的起点坐标大时）## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">20200</span>], b[<span class="number">20200</span>], l;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">l += b[i] - a[i];</span><br><span class="line"><span class="comment">//注意i&lt;n,因为a[n]，b[n]是最后的起点和终点</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">l -= b[i] - a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="领地选择"><ahref="https://www.luogu.com.cn/problem/P2004">领地选择</a></h1><h2 id="题目描述-5">题目描述</h2><p>作为在虚拟世界里统帅千军万马的领袖，小 Z认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z来说是非常重要的。</p><p>首都被认为是一个占地 <span class="math inline">\(C\times C\)</span>的正方形。小 Z希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。</p><h2 id="输入格式-5">输入格式</h2><p>第一行三个整数 <spanclass="math inline">\(N,M,C\)</span>，表示地图的宽和长以及首都的边长。</p><p>接下来 <span class="math inline">\(N\)</span> 行每行 <spanclass="math inline">\(M\)</span>个整数，表示了地图上每个地块的价值。价值可能为负数。</p><h2 id="输出格式-5">输出格式</h2><p>一行两个整数 <spanclass="math inline">\(X,Y\)</span>，表示首都左上角的坐标。</p><h2 id="样例-1-5">样例 #1</h2><h3 id="样例输入-1-5">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="提示-5">提示</h2><p>对于 <span class="math inline">\(60\%\)</span> 的数据，<spanclass="math inline">\(N,M\le 50\)</span>。</p><p>对于 <span class="math inline">\(90\%\)</span> 的数据，<spanclass="math inline">\(N,M\le 300\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1\le N,M\le 10^3\)</span>，<spanclass="math inline">\(1\le C\le \min(N,M)\)</span>。 ## 思路分析二维前缀和的练习题，不解释了qwq。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m, c;</span><br><span class="line">ll map[<span class="number">1010</span>][<span class="number">1010</span>], sum[<span class="number">1010</span>][<span class="number">1010</span>], maxn = <span class="number">-999999999</span>, nx,ny;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; map[i][j];</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + map[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= m; j++) &#123;</span><br><span class="line">    <span class="comment">//枚举以(i,j)为右下角、边长为c的正方形的面积，注意更新坐标</span></span><br><span class="line"><span class="keyword">if</span> (sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c] &gt; maxn) &#123;</span><br><span class="line">maxn = sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c];</span><br><span class="line">nx = i - c + <span class="number">1</span>;</span><br><span class="line">ny = j - c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; nx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ny;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聪明的质检员"><ahref="https://www.luogu.com.cn/problem/P1314">聪明的质检员</a></h1><blockquote><h2 id="题目描述-6">题目描述</h2><p><code>小T</code>是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 <spanclass="math inline">\(n\)</span> 个矿石，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 逐一编号，每个矿石都有自己的重量 <spanclass="math inline">\(w_i\)</span> 以及价值 <spanclass="math inline">\(v_i\)</span> 。检验矿产的流程是：</p><ol type="1"><li>给定$ m$ 个区间 <spanclass="math inline">\([l_i,r_i]\)</span>；</li><li>选出一个参数 <span class="math inline">\(W\)</span>；</li><li>对于一个区间 <spanclass="math inline">\([l_i,r_i]\)</span>，计算矿石在这个区间上的检验值<span class="math inline">\(y_i\)</span>：</li></ol><p><span class="math display">\[y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W]\times\sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j\]</span></p><p>其中 <span class="math inline">\(j\)</span> 为矿石编号。</p><p>这批矿产的检验结果 <span class="math inline">\(y\)</span>为各个区间的检验值之和。即：<spanclass="math inline">\(\sum\limits_{i=1}^m y_i\)</span></p><p>若这批矿产的检验结果与所给标准值 <spanclass="math inline">\(s\)</span>相差太多，就需要再去检验另一批矿产。<code>小T</code>不想费时间去检验另一批矿产，所以他想通过调整参数 <spanclass="math inline">\(W\)</span> 的值，让检验结果尽可能的靠近标准值<span class="math inline">\(s\)</span>，即使得 <spanclass="math inline">\(|s-y|\)</span> 最小。请你帮忙求出这个最小值。</p><h2 id="输入格式-6">输入格式</h2><p>第一行包含三个整数 <spanclass="math inline">\(n,m,s\)</span>，分别表示矿石的个数、区间的个数和标准值。</p><p>接下来的 <span class="math inline">\(n\)</span>行，每行两个整数，中间用空格隔开，第 <spanclass="math inline">\(i+1\)</span> 行表示 <spanclass="math inline">\(i\)</span> 号矿石的重量 <spanclass="math inline">\(w_i\)</span> 和价值 <spanclass="math inline">\(v_i\)</span>。</p><p>接下来的 <span class="math inline">\(m\)</span>行，表示区间，每行两个整数，中间用空格隔开，第 <spanclass="math inline">\(i+n+1\)</span> 行表示区间 <spanclass="math inline">\([l_i,r_i]\)</span> 的两个端点 <spanclass="math inline">\(l_i\)</span> 和 <spanclass="math inline">\(r_i\)</span>。注意：不同区间可能重合或相互重叠。</p><h2 id="输出格式-6">输出格式</h2><p>一个整数，表示所求的最小值。</p><h2 id="样例-1-6">样例 #1</h2><h3 id="样例输入-1-6">样例输入 #1</h3><p><code>5 3 15  1 5  2 5  3 5  4 5  5 5  1 5  2 4  3 3</code></p><h3 id="样例输出-1-6">样例输出 #1</h3><p><code>10</code></p><h2 id="提示-6">提示</h2><p>【输入输出样例说明】</p><p>当 <span class="math inline">\(W\)</span> 选 <spanclass="math inline">\(4\)</span> 的时候，三个区间上检验值分别为 <spanclass="math inline">\(20,5 ,0\)</span> ，这批矿产的检验结果为 <spanclass="math inline">\(25\)</span>，此时与标准值 <spanclass="math inline">\(S\)</span> 相差最小为 <spanclass="math inline">\(10\)</span>。</p><p>【数据范围】</p><p>对于 <span class="math inline">\(10\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤10\)</span>；</p><p>对于 <span class="math inline">\(30\%\)</span>的数据，有 <spanclass="math inline">\(1 ≤n ,m≤500\)</span> ；</p><p>对于 <span class="math inline">\(50\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤5,000\)</span>； 对于 <spanclass="math inline">\(70\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤10,000\)</span> ；</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤200,000\)</span>，<spanclass="math inline">\(0 &lt; w_i,v_i≤10^6\)</span>，<spanclass="math inline">\(0 &lt;s≤10^{12}\)</span>，<span class="math inline">\(1 ≤l_i ≤r_i ≤n\)</span>## 思路分析直接暴力枚举求出这个点肯定不行，并且看到题目要求最小值，所以可以猜测：使用二分。二分的是<span class="math inline">\(W\)</span>的值，<spanclass="math inline">\(check(mid)\)</span>的判断条件是<spanclass="math inline">\(s-\sum\limits_{i=1}^my_i\)</span>是否大于0，由此缩减二分的范围，分析一下单调性：当<spanclass="math inline">\(W\)</span>减少时，<spanclass="math inline">\(\sum\limits_{i=1}^my_i\)</span>增大，反之，则变小，并且当<spanclass="math inline">\(W\)</span>足够小时，<spanclass="math inline">\(\sum\limits_{i=1}^m y_i\)</span>会大于<spanclass="math inline">\(s\)</span>,符合单调性，可以使用二分。具体看看注释。还需要先预处理出前缀和：包括个数和总价值，否则会TLE。 ## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],l[MAXN],r[MAXN],cnt_num[MAXN],cnt_val[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    ll sum,ans,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    ans=s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//w是矿石的重量，v是矿石的价值</span></span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//输入的是查询的区间</span></span><br><span class="line">        cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt_num,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt_val,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_val));</span><br><span class="line">        <span class="comment">//利用前缀和，预处理出合格品的个数和总价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;=mid)&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>]+v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>];</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计一下检测结果，也就是查询的各个区间总价值之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            sum+=(cnt_val[r[i]]-cnt_val[l[i]<span class="number">-1</span>])*(cnt_num[r[i]]-cnt_num[l[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意更新答案，得到的是最小值，注意ans初始化为无穷大</span></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-s));</span><br><span class="line">        <span class="comment">//说明这个解合法，将右端点确定下来</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=s)right=mid;</span><br><span class="line">        <span class="comment">//否则，将左端点确定下来</span></span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序自动分析"><ahref="https://www.luogu.com.cn/problem/P1955">程序自动分析</a></h1><blockquote><h1 id="noi2015-程序自动分析">[NOI2015] 程序自动分析</h1><h2 id="题目描述-7">题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设 <spanclass="math inline">\(x_1,x_2,x_3,\cdots\)</span>代表程序中出现的变量，给定 <span class="math inline">\(n\)</span> 个形如<span class="math inline">\(x_i=x_j\)</span> 或 <spanclass="math inline">\(x_i\neq x_j\)</span>的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：<spanclass="math inline">\(x_1=x_2,x_2=x_3,x_3=x_4,x_4\neqx_1\)</span>，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入格式-7">输入格式</h2><p>输入的第一行包含一个正整数 <spanclass="math inline">\(t\)</span>，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第一行包含一个正整数 <spanclass="math inline">\(n\)</span>，表示该问题中需要被满足的约束条件个数。接下来<span class="math inline">\(n\)</span> 行，每行包括三个整数 <spanclass="math inline">\(i,j,e\)</span>，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若<span class="math inline">\(e=1\)</span>，则该约束条件为 <spanclass="math inline">\(x_i=x_j\)</span>。若<spanclass="math inline">\(e=0\)</span>，则该约束条件为 <spanclass="math inline">\(x_i\neq x_j\)</span>。</p><h2 id="输出格式-7">输出格式</h2><p>输出包括 <span class="math inline">\(t\)</span> 行。</p><p>输出文件的第 <span class="math inline">\(k\)</span> 行输出一个字符串<code>YES</code> 或者 <code>NO</code>（字母全部大写），<code>YES</code>表示输入中的第 <span class="math inline">\(k\)</span>个问题判定为可以被满足，<code>NO</code> 表示不可被满足。</p><h2 id="样例-1-7">样例 #1</h2><h3 id="样例输入-1-7">样例输入 #1</h3><p><code>2 2 1 2 1 1 2 0 2 1 2 1 2 1 1</code></p><h3 id="样例输出-1-7">样例输出 #1</h3><p><code>NO YES</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>2 3 1 2 1 2 3 1 3 1 1 4 1 2 1 2 3 1 3 4 1 1 4 0</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>YES NO</code></p><h2 id="提示-7">提示</h2><p>【样例解释1】</p><p>在第一个问题中，约束条件为：<spanclass="math inline">\(x_1=x_2,x_1\neqx_2\)</span>。这两个约束条件互相矛盾，因此不可被同时满足。</p><p>在第二个问题中，约束条件为：<span class="math inline">\(x_1=x_2,x_1 =x_2\)</span>。这两个约束条件是等价的，可以被同时满足。</p><p>【样例说明2】</p><p>在第一个问题中，约束条件有三个：<spanclass="math inline">\(x_1=x_2,x_2= x_3,x_3=x_1\)</span>。只需赋值使得<spanclass="math inline">\(x_1=x_2=x_3\)</span>，即可同时满足所有的约束条件。</p><p>在第二个问题中，约束条件有四个：<spanclass="math inline">\(x_1=x_2,x_2= x_3,x_3=x_4,x_4\neqx_1\)</span>。由前三个约束条件可以推出 <spanclass="math inline">\(x_1=x_2=x_3=x_4\)</span>，然而最后一个约束条件却要求<span class="math inline">\(x_1\neq x_4\)</span>，因此不可被满足。</p><p>【数据范围】</p><p>所有测试数据的范围和特点如下表所示：</p><h3id="勘误测试点-8-sim-10-的-i-j-约束为-1-leq-i-j-leq-109而不是下图中的-1010">勘误：测试点<span class="math inline">\(8 \sim 10\)</span> 的 <spanclass="math inline">\(i, j\)</span> 约束为 <span class="math inline">\(1\leq i, j \leq 10^9\)</span>，而不是下图中的 <spanclass="math inline">\(10^{10}\)</span>。</h3><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/4a99dde45fc5970ecba60d38c39a3bc2.png" />## 思路分析这个其实是并查集+离散化，但是离散化我还不太熟，暂时没写。当初用了<spanclass="math inline">\(unordered-map\)</span>混过去了qwq。说正题，这道题有两个特征，查询和赋值，我们分析一下，这其实跟并查集的功能很相似，并查集维护的是一些元素的分组，用的是查询和合并两个操作。这里的赋值，我们其实可以用合并来实现：1、如果是赋值，合并为一组。2、如果是查询，那么我们只要看两者是否在同一组内即可。这里并查集写的是按秩合并，不会的可以用普通的并查集代替。 ## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;Rank;</span><br><span class="line"><span class="type">int</span> x[MAXN],y[MAXN],e[MAXN];</span><br><span class="line"><span class="comment">//并查集的查询功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=<span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的合并功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]&gt;=Rank[fy])pre[fy]=fx;</span><br><span class="line">    <span class="keyword">else</span> pre[fx]=fy;</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]==Rank[fy]&amp;&amp;fx!=fy)Rank[fx]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意清空数组，因为有多组数据输入，不然喜迎WA qwq</span></span><br><span class="line">    pre.<span class="built_in">clear</span>();</span><br><span class="line">    Rank.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//输入元素，以及对应的操作，注意在原题中指的是下标x，y</span></span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;e[i];</span><br><span class="line">        <span class="comment">//将并查集初始化</span></span><br><span class="line">        pre[x[i]]=x[i];</span><br><span class="line">        pre[y[i]]=y[i];</span><br><span class="line">        <span class="comment">//按秩合并才需要的初始化，其实这一行也可以不用写@~@</span></span><br><span class="line">        Rank[x[i]]=<span class="number">1</span>,Rank[y[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果是1，合并两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(e[i])<span class="built_in">join</span>(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果不是1，查看两者的祖先是否一样</span></span><br><span class="line">        <span class="keyword">if</span>(!e[i])&#123;</span><br><span class="line">            <span class="comment">//不一样的话，直接输出NO，return 0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x[i])==<span class="built_in">find</span>(y[i]))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经历重重困难，终于是YES了！！！</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="usaco11mar-brownie-slicing-g"><ahref="https://www.luogu.com.cn/problem/P3017">[USACO11MAR] BrownieSlicing G</a></h1><h2 id="题面翻译">题面翻译</h2><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由 <spanclass="math inline">\(R\times C(1\leq R,C\leq 500)\)</span>个小的巧克力蛋糕组成的。第 <span class="math inline">\(i\)</span> 行，第<span class="math inline">\(j\)</span> 列的蛋糕有 <spanclass="math inline">\(N_{i,j}(N_{i,j}\leq 4000)\)</span>块巧克力碎屑。</p><p>Bessie想把蛋糕分成 <span class="math inline">\(A\times B(1\leq A\leqR,1\leq B\leq C)\)</span> 块，:给 <span class="math inline">\(A\timesB\)</span> 只奶牛。蛋糕先水平地切 <spanclass="math inline">\(A-1\)</span>刀（只能切沿整数坐标切）来把蛋糕划分成 <spanclass="math inline">\(A\)</span> 块。然后再把剩下来的每一块独立地切<span class="math inline">\(B-1\)</span> 刀，也只能切沿整数坐标切。其他<span class="math inline">\(A\times B-1\)</span>只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个<spanclass="math inline">\(5\times4\)</span>的蛋糕，上面的碎屑分布如下图所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure> 这样，Bessie至少能获得 <spanclass="math inline">\(3\)</span> 块巧克力碎屑</p><h2 id="题目描述-8">题目描述</h2><p>Bessie has baked a rectangular brownie that can be thought of as anRxC grid (1 &lt;= R &lt;= 500; 1 &lt;= C &lt;= 500) of little browniesquares. The square at row i, column j contains N_ij (0 &lt;= N_ij &lt;=4,000) chocolate chips.</p><p>Bessie wants to partition the brownie up into A*B chunks (1 &lt;= A&lt;= R; 1 &lt;= B &lt;= C): one for each of the A*B cows. The brownieis cut by first making A-1 horizontal cuts (always along integer</p><p>coordinates) to divide the brownie into A strips. Then cut each strip*independently* with B-1 vertical cuts, also on integer</p><p>boundaries. The other A*B-1 cows then each choose a brownie piece,leaving the last chunk for Bessie. Being greedy, they leave Bessie thebrownie that has the least number of chocolate chips on it.</p><p>Determine the maximum number of chocolate chips Bessie can receive,assuming she cuts the brownies optimally.</p><p>As an example, consider a 5 row x 4 column brownie with chips</p><p>distributed like this: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure></p><p>Bessie must partition the brownie into 4 horizontal strips, each withtwo pieces. Bessie can cut the brownie like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>Thus, when the other greedy cows take their brownie piece, Bessiestill gets 3 chocolate chips.</p><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由R*C(1 &lt;= R,C &lt;=500)个小的巧克力蛋糕组成的。第i行，第j列的蛋糕有N_ij(1&lt;= N_ij &lt;=4,000)块巧克力碎屑。</p><p>Bessie想把蛋糕分成A*B块，(1 &lt;= A&lt;= R,1 &lt;= B &lt;= C):给A*B只奶牛。蛋糕先水平地切A-1刀（只能切沿整数坐标切）来把蛋糕划分成A块。然后再把剩下来的每一块独立地切B-1刀，也只能切沿整数坐标切。其他A*B-1只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个5*4的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><h2 id="输入格式-8">输入格式</h2><p>* Line 1: Four space-separated integers: R, C, A, and B</p><p>* Lines 2..R+1: Line i+1 contains C space-separated integers: N_i1,..., N_iC</p><h2 id="输出格式-8">输出格式</h2><p>* Line 1: A single integer: the maximum number of chocolate chipsthat Bessie guarantee on her brownie</p><h2 id="样例-1-8">样例 #1</h2><h3 id="样例输入-1-8">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 4 2 </span><br><span class="line">1 2 2 1 </span><br><span class="line">3 1 1 1 </span><br><span class="line">2 0 1 3 </span><br><span class="line">1 1 1 1 </span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路分析-2">思路分析</h2><p>当初也没想出来怎么二分，看了题解区大佬的题解恍然大悟。蛋糕要分成<span class="math inline">\(A *B\)</span>块，注意可以先分成<spanclass="math inline">\(A\)</span>横块，每一块再分成<spanclass="math inline">\(B\)</span>条，也就是切条时可以不用一刀切！！！那么要统计一块蛋糕的巧克力屑，肯定就是使用前缀和了。我们也可以先预处理出前缀和，再进行二分。二分的是巧克力屑的数量，<spanclass="math inline">\(check(mid)\)</span>的是能否切出<spanclass="math inline">\(A*B\)</span>块蛋糕，具体<spanclass="math inline">\(check(mid)\)</span>怎么写可以看看代码+注释。 ##AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cake[<span class="number">510</span>][<span class="number">510</span>],line[<span class="number">510</span>][<span class="number">510</span>],pre[<span class="number">510</span>][<span class="number">510</span>],r,c,a,b,ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//我们先切一行，再将这一行切成B列，看看最终能否满足A*B块蛋糕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,sum_cake=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i枚举的是当前行，j枚举的是当前列，last记录的是上一块（行）蛋糕的最底行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="comment">//判断当前切的蛋糕的巧克力屑的数量是否大于x，也就是二分的值</span></span><br><span class="line">            <span class="comment">//我们一列一列的补充蛋糕，判断补充后，其巧克力屑数目是否大于x，不满足，则补充。</span></span><br><span class="line">            <span class="keyword">if</span>(sum_cake+(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>])&lt;x)&#123;</span><br><span class="line">                sum_cake+=(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足，另开一列，注意统计的蛋糕数目+1，蛋糕上的巧克力屑数目重置为0</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum_cake=<span class="number">0</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断这一行蛋糕，切出来是否有B块</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=b)&#123;</span><br><span class="line">        <span class="comment">//如果有B块，我们则记录这块蛋糕的最后一行，并且记录 行的蛋糕数量++，没有只能再加上一行继续切了，直到满足为止。</span></span><br><span class="line">            last=i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看看是否能不能切除A行蛋糕，满足return true，否则，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;a)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输入R、C、A、B</span></span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//输入蛋糕的巧克力屑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=MAXN;</span><br><span class="line">    <span class="comment">//二分，不多说了，重点在check(x)</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="海底高铁"><ahref="https://www.luogu.com.cn/problem/P3406">海底高铁</a></h1><h2 id="思路分析-3">思路分析</h2><p>先想想暴力怎么办？我们可以先统计每段铁路要经过几次，再贪心，看看是办卡优惠还是买票优惠。但是这样肯定会TLE，想想怎么改——————前缀和吗？不对，前缀和求的是多个元素之间的关系。差分吗？差分维护的是多个元素之间的逻辑关系，最终得到的是单个元素。那就是差分了！我们可以利用它来得出每段铁路经过的次数，想想差分的作用，O(1)修改区间的值，O(n)查询单个元素的值。基于此，我们可以先O(1)预处理区间总共要修改的值，再O(n)得到每段铁路经过的次数，最后贪心得出最小花费。具体可以看看注释。可以看看这篇<ahref="https://www.luogu.com.cn/article/srpjwp5w">搞笑的故事</a>，相信会有所收获。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll p[MAXN],a[MAXN],b[MAXN],c[MAXN],ans[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分，统计修改次数，注意相邻元素不一定是从小到大，所以可能得交换顺序</span></span><br><span class="line">    <span class="comment">//一般来说，是d[l]++,d[r+1]--。l指的是左端点，r指的是右端点，但是我们这里d[l]++,d[r]--即可，因为其实从r城市出发的铁路我们根本不需要经过。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans[<span class="built_in">min</span>(p[i],p[i+<span class="number">1</span>])]++;</span><br><span class="line">        ans[<span class="built_in">max</span>(p[i],p[i+<span class="number">1</span>])]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得出每段铁路需要经过的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//贪心，看看每一段铁路是买票优惠还是买卡优惠</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">min</span>(ans[i]*a[i],ans[i]*b[i]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="poetize6-incdec-sequence"><ahref="https://www.luogu.com.cn/problem/P4552">[Poetize6] IncDecSequence</a></h1><blockquote><h1 id="poetize6-incdec-sequence-1">[Poetize6] IncDec Sequence</h1><h2 id="题目描述-9">题目描述</h2><p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <spanclass="math inline">\({a_1,a_2,\cdots,a_n}\)</span>，每次可以选择一个区间<spanclass="math inline">\([l,r]\)</span>，使这个区间内的数都加 <spanclass="math inline">\(1\)</span> 或者都减 <spanclass="math inline">\(1\)</span>。请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p><h2 id="输入格式-9">输入格式</h2><p>第一行一个正整数 <span class="math inline">\(n\)</span> 接下来 <spanclass="math inline">\(n\)</span> 行,每行一个整数,第 $i+1 $行的整数表示<span class="math inline">\(a_i\)</span>。</p><h2 id="输出格式-9">输出格式</h2><p>第一行输出最少操作次数 第二行输出最终能得到多少种结果</p><h2 id="样例-1-9">样例 #1</h2><h3 id="样例输入-1-9">样例输入 #1</h3><p><code>4 1 1 2 2</code></p><h3 id="样例输出-1-9">样例输出 #1</h3><p><code>1 2</code></p><h2 id="提示-8">提示</h2><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n\le 100000, 0 \le a_i \le 2^{31}\)</span>。 ##思路分析先想想元素相同？其实就是他们的差都是0，我们关注的是单个元素，并且是各元素之间的逻辑关系问题，所以我们使用差分来求解。那么问题就变成了怎么让差分数组全为0（除了<spanclass="math inline">\(diff[1]\)</span>不为0，因为<spanclass="math inline">\(a[0]\)</span>为0），对一个区间<spanclass="math inline">\([l,r]\)</span>进行修改，其实就是<spanclass="math inline">\(diff[l]++\)</span>、<spanclass="math inline">\(dff[r+1]--\)</span>。而一个差分数组里元素肯定有正有负，最好的情况是，一次修改，可以让一个负数加1，一个正数减1，这样操作步骤就是最少的。但是如果只剩下正数或者负数，就只能一次一次进行了。至于有多少可能结果，其实就是最后只剩正数或者负数时，一步步修改的操作次数了。为什么？前面修改的时候，我们修改的是<spanclass="math inline">\([l,r]\)</span>，对<spanclass="math inline">\(diff[1]\)</span>无影响，而只剩正数或者负数时，我们可以<spanclass="math inline">\(diff[1]++\)</span><spanclass="math inline">\(diff[x]--\)</span>了，也可以<spanclass="math inline">\(diff[1]--\)</span><spanclass="math inline">\(diff[x]++\)</span>，也可以不动，所以可能的结果就是：剩余的正数/负数+1，因为本身不修改，也要加上。## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,x=<span class="number">0</span>,y=<span class="number">0</span>,d;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//求差分数组：x统计正数，y统计负数</span></span><br><span class="line">        d=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">0</span>)x+=d;</span><br><span class="line">        <span class="keyword">else</span> y-=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格的证明是:ans1=min(x,y)+abs(x-y),所以ans1=max(x,y)。</span></span><br><span class="line">    ll ans1=<span class="built_in">max</span>(x,y);</span><br><span class="line">    <span class="comment">//不解释了，看看上面</span></span><br><span class="line">    ll ans2=<span class="built_in">abs</span>(x-y)+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="noip2012-提高组-借教室"><ahref="https://www.luogu.com.cn/problem/P1083">[NOIP2012 提高组]借教室</a></h1><h2 id="题目描述-10">题目描述</h2><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来 <span class="math inline">\(n\)</span>天的借教室信息，其中第 <span class="math inline">\(i\)</span> 天学校有<span class="math inline">\(r_i\)</span> 个教室可供租借。共有 <spanclass="math inline">\(m\)</span>份订单，每份订单用三个正整数描述，分别为 <spanclass="math inline">\(d_j,s_j,t_j\)</span>，表示某租借者需要从第 <spanclass="math inline">\(s_j\)</span> 天到第 <spanclass="math inline">\(t_j\)</span> 天租借教室（包括第 <spanclass="math inline">\(s_j\)</span> 天和第 <spanclass="math inline">\(t_j\)</span> 天），每天需要租借 <spanclass="math inline">\(d_j\)</span> 个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供<span class="math inline">\(d_j\)</span>个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第<span class="math inline">\(s_j\)</span> 天到第 <spanclass="math inline">\(t_j\)</span> 天中有至少一天剩余的教室数量不足<span class="math inline">\(d_j\)</span> 个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><h2 id="输入格式-10">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,m\)</span>，表示天数和订单的数量。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个正整数，其中第<span class="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(r_i\)</span>，表示第 <spanclass="math inline">\(i\)</span> 天可用于租借的教室数量。</p><p>接下来有 <span class="math inline">\(m\)</span>行，每行包含三个正整数 <spanclass="math inline">\(d_j,s_j,t_j\)</span>，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 <spanclass="math inline">\(1\)</span> 开始的整数编号。</p><h2 id="输出格式-10">输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 <spanclass="math inline">\(0\)</span>。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数 <spanclass="math inline">\(-1\)</span>，第二行输出需要修改订单的申请人编号。</p><h2 id="样例-1-10">样例 #1</h2><h3 id="样例输入-1-10">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">2 5 4 3 </span><br><span class="line">2 1 3 </span><br><span class="line">3 2 4 </span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-9">提示</h2><p>【输入输出样例说明】</p><p>第 <span class="math inline">\(1\)</span>份订单满足后，<spanclass="math inline">\(4\)</span>天剩余的教室数分别为 <spanclass="math inline">\(0,3,2,3\)</span>。第 <spanclass="math inline">\(2\)</span> 份订单要求第 <spanclass="math inline">\(2\)</span>天到第 <spanclass="math inline">\(4\)</span> 天每天提供<spanclass="math inline">\(3\)</span>个教室，而第 <spanclass="math inline">\(3\)</span> 天剩余的教室数为<spanclass="math inline">\(2\)</span>，因此无法满足。分配停止，通知第<spanclass="math inline">\(2\)</span> 个申请人修改订单。</p><p>【数据范围】</p><p>对于10%的数据，有<span class="math inline">\(1≤ n,m≤10\)</span>；</p><p>对于30%的数据，有<span class="math inline">\(1≤n,m≤1000\)</span>；</p><p>对于 70%的数据，有<span class="math inline">\(1 ≤ n,m ≤10^5\)</span>；</p><p>对于 100%的数据，有<span class="math inline">\(1 ≤ n,m ≤ 10^6,0 ≤r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n\)</span>。</p><p>NOIP 2012 提高组 第二天 第二题</p><p>2022.2.20 新增一组 hack 数据 ## 思路分析（这道当初也不会qwq，看了题解<ahref="https://www.luogu.com.cn/article/sncheqxz">大佬——皎月半洒花</a>的博客）还是想想暴力，可以暴力先枚举订单数量，然后减少可以使用的教室数目，直到超过上限为止，但是这肯定会TLE。想想怎么办？我们修改的是教室的数目，并且是一个区间，所以想到的是差分。因为需要找到哪一个不满足，所以加上二分进行查询即可。 引用大佬的话：</p><blockquote><p>一般来说，二分是个很有用的优化途径，因为这样会直接导致减半运算，而对于能否二分，有一个界定标准：状态的决策过程或者序列<strong>是否满足单调性或者可以局部舍弃性</strong>。而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p></blockquote><h2 id="ac代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">ll r[MAXN],d_j[MAXN],s_j[MAXN],t_j[MAXN],diff[MAXN],need[MAXN],ans,n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(diff,<span class="number">0</span>,<span class="built_in">sizeof</span>(diff));</span><br><span class="line">    <span class="comment">//利用差分进行区间修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        diff[s_j[i]]+=d_j[i];</span><br><span class="line">        diff[t_j[i]+<span class="number">1</span>]-=d_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得到每天需要的教室数目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        need[i]=need[i<span class="number">-1</span>]+diff[i];</span><br><span class="line">        <span class="comment">//看看每天的教室数目能否满足需求</span></span><br><span class="line">        <span class="keyword">if</span>(need[i]&gt;r[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;d_j[i]&gt;&gt;s_j[i]&gt;&gt;t_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以先判断是否能全部满足，如果能输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">1</span>,right=m;</span><br><span class="line">    <span class="comment">//二分的是订单号，check的是每天的教室数目能否满足</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4391</title>
      <link href="/2024/03/13/Luogu%20P4391/"/>
      <url>/2024/03/13/Luogu%20P4391/</url>
      
        <content type="html"><![CDATA[<h1 id="boi2009-radio-transmission-无线传输">[BOI2009] RadioTransmission 无线传输</h1><blockquote><h2 id="题目描述">题目描述</h2><p>给你一个字符串 <spanclass="math inline">\(s_1\)</span>，它是由某个字符串 <spanclass="math inline">\(s_2\)</span> 不断自我连接形成的（保证至少重复<span class="math inline">\(2\)</span> 次）。但是字符串 <spanclass="math inline">\(s_2\)</span>是不确定的，现在只想知道它的最短长度是多少。</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 <spanclass="math inline">\(L\)</span>，表示给出字符串的长度。</p><p>第二行给出字符串 <span class="math inline">\(s_1\)</span>的一个子串，全由小写字母组成。</p><h2 id="输出格式">输出格式</h2><p>仅一行，表示 <span class="math inline">\(s_2\)</span>的最短长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 cabcabca</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>3</code></p><h2 id="提示">提示</h2><h4id="样例输入输出-1-解释-对于样例我们可以利用-textttabc-不断自我连接得到-textttabcabcabcabc读入的-textttcabcabca是它的子串">样例输入输出1 解释 对于样例，我们可以利用 <spanclass="math inline">\(\texttt{abc}\)</span> 不断自我连接得到 <spanclass="math inline">\(\texttt{abcabcabcabc}\)</span>，读入的 <spanclass="math inline">\(\texttt{cabcabca}\)</span>，是它的子串。</h4><h4 id="规模与约定-对于全部的测试点保证-1-l-le-106">规模与约定对于全部的测试点，保证 <span class="math inline">\(1 &lt; L \le10^6\)</span>。</h4></blockquote><p>按照题意，我们要求的是<spanclass="math inline">\(s_2\)</span>的最短长度，也就是<spanclass="math inline">\(s_1\)</span>最小的循环字串。这里实际上有一个结论：答案就是<spanclass="math inline">\(n-pmt[n-1]\)</span>。(可能有的结论是<spanclass="math inline">\(n-pmt[n]\)</span>，只是因为下标是从1开始)具体证明可以看这篇博客：（写得很清楚了） <ahref="https://lyyy.blog.luogu.org/p4391-boi2009radio-transmission-wu-xian-zhuan-shu-ti-xie">大佬的详解</a>下面贴上代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充证明">补充证明</h2><p><imgsrc="https://img-blog.csdnimg.cn/direct/444dc91cd4ed450f93fd37e51a114e9d.png#pic_center"alt="在这里插入图片描述" /> 上面的前后缀是<spanclass="math inline">\(max(border)\)</span>。不妨记上面的前缀为<spanclass="math inline">\(s_1\)</span>，下面的后缀为<spanclass="math inline">\(s_2\)</span>。 我们可以发现<imgsrc="https://img-blog.csdnimg.cn/direct/be681483c20c45ec91851a924eecfe1b.png#pic_center"alt="在这里插入图片描述" /> 箭头联系起来的各部分是相等的，也就是<spanclass="math inline">\(s_1[1]=s_2[2]、s_1[2]=s_2[3]、s_1[3]=s_2[4]······\)</span>，由此类推。同时，又因为<spanclass="math inline">\(s_1[1]=s_2[1]、s_1[2]=s_2[2]、s_1[3]=s_2[3]······\)</span>，将两者联系起来，我们可以得到：<spanclass="math display">\[s_1[i]=s_2[j]|1&lt;=i&lt;=5，1&lt;=j&lt;=5\]</span>那有没有可能：更一般的情况是：<spanclass="math inline">\(s_1\)</span>红色部分的后面加上一小段普通的字符串<spanclass="math inline">\(t\)</span>。我们可以分析一下：实际上这是可能的。我们可以结合样例进行分析。（这里不写了，样例的解释很清楚，可以认为：最后的循环节被强行切割了一部分。）所以我们总结一下上面的内容：红色部分的字符串就是我们要求的最小循环节了。所以问题转化为：求<span class="math inline">\(max(border)\)</span>。只需要求出<span class="math inline">\(pmt[n-1]\)</span>即可，那么<spanclass="math inline">\(n-pmt[n-1]\)</span>就是答案了。</p><h2 id="ac代码">AC代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 929(Div.3)</title>
      <link href="/2024/03/13/Codeforces%20Round%20929(Div.3)/"/>
      <url>/2024/03/13/Codeforces%20Round%20929(Div.3)/</url>
      
        <content type="html"><![CDATA[<h1 id="problem-a"><ahref="https://codeforces.com/contest/1933/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接累计各元素绝对值即可 ## AC代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans+=x;</span><br><span class="line">        <span class="keyword">else</span> ans-=x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # <ahref="https://codeforces.com/contest/1933/problem/B">Problem B</a> ##思路分析 两种操作：去除一个元素，或者某个元素+1。 其实可以发现，<spanclass="math inline">\(sum\)</span>%<spanclass="math inline">\(3\)</span>结果只有<spanclass="math inline">\(0,1,2\)</span>. <spanclass="math inline">\(0：\)</span>直接输出0即可。 <spanclass="math inline">\(1：\)</span>要不删去一个元素(其取模结果为1)，要不加2，所以可以用个<spanclass="math inline">\(flag\)</span>，看看有没有这样的元素存在。 <spanclass="math inline">\(2：\)</span>要不删去一个元素，要不加1，无所谓，都是两次操作。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,flag=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)flag=<span class="number">1</span>;</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-c"><ahref="https://codeforces.com/contest/1933/problem/C">Problem C</a></h1><h2 id="思路分析-1">思路分析</h2><p>坐牢的开始qwq，自己想得太复杂了，其实直接用快速幂枚举<spanclass="math inline">\(x,y\)</span>即可（看了队里大佬的代码）。这里去重有个小技巧，可以用<spanclass="math inline">\(set\)</span>，这样就可以不用写判断是否重复的条件（set可以直接去重），最后输出<spanclass="math inline">\(set.size()\)</span>即可。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpower</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans*=a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,l;cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;<span class="built_in">quickpower</span>(a,x)&lt;=l;x++)&#123;</span><br><span class="line">        <span class="comment">//注意y的枚举条件是quickpower(a,x)*quickpower(b,y)&lt;=l</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; <span class="built_in">quickpower</span>(a,x)*<span class="built_in">quickpower</span>(b,y)&lt;=l;y++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">quickpower</span>(a,x)* <span class="built_in">quickpower</span>(b,y);</span><br><span class="line">            <span class="keyword">if</span>(l%num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//将l/num存入set中</span></span><br><span class="line">                s.<span class="built_in">insert</span>(l/num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-d"><ahref="https://codeforces.com/contest/1933/problem/D">Problem D</a></h1><h2 id="思路分析-2">思路分析</h2><p>看看样例，可以大胆猜测一下，先从小到大排序，可以发现，<spanclass="math inline">\(SmallElememt\)</span>%<spanclass="math inline">\(BigElememt\)</span>肯定不为0，那么这样贪心排序下来，如果可以得到结果不为0，满足题意，直接<spanclass="math inline">\(return\)</span>即可。但是，需要特判是否有相同的情况，只需要考虑<spanclass="math inline">\(a_0、a_1\)</span>即可，后面是否连续无影响，如果<spanclass="math inline">\(a_0==a_1\)</span>，则不满足题意。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//元素按照从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=a[<span class="number">0</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果%!=0，输出yes</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%a[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="problem-e"><ahref="https://codeforces.com/contest/1933/problem/E">Problem E</a></h1><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 928(Div.4)</title>
      <link href="/2024/03/13/Codeforces%20Round%20928(Div.4)/"/>
      <url>/2024/03/13/Codeforces%20Round%20928(Div.4)/</url>
      
        <content type="html"><![CDATA[<h1 id="problem-a"><ahref="https://codeforces.com/contest/1926/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接模拟即可 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">5</span>-a)cout&lt;&lt;<span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-b"><ahref="https://codeforces.com/contest/1926/problem/B">Problem B</a></h1><h2 id="思路分析-1">思路分析</h2><p>我的思路是：当统计每一行1的个数，当第<spanclass="math inline">\(i\)</span>与第<spanclass="math inline">\(i-1\)</span>行中统计到的1的个数（前提是这两行中1的个数不为0）不同时，就是三角形，否则是正方形。</p><p>一开始的时候WA了一次，就是没考虑到第<spanclass="math inline">\(i\)</span>行与第<spanclass="math inline">\(i+1\)</span>行中1的个数都得不为0 ## WA代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚写博客的时候想到可以改进一下，如果<spanclass="math inline">\(flag==1\)</span>了，那么后面的输入其实都是没有意义的，也就不需要统计和判断了，修改如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;!flag;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i]&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-c"><ahref="https://codeforces.com/contest/1926/problem/C">Problem C</a></h1><h2 id="思路分析-2">思路分析</h2><p>其实是一个见过很多次的操作了qwq，先离线处理计算（没错，就是你想的暴力计算<spanclass="math inline">\(qwq\)</span>）出所有在数据范围内的答案，然后用一个数组将其存下即可。这样可以做到<spanclass="math inline">\(O(1)询问\)</span>，预处理时间是<spanclass="math inline">\(O(MAXN)\)</span>，总的时间复杂度为<spanclass="math inline">\(O(MAXN+n)\)</span> ## AC代码 具体细节看看代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x的各位数字拆解，并统计各位数字总和</span></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        tot+=(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//直接输出计算好的ans[n]即可</span></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">        <span class="comment">//需要用前缀和数组存下来，因为后面有多次询问，所以需要对应记录哪个i，对应哪个ans[i]</span></span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]+<span class="built_in">cal</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-d"><ahref="https://codeforces.com/contest/1926/problem/D">Problem D</a></h1><h2 id="思路分析-3">思路分析</h2><p>题目的意思：将给的数字分成若干组，同一组中的若干个数字之间，他们的二进制形式的每一位必须都是不同的，求最小组数我们可以先分析同一组中的数字有什么特点： <imgsrc="https://img-blog.csdnimg.cn/direct/064ba75fccfd477c99803f52409a641e.png#pic_center"alt="在这里插入图片描述" />那么我们可以根据这个性质，来求解这道题了，具体还得看代码。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LUOGU_RID: 148392530</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//book：输入的数字x的个数，可以理解为存放x的库</span></span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//查看存放 x对应的异或数（记作y）的库 是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x])&#123;</span><br><span class="line">            <span class="comment">//如果存在，那么book[y]的数量--</span></span><br><span class="line">            book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x]--;</span><br><span class="line">            <span class="comment">//说明可以创建出一组满组（也就是有x，y的组），ans++，统计一下</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，book[x]++，说明x库中x的数量增加了一个</span></span><br><span class="line">        <span class="keyword">else</span> book[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再遍历一下无法找到 对应的y 的x，那么他们只能单独成组了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:book)&#123;</span><br><span class="line">        ans+=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-e"><ahref="https://codeforces.com/contest/1926/problem/E">Problem E</a></h1><h2 id="思路分析-4">思路分析</h2><p>可以先模拟一下题目说的流程： <imgsrc="https://img-blog.csdnimg.cn/direct/c675e02c15524d56a0222edca40eef9e.png#pic_center"alt="在这里插入图片描述" /> ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意得向上取整</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;(n+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tot=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        k-=tot;</span><br><span class="line">        <span class="comment">//注意总数/2</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//轮数++</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说实话，我也没太懂为什么是2*k-1</span></span><br><span class="line">    <span class="comment">//owo 我们每一次删除的时候删的是K*(1,3,5······)，所以这里2*k-1，才是对应删的奇数（K泛指系数）</span></span><br><span class="line">    cout&lt;&lt;((<span class="number">2</span>*k<span class="number">-1</span>)&lt;&lt;cnt)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Edu 162</title>
      <link href="/2024/03/13/Codeforces%20Edu%20162/"/>
      <url>/2024/03/13/Codeforces%20Edu%20162/</url>
      
        <content type="html"><![CDATA[<h2 id="problem-a"><ahref="https://codeforces.com/contest/1923/problem/A">Problem A</a></h2><h3 id="思路分析">思路分析</h3><p>贪心，因为<spanclass="math inline">\(chips\)</span>只能左移到最近的空格子，所以其实只需要考虑在最长的以1开头和以1结尾的串内（记作<spanclass="math inline">\(s\)</span>）移动即可（其他部分没用，不然只会做多余的移动）。至于怎么移，可以想象把从第一个1串右端的所有1串保持成串的形式，轮流滚近第一个1串，恰好接上为止，可以证明，滚的次数恰好就是<spanclass="math inline">\(s\)</span>内0的个数。 画个图比较好理解： <imgsrc="https://img-blog.csdnimg.cn/direct/52b551df24b94fe297337faaa27b22d7.png#pic_center"alt="在这里插入图片描述" /> 不难发现：答案就是<spanclass="math inline">\(s\)</span>中0的个数，可以多结合几个样例分析一下。### 代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l=MAXN,r,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//预处理出最长的$s$串的左右端点，注意l初始化为MAXN，并且统计出1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;    </span><br><span class="line">            r=i;</span><br><span class="line">            l=<span class="built_in">min</span>(l,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r-l+<span class="number">1</span>-cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//求出0的个数，也就是最少的移动次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-b"><ahref="https://codeforces.com/contest/1923/problem/B">Problem B</a></h2><h3 id="思路分析-1">思路分析</h3><p>贪心，很显然，肯定是需要先打举例我们最近的怪物，再打次近的怪物，依此类推，只要在其中，有一个怪物打不死，那么我们就输了。所以这里可以用到前缀和，预处理出前<spanclass="math inline">\(i\)</span>个最近的怪物们的总血量（记作<spanclass="math inline">\(pre[i]\)</span>），如果在对应的这段时间内，（也就是<spanclass="math inline">\(abs(a[i].pos)\)</span>），我们打出的子弹数<spanclass="math inline">\(k*abs(a[i].pos)&lt;pre[i]\)</span>，那么我们就输出<spanclass="math inline">\(NO\)</span>直接判掉。注意得先派个序，按距离从小到大，可以用结构体+<spanclass="math inline">\(cmp\)</span>。 ### 代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll hp,pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.pos)&lt;<span class="built_in">abs</span>(b.pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,k,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].hp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].pos;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=a[i].hp;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;k*<span class="built_in">abs</span>(a[i].pos))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-c"><ahref="https://codeforces.com/contest/1923/problem/C">Problem C</a></h2><h3 id="思路分析-2">思路分析</h3><p>其实就是看能否根据给出的子数组，构造出一个好数组（被翻译坑了）。怎么构造？？？总和相同，但是相同位置的元素不同，并且元素都大于0。有一个比较容易实现的想法：就是在原有的基础上，部分元素加1，显然，有一些元素需要减少，但是又不能减太多（不然就小于0了）。这其中就有一个比较特别的元素：1。1只能加，不能减，那么要加多少个1（记作<spanclass="math inline">\(x\)</span>）就只能由其他非一元素（能够贡献的记作<spanclass="math inline">\(y\)</span>）贡献了。</p><h3 id="代码实现">代码实现</h3><p>可以用前缀和，预处理出在各个区间内1的个数，以及各个区间内非一元素的最大贡献。这里有用到一些小技巧：可以先在输入<spanclass="math inline">\(a[i]\)</span>时，将<spanclass="math inline">\(a[i]--\)</span>，这样求出来<spanclass="math inline">\(sum[r]-sum[l-1]\)</span>就是<spanclass="math inline">\(y\)</span>了。 需要注意特判一下：如果<spanclass="math inline">\(l==r\)</span>，那么我们就无法构造出好数组（很显然）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,q,l,r,tot;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">cnt</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];       <span class="comment">//预处理出前i个元素的最大贡献</span></span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);  <span class="comment">//预处理出前i个元素中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ll x=cnt[r]-cnt[l<span class="number">-1</span>];</span><br><span class="line">        ll y=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==r||x&gt;y)cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;  <span class="comment">//无法满足或者长度为1，就NO，否则YES</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="problem-d"><ahref="https://codeforces.com/contest/1923/problem/D">Problem D</a></h2><h3 id="思路分析-3">思路分析</h3><p>分析题意，很容易想到<spanclass="math inline">\(i-nd\)</span>史莱姆只能被左边的或者右边的吃掉，先分析左边的情况。假设<span class="math inline">\(i\)</span>（偷懒，其实是<spanclass="math inline">\(i-nd\)</span>史莱姆，下面也一样）被左边的史莱姆吃掉，先做一些定义：<span class="math inline">\(ans[i]\)</span>：被吃掉的最小操作次数。<span class="math inline">\(l[i]\)</span>：第<spanclass="math inline">\(i\)</span>个数字的上一个与<spanclass="math inline">\(a[i]\)</span>不同的位置。 <spanclass="math inline">\(left\)</span>：记录一个区间的左端点。</p><p>如果存在<span class="math inline">\(left\)</span>，使得： 1、<spanclass="math inline">\([left,i-1]\)</span>区间的和&gt;<spanclass="math inline">\(ans[i]\)</span>。 2、<spanclass="math inline">\([left,i-1]\)</span>区间数字种类<spanclass="math inline">\(&gt;=2\)</span>（因为相同不能互相吞并，那么最少需两种大小不同的史莱姆）。那么操作次数就是:<span class="math inline">\(i-left\)</span>。</p><p>可以发现<spanclass="math inline">\(i-1\)</span>其实是固定的（对于每一个<spanclass="math inline">\(i\)</span>来说）,并且<spanclass="math inline">\(left\)</span>越小，区间和越大，反之，区间和越小，所以想到可以用二分。那么我们就需要用前缀和求出区间和，再用二分求出端点位置。</p><p>但是怎么判断<spanclass="math inline">\([left,i-1]\)</span>区间数字种类<spanclass="math inline">\(&gt;=2\)</span>，这时候<spanclass="math inline">\(l[i]\)</span>就派上用场了。二分的左右端点分别为<spanclass="math inline">\(left\)</span>（这里的<spanclass="math inline">\(left\)</span>与上面的<spanclass="math inline">\(left\)</span>无关，是完全不同的两个），<spanclass="math inline">\(right\)</span>。中间值为<spanclass="math inline">\(mid\)</span>。 如果<spanclass="math inline">\(mid&gt;l[i-1]\)</span>，那么第二个条件就不成立（此时区间数字种类只有1）.</p><p>基本上就分析完了，但是如果是右边怎么办，我们只需要将数组反转即可。</p><h3 id="代码实现-1">代码实现</h3><p>一些细节可以看注释 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(MAXN)</span>,<span class="title">pre</span><span class="params">(MAXN)</span>,<span class="title">l</span><span class="params">(MAXN)</span>,<span class="title">ans</span><span class="params">(MAXN)</span>,<span class="title">b</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//其实跟下面的条件2判断一样，也就是前面的一段全都是同一个数字</span></span><br><span class="line">    <span class="comment">//思路是参考RegenFallen大佬的，但我感觉这一行不用加上去，因为不可能二分到位置为0，试了一下，删去也AC了，所以加不加无所谓</span></span><br><span class="line">    <span class="comment">//if(x&lt;=0)return 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件2：区间内数字种类小于2</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;l[i<span class="number">-1</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//条件1</span></span><br><span class="line">    <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[x<span class="number">-1</span>]&gt;a[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[n-i+<span class="number">1</span>]=a[i];    <span class="comment">//先反转，存起来</span></span><br><span class="line">        ans[i]=<span class="number">1e9</span>;       <span class="comment">//ans[i]先预处理为1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];         <span class="comment">//预处理出前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];  <span class="comment">//预处理出l[i],可以举几个例子：0333332222</span></span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右端点都得判，先判右，再判左，可以保证求出来ans[i]最小，并且有可能右端点不满足（check==false），所以左端点也必须得判断。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[i]=<span class="built_in">min</span>(ans[i],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[i]=<span class="built_in">min</span>(ans[i],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来就是相同的操作，但是注意ans数组的下标要反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[n-i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans[i]==<span class="number">1e9</span>?<span class="number">-1</span>:ans[i])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="problem-e"><ahref="https://codeforces.com/contest/1923/problem/E">Problem E</a></h2><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1029A</title>
      <link href="/2024/03/13/CF1029A/"/>
      <url>/2024/03/13/CF1029A/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="many-equal-substrings">Many Equal Substrings</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>你有一个字符串t，它由n个字母组成。</p><p>定义一个字符串s的子串为s[l...r]，表示从位置l到r构成的一个新的串。</p><p>你的目标是构造一个字符串s，使得它的可能长度最小，要求s中存在k个位置i,可以找到k个以i为出发点的子串t。</p><p>输入： 第一行输入两个整数n和k，表示t的长度和需要k个子串</p><p>第二行输入字符串t</p><p>输出：</p><p>输出满足条件的长度最小的s。题目保证答案唯一。</p><h2 id="题目描述">题目描述</h2><p>You are given a string $ t $ consisting of $ n $ lowercase Latinletters and an integer number $ k $ .</p><p>Let's define a substring of some string $ s $ with indices from $ l $to $ r $ as $ s[l r] $ .</p><p>Your task is to construct such string $ s $ of minimum possiblelength that there are exactly $ k $ positions $ i $ such that $ s[i i +n - 1] = t $ . In other words, your task is to construct such string $ s$ of minimum possible length that there are exactly $ k $ substrings of$ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="输入格式">输入格式</h2><p>The first line of the input contains two integers $ n $ and $ k $ ( $1 n, k $ ) — the length of the string $ t $ and the number ofsubstrings.</p><p>The second line of the input contains the string $ t $ consisting ofexactly $ n $ lowercase Latin letters.</p><h2 id="输出格式">输出格式</h2><p>Print such string $ s $ of minimum possible length that there areexactly $ k $ substrings of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 4 aba</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababababa</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>3 2 cat</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>catcat</code></p></blockquote><p>看到这道题要求的答案，想到了熟悉的循环节问题，就从这入手吧。还是先求出来<spanclass="math inline">\(t\)</span>的最小的循环节（记作<spanclass="math inline">\(p\)</span>），并根据<spanclass="math inline">\(k\)</span>进行多次构造。</p><p>但是，通过样例一可以发现，构造出来的<spanclass="math inline">\(s\)</span>可能不是恰好由整数个<spanclass="math inline">\(p\)</span>构成。看样例一，可以发现最后恰好是由<spanclass="math inline">\(pmt[n-1]\)</span>构成。</p><p>根据题意，可以总结出：前面输出<spanclass="math inline">\(k-1\)</span>个循环节，后面输出<spanclass="math inline">\(t\)</span>即可。 因为前面的<spanclass="math inline">\(k-1\)</span>个循环节首尾相连，已经是构成了<spanclass="math inline">\(k-1\)</span>个<spanclass="math inline">\(t\)</span>结构了。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>()-pmt[s.<span class="built_in">length</span>()<span class="number">-1</span>];j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF45D</title>
      <link href="/2024/03/13/CF54D/"/>
      <url>/2024/03/13/CF54D/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="writing-a-song">Writing a Song</h1><h2 id="题面翻译">题面翻译</h2><p><strong>题目大意</strong></p><p>求一个字符串s，满足该串长度为n，只出现字母表中前k个字母，并且在指定位置必须出现指定字符串p</p><p><strong>输入格式</strong></p><p>第一行 n，k。(n为所需字符串的长度 n&lt;=100，k为相应的字母大小2&lt;=k&lt;=26)</p><p>第二行 p。（一个长度小于n，只包含字母表中前k个字母的字符串）</p><p>第三行01串。（在第i个位置的数字1表示p的出现应该从s的第i个位置开始，而0表示从这里开始没有出现。）</p><p><strong>输出格式</strong></p><p>输出任意一个符合题意的字符串s</p><p>若无，输出“No solution”</p><h2 id="题目描述">题目描述</h2><p>One of the Hedgehog and his friend's favorite entertainments is totake some sentence or a song and replace half of the words (sometimeseven all of them) with each other's names.</p><p>The friend's birthday is approaching and the Hedgehog decided to makea special present to his friend: a very long song, where his name willbe repeated many times. But try as he might, he can't write a decentsong!</p><p>The problem is that the Hedgehog has already decided how long theresulting sentence should be (i.e. how many letters it should contain)and in which positions in the sentence the friend's name should occur,and it must not occur in any other position in the sentence. Besides,the Hedgehog decided to limit himself to using only the first $ K $letters of an English alphabet in this sentence (so it will be not evena sentence, but one long word).</p><p>The resulting problem is indeed quite complicated, that's why theHedgehog asks you to help him and write a program that will make thedesired word by the given name $ P $ , the length $ N $ of the requiredword, the given positions of the occurrences of the name $ P $ in thedesired word and the alphabet's size $ K $ . Note that the occurrencesof the name can overlap with each other.</p><h2 id="输入格式">输入格式</h2><p>The first line contains numbers $ N $ and $ K $ which are the lengthof the required string and the alphabet size accordingly. Thelimitations are: $ 1&lt;=N&lt;=100 $ , $ 2&lt;=K&lt;=26 $ .</p><p>The second line contains the name $ P $ which is a non-empty stringwhose length does not exceed $ N $ characters. The string consists onlyof the first $ K $ lowercase symbols of an English alphabet.</p><p>The third line contains the string of length $ N-length(P)+1 $ ,consisting only of numbers zero and one. A number one in the $ i $ -thposition means that an occurrence of the name $ P $ should start from $i $ -th position of the desired word, while a zero means that there isno occurrence starting here.</p><h2 id="输出格式">输出格式</h2><p>Print the desired word $ S $ . If there are several answers, printany of them.</p><p>If there is no solution, then print "No solution".</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>5 2 aba 101</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababa</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>5 2 a 10001</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>abbba</code></p><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><p><code>6 2 abba 101</code></p><h3 id="样例输出-3">样例输出 #3</h3><p><code>No solution</code></p></blockquote><p>可怕的构造题，不会qwq，只能看题解区大佬了（大佬讲得很清楚）：https://www.luogu.com.cn/problem/solution/CF54D构造这方面得加强qwq，贴上AC代码：</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    string p;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> lenp=p.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> lens=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i+j]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ans[i+j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p[j]==<span class="string">&#x27;a&#x27;</span>)ans[i+j]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                        <span class="keyword">else</span> ans[i+j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])ans[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉还是得多想想特殊情况：1、搜索1的时候：有没有重复占位，也就是<spanclass="math inline">\(ans[i+j]\)</span>存在，并且<spanclass="math inline">\(ans[i+j]!=p[j]\)</span>，如果存在，说明该位已经被占领了，直接<spanclass="math inline">\(No\)</span> <spanclass="math inline">\(solution\)</span>。2、搜索0的时候：看看有没有<spanclass="math inline">\(ans[i+j]\)</span>存在，并且<spanclass="math inline">\(ans[i+j]!=p[j]\)</span>，如果存在，则该位构造成功，直接<spanclass="math inline">\(break\)</span>，不用做重复的判断。3、如果2的情况没有发生，我们发现这里实际上只有两种情况（与上面相对应）：<spanclass="math inline">\(ans[i+j]==0\)</span> <spanclass="math inline">\(or\)</span> <spanclass="math inline">\(ans[i+j]==p[j]\)</span>。第二种情况已经没办法改变了（因为我们在上面的构造时已经确定<spanclass="math inline">\(ans[i+j]==p[j]\)</span>），那么我们只能改变第一种情况，看看<spanclass="math inline">\(s[j]\)</span>是什么，那么<spanclass="math inline">\(ans[i+j]\)</span>构造时只需要注意不等于<spanclass="math inline">\(s[j]\)</span>即可（这里情况一存在的话，可以直接构造后<spanclass="math inline">\(break\)</span>掉，提高一点效率，后面输出时再简单构造即可）。4、如果情况一也没有发生呢？？？很不幸，那就只能<spanclass="math inline">\(No\)</span> <spanclass="math inline">\(solution\)</span>了。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF126B</title>
      <link href="/2024/03/13/CF126B/"/>
      <url>/2024/03/13/CF126B/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="password">Password</h1><h2 id="题面翻译">题面翻译</h2><p>Asterix，Obelix 和他们的临时伙伴 Suffix、Prefix已经最终找到了和谐寺。然而和谐寺大门紧闭，就连 Obelix的运气也没好到能打开它。</p><p>不久他们发现了一个字符串 <span class="math inline">\(S\(1\leqslant\vertS\vert\leqslant1000000)\)</span>，刻在和谐寺大门下面的岩石上。Asterix猜想那一定是打开寺庙大门的密码，于是就大声将字符串朗读了出来，然而并没有什么事发生。于是Asterix 又猜想密码一定是字符串 <span class="math inline">\(S\)</span>的子串 <span class="math inline">\(T\)</span>。</p><p>Prefix 认为 <span class="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的前缀，Suffix 认为 <spanclass="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的后缀，Obelix 却认为 <spanclass="math inline">\(T\)</span> 应该是 <spanclass="math inline">\(S\)</span> 中的某一部分，也就是说，<spanclass="math inline">\(T\)</span> 既不是 <spanclass="math inline">\(S\)</span> 的前缀，也不是 <spanclass="math inline">\(S\)</span> 的后缀。</p><p>Asterix 选择子串 <span class="math inline">\(T\)</span>来满足所有伙伴们的想法。同时，在所有可以被接受的子串变形中，Asterix选择了最长的一个。当 Asterix 大声读出子串 <spanclass="math inline">\(T\)</span>时，寺庙的大门开了。（也就是说，你需要找到既是 <spanclass="math inline">\(S\)</span> 的前缀又是 <spanclass="math inline">\(S\)</span> 的后缀同时又在 <spanclass="math inline">\(S\)</span> 中间出现过的最长子串）</p><p>现在给你字符串 <spanclass="math inline">\(S\)</span>，你需要找到满足上述要求的子串 <spanclass="math inline">\(T\)</span>。</p><h3 id="输入格式">输入格式</h3><p>一行一个只包含小写字母的字符串 <spanclass="math inline">\(S\)</span>。</p><h3 id="输出格式">输出格式</h3><p>输出子串 <span class="math inline">\(T\)</span>，如果 <spanclass="math inline">\(T\)</span> 不存在，输出<code>Just a legend</code>。</p><h2 id="题目描述">题目描述</h2><p>Asterix, Obelix and their temporary buddies Suffix and Prefix hasfinally found the Harmony temple. However, its doors were firmly lockedand even Obelix had no luck opening them.</p><p>A little later they found a string $ s $ , carved on a rock below thetemple's gates. Asterix supposed that that's the password that opens thetemple and read the string aloud. However, nothing happened. ThenAsterix supposed that a password is some substring $ t $ of the string $s $ .</p><p>Prefix supposed that the substring $ t $ is the beginning of thestring $ s $ ; Suffix supposed that the substring $ t $ should be theend of the string $ s $ ; and Obelix supposed that $ t $ should belocated somewhere inside the string $ s $ , that is, $ t $ is neitherits beginning, nor its end.</p><p>Asterix chose the substring $ t $ so as to please all his companions.Besides, from all acceptable variants Asterix chose the longest one (asAsterix loves long strings). When Asterix read the substring $ t $aloud, the temple doors opened.</p><p>You know the string $ s $ . Find the substring $ t $ or determinethat such substring does not exist and all that's been written above isjust a nice legend.</p><h2 id="输入格式-1">输入格式</h2><p>You are given the string $ s $ whose length can vary from $ 1 $ to $10^{6} $ (inclusive), consisting of small Latin letters.</p><h2 id="输出格式-1">输出格式</h2><p>Print the string $ t $ . If a suitable $ t $ string does not exist,then print "Just a legend" without the quotes.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>fixprefixsuffix</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>fix</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>abcdabc</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>Just a legend</code></p></blockquote><p>看到这题的第一眼，想到的肯定是KMP（因为需要求最长公共前后缀嘛，将其记作<spanclass="math inline">\(t\)</span>，母串记作<spanclass="math inline">\(s\)</span>）。 但是，<spanclass="math inline">\(t\)</span>还需要是<spanclass="math inline">\(s\)</span>的中间部分，这个怎么办？？？我们可以将它转化为熟悉的问题，画个图解释一下： <imgsrc="https://img-blog.csdnimg.cn/direct/3fa1ee27e9eb4e6d8580999418d6f7b0.png#pic_center"alt="在这里插入图片描述" />这样就一目了然了吧，<spanclass="math inline">\(t\)</span>也是中间的橙色串的最长前后缀，这就转化成了我们熟悉的问题。</p><p>那么我们只要<span class="math inline">\(2\)</span>遍历到<spanclass="math inline">\(n-2\)</span>，只要<spanclass="math inline">\(pmt[i]==pmt[n-1]\)</span>，那么我们就找到最长的<spanclass="math inline">\(t\)</span>了。</p><p>但是，实际上可能是找不到的（看题意就知道了），如果<spanclass="math inline">\(pmt[n-1]\)</span>比<spanclass="math inline">\(max(pmt[i])\)</span>还大，所以这时<spanclass="math inline">\(t\)</span>的长度就得缩小了（也就是不断地往回跳：<spanclass="math inline">\(pmt[pmt[n-1]]\)</span>，<spanclass="math inline">\(pmt[pmt[pmt[n-1]]]······\)</span>，直到小于<spanclass="math inline">\(max(pmt[i])\)</span>，注意<spanclass="math inline">\(i&lt;=n-2\)</span>）。</p><p>可能有点混乱，将上述的步骤总结一下： 1、先预处理出<spanclass="math inline">\(max(pmt[i])，i&lt;=n-2\)</span>。 2、判断<spanclass="math inline">\(pmt[n-1]\)</span>与<spanclass="math inline">\(max(pmt[i])\)</span>的大小关系，如果<spanclass="math inline">\(pmt[n-1]&gt;=max(pmt[i])\)</span>，就得往回跳，直到小于<spanclass="math inline">\(max(pmt[i])\)</span>为止（记作<spanclass="math inline">\(len\)</span>吧)，当然有可能跳到0，那么这时候就无解了。3、如果有解，那么我们只需要输出<spanclass="math inline">\(0\)</span>~<spanclass="math inline">\(len-1\)</span>即可，毕竟<spanclass="math inline">\(len\)</span>是字符串的长度。</p><p>我们可以在第二步开始前加上特判<spanclass="math inline">\(pmt[n-1]==0\)</span>是否成立，如果成立，就说明前后缀不同，肯定无解。</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],maxn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,pmt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len=pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;maxn)&#123;</span><br><span class="line">            len=pmt[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                cout&lt;&lt;s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA1328</title>
      <link href="/2024/03/13/UVA1328/"/>
      <url>/2024/03/13/UVA1328/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="period">Period</h1><h2 id="题面翻译">题面翻译</h2><p>对于给定字符串 <span class="math inline">\(S\)</span>的每个前缀，我们想知道它是否为周期串（周期串定义为由若干最小循环节拼接而成的字符串），若是，输出前缀长度和循环节数量。</p><p><strong>【输入格式】</strong></p><p>多组数据，每组数据第一行一个整数 <spanclass="math inline">\(n\)</span>，表示字符串 <spanclass="math inline">\(s\)</span> 的长度，若 <spanclass="math inline">\(n=0\)</span> 则结束输入。</p><p>若 <span class="math inline">\(n\ne0\)</span>，则第二行一个字符串<span class="math inline">\(S\)</span>，如题意。</p><p><strong>【输出格式】</strong></p><p>对于第 <span class="math inline">\(i\)</span>组输出，第一行一个字符串 <code>Test case #i</code>。</p><p>之后若干行一行两个整数，表示如果字符串 <spanclass="math inline">\(S\)</span>的一个前缀是周期串，它的长度和循环节数量（注意这里的循环节是指<strong>长度最小的</strong>循环节）。</p><p>之后再空一行。</p><p><strong>【说明】</strong></p><p><span class="math inline">\(n\leq10^6\)</span>，字符串 <spanclass="math inline">\(S\)</span> 均由小写字母构成。</p><h2 id="题目描述">题目描述</h2><p><ahref="https://uva.onlinejudge.org/external/13/p1328.pdf">PDF</a></p><h2 id="输入格式">输入格式</h2><h2 id="输出格式">输出格式</h2><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 aaa 12 aabaabaabaab 0</code></p><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><figcaption><span>case #1 2 2 3 3</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Test case #2 2 2 6 2 9 3 12 4 ```</span><br><span class="line"></span><br><span class="line">还是熟悉的最小循环节问题，需要注意的是，前缀长度需要大于1，所以需要从2开始判断，最大前缀长度就是$S$的长度。</span><br><span class="line"></span><br><span class="line">判断有没有循环节，看$pmt[i-1]$是否存在，计算循环节数量，看$n$%$(n-pmt[n-1])$是否等于0（因为$S$的前缀串$t$需要作为周期串）。</span><br><span class="line"></span><br><span class="line">每个测试点之间的空行特判一下即可，看$i==len$是否成立。</span><br><span class="line"></span><br><span class="line">## AC代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll=long long;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">int pmt[MAXN],n,cnt;</span><br><span class="line">string s;</span><br><span class="line">void get_pmt(const string&amp; s)&#123;</span><br><span class="line">   for(int i=1,j=0;i&lt;s.length();i++)&#123;</span><br><span class="line">       while(j&amp;&amp;s[i]!=s[j])j=pmt[j-1];</span><br><span class="line">       if(s[i]==s[j])j++;</span><br><span class="line">       pmt[i]=j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">   ios::sync_with_stdio(0),cin.tie(0);</span><br><span class="line">   while(1)&#123;</span><br><span class="line">       cin&gt;&gt;n;</span><br><span class="line">       if(n==0)break;</span><br><span class="line">       cin&gt;&gt;s;</span><br><span class="line">       int len=s.length();</span><br><span class="line">       memset(pmt,0,sizeof(pmt));</span><br><span class="line">       get_pmt(s);</span><br><span class="line">       cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;++cnt&lt;&lt;&quot;\n&quot;;</span><br><span class="line">       for(int i=2;i&lt;=len;i++)&#123;</span><br><span class="line">           if(pmt[i-1]&amp;&amp;i%(i-pmt[i-1])==0)&#123;</span><br><span class="line">               cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i/(i-pmt[i-1])&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           if(i==len)&#123;</span><br><span class="line">               cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA10298</title>
      <link href="/2024/03/13/UVA10298/"/>
      <url>/2024/03/13/UVA10298/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="power-strings">Power Strings</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题意简述">题意简述：</h3><p>求一个字符串由多少个重复的子串连接而成。</p><p>例如 <code>ababab</code> 由三个 <code>ab</code>连接而成，<code>abcd</code> 由 <code>abcd</code> 由一个<code>abcd</code> 连接而成。</p><h3 id="输入格式">输入格式</h3><p><strong>本题多组数据</strong>。</p><p>每一组数据仅有一行，这一行仅有一个字符串 <spanclass="math inline">\(s\)</span>。</p><p>输入的结束标志为一个 <code>.</code>。</p><h3 id="输出格式">输出格式</h3><p>对于每一组数据，输出这组字符串由多少个重复的子串连接而成。</p><h3 id="说明提示">说明/提示</h3><p><span class="math inline">\(1\le |s|\le 10^6\)</span>。</p><h2 id="题目描述">题目描述</h2><p><ahref="https://uva.onlinejudge.org/external/102/p10298.pdf">PDF</a></p><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/5a89b1b5be26ca2d032d51c4fc5e18d2.png" /></p><h2 id="输入格式-1">输入格式</h2><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/aa5c61819fa5b54135f8b7236af00a7e.png" /></p><h2 id="输出格式-1">输出格式</h2><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/795c5ef49846eb46a838271a5812fff1.png" /></p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>abcd aaaa ababab .</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 4 3</code></p></blockquote><p>其实方法还是一样的，求出最短的循环节(记作<spanclass="math inline">\(p\)</span>)，也就是<spanclass="math inline">\(n-pmt[n-1]\)</span>，然后就是<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>。但是，这里需要注意的是：<spanclass="math inline">\(s\)</span>可能不是由整数个<spanclass="math inline">\(p\)</span>构成的，可能存在最后的<spanclass="math inline">\(p\)</span>被切割的情况。（一开始没考虑到这点，看了题解才反应过来）。那么这里就需要进行特叛了：如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])==0\)</span>，说明恰好整除，那么<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>就是答案了。 如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])!=0\)</span>，那么只能以<spanclass="math inline">\(s\)</span>自身作为循环节了，答案也就是1。具体的证明可以看看评论区的大佬，写的很好：https://www.luogu.com.cn/blog/hzz/solution-uva10298</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">get_pmt</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%(n-pmt[n<span class="number">-1</span>])==<span class="number">0</span>)cout&lt;&lt;n/(n-pmt[n<span class="number">-1</span>])&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>因为这道题目是有多个数据输入，且一行一个<spanclass="math inline">\(s\)</span>，所以我们可以用<spanclass="math inline">\(getlin(cin,s)\)</span>，只需要当<spanclass="math inline">\(s\)</span>为"<spanclass="math inline">\(.\)</span>"时结束即可。</p><h2 id="结论总结">结论总结：</h2><p>设字符串的长度为<spanclass="math inline">\(n\)</span>，最长相同前后缀的长度为<spanclass="math inline">\(pmt[n-1]\)</span>。如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])==0\)</span>，则答案为<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>，否则为1。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3375</title>
      <link href="/2024/03/13/Luogu%20P3375/"/>
      <url>/2024/03/13/Luogu%20P3375/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="模板kmp">【模板】KMP</h1><h2 id="题目描述">题目描述</h2><p>给出两个字符串 <span class="math inline">\(s_1\)</span> 和 <spanclass="math inline">\(s_2\)</span>，若 <spanclass="math inline">\(s_1\)</span> 的区间 <spanclass="math inline">\([l, r]\)</span> 子串与 <spanclass="math inline">\(s_2\)</span> 完全相同，则称 <spanclass="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中出现了，其出现位置为 <spanclass="math inline">\(l\)</span>。 现在请你求出 <spanclass="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中所有出现的位置。</p><p>定义一个字符串 <span class="math inline">\(s\)</span> 的 border 为<span class="math inline">\(s\)</span> 的一个<strong>非 <spanclass="math inline">\(s\)</span> 本身</strong>的子串 <spanclass="math inline">\(t\)</span>，满足 <spanclass="math inline">\(t\)</span> 既是 <spanclass="math inline">\(s\)</span> 的前缀，又是 <spanclass="math inline">\(s\)</span> 的后缀。 对于 <spanclass="math inline">\(s_2\)</span>，你还需要求出对于其每个前缀 <spanclass="math inline">\(s&#39;\)</span> 的最长 border <spanclass="math inline">\(t&#39;\)</span> 的长度。</p><h2 id="输入格式">输入格式</h2><p>第一行为一个字符串，即为 <span class="math inline">\(s_1\)</span>。第二行为一个字符串，即为 <span class="math inline">\(s_2\)</span>。</p><h2 id="输出格式">输出格式</h2><p>首先输出若干行，每行一个整数，<strong>按从小到大的顺序</strong>输出<span class="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中出现的位置。 最后一行输出 <spanclass="math inline">\(|s_2|\)</span> 个整数，第 <spanclass="math inline">\(i\)</span> 个整数表示 <spanclass="math inline">\(s_2\)</span> 的长度为 <spanclass="math inline">\(i\)</span> 的前缀的最长 border 长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>ABABABC ABA</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 3 0 0 1</code></p><h2 id="提示">提示</h2><h3 id="样例-1-解释">样例 1 解释</h3><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/3c98caa2ee905bfada0eb2516ba7b8cc.png" />。对于 <span class="math inline">\(s_2\)</span> 长度为 <spanclass="math inline">\(3\)</span> 的前缀 <code>ABA</code>，字符串<code>A</code> 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为<span class="math inline">\(1\)</span>。</p><h3 id="数据规模与约定">数据规模与约定</h3><p><strong>本题采用多测试点捆绑测试，共有 3 个子任务</strong>。</p><ul><li>Subtask 1（30 points）：<span class="math inline">\(|s_1| \leq15\)</span>，<span class="math inline">\(|s_2| \leq 5\)</span>。</li><li>Subtask 2（40 points）：<span class="math inline">\(|s_1| \leq10^4\)</span>，<span class="math inline">\(|s_2| \leq10^2\)</span>。</li><li>Subtask 3（30 points）：无特殊约定。</li></ul><p>对于全部的测试点，保证 <span class="math inline">\(1 \leq |s_1|,|s_2|\leq 10^6\)</span>，<span class="math inline">\(s_1, s_2\)</span>中均只含大写英文字母。</p></blockquote><p>这道题就是妥妥的KMP模板题，具体原理可以参考知乎Pecco大佬的文章，链接贴上：https://zhuanlan.zhihu.com/p/105629613</p><p>需要注意的一点是：Pecco大佬的KMP写法与我所看到的大部分写法有细节上的不同，所以做题的时候，如果打算用Pecco大佬的码作为模板，你需要经常琢磨到底哪一点需要修改，就当是锻炼自己是否真正理解了KMP算法吧。</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> pmt[MAXN];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;  </span><br><span class="line">        pmt[i]=j;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">const</span> string &amp;p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])j++;  </span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">length</span>())&#123;  </span><br><span class="line">            cout&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">            j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    string s,p;  </span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;  </span><br><span class="line">    <span class="built_in">get_pmt</span>(p);  </span><br><span class="line">    <span class="built_in">kmp</span>(s,p);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        cout&lt;&lt;pmt[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3435</title>
      <link href="/2024/03/12/Luogu%20P3435/"/>
      <url>/2024/03/12/Luogu%20P3435/</url>
      
        <content type="html"><![CDATA[<hr /><h1 id="poi2006-okr-periods-of-words">[POI2006] OKR-Periods ofWords</h1><blockquote><h2 id="题面翻译">题面翻译</h2><p>对于一个仅含小写字母的字符串 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(p\)</span>为 <span class="math inline">\(a\)</span> 的前缀且 <spanclass="math inline">\(p\ne a\)</span>，那么我们称 <spanclass="math inline">\(p\)</span> 为 <spanclass="math inline">\(a\)</span> 的 proper 前缀。</p><p>规定字符串 <span class="math inline">\(Q\)</span> 表示 <spanclass="math inline">\(a\)</span> 的周期，当且仅当 <spanclass="math inline">\(Q\)</span> 是 <spanclass="math inline">\(a\)</span> 的 proper 前缀且 <spanclass="math inline">\(a\)</span> 是 <spanclass="math inline">\(Q+Q\)</span> 的前缀。若这样的字符串不存在，则<span class="math inline">\(a\)</span> 的周期为空串。</p><p>例如 <code>ab</code> 是 <code>abab</code> 的一个周期，因为<code>ab</code> 是 <code>abab</code> 的 proper 前缀，且<code>abab</code> 是 <code>ab+ab</code> 的前缀。</p><p>求给定字符串所有前缀的最大周期长度之和。</p><h2 id="题目描述">题目描述</h2><p>A string is a finite sequence of lower-case (non-capital) letters ofthe English alphabet. Particularly, it may be an empty sequence, i.e. asequence of 0 letters. By A=BC we denotes that A is a string obtained byconcatenation (joining by writing one immediately after another, i.e.without any space, etc.) of the strings B and C (in this order). Astring P is a prefix of the string !, if there is a string B, that A=PB.In other words, prefixes of A are the initial fragments of A. Inaddition, if P!=A and P is not an empty string, we say, that P is aproper prefix of A.</p><p>A string Q is a period of Q, if Q is a proper prefix of A and A is aprefix (not necessarily a proper one) of the string QQ. For example, thestrings abab and ababab are both periods of the string abababa. Themaximum period of a string A is the longest of its periods or the emptystring, if A doesn't have any period. For example, the maximum period ofababab is abab. The maximum period of abc is the empty string.</p><p>Task Write a programme that:</p><p>reads from the standard input the string's length and the stringitself,calculates the sum of lengths of maximum periods of all itsprefixes,writes the result to the standard output.</p><h2 id="输入格式">输入格式</h2><p>In the first line of the standard input there is one integer <spanclass="math inline">\(k\)</span> (<span class="math inline">\(1\le k\le1\ 000\ 000\)</span>) - the length of the string. In the following linea sequence of exactly <span class="math inline">\(k\)</span> lower-caseletters of the English alphabet is written - the string.</p><h2 id="输出格式">输出格式</h2><p>In the first and only line of the standard output your programmeshould write an integer - the sum of lengths of maximum periods of allprefixes of the string given in the input.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 babababa</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>24</code></p></blockquote><p>先理解清楚题意：proper前缀可以配合下图理解 <imgsrc="https://img-blog.csdnimg.cn/direct/2c12d9db942e46608af09d0f84a0255d.png#pic_center"alt="在这里插入图片描述" />这里我们不难看出：abcabcab的最长proper字串为abcabc，长度是6。记原来的字符串为<spanclass="math inline">\(s\)</span>，proper子串为<spanclass="math inline">\(t\)</span>。想想看，如果是要使得proper字串最长，那么恰好就是<spanclass="math inline">\(len(s)-min(border)\)</span>。我们可以大致感受一下，如果<spanclass="math inline">\(border\)</span>越大，那么对应的<spanclass="math inline">\(len(t)\)</span>越小，可以结合上面的例子。那么我们的问题就变成了怎么求最小的<spanclass="math inline">\(border\)</span>。 问题是，在KMP算法中，<spanclass="math inline">\(pmt\)</span>求出来的是<spanclass="math inline">\(max(border)\)</span>。我们可以利用KMP算法的一个性质：<spanclass="math inline">\(pmt[i]、pmt[pnt[i]]、pmt[pmt[pmt[i]]]······\)</span>直到为0，以上这些都是<span class="math inline">\(s\)</span>的<spanclass="math inline">\(border\)</span>的长度，并且越来越小。利用这个性质，我们就可以求出来<spanclass="math inline">\(min(border)\)</span>。</p><p>因为题目是求所有前缀的最大周期长度之和，所以我们令<spanclass="math inline">\(j=i+1\)</span>。（因为我个人的KMP写得比较奇怪，题解区的大佬是令<spanclass="math inline">\(j=i\)</span>）。然后在<spanclass="math inline">\(j&gt;0\)</span>的情况下不断令<spanclass="math inline">\(j=pmt[j-1]\)</span>，直到<spanclass="math inline">\(j\)</span>最小为止。此时<spanclass="math inline">\(ans+=i-j+1\)</span>。 这里有一个技巧：当<spanclass="math inline">\(j\)</span>求出来后，令<spanclass="math inline">\(pmt[i]=j\)</span>，相当于记忆化，否则可能会T。</p><p>思路参考：https://www.luogu.com.cn/problem/solution/P3435</p><p>贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pmt[j<span class="number">-1</span>])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pmt[i])pmt[i]=j;</span><br><span class="line">        ans+=i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
