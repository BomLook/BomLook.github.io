<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>继承</title>
      <link href="/2024/03/26/%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/03/26/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr /><h3 id="继承">4.6 继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="https://img2.imgtp.com/2024/03/26/45FfiE86.png" /></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/h2EaLshZ.png" /></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="继承中的对象模型">4.6.3 继承中的对象模型</h4><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="https://img2.imgtp.com/2024/03/26/WB7DLB75.png" /></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名 所属文件名</p><p>效果如下图：</p><p><img src="https://img2.imgtp.com/2024/03/26/SPiG6Y3o.png" /></p><blockquote><p>结论：父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol type="1"><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和 通过类名）</p></blockquote><h4 id="多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​ 两个派生类继承同一个基类</p><p>​ 又有某个类同时继承者两个派生类</p><p>​ 这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="https://img2.imgtp.com/2024/03/26/VmrX5axh.jpg" /></p><p><strong>菱形继承问题：</strong></p><ol type="1"><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC058</title>
      <link href="/2024/03/24/ABC058/"/>
      <url>/2024/03/24/ABC058/</url>
      
        <content type="html"><![CDATA[<h1 id="abc058">ABC058</h1><blockquote><h1 id="abc058d-井井井">[ABC058D] 井井井</h1><h2 id="题面翻译">题面翻译</h2><p>给定 <span class="math inline">\(n\)</span> 条平行于 <spanclass="math inline">\(y\)</span> 轴的直线 <spanclass="math inline">\(x_{1...n}\)</span>，和 <spanclass="math inline">\(m\)</span> 条平行于 <spanclass="math inline">\(x\)</span> 轴的直线 <spanclass="math inline">\(y_{1...n}\)</span>，</p><p>计算 <span class="math inline">\(x_i,x_j\)</span> 和 <spanclass="math inline">\(y_k,y_l\)</span> 组成的矩形面积之和，<spanclass="math inline">\(1\le x&lt;y\le n\)</span>，<spanclass="math inline">\(1\le k&lt;l\le m\)</span>。</p><h2 id="题目描述">题目描述</h2><p>$ 2 $ 次元平面上に $ x $ 軸と平行な直線が $ m $ 本と $ y $軸と平行な直線が $ n $ 本引いてあります。 $ x $軸と平行な直線のうち下から $ i $ 番目は $ y = y_i $ で表せます。 $ y $軸と平行な直線のうち左から $ i $ 番目は $ x = x_i $ で表せます。</p><p>この中に存在しているすべての長方形についてその面積を求め、 合計を $10^9+7 $ で割ったあまりを出力してください。</p><p>つまり、$ 1 i &lt; j n $ と $ 1 k &lt; l m $ を満たすすべての組 $(i,j,k,l) $ について、 直線 $ x=x_i $, $ x=x_j $, $ y=y_k $, $ y=y_l $で囲まれる 長方形の面積を求め、合計を $ 10^9+7 $で割ったあまりを出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ m $ $ x_1 $ $ x_2 $ $ ... $ $ x_n $ $ y_1 $ $ y_2 $ $ ... $ $y_m $</p></blockquote><h2 id="输出格式">输出格式</h2><p>長方形の面積の合計を $ 10^9+7 $ で割ったあまりを $ 1 $行に出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 3 4</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">-790013317 -192321079 95834122 418379342 586260100 802780784</span><br><span class="line">-253230108 193944314 363756450 712662868 735867677</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">835067060</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2  n,m  10^5 $</li><li>$ -10<sup>9  x_1 &lt; ... &lt; x_n  10</sup>9 $</li><li>$ -10<sup>9  y_1 &lt; ... &lt; y_m  10</sup>9 $</li><li>$ x_i, y_i $ は整数である。</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>この入力を図にすると、以下のようになります。![sample1-1](https://atcoder.jp/img/arc071/aec4d5cc2e5c73dbee455be237a649a5.png)長方形 A,B,...,I それぞれの面積を合計すると $ 60 $ になります。![sample1-2](https://atcoder.jp/img/arc071/f0771c0f7e68af2b00e7513186f585ff.png)</p></blockquote><h2 id="思路">思路</h2><p>一开始想的是枚举可能有多少种排列方式（构成整个大矩形），然后统计输出即可，但是好像不合题意？</p><p>思路参考自：[【题解】AT2394 <ahref="https://www.luogu.com.cn/article/wlvi5bx0">ARC071B] 井井井 / ### -洛谷专栏 (luogu.com.cn)</a></p><p>可以将线段分解成相邻两直线之间的距离，如<spanclass="math inline">\(x_i-x_{i-1}\)</span>，那么只需要枚举左右端点：<spanclass="math inline">\((i-1)*(n-i+1)\)</span>。</p><p>就可以得到所有的情况<spanclass="math inline">\((x_i-x_{i-1})*(i-1)*(n-i+1)\)</span>。同理<spanclass="math inline">\(y\)</span>也是如此。最后<spanclass="math inline">\(sumx*sumy\)</span>即为答案，注意不要忘记取模。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll x[MAXN],y[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sumx=<span class="number">0</span>,sumy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)sumx=(sumx+(x[i]-x[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(n-i+<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)sumy=(sumy+(y[i]-y[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(m-i+<span class="number">1</span>))%mod;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(sumx*sumy)%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC057</title>
      <link href="/2024/03/24/ABC057/"/>
      <url>/2024/03/24/ABC057/</url>
      
        <content type="html"><![CDATA[<h1 id="abc057">ABC057</h1><blockquote><h1 id="abc057c-digits-in-multiplication">[ABC057C] Digits inMultiplication</h1><h2 id="题面翻译">题面翻译</h2><p>对于两个正整数A和B，将F ( A，B )定义为以下两者中较大的一个:max（A的位数，B的位数） 例如，F ( 3，11 ) =2，因为3有一位，11有两位。</p><p>给你一个整数n 求F ( A，B )的最小值为 使得 N = A×B</p><p>输入 n</p><p>输出 min f(a,b)</p><p>感谢@chengni 提供的翻译</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。<br />ここで、$ 2 $ つの正の整数 $ A,B $ に対して、$ F(A,B) $ を「$ 10 $進表記における、$ A $ の桁数と $ B $の桁数のうち大きい方」と定義します。<br />例えば、$ F(3,11) $ の値は、$ 3 $ は $ 1 $ 桁、$ 11 $ は $ 2 $桁であるため、$ F(3,11)=2 $ となります。<br />$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くとき、$F(A,B) $ の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $を満たすように動くときの $ F(A,B) $ の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000003</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9876543210</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^{10} $</li><li>$ N $ は整数である。</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>$ (A,B)=(100,100) $ のときに $ F(A,B) $ は最小値をとるため、$F(100,100)=3 $ を出力します。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>条件を満たす $ (A,B) $ の組は $ (1,1000003) $ と $ (1000003,1) $ の $2 $ 通りで、$ F(1,1000003)=F(1000003,1)=7 $ です。</p></blockquote><h2 id="思路">思路</h2><p>不难想到，最小值与平方根有关，所以我们可以求出平方根，然后选出较大的数。分解位数并统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll d=(ll)<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    ll num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//选出较大的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            num=n/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分解数位并统计</span></span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc057d-maximum-average-sets">[ABC057D] Maximum AverageSets</h1><h2 id="题面翻译-1">题面翻译</h2><p>有n个数，可以选取最少A个最多B个，使得所选的数的平均值最大。求可能的最大平均值和 在平均值最大的情况下的方案数</p><h2 id="题目描述-1">题目描述</h2><p>$ N $ 個の品物が与えられます。<br />$ i $ 番目の品物の価値は $ v_i (1≦i≦N) $ です。<br />これらの品物から、$ A $ 個以上、$ B $個以下を選ばなければなりません。<br />この制約下において、選んだ品物の価値の平均の最大値を求めてください。<br />また、選んだ品物の平均が最大となるような品物の選び方が何通りあるかを求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ v_1 $ $ v_2 $ $ ... $ $ v_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>解答を $ 2 $ 行に出力せよ。<br />$ 1 $行目には、選んだ品物の価値の平均の最大値を出力せよ。絶対誤差または相対誤差が$ 10^{−6} $ 以下ならば正解となる。<br />$ 2 $行目には、選んだ品物の平均が最大となるような品物の選び方の数を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2 2</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.500000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 3</span><br><span class="line">10 20 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15.000000</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">1000000000000000 999999999999999 999999999999998 999999999999997 999999999999996</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000.000000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50 1 50</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.000000</span><br><span class="line">1125899906842623</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1≦N≦50 $</li><li>$ 1≦A≦B≦N $</li><li>$ 1≦v_i≦10^{15} $</li><li>$ v_i $ は全て整数である。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>$ 4 $ 番目の品物と $ 5 $番目の品物を選ぶと価値の平均が最大となるため、出力の $ 1 $ 行目は $ 4.5$ です。 また、それ以外の品物の選び方で価値の平均が $ 4.5 $になるものはないため、出力の $ 2 $ 行目は $ 1 $ です。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>価値の平均が最大となる品物の選び方は複数存在することがあります。</p></blockquote><h2 id="思路-1">思路</h2><p>显然，选取最大的A个数，再往下选均值只会越来越小。</p><p>方案数只与临界值有关，其他更大的肯定被选了。</p><p>注意考虑临界情况，可能在最大的A个数后面还存在若干个数与临界值相等，所以利用排列组合计算方案。</p><p>但是还有一种特殊情况，就是最大值与临界值相等，所以不一定只选A个，还可能选A+1、A+2个等等。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll n,a,b,num;</span><br><span class="line">ll v[MAXN];</span><br><span class="line">ll C[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="comment">//组合数预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选出最大的A个数</span></span><br><span class="line">    <span class="built_in">sort</span>(v+<span class="number">1</span>,v+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;(<span class="type">double</span>)ans/a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计n个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计a个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最大值与临界值相等，那么最多可以选择b个</span></span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">1</span>]==v[a])&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=a;i&lt;=b;i++)&#123;</span><br><span class="line">            num+=C[cnt1][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        num=C[cnt1][cnt2];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC056</title>
      <link href="/2024/03/24/ABC056/"/>
      <url>/2024/03/24/ABC056/</url>
      
        <content type="html"><![CDATA[<h1 id="abc056">ABC056</h1><blockquote><h1 id="abc056c-go-home">[ABC056C] Go Home</h1><h2 id="题面翻译">题面翻译</h2><p>在0秒的时候有一只袋鼠在左右无限长的数轴上的原点上。在i-1到i的时间内，袋鼠可以选择不动，也可以向任意方向跳i个单位长度。也就是说，如果袋鼠在坐标x，时间i-1到i的时候，可以存在x-i,x,x+i三点之中。袋鼠的家在坐标X。袋鼠想尽快移动到它家。求袋鼠到达家的时间的最小值。</p><p>输入格式：</p><p>输入由标准输入以下列格式给出：$ X $</p><p>输出：</p><p>袋鼠到达坐标的最早时间</p><h2 id="题目描述">题目描述</h2><p>無限に左右に伸びている数直線上の $ 0 $ の地点に時刻 $ 0 $にカンガルーがいます。 カンガルーは時刻 $ i-1 $ から $ i $にかけて、なにもしないか、もしくは長さがちょうど $ i $のジャンプを、左右どちらかの方向を選んで行えます。 つまり、時刻 $ i-1 $に座標 $ x $ にいたとすると、時刻 $ i $ には $ x-i $, $ x $, $ x+i $のどれかに存在することが出来ます。 カンガルーの家は座標 $ X $にあります。カンガルーはできるだけ早く座標 $ X $まで移動しようとしています。 カンガルーが座標 $ X $に到着する時刻の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $</p></blockquote><h2 id="输出格式">输出格式</h2><p>カンガルーが座標 $ X $ に到着する時刻の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ X $ は整数</li><li>$ 1≦X≦10^9 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>$ 3 $ 回右にジャンプすると時刻 $ 3 $に家にたどり着けて、これが最小です。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>時刻 $ 0 $ にはなにもせず、時刻 $ 1 $ に右にジャンプすることで時刻 $2 $ に家にたどり着けます。</p></blockquote><h2 id="思路">思路</h2><p>可以发现，一直往前跳，肯定跳得是最多的，所以我们采取贪心想法，一直跳，直到超过范围即可结束。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//ans记录的是时间</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i记录的是跳过的路程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        i+=ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc056d-no-need">[ABC056D] No Need</h1><h2 id="题面翻译-1">题面翻译</h2><p>给出一个由 <span class="math inline">\(N\)</span>个整数构成的集合和一个整数 <spanclass="math inline">\(K\)</span>，若该集合中的的非空子集和大于等于 <spanclass="math inline">\(K\)</span>，则称该子集为优秀的集合</p><p>若所有包含这个数的优秀子集去掉该数后仍然是优秀集合，则称该数字为“可有可无的数字”。</p><p>请求出在 <span class="math inline">\(N\)</span>个数中“可有可无的数字”个数。</p><h2 id="题目描述-1">题目描述</h2><p>シカのAtCoDeerくんは正整数が書かれたカードを $ N $ 枚持っています。$i(1≦i≦N) $ 枚目に書かれている数は $ a_i $ です。AtCoDeerくんは大きい数が好きなので、カードに書かれた数の総和が $ K $以上になるようなカードの部分集合を<em>よい集合</em>と呼びます。</p><p>そして、各カード $ i $に対して、そのカードが<em>不必要</em>かどうかを次のように判定します。</p><ul><li>「カード $ i $を含む任意の<em>よい集合</em>に対して、その集合からカード $ i $を除いたものも<em>よい集合</em>」 ならカード $ i $は<em>不必要</em></li><li>それ以外の場合は、<em>不必要</em>でない</li></ul><p>不必要なカードの枚数を求めてください。ただし、それぞれの判定は独立に行われ、不必要だからと言ってカードが途中で捨てられたりすることはありません。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ a_1 $ $ a_2 $ ... $ a_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>不必要なカードの枚数を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1 4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 400</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 20</span><br><span class="line">10 4 3 10 25 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>入力は全て整数</li><li>$ 1≦N≦5000 $</li><li>$ 1≦K≦5000 $</li><li>$ 1≦a_i≦10^9 (1≦i≦N) $</li></ul><h3 id="部分点">部分点</h3><ul><li>$ N,K≦400 $ を満たすデータセットに正解した場合は、部分点として $ 300$ 点が与えられる。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>よい集合は {$ 2,3 <span class="math inline">\(} と {\)</span> 1,2,3$} の二つです。 カード $ 1 $ を含むよい集合は {$ 1,2,3 $}しかなく、これから $ 1 $ を取り除いた {$ 2,3 $} もよい集合なので、カード$ 1 $ は不必要です。 また、よい集合である {$ 2,3 $} から $ 2 $を取り除いた集合 {$ 3 $} はよい集合ではないため、カード $ 2 $は不必要ではありません。 カード $ 3 $ も同様に不必要ではないため、答えは$ 1 $ です。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>この場合よい集合は存在しないため、全てのカードは不必要となります。</p></blockquote><h2 id="思路-1">思路</h2><p>直接算可有可无的，似乎有点困难，所以算那些是必须的。不难想到，只要一个数本身大于<spanclass="math inline">\(k\)</span>，那么他就是必须的，所以可以先排个序，那些大于<spanclass="math inline">\(k\)</span>的数肯定不是可有可无的。</p><p>接下来就是进行判断了：怎么判断一个数是不是必须的呢？我们不妨假设<spanclass="math inline">\(x\)</span>是必须的，那么设原有的和为<spanclass="math inline">\(sum\)</span>，则<spanclass="math inline">\(sum&lt;k\)</span>且<spanclass="math inline">\(sum+x\geq k\)</span>必成立。</p><p>那么我们不妨枚举一下<spanclass="math inline">\(sum\)</span>，然后进行判断（可以用<spanclass="math inline">\(DP\)</span>解决）。</p><p>设<span class="math inline">\(dp[i]\)</span>表示的是当总和为<spanclass="math inline">\(i\)</span>时，是否符合大于<spanclass="math inline">\(k\)</span>，<spanclass="math inline">\(0\)</span>表示不合法，<spanclass="math inline">\(1\)</span>表示合法。并对此进行状态转移，具体看看代码。</p><p>思路参考自：[题解 AT2346【<ahref="https://www.luogu.com.cn/article/qo9lzcig">ARC070B] No Need】 -洛谷专栏 (luogu.com.cn)</a></p><p>​ [题解 <a href="https://www.luogu.com.cn/article/g80jpt1t">ABC056D]No Need - 洛谷专栏 (luogu.com.cn)</a></p><p>题解区还有一些有趣的写法：[AT_arc070_b <ahref="https://www.luogu.com.cn/problem/solution/AT_arc070_b">ABC056D] NoNeed - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">bool</span> dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意初始化</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//a[i]&gt;=k，更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=k)cnt=i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举不合法的总和，并枚举对应可能的a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//如果dp[j]合法且j+a[i]&gt;=k,说明i不是必须的</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;j+a[i]&gt;=k)cnt=i;</span><br><span class="line">            <span class="comment">//如果dp[j]是合法的，则dp[j+a[i]]也是合法的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[j])dp[j+a[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC055</title>
      <link href="/2024/03/24/ABC055/"/>
      <url>/2024/03/24/ABC055/</url>
      
        <content type="html"><![CDATA[<h1 id="abc055">ABC055</h1><blockquote><h1 id="abc055d-menagerie">[ABC055D] Menagerie</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>Snuke，一个喜欢动物的人，建立了一个动物园。</p><p>一共有n个动物在动物园中，编号 <spanclass="math inline">\(1-n\)</span> ，被按顺序围成一个圈。</p><p>有两种动物：诚实的羊只说真话，不诚实的狼只说假话。</p><p>Snuke无法区别这两种动物，他问每只动物以下问题：“你旁边的两只动物是同一种吗？”第i只动物的答案为<span class="math inline">\(Si\)</span> 。如果 <spanclass="math inline">\(Si\)</span> 为“o”，则表示相同，“x”则相反。</p><p>此外，若羊回答“o”，相邻的生物则都是羊或都是狼，而“x”则相反。若狼回答“x”，相邻的生物则都是羊或狼，而“o”则相反。</p><p>Snuke想知道是否有一种可行的排列方式。如果有，输出这种排列。如果没有，则输出“-1”。</p><p>注：“S”表示羊，“W”表示狼。</p><h2 id="题目描述-1">题目描述</h2><p>すぬけくんは動物が好きなので動物園を作りました。</p><p>この動物園では $ 1,2,3, ..., N $ の番号を割り振られた $ N $匹の動物が円環状に並べられています。 $ i (2≦i≦N-1) $ 番の動物は $ i-1 $番の動物と $ i+1 $ 番の動物と隣り合っています。また、$ 1 $ 番の動物は $N $ 番の動物と $ 2 $ 番の動物と隣り合っており、$ N $ 番の動物は $ N-1 $番の動物と $ 1 $ 番の動物と隣り合っています。</p><p>動物園には本当のことしか言わない正直者の羊と、嘘しか言わない嘘つきの狼の2 種類の動物がいます。</p><p>すぬけくんには羊と狼の区別がつかないので、それぞれの動物に両隣の動物が同じ種類かどうかを訪ねたところ、$i $ 番目の動物は $ s_i $ と答えました。$ s_i $ が <code>o</code>ならば両隣の動物が同じ種類であると、<code>x</code>ならば異なる種類であると $ i $ 番の動物が言ったことを示します。</p><p>より形式的には、羊は両隣の動物がどちらも羊あるいはどちらも狼のとき<code>o</code> と答え、そうでないとき <code>x</code> と答えます。狼は両隣の動物がどちらも羊あるいはどちらも狼のとき <code>x</code>と答え、そうでないとき <code>o</code> と答えます。</p><p>これらの回答結果と矛盾しないような各動物の種別の割り当てが存在するか、すぬけくんは気になっています。存在するならば一例を示し、存在しないならば<code>-1</code> を出力しなさい。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ s $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ s $ と矛盾しないような各動物の種類の割当てが存在しないならば<code>-1</code> を出力してください。 存在するならば以下の形式で文字列 $t $ を出力してください。 $ t $ で示される割り当てが $ s $と矛盾しないならば正解となります。</p><ul><li>$ t $ は長さ $ N $ で <code>S</code> と <code>W</code>のみからなる文字列</li><li>$ t_i $ が <code>S</code> ならば $ i $番の動物が羊であることを、<code>W</code> ならば狼であることを示す</li></ul><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">ooxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSSWWS</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">oox</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">oxooxoxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSWWSSSWWS</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 3 ≦ N ≦ 10^{5} $</li><li>$ s $ は <code>o</code> と <code>x</code> のみからなる長さ $ N $の文字列</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>例えば $ 1,2,3,4,5,6 $番の動物がそれぞれ羊、羊、羊、狼、狼、羊であるとき発言と矛盾しません。その他、狼、羊、狼、羊、狼、狼であるようなときも矛盾しません。両隣が同じ種類の動物のとき羊は <code>o</code> と発言し、狼は<code>x</code> と発言すること、 両隣が異なる種類の動物のとき羊は<code>x</code> と発言し、狼は <code>o</code>と発言することに注意してください。![b34c052fc21c42d2def9b98d6dccd05c.png](https://atcoder.jp/img/arc069/b34c052fc21c42d2def9b98d6dccd05c.png)</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>存在しない場合は <code>-1</code> を出力してください。</p></blockquote><h2 id="思路">思路</h2><p>思路转载自：[AT_arc069_b <ahref="https://www.luogu.com.cn/article/6yhy8dr1">ABC055D] Menagerie 题解- 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>我们只要知道了前两个动物的种类，就可以推出所有动物的种类。那么思路就是，枚举前两个动物的种类即可。</p><p>但如果每种情况都讨论的话未免太复杂，所以我们考虑一种简化方法。</p><table><thead><tr class="header"><th>前两个动物的种类</th><th>第 22 个动物的回答</th><th>第 33 个动物的种类</th></tr></thead><tbody><tr class="odd"><td>SS</td><td>o</td><td>S</td></tr><tr class="even"><td>SS</td><td>x</td><td>W</td></tr><tr class="odd"><td>SW</td><td>o</td><td>W</td></tr><tr class="even"><td>SW</td><td>x</td><td>S</td></tr><tr class="odd"><td>WS</td><td>o</td><td>W</td></tr><tr class="even"><td>WS</td><td>x</td><td>S</td></tr><tr class="odd"><td>WW</td><td>o</td><td>S</td></tr><tr class="even"><td>WW</td><td>x</td><td>W</td></tr></tbody></table><p>找规律得：如果设<spanclass="math inline">\(S=1,W=0,o=1，x=0\)</span>，则第三个动物种类为<spanclass="math inline">\((a_2+b_1+b_2)mod\ 2\)</span>，可以得到递推式：<span class="math display">\[b_i=(b_{i-1}+b_{i-2}+a_{i-1})mod\ 2\]</span>推出所有动物的种类之后，还要进行验证，第一、二个动物再往前两个在环的情况下是否一样，需要特判。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">bool</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="comment">//b数组代表的是动物种类，a数组代表的是第i个动物说的话是真是假</span></span><br><span class="line"><span class="comment">//判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>]=x,b[<span class="number">2</span>]=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=(a[i<span class="number">-1</span>]+b[i<span class="number">-1</span>]+b[i<span class="number">-2</span>])%<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里需要特判推导出来的1、2是否与实际一致</span></span><br><span class="line">    <span class="keyword">if</span>((b[<span class="number">1</span>]==(a[n]+b[n]+b[n<span class="number">-1</span>])%<span class="number">2</span>)&amp;&amp;(b[<span class="number">2</span>]==(a[<span class="number">1</span>]+b[<span class="number">1</span>]+b[n])%<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i])cout&lt;&lt;<span class="string">&quot;S&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;W&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="comment">//进行初始化，如果为o，初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=(s[i]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举1、2号动物所有可能情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC054</title>
      <link href="/2024/03/24/ABC054/"/>
      <url>/2024/03/24/ABC054/</url>
      
        <content type="html"><![CDATA[<h1 id="abc054">ABC054</h1><blockquote><h1 id="abc054b-template-matching">[ABC054B] Template Matching</h1><h2 id="题面翻译">题面翻译</h2><p>给与纵N行，横N N列像素排列了的图像A，纵M行，横MM列像素排列了的模板图像B。</p><p>像素是构成图像的最小单位，其中1×1×1的正方形。</p><p>另外，给定的图像全部是二值图像，各像素的颜色用白和黑两种表示。</p><p>在输入中，全部的像素用文字表示，.白色的像素，#与黑色的像素对应。图像A由NN个字符串A_1、...、A_N A 1、...、A_N A N表示。字符串A_i Ai</p><p>的j j字符目对应于图像A上第i i、从左边第j j j个像素。(1≤i，j≤N)(1≤i，j≤N)同样，模板图像B由M M个字符串B_1，...，B_M B 1，...，B M MM表示。字符串B_i B i的j j j字符目对应于模板图像B上第i i、从左边第j jj的像素。(1≤i,j≤M) (1≤i,j≤M)</p><p>当仅允许图像平行移动时，请确定模板图像B是否包含在图像A中。</p><h2 id="题目描述">题目描述</h2><p>縦 $ N $ 行、横 $ N $ 列に画素が並んだ画像Aと、縦 $ M $ 行、横 $ M $列に画素が並んだテンプレート画像Bが与えられます。<br />画素は画像を構成する最小単位であり、ここでは $ 1×1 $の正方形とします。<br />また、与えられる画像は全て2値画像であり、各画素の色は白と黒の2種類で表されます。</p><p>入力において、全ての画素は文字で表されており、<code>.</code>は白色の画素、<code>#</code> は黒色の画素に対応します。<br />画像Aは $ N $ 個の文字列 $ A_1,...,A_N $ で表されます。<br />文字列 $ A_i $ の $ j $ 文字目は、画像Aの上から $ i $ 番目、左から $ j $番目の画素に対応します。$ (1≦i,j≦N) $<br />同様に、テンプレート画像Bは $ M $ 個の文字列 $ B_1,...,B_M $で表されます。<br />文字列 $ B_i $ の $ j $ 文字目は、テンプレート画像Bの上から $ i $番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦M) $</p><p>画像の平行移動のみ許されるとき、テンプレート画像Bが画像Aの中に含まれているかを判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ A_1 $ $ A_2 $ $ : $ $ A_N $ $ B_1 $ $ B_2 $ $ : $ $ B_M$</p></blockquote><h2 id="输出格式">输出格式</h2><p>画像Aの中にテンプレート画像Bを含む場合は<code>Yes</code>、含まない場合は <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">#.</span><br><span class="line">.#</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦M≦N≦50 $</li><li>$ A_i $ は <code>#</code> と <code>.</code> からなる長さ $ N $の文字列</li><li>$ B_i $ は <code>#</code> と <code>.</code> からなる長さ $ M $の文字列</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>テンプレート画像Bが、画像A中の左上の $ 2 × 2 $ の部分画像と右下の $2 × 2 $ の部分画像に一致するため、<code>Yes</code> と出力します。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>画像Aは白色の画素、テンプレート画像Bは黒色の画素で構成されるため、含まれることはありません。</p></blockquote><h2 id="思路">思路</h2><p>直接从矩形的左上角开始暴力匹配即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a[<span class="number">55</span>],b[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//思路，从左上角开始暴力匹配即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+x<span class="number">-1</span>][j+y<span class="number">-1</span>]!=b[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]=<span class="string">&quot; &quot;</span>+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;b[i],b[i]=<span class="string">&quot; &quot;</span>+b[i];</span><br><span class="line">    <span class="comment">//从左上角开始暴力匹配，注意范围</span></span><br><span class="line">    <span class="comment">//如果合法，cout&lt;&lt;&quot;YES&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-m+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc054c-one-stroke-path">[ABC054C] One-stroke Path</h1><h2 id="题面翻译-1">题面翻译</h2><h4 id="题目描述-1">题目描述</h4><p>给定一个没有重边和自环的 <span class="math inline">\(N\)</span> 个点<span class="math inline">\(M\)</span> 条边的无权无向图，第 <spanclass="math inline">\(i\)</span> 条边连接顶点 <spanclass="math inline">\(a _ i\)</span> 和 <span class="math inline">\(b _i\)</span>。</p><p>求以顶点 <span class="math inline">\(1\)</span> 为起点，只访问 <spanclass="math inline">\(1\)</span>次所有顶点的路径有多少条？特别地，起点和终点也视为被访问。</p><h4 id="输入格式-1">输入格式</h4><p>第一行两个整数 <span class="math inline">\(N, M\)</span>。</p><p>接下来 <span class="math inline">\(m\)</span> 行，其中第 <spanclass="math inline">\(i\)</span> 行两个整数 <spanclass="math inline">\(a _ i, b _ i\)</span>。</p><p>$ N M \ a _ 1 b _ 1 \ a _ 2 b _ 2 \ \ a _ M b _ M $</p><h4 id="输出格式-1">输出格式</h4><p>输出满足条件的路径有多少。</p><h4 id="数据范围">数据范围</h4><p>$ 2 N \ 0 M N(N - 1) \ 1 a _ i &lt; b _ i N $</p><p>给定的无向图中不包含重边和自环。</p><h2 id="题目描述-2">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $辺の重み無し無向グラフが与えられます。<br />$ i (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。<br />ここで、自己ループは $ a_i = b_i (1≦i≦M) $となる辺のことを表します。<br />また、二重辺は $ a_i=a_j $ かつ $ b_i=b_j (1≦i &lt; j≦M) $となる辺のことを表します。<br />頂点 $ 1 $を始点として、全ての頂点を1度だけ訪れるパスは何通りありますか。<br />ただし、パスの始点と終点の頂点も訪れたものとみなします。</p><p>例として、図1のような無向グラフが与えられたとします。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/5764771c0b3041c3346efe47c98edb49c94a9b3d.png" />図1：無向グラフの例</p><p>このとき、図2で表されるパスは条件を満たします。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/7f5174784cef5e6da48aed9eeb9756a6de9199db.png" />図2：条件を満たすパスの例</p><p>しかし、図3で表されるパスは条件を満たしません。全ての頂点を訪れていないからです。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad6e861039122f07481a4ef820a2461de4e5e54c.png" />図3：条件を満たさないパスの例1</p><p>また、図4で表されるパスも条件を満たしません。始点が頂点 $ 1 $ではないからです。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad37aa02ed59054ab7ef974821bffd978f95285d.png" />図4：条件を満たさないパスの例2</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ : $ $ a_M $ $ b_M $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>問題文の条件を満たすパスが何通りあるか出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">2 7</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 2≦N≦8 $</li><li>$ 0≦M≦N(N-1)/2 $</li><li>$ 1≦a_i &lt; b_i≦N $</li><li>与えられるグラフは自己ループと二重辺を含まない。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>与えられるグラフは以下の図で表されます。![43c0ac53de20d989d100bf60b3cd05fa.png](https://atcoder.jp/img/5013/43c0ac53de20d989d100bf60b3cd05fa.png)条件を満たすパスは以下の $ 2 $ 通りです。![c4a27b591d364fa479314e3261b85071.png](https://atcoder.jp/img/5013/c4a27b591d364fa479314e3261b85071.png)</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>このテストケースは問題文の例と同じです。</p></blockquote><h2 id="思路-1">思路</h2><p>范围很小，直接DFS即可，记录从1开始能否访问所有顶点的路径数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">bool</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x是当前所在的点，cnt是当前统计的经过点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意标记</span></span><br><span class="line">    b[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])&#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(b[to])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//这里写cnt+1，不要写cnt++</span></span><br><span class="line">        <span class="built_in">dfs</span>(to,cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    b[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc054d-mixing-experiment">[ABC054D] Mixing Experiment</h1><h2 id="题面翻译-2">题面翻译</h2><hr /><h2 id="题目描述-3">题目描述：</h2><p>有 <span class="math inline">\(N\)</span> 个物体，第 <spanclass="math inline">\(i\)</span> 个物体含有 <spanclass="math inline">\(a_i\)</span> 质量的 A 元素 和 <spanclass="math inline">\(b_i\)</span> 质量的 B 元素，代价为 <spanclass="math inline">\(c_i\)</span> 。</p><p>问能否取若干个物体，使 A 元素与 B 元素质量之比为 <spanclass="math inline">\(M_a : M_b\)</span> ，并使代价最小。</p><hr /><h2 id="输入格式-3">输入格式:</h2><p>第一行3个整数 <span class="math inline">\(N ,M_a ,M_b\)</span></p><p>下面 <span class="math inline">\(N\)</span> 行，每行3个整数 <spanclass="math inline">\(a_i ,b_i ,c_i\)</span></p><p>$ N $ $ M_a $ $ M_b $<br />$ a_1 $ $ b_1 $ $ c_1 $<br />$ a_2 $ $ b_2 $ $ c_2 $</p><p>$ : $<br />$ a_N $ $ b_N $ $ c_N $</p><hr /><h2 id="输出格式-3">输出格式：</h2><p>若能满足条件则输出 <strong>最小代价</strong>。</p><p>否则输出 -1</p><hr /><h2 id="数据范围-1">数据范围：</h2><ul><li><p><span class="math inline">\(1\le N\le 40\)</span></p></li><li><p><span class="math inline">\(1\le a_i,b_i\le 10\)</span></p></li><li><p><span class="math inline">\(1\le c_i\le 100\)</span></p></li><li><p><span class="math inline">\(1\le M_a,M_b\le 10\)</span></p></li><li><p><span class="math inline">\(gcd(M_a,M_b)=1\)</span></p></li><li><p>输入都为整数。</p></li></ul><hr /><p>translated by <span class="citation"data-cites="君のNOIP">@君のNOIP</span>。</p><h2 id="题目描述-4">题目描述</h2><p>イルカは、微量の物質Cを生成したいと考えています。<br />物質Cを生成するためには、タイプAの物質とタイプBの物質の混合比が $M_a:M_b $ となる溶液を用意する必要があります。<br />しかし、イルカは薬品を1つも持っていないため、薬局へ薬品を買いに行くことにしました。<br />薬局では、$ N $ 種類の薬品を取り扱っており、各薬品 $ i $の在庫はちょうど1つです。<br />各薬品 $ i $ は、タイプAの物質 $ a_i $ グラム、タイプBの物質 $ b_i $グラム含んでおり、価格 $ c_i $ 円で売られています。<br />イルカは、いくつかの薬品を薬局で買います。買った薬品は全て使わなければなりません。<br />物質Cを生成するために、必要な最小予算を求めてください。<br />薬局で売られている薬品の組み合わせで、物質Cを生成できない場合はそれを報告してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M_a $ $ M_b $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $$ : $ $ a_N $ $ b_N $ $ c_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>物質Cを生成するために必要な最小予算を出力せよ。物質Cを生成できない場合には<code>-1</code> を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 1</span><br><span class="line">1 2 1</span><br><span class="line">2 1 2</span><br><span class="line">3 3 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 10</span><br><span class="line">10 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦40 $</li><li>$ 1≦a_i,b_i≦10 $</li><li>$ 1≦c_i≦100 $</li><li>$ 1≦M_a,M_b≦10 $</li><li>$ gcd(M_a,M_b)=1 $</li><li>$ a_i <span class="math inline">\(、\)</span> b_i <spanclass="math inline">\(、\)</span> c_i <spanclass="math inline">\(、\)</span> M_a <spanclass="math inline">\(、\)</span> M_b $は整数である。</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>最小予算となる組み合わせは、薬品 $ 1 $ と薬品 $ 2 $を混合する場合です。 この場合、混合した溶液中に物質Aは $ 3 $グラム、物質Bは $ 3 $ グラム含まれており、混合比は $ 3:3=1:1 $となって条件を満たします。 このときの合計価格は $ 3 $ 円となります。</p><h3 id="sample-explanation-2-2">Sample Explanation 2</h3><p>物質Aと物質Bの混合比が $ 1:10 $となる薬品の組み合わせはないので、<code>-1</code>を出力します。</p></blockquote><h2 id="思路-2">思路</h2><p>很容易看出来这是一个01背包问题。</p><p>注意有两个维度：<spanclass="math inline">\(dp[i][j]\)</span>表示<spanclass="math inline">\(A\)</span>总质量为<spanclass="math inline">\(i\)</span>，<spanclass="math inline">\(B\)</span>总质量为<spanclass="math inline">\(j\)</span>。由此可得状态转移方程，注意要倒序枚举。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m_a,m_b,suma,sumb;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m_a&gt;&gt;m_b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        suma+=a[i];</span><br><span class="line">        sumb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=suma;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sumb;j++)&#123;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ans存储答案</span></span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒序枚举，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=suma;i&gt;=a[k];i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sumb;j&gt;=b[k];j--)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i-a[k]][j-b[k]]+c[k]);</span><br><span class="line">                <span class="comment">//如果有满足合法比的情况，则更新答案</span></span><br><span class="line">                <span class="keyword">if</span>(i*m_b==j*m_a)ans=<span class="built_in">min</span>(ans,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC053</title>
      <link href="/2024/03/24/ABC053/"/>
      <url>/2024/03/24/ABC053/</url>
      
        <content type="html"><![CDATA[<h1 id="abc053">ABC053</h1><blockquote><h1 id="abc053c-x-yet-another-die-game">[ABC053C] X: Yet Another DieGame</h1><h2 id="题面翻译">题面翻译</h2><p>一个骰子，初始的时候任意的一个面朝上，接下来每一轮可以翻转骰子到相邻的一面，并获得此面的得分（那一面的数值即是得分）。问至少要几轮才可以获得够<span class="math inline">\(x\)</span> 分。</p><p><strong>注</strong>：所有数均在<spanclass="math inline">\(longlong\)</span>范围内。</p><h3 id="输入格式">输入格式</h3><p>一个数 <span class="math inline">\(x\)</span> 。</p><h3 id="输出格式">输出格式</h3><p>输出也是一个数，即最少的轮数。</p><h2 id="题目描述">题目描述</h2><p>すぬけくんは $ 6 $ 面サイコロで遊ぶことにしました。 サイコロは $ 1 $から $ 6 $までの整数がそれぞれの面に書かれており、向かい合う面に書かれた数の和はどれも$ 7 $ です。</p><p>すぬけくんはサイコロの好きな面が上向きになるように置いたのち何回か以下の操作を行います。</p><ul><li>操作：サイコロを手前、奥、左、右のどれかの方向に $ 90° $だけ回転させる。その後、上を向いている面に書かれた数を $ y $ として $ y$ 点得る。</li></ul><p>例えば、図のように $ 1 $ と書かれた面が上を向いており、手前側の面に $5 $ が、右側の面に $ 4 $ が書かれている状況を考えます。<br />図に示されるように右方向に回転させることで $ 3 $と書かれた面が上を向くようにすることが可能です。その他、左方向に回転させた場合は $ 4 $と書かれた面が、手前方向に回転させた場合は $ 2 $と書かれた面が、奥方向に回転させた場合は $ 5 $と書かれた面が上を向くようにすることが可能です。</p><figure><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc068_a/853455ad24539a0166e2da8cad62831372eeae9b.png"alt="864abc2e4a08c26015ffd007a30aab03.png" /><figcaptionaria-hidden="true">864abc2e4a08c26015ffd007a30aab03.png</figcaption></figure><p>すぬけくんが合計で $ x $点以上得るために必要な最小の操作回数を求めなさい。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ x $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">149696127901</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27217477801</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1 ≦ x ≦ 10^{15} $</li><li>$ x $ は整数</li></ul></blockquote><h2 id="思路">思路</h2><p>被题意误导了，其实大于<spanclass="math inline">\(x\)</span>也是可以的</p><p>如果要步骤最少，我们可以6-5-6-5······，这样一路下来，就能得到最小的操作次数。</p><p>注意下面的一轮是按6-5算的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll x;cin&gt;&gt;x;</span><br><span class="line">    <span class="comment">//注意这里要乘上2</span></span><br><span class="line">    ll ans=(x/<span class="number">11</span>)*<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果恰好完成，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">11</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有，判断是否在0-6之间，如果是则加1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>&lt;=x%<span class="number">11</span>&amp;&amp;x%<span class="number">11</span>&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则加2</span></span><br><span class="line">    cout&lt;&lt;ans+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc053d-card-eater">[ABC053D] Card Eater</h1><h2 id="题面翻译-1">题面翻译</h2><p>有一堆牌，每张牌上有一个数字。每次可以取出其中3张，丢掉数字最大的和数字最小的牌，把中间那张再放回牌堆。要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。</p><h2 id="题目描述-1">题目描述</h2><p>すぬけくんはカードゲームで遊ぶことにしました。 $ N $枚からなるカードの山があり、上から $ i $ 枚目のカードには整数 $ A_i $が書かれています。</p><p>すぬけくんはこのカードの山に対し $ 0 $回以上、以下の操作を行い、残ったカードに書かれた値が互いに異なるようにしたいです。最大で何枚のカードを残すことが可能か求めなさい。なお、$N $ は奇数であり、少なくとも $ 1 $枚のカードを残すことが可能であることが保証されます。</p><p>操作：カードの山から任意の $ 3 $枚のカードを抜き出す。抜き出したカードのうち書かれた値が最大であるようなカード$ 1 $ 枚と最小であるようなカード $ 1 $ 枚の合計 $ 2 $枚を選んで食べる。その後残った $ 1 $ 枚をカードの山に戻す。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ A_3 $ ... $ A_{N} $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 3 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">1 3 5 2 1 3 2 8 8 6 2 6 11 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 3 ≦ N ≦ 10^{5} $</li><li>$ N $ は奇数</li><li>$ 1 ≦ A_i ≦ 10^{5} $</li><li>$ A_i $ は整数</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>操作を $ 1 $ 回行って $ 1,1,2 $ を取り出すというのが最適な操作手順の$ 1 $ つです。最大値である $ 2 $ と書かれたカードで最小値である $ 1 $と書かれたカードがそれぞれ $ 1 $ 枚ずつ食べられ、残った $ 1 $と書かれたカードがカードの山に戻されます。カードの山に残っているカードは$ 1,3,7 $ となり、これらは互いに異なります。</p></blockquote><h2 id="思路-1">思路</h2><p>一个很好想的思路，可以统计一下有多少种牌的数量是大于1的（记作<spanclass="math inline">\(cnt\)</span>），这样的话，他们之间就可以两两配对，这样可以避免减少卡牌的种类。</p><p>但是有特殊情况，如果<spanclass="math inline">\(cnt\)</span>是奇数，说明会剩下一张重复的卡牌，所以我们不得不重新选出一张牌来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,a=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//记录重复的卡牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(m[a])cnt++;</span><br><span class="line">        <span class="keyword">else</span> m[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否可能无法配对</span></span><br><span class="line">    cnt+=cnt%<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC052</title>
      <link href="/2024/03/24/ABC052/"/>
      <url>/2024/03/24/ABC052/</url>
      
        <content type="html"><![CDATA[<h1 id="abc052">ABC052</h1><blockquote><h1 id="abc052c-factors-of-factorial">[ABC052C] Factors ofFactorial</h1><h2 id="题面翻译">题面翻译</h2><p>给定正整数 <span class="math inline">\(N \left( 1\leq N \leq 10 ^3\right)\)</span> 求 <span class="math inline">\(N!\)</span>的约数个数。结果对 <span class="math inline">\(10^9 + 7\)</span>取模</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。 $ N! $ の正の約数の個数を $ 10^9+7 $で割った余りを求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ N! $ の正の約数の個数を $ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">972926972</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^3 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>$ 3! $ $ =6 $ です。$ 6 $ の正の約数は $ 1,2,3,6 $ の $ 4 $個なので、$ 4 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>需要一点点数论知识（可惜我没有）。</p><p>思路转载自：[<ahref="https://www.luogu.com.cn/article/5yq3f4lw">题解] AT2286 [ARC067A]Factors of Factorial - 洛谷专栏 (luogu.com.cn)</a></p><p>若一个正整数<spanclass="math inline">\(n&gt;1\)</span>，且可分解为一系列质因数的乘积：<span class="math display">\[n=\prod \limits_{i=1}^k {p}^{a_i}_i\]</span> 则<span class="math inline">\(n\)</span>约数的个数<spanclass="math inline">\(f(n)\)</span>为： <span class="math display">\[f(n)=\prod \limits_{i=1}^k(a_i+1)\]</span> 由于观察到数据并不大，<spanclass="math inline">\(n\leq1000\)</span>，我们可以考虑从<spanclass="math inline">\(1\)</span>到<spanclass="math inline">\(n\)</span>，每乘到一个数时，都分解一次质因数，用一个<spanclass="math inline">\(map\)</span>数组统计可分解的质因数个数。中间的每个数可以分解的质因数指数都加1，到最后就统计出了<spanclass="math inline">\(n!\)</span>的质因数分解形式。时间复杂度<spanclass="math inline">\(O(n^2)\)</span>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="comment">//分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            n/=i;</span><br><span class="line">            <span class="comment">//进行统计</span></span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(p=m.<span class="built_in">begin</span>();p!=m.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">        ans=ans*(p-&gt;second+<span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc052d-walk-and-teleport">[ABC052D] Walk and Teleport</h1><h2 id="题面翻译-1">题面翻译</h2><p>在东西方向延伸的直线上，有N个城市。城市坐标按从西到东递增。</p><p>你现在在某个城市里，想去其他所有的城市。移动的方法有以下两种。</p><p>一，在直线上按东西方向平移，每移动一个单位距离疲劳值加A</p><p>二，直接瞬移到某个坐标，并且疲劳值加B</p><p>请使用以上两种方式直到去完其他所有的城市，并求出最小的疲劳值。</p><p><strong>输入输出格式</strong></p><p>输入格式：</p><p>第一行三个数,即N,A,B,</p><p>第二行N个数，即X[1],X[2]...,X[N]。</p><p>输出格式：</p><p>输出最小的疲劳值。</p><p><strong>说明</strong></p><p>2&lt;=N&lt;=1e5</p><p>1&lt;=Xi,A,B&lt;=1e9且X(i)&lt;X(i+1)</p><h2 id="题目描述-1">题目描述</h2><p>東西方向にのびる直線上に、$ N $ 個の町があります。 町には、西から順に$ 1 $ から $ N $ までの番号がついています。直線上には座標が設定されていて、東に行くほど座標が大きくなります。 町 $i $ の座標は $ X_i $ です。</p><p>あなたは今、町 $ 1 $ にいて、これからほかの全ての町を訪れたいです。移動する手段は次の $ 2 $ 種類あります。</p><ul><li>直線上を歩いて移動する。 東西どちらに歩いても、$ 1 $移動する度に疲労度が $ A $ 上がります。</li><li>好きな場所へテレポートする。テレポートをすると、移動した距離によらず疲労度が $ B $ 上がります。</li></ul><p>この $ 2 $種類の移動を繰り返して全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるか求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ X_1 $ $ X_2 $ $ ... $ $ X_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるかを出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 5</span><br><span class="line">1 2 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 100</span><br><span class="line">40 43 45 105 108 115 124</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">84</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 2</span><br><span class="line">24 35 40 68 72 99 103</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>入力は全て整数である</li><li>$ 2≦N≦10^5 $</li><li>$ 1≦X_i≦10^9 $</li><li>全ての $ i(1≦i≦N-1) $ について、$ X_i &lt; X_{i+1} $ が成り立つ</li><li>$ 1≦A≦10^9 $</li><li>$ 1≦B≦10^9 $</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>町 $ 1 $ から町 $ 2 $ まで $ 1 $ の距離歩いて移動したあと、町 $ 3 $にテレポートし、そこから町 $ 4 $ まで $ 2 $ の距離歩いて移動すると、疲労度の上昇値の合計が $ 2×1+5+2×2=11 $ になり、これが最小です。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>町 $ 1 $ から町 $ 7 $ まで歩き続けると、疲労度の上昇値の合計が $ 84 $になり、これが最小です。</p><h3 id="sample-explanation-3">Sample Explanation 3</h3><p>どのような順番でもよいので、$ 6 $回のテレポートで全ての町を訪れると、疲労度の上昇値の合計が $ 12 $になり、これが最小です。</p></blockquote><h2 id="思路-1">思路</h2><p>一眼的贪心</p><p>题解区发现一篇奇怪的题解：[题解 AT2287 【<ahref="https://www.luogu.com.cn/article/gs4bm7sp">ARC067B] Walk andTeleport】 - 洛谷专栏 (luogu.com.cn)</a>，可以看看。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> x[MAXN];</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a*(x[i]-x[i<span class="number">-1</span>])&lt;b)ans+=a*(x[i]-x[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">else</span> ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC051</title>
      <link href="/2024/03/24/ABC051/"/>
      <url>/2024/03/24/ABC051/</url>
      
        <content type="html"><![CDATA[<h1 id="abc051">ABC051</h1><blockquote><h1 id="abc051b-sum-of-three-integers">[ABC051B] Sum of ThreeIntegers</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目描述">题目描述</h1><p>有两个整数 <span class="math inline">\(K\)</span> , <spanclass="math inline">\(S\)</span></p><p>求有几种方案使得三个非负整数 <span class="math inline">\(X\)</span> ,<span class="math inline">\(Y\)</span> , <spanclass="math inline">\(Z\)</span> 之和= <spanclass="math inline">\(S\)</span> 并且均 <span class="math inline">\(\leqK\)</span></p><h1 id="输入格式">输入格式</h1><p>两个正整数 <span class="math inline">\(K\)</span> , <spanclass="math inline">\(S\)</span> , 见题目描述。</p><h1 id="输出格式">输出格式</h1><p>一个整数，表示方案数</p><h2 id="题目描述-1">题目描述</h2><p>$ 2 $ つの整数 $ K,S $ が与えられます。<br />$ 3 $ つの変数 $ X,Y,Z $ があり、$ 0≦X,Y,Z≦K $を満たす整数の値を取ります。<br />$ X + Y + Z = S $ を満たす $ X,Y,Z $への値の割り当ては何通りありますか。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ K $ $ S $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>問題文の条件を満たす $ X,Y,Z $ の組が何通りあるか出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2≦K≦2500 $</li><li>$ 0≦S≦3K $</li><li>$ K,S $ は整数である。</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>問題文の条件を満たす $ X,Y,Z $ の組は以下の $ 6 $ 通りです。 - $X = 0, Y = 0, Z = 2 $ - $ X = 0, Y = 2, Z = 0 $ - $ X = 2, Y = 0, Z = 0$ - $ X = 0, Y = 1, Z = 1 $ - $ X = 1, Y = 0, Z = 1 $ - $X = 1, Y = 1, Z = 0 $</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>$ X + Y + Z $ の最大値は $ 15 $ であり、それを満たす組は $ 1 $通りです。</p></blockquote><h2 id="思路">思路</h2><p>直接枚举不行，所以我们可以只要枚举X，Y，然后判断是否存在符合要求的Z即可，注意X,Y,Z的范围</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> k,s;cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j&lt;=s&amp;&amp;s-j-i&lt;=k)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc051c-back-and-forth">[ABC051C] Back and Forth</h1><h2 id="题面翻译-1">题面翻译</h2><p>在平面直角坐标系中，有点 <spanclass="math inline">\(A（sx,sy）\)</span> 和 点 <spanclass="math inline">\(B（tx,ty）\)</span> 保证 <spanclass="math inline">\(sx&lt;tx\)</span>，<spanclass="math inline">\(sy&lt;ty\)</span> 并且 <spanclass="math inline">\(sx,sy,tx,ty\)</span> 都为整数。</p><p>在 <span class="math inline">\(A\)</span>点有一只海豚，它每次可以向上下左右其中一个方向移动一个单位长度。这只海豚想从<span class="math inline">\(A\)</span> 点到 <spanclass="math inline">\(B\)</span> 点再回到 <spanclass="math inline">\(A\)</span> 点再到 <spanclass="math inline">\(B\)</span> 点再回到 <spanclass="math inline">\(A\)</span> 点。</p><p>要求：除了 <span class="math inline">\(A,B\)</span>点以外，所有格点都不能走第二遍。海豚不能斜着走。</p><p>输出一个字符串 <code>S</code> 表示海豚的最短路径， <code>S</code>中只包括 <span class="math inline">\(U,R,D,L\)</span>。</p><ul><li><span class="math inline">\(U\)</span>：向上走一个单位长度。</li><li><span class="math inline">\(R\)</span>：向右走一个单位长度。</li><li><span class="math inline">\(D\)</span>：向下走一个单位长度。</li><li><span class="math inline">\(L\)</span>：向左走一个单位长度。</li></ul><h1 id="输入格式-2">输入格式：</h1><p>一行，<span class="math inline">\(sx,sy,tx,ty\)</span>。</p><h1 id="输出格式-2">输出格式：</h1><p>一行，字符串 <code>S</code>。</p><p>如果有多个最短路径，输出其中任意一个。</p><p>Translate by <span class="citation"data-cites="sqh_let_it_be">@sqh_let_it_be</span></p><h2 id="题目描述-2">题目描述</h2><p>イルカは $ x $ 軸正方向を右、$ y $ 軸正方向を上とする 2次元座標平面にいます。<br />イルカは現在点 $ (sx,sy) $ にいて、$ 1 $ 秒あたり上下左右に距離 $ 1 $だけ進むことができます。<br />このとき、移動前と移動後の $ x $ 座標、$ y $座標はともに整数でなければなりません。<br />イルカはここから $ sx と sy を満たす点 (tx,ty) $ に行き、その後点 $(sx,sy) $ に戻り、また点 $ (tx,ty) $ に行き、その後点 $ (sx,sy) $に戻ります。<br />このとき、イルカは点 $ (sx,sy) $ と点 $ (tx,ty) $を除いて、途中で同じ座標を複数回通らないように移動しなければなりません。<br />このような条件を満たすイルカの最短経路を $ 1 $ つ求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ sx $ $ sy $ $ tx $ $ ty $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>イルカの最短経路を表す文字列 $ S $ を出力せよ。<br />$ S $ の $ i $ 番目の文字はイルカの $ i $ 番目の移動を表す。<br />イルカの各方向への移動を表す文字の対応関係は以下のとおりである。</p><ul><li><code>U</code>: 上方向</li><li><code>D</code>: 下方向</li><li><code>L</code>: 左方向</li><li><code>R</code>: 右方向</li></ul><p>条件を満たすような最短経路が複数ある場合、そのうちどれか $ 1 $つを出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURDDLLUUURRDRDDDLLU</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2 -2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURRURRDDDLLDLLULUUURRURRDDDLLDL</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ -1000≦ sx $</li><li>$ -1000≦ sy $</li><li>$ sx,sy,tx,ty $ は整数である。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>以下に示す移動経路が最短経路の $ 1 $ つです。 - $ 1 $ 回目の $(sx,sy) $ から $ (tx,ty) $ への移動: $ (0,0) $ → $ (0,1) $ → $ (0,2) $ →$ (1,2) $ - $ 1 $ 回目の $ (tx,ty) $ から $ (sx,sy) $ への移動: $ (1,2)$ → $ (1,1) $ → $ (1,0) $ → $ (0,0) $ - $ 2 $ 回目の $ (sx,sy) $ から $(tx,ty) $ への移動: $ (0,0) $ → $ (-1,0) $ → $ (-1,1) $ → $ (-1,2) $ → $(-1,3) $ → $ (0,3) $ → $ (1,3) $ → $ (1,2) $ - $ 2 $ 回目の $ (tx,ty) $から $ (sx,sy) $ への移動: $ (1,2) $ → $ (2,2) $ → $ (2,1) $ → $ (2,0) $→ $ (2,-1) $ → $ (1,-1) $ → $ (0,-1) $ → $ (0,0) $</p></blockquote><h2 id="思路-1">思路</h2><p>直接暴力模拟过程即可。</p><p>具体看大佬的图示：</p><p><img src="https://img2.imgtp.com/2024/03/24/t2daHxyP.png" /></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> sx,sy,tx,ty;cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;</span><br><span class="line">    <span class="type">int</span> x=tx-sx,y=ty-sy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DR&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc051d-candidates-of-no-shortest-paths">[ABC051D] Candidates ofNo Shortest Paths</h1><h2 id="题面翻译-2">题面翻译</h2><p>给定一个 <span class="math inline">\(n\)</span> 个点，<spanclass="math inline">\(m\)</span>条边的无重边无自环的加权无向连通图，问全源最短路有几条边没被用到。</p><h2 id="题目描述-3">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $辺の重み付き無向連結グラフが与えられます。<br />$ i (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を距離 $ c_i $で結びます。<br />ここで、自己ループは $ a_i = b_i (1≦i≦M) $となる辺のことを表します。<br />また、二重辺は $ (a_i,b_i)=(a_j,b_j) $ または $(a_i,b_i)=(b_j,a_j) (1≦i &lt; j≦M) $ となる辺のことを表します。<br />連結グラフは、どの異なる $ 2 $頂点間にも経路が存在するグラフのことを表します。<br />どの異なる $ 2 $頂点間の、どの最短経路にも含まれない辺の数を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $a_M $ $ b_M $ $ c_M $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>グラフ上の、どの異なる $ 2 $頂点間の、どの最短経路にも含まれない辺の数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2≦N≦100 $</li><li>$ N-1≦M≦min(N(N-1)/2,1000) $</li><li>$ 1≦a_i,b_i≦N $</li><li>$ 1≦c_i≦1000 $</li><li>$ c_i $ は整数である。</li><li>与えられるグラフは自己ループと二重辺を含まない。</li><li>与えられるグラフは連結である。</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>この入力例で与えられるグラフにおける、全ての異なる $ 2 $頂点間の最短経路は以下の通りです。 - 頂点 $ 1 $ から頂点 $ 2 $への最短経路は、頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 1 $ - 頂点 $ 1 $から頂点 $ 3 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 1 $- 頂点 $ 2 $ から頂点 $ 1 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 3 $ への最短経路は、頂点 $ 2 $→ 頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 2 $ - 頂点 $ 3 $ から頂点 $ 1 $への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 3 $から頂点 $ 2 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ → 頂点 $ 2 $で経路長は $ 2 $したがって、一度も最短経路として使用されていない辺は、頂点 $ 2 $ と頂点$ 3 $ を結ぶ長さ $ 3 $ の辺のみであるため、$ 1 $ を出力します。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>全ての辺が異なる $ 2 $ 頂点間のある最短経路で使用されます。</p></blockquote><h2 id="思路-2">思路</h2><p><span class="math inline">\(n\)</span>只有100，所以直接用<spanclass="math inline">\(Floyd\)</span>即可，再每次记录当前边有没有被松弛掉，如果是第一次松弛就<spanclass="math inline">\(ans++\)</span>。</p><p>注意到是无向图，所以<spanclass="math inline">\(ans\)</span>要除以二。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],ans;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">g[x][y]=g[y][x]=z,vis[x][y]=vis[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//记录边，并且给边打上标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]&gt;g[i][k]+g[k][j])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i][j])ans++,vis[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果是第一次松弛，ans++</span></span><br><span class="line">g[i][j]=g[i][k]+g[k][j];</span><br><span class="line">&#125;<span class="comment">//Floyd模板</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC050</title>
      <link href="/2024/03/22/ABC050/"/>
      <url>/2024/03/22/ABC050/</url>
      
        <content type="html"><![CDATA[<h1 id="abc050">ABC050</h1><blockquote><h1 id="abc050b-contest-with-drinks-easy">[ABC050B] Contest with DrinksEasy</h1><h2 id="题面翻译">题面翻译</h2><p>joisino 小姐姐即将参加某个编程比赛的决赛。在这个比赛中，准备了 <spanclass="math inline">\(N\)</span> 个问题，其中从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(N\)</span> 号码。我知道 joisino 小姐姐要解决问题<span class="math inline">\(i\)</span>（<spanclass="math inline">\(1≤i≤N\)</span>）需要的时间是 <spanclass="math inline">\(T_i\)</span> 秒。</p><p>另外，在这个比赛中，提供M种不同的饮料，有 <spanclass="math inline">\(1\)</span>~<span class="math inline">\(M\)</span>的号码。如果喝了饮料 <span class="math inline">\(i\)</span>（<spanclass="math inline">\(1≤i≤M\)</span>）的话，参赛者的大脑会被给予强烈的刺激，解决问题 <spanclass="math inline">\(P_i\)</span> 的时间是 <spanclass="math inline">\(X_i\)</span> 秒。问题之间的时间互不 影响。</p><p>每名参赛者在比赛开始前可以喝一瓶饮料。小姐姐joisino对于各自的饮料，想知道要解答所有的问题需要多少秒。解决所有问题的时间是解决各个问题的时间的总和。你的工作是为了帮助(取悦)小姐姐写一个程序。</p><h2 id="题目描述">题目描述</h2><p>joisinoお姉ちゃんは、あるプログラミングコンテストの決勝を控えています。このコンテストでは、$ N $ 問の問題が用意されており、それらには $ 1～N $の番号がついています。 joisinoお姉ちゃんは、問題 $ i(1≦i≦N) $を解くのにかかる時間が $ T_i $ 秒であることを知っています。</p><p>また、このコンテストでは、$ M $ 種類のドリンクが提供されており、$1～M $ の番号がついています。 そして、ドリンク $ i(1≦i≦M) $を飲むと、脳が刺激され、問題 $ P_i $ を解くのにかかる時間が $ X_i $秒になります。 他の問題を解くのにかかる時間に変化はありません。</p><p>コンテスタントは、コンテスト開始前にいずれかのドリンクを $ 1 $本だけ飲むことができます。joisinoお姉ちゃんは、それぞれのドリンクについて、それを飲んだ際に、全ての問題を解くのに何秒必要なのかを知りたくなりました。全ての問題を解くのに必要な時間とは、それぞれの問題を解くのにかかる時間の合計です。あなたの仕事は、joisinoお姉ちゃんの代わりにこれを求めるプログラムを作成することです。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ T_2 $ $ ... $ $ T_N $ $ M $ $ P_1 $ $ X_1 $ $ P_2 $ $X_2 $ $ : $ $ P_M $ $ X_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>それぞれのドリンクについて、それを飲んだ際に全ての問題を解くのに必要な時間を求め、順番に$ 1 $ 行ずつ出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7 2 3 8 5</span><br><span class="line">3</span><br><span class="line">4 2</span><br><span class="line">1 7</span><br><span class="line">4 13</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br><span class="line">25</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>入力は全て整数である</li><li>$ 1≦N≦100 $</li><li>$ 1≦T_i≦10^5 $</li><li>$ 1≦M≦100 $</li><li>$ 1≦P_i≦N $</li><li>$ 1≦X_i≦10^5 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>一つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$1 $ 秒、$ 1 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 6 $秒が答えになり、$ 6 $ を出力します。二つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$ 2$ 秒、$ 3 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 9 $秒が答えになり、$ 9 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>其实求的就是喝下第<spanclass="math inline">\(i\)</span>杯饮料后，总时间变为多少。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i],sum+=t[i];</span><br><span class="line">    <span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;sum-t[x]+y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc050c-lining-up">[ABC050C] Lining Up</h1><h2 id="题面翻译-1">题面翻译</h2><p>有编号为1-N号的N个人，他们都记得“自己左边排队的人数和自己右边排队的人数之差的绝对值”，根据他们的报告，给你i的「自己的左排列的人数和自己的右排列的人数的差的绝对值」Ai。请根据他们的报告，求出原来的排列方法有几种。但是，因为答案有时候会变得很大，请对10^9+7取模。另外，他们的报告可能有错误，没有可能的排列方法，此时请输出0。</p><p>范围： <span class="math display">\[1≦N≦10^5;0≦Ai≦N−1.\]</span></p><h2 id="题目描述-1">题目描述</h2><p>$ 1～N $ までの番号がついた、$ N $ 人の人がいます。彼らは昨日、ある順番で左右一列に並んでいましたが、今日になってその並び方が分からなくなってしまいました。しかし、彼らは全員、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」を覚えています。彼らの報告によると、人 $ i $の、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」は$ A_i $ です。</p><p>彼らの報告を元に、元の並び方が何通りあり得るかを求めてください。ただし、答えは非常に大きくなることがあるので、$ 10^9+7 $で割った余りを出力してください。また、彼らの報告が間違っており、ありうる並び方がないこともありえます。その際は $ 0 $ を出力してください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ ... $ $ A_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>元の並び順としてありうるものが何通りあるか求め、$ 10^9+7 $で割った余りを出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">6 4 0 2 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">7 5 1 1 7 3 5 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ 0≦A_i≦N-1 $</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>ありうる並び方は、人の番号で書くと、 - $ 2,1,4,5,3 $ - $ 2,5,4,1,3 $- $ 3,1,4,5,2 $ - $ 3,5,4,1,2 $ の $ 4 $ 通りです。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>どのような並び方でも、報告と矛盾するので、$ 0 $が答えになります。</p></blockquote><h2 id="思路-1">思路</h2><p>当初WA了好多发，不是忘记取模，就是WA了一个点qwq。</p><p>思路不难想，不过要注意分奇偶讨论。</p><p>注意到分布的值<spanclass="math inline">\(A_i\)</span>应该具有对称性，所以对于每一个<spanclass="math inline">\(A_i\)</span>值，它可能的个数就只能是0或2（除了为奇数情况时，0值只有一个，其他情况没有0值）。</p><p>所以我们只需要分奇偶讨论，然后判断即可。</p><p>注意到范围很大，所以可以用快速幂优化一下（我也不知道没有快速幂会不会喜提<spanclass="math inline">\(TLE\)</span>）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].num;</span><br><span class="line">        b[a[i].num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="built_in">qpower</span>(<span class="number">2</span>,n/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h1 id="abc050d-xor-sum">[ABC050D] Xor Sum</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>给出正整数<span class="math inline">\(N\)</span>.</p><p>求出整数对<span class="math inline">\(u\)</span>和<spanclass="math inline">\(v\)</span> <spanclass="math inline">\((0≤u,v≤N)\)</span>的数目，使得存在两个非负整数<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>满足<span class="math inline">\(a\xor\  b = u\)</span>和<span class="math inline">\(a\ +\ b=v\)</span>。这里，<span class="math inline">\(xor\)</span>表示按位异或。要求对答案取模<span class="math inline">\(10^9 + 7\)</span>。</p><h2 id="输入输出格式">输入输出格式</h2><h3 id="输入格式-2">输入格式</h3><p>一个正整数<span class="math inline">\(N\)</span></p><h3 id="输出格式-2">输出格式</h3><p>满足条件的<span class="math inline">\(u,v\)</span>的个数，对<spanclass="math inline">\(10^9+7\)</span>取模</p><h2 id="数据范围">数据范围：</h2><p><span class="math inline">\(N&lt;=10^{18}\)</span></p><h2 id="题目描述-3">题目描述</h2><p>正の整数 $ N $ が与えられます。 $ 2 $ つの整数 $ u,v(0≦u,v≦N) $であって、ある非負整数 $ a,b $ が存在して、$ a $ $ xor $ $ b=u <spanclass="math inline">\(、\)</span> a+b=v $となるようなものが何通りあるかを求めてください。 ここで、$ xor $はビットごとの排他的論理和を表します。なお、答えは非常に大きくなることがあるので、$ 10^9+7 $で割った余りを求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>ありうる $ 2 $ 数の組が何通りあるかを求め、$ 10^9+7 $で割った余りを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1422</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52277</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">787014179</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦10^{18} $</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>$ u,v $ としてありうるものは、以下の $ 5 $ 通りです。 - $ u=0,v=0 $（$ a=0,b=0 $ とすると、$ 0 $ $ xor $ $ 0=0 <spanclass="math inline">\(、\)</span> 0+0=0 $ となります。） - $ u=0,v=2 $（$ a=1,b=1 $ とすると、$ 1 $ $ xor $ $ 1=0 <spanclass="math inline">\(、\)</span> 1+1=2 $ となります。） - $ u=1,v=1 $（$ a=1,b=0 $ とすると、$ 1 $ $ xor $ $ 0=1 <spanclass="math inline">\(、\)</span> 1+0=1 $ となります。） - $ u=2,v=2 $（$ a=2,b=0 $ とすると、$ 2 $ $ xor $ $ 0=2 <spanclass="math inline">\(、\)</span> 2+0=2 $ となります。） - $ u=3,v=3 $（$ a=3,b=0 $ とすると、$ 3 $ $ xor $ $ 0=3 <spanclass="math inline">\(、\)</span> 3+0=3 $ となります。）</p></blockquote><h2 id="思路-2">思路</h2><p>[题解 <a href="https://www.luogu.com.cn/article/s9kikzf6">ARC066] B -洛谷专栏 (luogu.com.cn)</a></p><p>暂时先不写思路了，帮舍友配博客去了。可以先看看上面的文章，大佬讲得很好。</p><hr /><p>补思路</p><p>一开始的想法是<span class="math inline">\(v\)</span>可能与<spanclass="math inline">\(u\)</span>相同，或者比<spanclass="math inline">\(u\)</span>多出一位（这里是二进制位），所以肯定比<spanclass="math inline">\(u\)</span>多出<spanclass="math inline">\(2^{n+1}\)</span>（假设<spanclass="math inline">\(u\)</span>原来有<spanclass="math inline">\(n\)</span>位），然后想办法枚举，发现好像不行？也许以后尝试实现一下</p><p>下面的思路是大佬的：</p><blockquote><p>考虑 <span class="math display">\[a+b=((a\ and\ b)&lt;&lt;1)+(a\ xor\ b)\]</span> $</p><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到<spanclass="math inline">\(a+b\geq a\ xor b\)</span>这样的结论。</p><p>那么如果由于<spanclass="math inline">\(u&lt;v\)</span>，所以如果<spanclass="math inline">\(v\)</span>不越界那么<spanclass="math inline">\(u\)</span>一定不越界。于是考虑按<spanclass="math inline">\(v\)</span>进行<spanclass="math inline">\(dp\)</span>。具体的，考虑状态<spanclass="math inline">\(f_{i,j}\)</span>表示考虑了<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>二进制下的前<spanclass="math inline">\(i\)</span>位，当前<spanclass="math inline">\(v=a+b=j\)</span>的方案数。</p><p>考虑如何转移。对于<span class="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>而言，第<spanclass="math inline">\(i\)</span>位有三种情况，<spanclass="math inline">\((0,0),(0,1),(1,1)\)</span>。那么也就是假设原来的和为<spanclass="math inline">\(j&#39;\)</span>，和当前的和<spanclass="math inline">\(j\)</span>可能有以下关系：</p><p>1、<spanclass="math inline">\(2*(j&#39;+1)=j\)</span>对应着都补一位1。</p><p>2、<span class="math inline">\(2*j&#39;=j\)</span>对应着都补一位0。</p><p>3、<spanclass="math inline">\(j&#39;+(j&#39;+1)=j\)</span>对应着一个补1一个补0。</p><p>那么也就是 <span class="math display">\[f_{i,j}=f_{i-1,\lfloor \frac{j}{2}\rfloor}+f_{i-1,\lfloor\frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor{\frac{(j-2)}{2}\rfloor}}\]</span></p><p>考虑把第一维压掉之后，就是另一篇题解的那种做法了。</p><p>（下面的代码就是优化的）</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//注意范围为10^18，所以用map</span></span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    m[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    ll ans=<span class="built_in">solve</span>(n);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC049</title>
      <link href="/2024/03/22/ABC049/"/>
      <url>/2024/03/22/ABC049/</url>
      
        <content type="html"><![CDATA[<h1 id="abc049">ABC049</h1><blockquote><h1 id="abc049c-白昼夢">[ABC049C] 白昼夢</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目大意">题目大意</h1><p>输入一个以英文小写字母组成的字符串S，规定一个空的字符串T，现在你可对字符串T进行你喜欢的操作，问是否能让字符串T变为字符串S？</p><p><strong>喜欢的操作如下 ：</strong></p><p>在字符串T的末尾加入 “dream”或“dreamer”或“erase”或“eraser”。</p><hr /><h2 id="输入格式">输入格式</h2><p>一个字符串S</p><h2 id="输出格式">输出格式</h2><p>若可以输出<strong>YES</strong>,否则输出<strong>NO</strong>。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる文字列 $ S $ が与えられます。 $ T$が空文字列である状態から始め、以下の操作を好きな回数繰り返すことで $S = T $ とすることができるか判定してください。</p><ul><li>$ T $ の末尾に <code>dream</code> <code>dreamer</code><code>erase</code> <code>eraser</code> のいずれかを追加する。</li></ul><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>$ S = T $ とすることができる場合 <code>YES</code> を、そうでない場合<code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erasedream</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreameraser</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreamerer</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦|S|≦10^5 $</li><li>$ S $ は英小文字からなる。</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p><code>erase</code> <code>dream</code> の順で $ T $の末尾に追加することで $ S = T $ とすることができます。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p><code>dream</code> <code>eraser</code> の順で $ T $の末尾に追加することで $ S = T $ とすることができます。</p></blockquote><h2 id="思路">思路</h2><p>其实是一道模拟题（doge），只要判断读到<spanclass="math inline">\(d\)</span>或<spanclass="math inline">\(e\)</span>时，判断是不是<spanclass="math inline">\(dream、dreamer、erase、eraser\)</span>中的一个即可，注意<spanclass="math inline">\(dreamer\)</span>与<spanclass="math inline">\(erase、eraser\)</span>会首尾重叠，所以还需进一步分类。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//读到e，判断是不是eraser或erase</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;s&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">5</span>]==<span class="string">&#x27;r&#x27;</span>)&#123;</span><br><span class="line">                    i+=<span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到d，判断是不是dream、dreamer、dreamerase、dreameraser即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;e&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;m&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp; s[i + <span class="number">7</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i + <span class="number">8</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; s[i + <span class="number">9</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                    i += <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        i += <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        i += <span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc049d-連結">[ABC049D] 連結</h1><h2 id="题面翻译-1">题面翻译</h2><h2 id="题目描述-1">题目描述</h2><p>有<span class="math inline">\(N\)</span>个城市，<spanclass="math inline">\(K\)</span>条道路（指地面上的道路）和<spanclass="math inline">\(L\)</span>条地铁。道路和地铁都是无向的。对于每个点，请你求出它只通过道路<strong>和</strong>只通过地铁都能到达的点的个数。道路和地铁之间不能换乘，你只能<strong>完全</strong>通过地铁到达某个点，或者<strong>完全</strong>通过道路到达某个点。</p><h2 id="输入格式-2">输入格式</h2><p>第一行三个正整数<span class="math inline">\(N,K,L\)</span> (<spanclass="math inline">\(N\le2\times 10^5,K,L\le10^5\)</span>)<br />然后<span class="math inline">\(K\)</span>行，每行两个数<spanclass="math inline">\(p,q\)</span>，表示城市<spanclass="math inline">\(p\)</span>和城市<spanclass="math inline">\(q\)</span>通过道路连接。<br />然后<span class="math inline">\(L\)</span>行，每行两个数<spanclass="math inline">\(r,s\)</span>，表示城市<spanclass="math inline">\(r\)</span>和城市<spanclass="math inline">\(s\)</span>通过地铁连接。</p><h2 id="输出格式-2">输出格式</h2><p>一行<spanclass="math inline">\(N\)</span>个正整数，表示每个点只通过道路和只通过地铁都能到达的点的个数。</p><h2 id="题目描述-2">题目描述</h2><p>$ N $ 個の都市があり、$ K $ 本の道路と $ L $本の鉄道が都市の間に伸びています。 $ i $ 番目の道路は $ p_i $ 番目と $q_i $ 番目の都市を双方向に結び、 $ i $ 番目の鉄道は $ r_i $ 番目と $ s_i$ 番目の都市を双方向に結びます。 異なる道路が同じ $ 2 $つの都市を結ぶことはありません。同様に、異なる鉄道が同じ $ 2 $つの都市を結ぶことはありません。</p><p>ある都市から別の都市に何本かの道路を通って到達できるとき、それらの都市は道路で連結しているとします。また、すべての都市はそれ自身と道路で連結しているとみなします。<br />鉄道についても同様に定めます。</p><p>全ての都市について、その都市と道路・鉄道のどちらでも連結している都市の数を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ L $ $ p_1 $ $ q_1 $ : $ p_K $ $ q_K $ $ r_1 $ $ s_1 $ :$ r_L $ $ s_L $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ N $ 個の整数を出力せよ。$ i $ 番目の数は $ i $番目の都市と道路・鉄道の両方で連結している都市の数である。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 4 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">6 7</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2 2 2</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 2 ≦ N ≦ 2*10^5 $</li><li>$ 1 ≦ K, L≦ 10^5 $</li><li>$ 1 ≦ p_i, q_i, r_i, s_i ≦ N $</li><li>$ p_i &lt; q_i $</li><li>$ r_i &lt; s_i $</li><li>$ i ≠ j $ のとき、$ (p_i, q_i) ≠ (p_j, q_j) $</li><li>$ i ≠ j $ のとき、$ (r_i, s_i) ≠ (r_j, s_j) $</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>$ 1, 2, 3, 4 $ 番目の都市は全て互いに道路で連結しています。鉄道で連結している都市は $ 2, 3 $ のみなので、答えは順に $ 1, 2, 2, 1 $となります。</p></blockquote><h2 id="思路-1">思路</h2><p>并查集+map，具体也不知道怎么解释，太累了，不想写了qwq</p><p>直接看题解吧：<ahref="https://www.luogu.com.cn/article/j3jx0o1z">题解 AT2159 【連結 /Connectivity】 - 洛谷专栏 (luogu.com.cn)</a></p><hr /><p>补思路补思路~~~</p><p>可以发现这是一个连通性问题，<del>所以我们不难想到用并查集</del>。</p><p>但是答案求的是这两个图的交集的元素个数，所以我们可以开一个数组<spanclass="math inline">\(Fa[i][j]\)</span>，表示有多少个点满足在<spanclass="math inline">\(fa1\)</span>中的祖先是<spanclass="math inline">\(i\)</span>，有多少个点在<spanclass="math inline">\(fa2\)</span>中的祖先是<spanclass="math inline">\(j\)</span>。那么，对于一个点<spanclass="math inline">\(u\)</span>，它走两条线路都能到的点数量就是<code>Fa[fa1.find(i)][fa2.find(i)]</code>（其中<spanclass="math inline">\(find\)</span>是查找祖先的函数）。记录这个数组的方法也很简单，就是对于每个点，<code>Fa[fa1.find(i)][fa2.find(i)]++</code>。</p><p>但是这样会喜提<spanclass="math inline">\(MLE\)</span>，所以我们可以拿出神器：<spanclass="math inline">\(map+pair\)</span></p><p>用<spanclass="math inline">\(map&lt;pair&lt;int,int&gt;,int&gt;\)</span>就可以省下很多空间，而我们其实只需要遍历这<spanclass="math inline">\(n\)</span>个点即可，所以绰绰有余，我们只需要遍历每个点时加一即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa1[MAXN],fa2[MAXN];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//思路：并查集+stl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x],fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x,fa),fy=<span class="built_in">find</span>(y,fa);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,k,l;cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa1[i]=i,fa2[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC048</title>
      <link href="/2024/03/22/ABC048/"/>
      <url>/2024/03/22/ABC048/</url>
      
        <content type="html"><![CDATA[<h1 id="abc048">ABC048</h1><blockquote><h1 id="abc048a-atcoder-contest">[ABC048A] AtCoder *** Contest</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个字符串，求这三个字符串的首字母并输出。</p><p>翻译提供者：一条小鱼</p><h2 id="题目描述">题目描述</h2><p>すぬけ君は、AtCoder $ s $ Contestという名前のコンテストを開こうとしています。 ここで、$ s $ は長さ $ 1 $以上の文字列であり、$ 1 $ 文字目は英大文字、$ 2 $文字目以降は英小文字です。</p><p>すぬけ君は、このコンテストの略称を A$ x <span class="math inline">\(Cに決めました。 ここで、\)</span> x $ は $ s $ の先頭の英大文字です。</p><p>コンテストの名前が与えられるので、コンテストの略称を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>AtCoder $ s $ Contest</p></blockquote><h2 id="输出格式">输出格式</h2><p>コンテストの略称を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Beginner Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Snuke Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder X Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AXC</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ s $ の長さは $ 1 $ 以上 $ 100 $ 以下である。</li><li>$ s $ の $ 1 $ 文字目は英大文字である。</li><li>$ s $ の $ 2 $ 文字目以降は英小文字である。</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>今あなたが参加しているコンテストです。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>このコンテストは存在しません。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s1,s2,s;cin&gt;&gt;s1&gt;&gt;s&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[<span class="number">0</span>]&amp;&amp;s[<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">        s[<span class="number">0</span>]=s[<span class="number">0</span>]<span class="number">-32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;s[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc048b-between-a-and-b-...">[ABC048B] Between a and b ...</h1><h2 id="题面翻译-1">题面翻译</h2><h2 id="题目描述-1">题目描述</h2><p>给出两个非负整数a，b（a≤b）和一个正整数x。请在 a 以上 b以下（包含a，b）的整数中， 找出可被 x 整除的数数量。</p><h2 id="输入输出格式">输入输出格式</h2><h4 id="输入格式-1">输入格式：</h4><p>三个数，a b x</p><h4 id="输出格式-1">输出格式：</h4><p>一行，一个整数，在 a 以上 b 以下（包含a，b）的整数中可被 x整除的数数量。</p><h2 id="输入输出样例">输入输出样例</h2><ol type="1"><li>输入样例#1: 4 8 2<br />输出样例#1: 3</li><li>输入样例#2: 0 5 1<br />输出样例#2: 6</li><li>输入样例#3: 9 9 2<br />输出样例#3: (无)</li><li>输入样例#4: 1 1000000000000000000 3 输出样例#4:333333333333333333</li></ol><h3 id="数据范围">数据范围：</h3><p>0 ≤ a ≤ b ≤ 10^18 1 ≤ x ≤ 10^18</p><h4 id="样例说明1">样例说明1:</h4><p>4 6 8 可以</p><h4 id="样例说明2">样例说明2:</h4><p>0 1 2 3 4 5 可以</p><h4 id="样例说明3">样例说明3:</h4><p>没有能被2整除的</p><h4 id="样例说明4">样例说明4:</h4><p>请注意溢出</p><p>感谢@2x6_81和 <span class="citation"data-cites="曾熠辰">@曾熠辰</span> 提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>非負の整数 $ a $, $ b $ ($ a &lt; = b $) と、正の整数 $ x $が与えられます。 $ a $ 以上 $ b $ 以下の整数のうち、$ x $で割り切れるものの個数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ x $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ a $ 以上 $ b $ 以下の整数のうち、$ x $で割り切れるものの個数を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 9 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1000000000000000000 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">333333333333333333</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 0 &lt; = a &lt; = b &lt; = 10^{18} $</li><li>$ 1 &lt; = x &lt; = 10^{18} $</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>$ 4 $ 以上 $ 8 $ 以下の整数のうち $ 2 $ で割り切れるものは、$ 4 $, $6 $, $ 8 $ です。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>$ 0 $ 以上 $ 5 $ 以下の整数のうち $ 1 $ で割り切れるものは、$ 0 $, $1 $, $ 2 $, $ 3 $, $ 4 $, $ 5 $ です。</p><h3 id="sample-explanation-3">Sample Explanation 3</h3><p>$ 9 $ 以上 $ 9 $ 以下の整数のうち $ 2 $で割り切れるものはありません。</p><h3 id="sample-explanation-4">Sample Explanation 4</h3><p>オーバーフローに注意してください。</p></blockquote><h2 id="思路-1">思路</h2><p>数据范围很大，所以肯定不能暴力枚举。</p><p>我们只需要找到最小的大于<spanclass="math inline">\(a\)</span>的数，同时也是<spanclass="math inline">\(x\)</span>的倍数，最大的小于<spanclass="math inline">\(b\)</span>的数，同时也是<spanclass="math inline">\(x\)</span>的倍数。</p><p>然后简单算一下即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll a,b,x;cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;</span><br><span class="line">    ll ans1=(a/x+(a%x==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>))*x;</span><br><span class="line">    ll ans2=(b/x)*x;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(ans2-ans1)/x;</span><br><span class="line">    cout&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc048c-boxes-and-candies">[ABC048C] Boxes and Candies</h1><h2 id="题面翻译-2">题面翻译</h2><p><span class="math inline">\(N\)</span>个箱子横排成一列，左边第<spanclass="math inline">\(i\)</span>个箱子里装着<spanclass="math inline">\(a_i\)</span>个糖果。</p><p>Snuke可以多次执行以下操作：</p><p>选一个里面不少于<spanclass="math inline">\(1\)</span>个糖果的箱子，从那个箱子里吃一个糖果。</p><p>他的目标：</p><p>任何<span class="math inline">\(2\)</span>个相邻的箱子都不多于<spanclass="math inline">\(x\)</span>个糖果。</p><p>请确定实现他的目标所需的最小操作次数。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の箱が横一列に並んでいます。 最初、左から $ i $ 番目の箱には$ a_i $ 個のキャンディが入っています。</p><p>すぬけ君は次の操作を好きな回数だけ行うことができます。</p><ul><li>キャンディが $ 1 $個以上入っている箱をひとつ選び、その箱のキャンディを $ 1 $個食べる。</li></ul><p>すぬけ君の目標は次の通りです。</p><ul><li>どの隣り合う $ 2 $つの箱を見ても、それらの箱に入っているキャンディの個数の総和が $ x $以下である。</li></ul><p>目標を達成するために必要な操作回数の最小値を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ x $ $ a_1 $ $ a_2 $ $ ... $ $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>目標を達成するために必要な操作回数の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1</span><br><span class="line">1 6 1 2 0 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4-1">样例 #4</h2><h3 id="样例输入-4-1">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-1">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2 &lt; = N &lt; = 10^5 $</li><li>$ 0 &lt; = a_i &lt; = 10^9 $</li><li>$ 0 &lt; = x &lt; = 10^9 $</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>$ 2 $ 番目の箱のキャンディを $ 1 $ 個食べればよいです。すると、各箱のキャンディの個数は $ (2, 1, 2) $ となります。</p><h3 id="sample-explanation-2-2">Sample Explanation 2</h3><p>たとえば、$ 2 $ 番目の箱のキャンディを $ 6 $ 個食べ、$ 4 $番目の箱のキャンディを $ 2 $ 個食べ、$ 6 $ 番目の箱のキャンディを $ 3 $個食べればよいです。 すると、各箱キャンディの個数は $ (1, 0, 1, 0, 0, 1)$ となります。</p><h3 id="sample-explanation-3-1">Sample Explanation 3</h3><p>最初から目標が達成されているので、操作を行う必要はありません。</p><h3 id="sample-explanation-4-1">Sample Explanation 4</h3><p>すべてのキャンディを食べなければなりません。</p></blockquote><h2 id="思路-2">思路</h2><p>贪心题，和前一个盒子进行判断是否大于<spanclass="math inline">\(x\)</span>，简单的模拟即可，注意一下当前盒子数目情况的判断。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,x;cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]+a[i]&gt;x)&#123;</span><br><span class="line">            ans+=(a[i<span class="number">-1</span>]+a[i]-x);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=a[i<span class="number">-1</span>]+a[i]-x)&#123;</span><br><span class="line">                a[i]-=a[i<span class="number">-1</span>]+a[i]-x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc048d-an-ordinary-game">[ABC048D] An Ordinary Game</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个长度大于等于3的字符串<spanclass="math inline">\(S\)</span>,<spanclass="math inline">\(S\)</span>中没有相邻的两个字符相等。</p><p><strong>玩法</strong>:</p><p>玩家<span class="math inline">\(1\)</span>和玩家<spanclass="math inline">\(2\)</span>交替进行操作——从<spanclass="math inline">\(S\)</span>中删除一个字符,但删除后<spanclass="math inline">\(S\)</span>不能有相邻的两个字符相等,否则另一位玩家获胜(两人都很聪明)</p><p>现在玩家<spanclass="math inline">\(1\)</span>先操作,请问谁可以获得胜利?</p><p>输入一个字符串<span class="math inline">\(S\)</span></p><p>若玩家<spanclass="math inline">\(1\)</span>胜利,输出<code>first</code>;玩家<spanclass="math inline">\(2\)</span>获胜,输出<code>Second</code></p><h2 id="题目描述-4">题目描述</h2><p>長さ $ 3 $ 以上の文字列 $ s $ があります。 $ s $の中に同一の文字が隣り合う箇所はありません。</p><p>高橋君と青木君がゲームで勝負します。 二人は交互に次の操作を行います。高橋君が先手です。</p><ul><li>$ s $ から両端以外の文字をひとつ取り除く。ただし、その文字を取り除くことで、$ s $の中に同一の文字が隣り合う箇所ができる場合、その文字を取り除くことはできない。</li></ul><p>先に操作を行えなくなった人が負けです。二人が最適に行動したとき、どちらが勝つかを判定してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>先手の高橋君が勝つならば <code>First</code>を、後手の青木君が勝つならば <code>Second</code> を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Second</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcab</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 3 &lt; = |s| &lt; = 10^5 $</li><li>$ s $ は英小文字のみからなる。</li><li>$ s $ の中に同一の文字が隣り合う箇所はない。</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>先手の高橋君は操作を行うことができません。 なぜならば、$ s $から両端以外の文字の <code>b</code> を取り除くと、$ s $ は<code>aa</code> となって <code>a</code> が隣り合うからです。</p><h3 id="sample-explanation-2-3">Sample Explanation 2</h3><p>先手の高橋君が $ s $ から <code>b</code> を取り除くと、$ s $ は<code>ac</code> となります。すると、後手の青木君は操作を行うことができません。 なぜならば、$ s $には両端以外の文字が存在しないからです。</p></blockquote><h2 id="思路-3">思路</h2><p>应该是博弈论。</p><p>推导过程看这里：[题解 AT2153 【<ahref="https://www.luogu.com.cn/article/lwt0riem">ARC064B] An OrdinaryGame】 - 洛谷专栏 (luogu.com.cn)</a></p><p>我就直接贴代码了qwq</p><hr /><p>好的，我来补思路了uwu</p><p>其实从样例中可以比较明显地发现，结果与字符串的长度、首尾是否相同有关。</p><p>引用<span class="math inline">\(DPair\)</span>大佬思路：</p><blockquote><p>首先我们发现一个及其显然的结论：删除到无法删除时，字符串情况只可能是这样的：</p><p><span class="math display">\[ababababa···ababab\]</span></p><p>即字符串中出现且只出现<strong>两种不同</strong>的字符，并<strong>交替出现</strong>（或只剩两个，但也可以看作这种情况）。</p><p>字符不可能只有一个，否则就违背题意了，而且由于首尾不能被删除，因此最后至少剩下两个字符，即不可能出现只有一个字符的情况。</p><p>排除这种可能性后，只出现两种不同字符的原因在于，由于相邻字符保证不同，且我要保证我现在的状态是一个死局，那么字符串<spanclass="math inline">\(s\)</span>中<spanclass="math inline">\(s_{i-1}=s_{i+1}\)</span>，即所有奇数下标位置的字符相同，所有偶数下标位置的字符相同，且这两种字符不同。故只有两种字符，且<strong>奇偶交替出现</strong>。</p><p>然后我们发现，若字符串长度为奇数，则首尾下标都为奇数，故要使该状态成为死局必须保证<strong>首尾相同</strong>，反之，即<strong>首尾不同</strong>，则绝对安全，不可能死局，也就是必胜，那么对手也就必败（这一步好像是博弈论的一个<strong>经典思考环节</strong>）。所以当<strong>字符串长度为偶数且首尾不同</strong>时，我的下一步操作一定会使对手进入必胜态，那么我就必败（因为本游戏没有平局）。</p><p><strong>首尾相同</strong>的情况也类似，只不过此时字符串长度为偶数时是安全的必胜态，奇数才为必败态。</p><p>因此当<strong>首尾相同且长度偶数</strong>或<strong>首尾不同且长度奇数</strong>时，先手必胜，反之后手必胜。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//ababababa</span></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[len<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC047</title>
      <link href="/2024/03/22/ABC047/"/>
      <url>/2024/03/22/ABC047/</url>
      
        <content type="html"><![CDATA[<h1 id="abc047">ABC047</h1><blockquote><h1 id="abc047a-キャンディーと2人の子供">[ABC047A]キャンディーと2人の子供</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个数，如果存在其中两个数的和等于第三个数，输出Yes，不存在，输出No，强调一下，岛国的题最后输出要记得换行，否则听取WA声一片</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園に通う $ 2 $人の子供がキャンディーの取り合いをしています。</p><p>$ 3 $個のキャンディーパックがあり、それぞれのパックにはキャンディーが $ a $,$ b $, $ c $ 個入っています。</p><p>えび先生はこの $ 3 $個のパックを、キャンディーの個数が等しくなるように $ 2 $人に分けようとしています。そのような分け方が可能かどうかを判定してください。</p><p>ただし、キャンディーをパックから取り出すことはできず、それぞれのパックをそのままどちらかの子供にあげる必要があります。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>キャンディーを同じ個数に分けられるなら <code>Yes</code>を、そうでなければ <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 30 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 30 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">56 25 31</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1 ≦ a, b, c ≦ 100 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>ひとりめの子供に $ 30 $個のキャンディーの入ったパックを、もう一方の子供に $ 10 $ 個と $ 20 $個のキャンディーの入ったパックをあげると、$ 2 $人のもらうキャンディーの個数を等しくすることができます。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>この場合、$ 100 $個のキャンディーの入ったパックを貰った子供は必ずもう一方の子供より多くのキャンディーを貰うことになってしまいます。$ 3 $つすべてのパックをどちらかの子供にあげるように分けなければならないことに注意してください。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(a+b==c||a+c==b||b+c==a)cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc047b-すぬけ君の塗り絵-2-イージー">[ABC047B] すぬけ君の塗り絵2 イージー</h1><h2 id="题面翻译-1">题面翻译</h2><p>平面上有一个左下角坐标<spanclass="math inline">\((0,0)\)</span>，右上角坐标<spanclass="math inline">\((W,H)\)</span> 的矩形，起初长方形内部被涂白。</p><p>现在给出<spanclass="math inline">\(N\)</span>个操作，每个操作都给定一个点<spanclass="math inline">\((x_i,y_i)\)</span>和一个参数<spanclass="math inline">\(a_i\)</span>，代表：</p><ul><li><span class="math inline">\(a_i=1\)</span>时，<spanclass="math inline">\(x&lt;x_i\)</span>的区域将被涂黑</li><li><span class="math inline">\(a_i=2\)</span>时，<spanclass="math inline">\(x&gt;x_i\)</span>的区域将被涂黑</li><li><span class="math inline">\(a_i=3\)</span>时，<spanclass="math inline">\(y&lt;y_i\)</span>的区域将被涂黑</li><li><span class="math inline">\(a_i=4\)</span>时，<spanclass="math inline">\(y&gt;y_i\)</span>的区域将被涂黑</li></ul><p>现在问当所有操作均结束后剩下的白色区域的面积</p><h2 id="题目描述-1">题目描述</h2><p>$ xy $ 平面上に、左下の座標が $ (0, 0) $、右上の座標が $ (W, H) $で、各辺が $ x $ 軸か $ y $軸に平行な長方形があります。最初、長方形の内部は白く塗られています。</p><p>すぬけ君はこの長方形の中に $ N $ 個の点を打ちました。$ i $ 個目 ($1 ≦ i ≦ N $) 点の座標は $ (x_i, y_i) $ でした。</p><p>また、すぬけ君は長さ $ N $ の数列 $ a $ を決めて、各 $ 1 ≦ i ≦ N $に対し、</p><ul><li>$ a_i = 1 $ のときは長方形の $ x &lt; x_i $ をみたす領域</li><li>$ a_i = 2 $ のときは長方形の $ x &gt; x_i $ をみたす領域</li><li>$ a_i = 3 $ のときは長方形の $ y &lt; y_i $ をみたす領域</li><li>$ a_i = 4 $ のときは長方形の $ y &gt; y_i $ をみたす領域</li></ul><p>を黒く塗りました。</p><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ W $ $ H $ $ N $ $ x_1 $ $ y_1 $ $ a_1 $ $ x_2 $ $ y_2 $ $ a_2 $ $ :$ $ x_N $ $ y_N $ $ a_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 2</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 5</span><br><span class="line">1 6 1</span><br><span class="line">4 1 3</span><br><span class="line">6 9 4</span><br><span class="line">9 4 2</span><br><span class="line">3 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1 ≦ W, H ≦ 100 $</li><li>$ 1 ≦ N ≦ 100 $</li><li>$ 0 ≦ x_i ≦ W $ ($ 1 ≦ i ≦ N $)</li><li>$ 0 ≦ y_i ≦ H $ ($ 1 ≦ i ≦ N $)</li><li>$ W $, $ H $ (21:32 追記), $ x_i $, $ y_i $ は整数である</li><li>$ a_i $ ($ 1 ≦ i ≦ N $) は $ 1, 2, 3, 4 $ のいずれかである</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>すぬけ君が塗りつぶしを始める前の長方形は以下の図のようになっています。![e19e673abcd0882783f635cce9d2f94d.png](https://atcoder.jp/img/abc047/e19e673abcd0882783f635cce9d2f94d.png)$ (x_1, y_1) = (2, 1) <span class="math inline">\(、\)</span> a_1 = 1 $なので、まずすぬけ君は $ x $ 座標が $ 2 $より小さい領域を塗りつぶし、長方形は以下のようになります。![f25cd04bbac23c4e5426d70511a9762f.png](https://atcoder.jp/img/abc047/f25cd04bbac23c4e5426d70511a9762f.png)$ (x_2, y_2) = (3, 3) <span class="math inline">\(、\)</span> a_2 = 4 $なので、次にすぬけ君は $ y $ 座標が $ 3 $より大きい領域を塗りつぶし、長方形は最終的に以下のようになります。![46b0c06fd9eee4f148e1f441f7abca53.png](https://atcoder.jp/img/abc047/46b0c06fd9eee4f148e1f441f7abca53.png)この最終的な状態における白い部分の面積は $ 9 $ なので、出力は $ 9 $となります。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>塗りつぶした結果、白い部分が残らないこともありえます。</p></blockquote><h2 id="思路-1">思路</h2><p>其实直接暴力就可以，但是我们想想优化方法</p><p>以<spanclass="math inline">\(a=1\)</span>为例，可以发现：对结果有影响的只有当<spanclass="math inline">\(a=1\)</span>时，所有<spanclass="math inline">\(x\)</span>的可能取值中最大的，其他的只是重复填涂而已，对结果没影响。同理可得<spanclass="math inline">\(a=2,a=3,a=4\)</span>的情况。</p><p>注意可能是否不存在的情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> w,h,n;cin&gt;&gt;w&gt;&gt;h&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">0</span>,a2=w,a3=<span class="number">0</span>,a4=h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,a;cin&gt;&gt;x&gt;&gt;y&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">            a1=<span class="built_in">max</span>(a1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">            a2=<span class="built_in">min</span>(a2,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">3</span>)&#123;</span><br><span class="line">            a3=<span class="built_in">max</span>(a3,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">4</span>)&#123;</span><br><span class="line">            a4=<span class="built_in">min</span>(a4,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边界小于左边界，或者上边界小于下边界</span></span><br><span class="line">    <span class="keyword">if</span>(a4&lt;a3||a2&lt;a1)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;(a2-a1)*(a4-a3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc047c-一次元リバーシ">[ABC047C] 一次元リバーシ</h1><h2 id="题面翻译-2">题面翻译</h2><p>输入一个长度不多于<spanclass="math inline">\(10^5\)</span>的字符串，只包含B或W。若前后两个字符不一样，答案累加，输出答案。</p><p>感谢@da32s1da 提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>きつねの次郎と三郎が一次元リバーシで遊んでいます。一次元リバーシでは、盤面には白か黒の石が一列に並んだ状態となっており、列の右端か左端に新たに石を打っていきます。通常のリバーシと同じように、たとえば白の石を打つことで黒の石を挟むと、挟まれた黒の石は白い石に変わります。</p><p>ゲームの途中で三郎に急用ができて帰ってしまうことになりました。このとき、盤面の状態は文字列$ S $ で表されます。石は $ |S| $ (文字列の長さ) 個並んでおり、左から $ i$ ($ 1 ≦ i ≦ |S| <span class="math inline">\() 個目の石の色は、\)</span>S $ の $ i $ 文字目が <code>B</code> のとき黒、<code>W</code>のとき白です。</p><p>次郎は現在の盤面に対して、できるだけ少ない個数の石を新たに打つことで全ての石を同じ色にしようと考えました。最小で何個の石を打てばよいかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>全ての石を同じ色にするために打つ必要のある石の個数の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BBBWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WWWWWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WBWBWBWBWB</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1 ≦ |S| ≦ 10^5 $</li><li>$ S $ に含まれる文字は <code>B</code> または <code>W</code>のいずれかである</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>たとえば右端に黒い石を打つとすべての白い石を黒い石にすることができます。他にも、左端に白い石を打つことでもすべての石の色を同じにできます。いずれの場合も $ 1 $ 個の石ですべての石を同じ色にすることができるので、$1 $ を出力します。</p><h3 id="sample-explanation-2-2">Sample Explanation 2</h3><p>最初から全ての石が同じ色の場合、新たに石を打つ必要はありません。</p></blockquote><h2 id="思路-2">思路</h2><p>开个<span class="math inline">\(flag\)</span>记录一下即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">char</span> flag=s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag!=s[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>发现自己<spanclass="math inline">\(SB\)</span>了，直接统计有多少个相邻的字符不同即可</p><blockquote><h1 id="abc047d-高橋君と見えざる手">[ABC047D] 高橋君と見えざる手</h1><h2 id="题面翻译-3">题面翻译</h2><h1 id="高桥君和不可见之手">高桥君和不可见之手</h1><h2 id="问题描述">问题描述</h2><p>有 <span class="math inline">\(N\)</span>个小镇排在一条直线上。旅行商人高桥君从小镇 <spanclass="math inline">\(1\)</span> 出发，一边买卖苹果一边朝小镇 <spanclass="math inline">\(N\)</span> 前行。</p><p>开始时高桥君处在小镇 <span class="math inline">\(1\)</span>，身上一个苹果也没有。高桥君不断进行以下行动。</p><ul><li>移动：从小镇 <span class="math inline">\(i(i &lt; N)\)</span>开始，移动到小镇 <span class="math inline">\(i+1\)</span> 。</li><li>买卖苹果：买进或卖出任意个苹果。在小镇 <spanclass="math inline">\(i(1 \leq i \leq N)\)</span> 买进或卖出苹果单价都为<span class="math inline">\(A_i\)</span> 円。 <spanclass="math inline">\(A_i\)</span> 为相异的整数。</li></ul><p>在每个小镇进行交易的苹果数量没有限制，但是旅行中所买进和卖出的苹果总数(买进苹果数加上卖出苹果数)必须在<span class="math inline">\(T\)</span>以内。高桥君会使自己在旅程中所获利益(卖苹果所得钱数减去买苹果所花钱数)最大。</p><p>在高桥君进行旅行之前，青木君可以对于任意 <spanclass="math inline">\(i\)</span> ，使 <spanclass="math inline">\(A_i\)</span> 变为非负整数 <spanclass="math inline">\(A_i&#39;\)</span> 。这个操作的代价为 <spanclass="math inline">\(|A_i-A_i&#39;|\)</span>。操作后即使出现相异小镇苹果单价相同的情况也没关系。</p><p>青木君的目的是：花费尽量少的代价，使高桥君所得的最大利益至少下降<span class="math inline">\(1\)</span> 円。请求出最小代价。</p><p>数据保证初始状态下高桥君至少能获得 <spanclass="math inline">\(1\)</span> 円的利益。</p><h2 id="数据范围">数据范围</h2><ul><li><span class="math inline">\(1 \leq N \leq 10^5\)</span></li><li><span class="math inline">\(1 \leq A_i \leq 10^9\)</span></li><li><span class="math inline">\(A_i\)</span> 相异</li><li><span class="math inline">\(2 \leq T \leq 10^9\)</span></li><li>保证初始状态下高桥君至少能获得 <spanclass="math inline">\(1\)</span> 円的利益。</li></ul><h2 id="输入">输入</h2><p>输入按以下标准： <span class="math display">\[ N \space T \]</span><span class="math display">\[ A_1 \space A_2 \space \dots \space A_N\]</span></p><h2 id="输出">输出</h2><p>输出使高桥君最大收益至少下降 <span class="math inline">\(1\)</span>円的最小代价和。</p><h2 id="样例1解释">样例1解释</h2><p>在初始状态下，高桥君能够进行以下的行动来获得最大收益( <spanclass="math inline">\(150\)</span> 円)：</p><ol type="1"><li>从小镇 <span class="math inline">\(1\)</span> 移动到小镇 <spanclass="math inline">\(2\)</span> 。</li><li>在小镇 <span class="math inline">\(2\)</span> 处花 <spanclass="math inline">\(50\)</span> 円买一个苹果。</li><li>从小镇 <span class="math inline">\(2\)</span> 移动到小镇 <spanclass="math inline">\(3\)</span> 。</li><li>在小镇 <span class="math inline">\(3\)</span> 处卖掉一个苹果获得<span class="math inline">\(200\)</span> 円。</li></ol><p>举例来说，如果青木君把小镇 <span class="math inline">\(2\)</span>的苹果单价从 <span class="math inline">\(50\)</span> 円上调至 <spanclass="math inline">\(51\)</span> 円，高桥君就无法获得 <spanclass="math inline">\(150\)</span>円的收益。也就是说，此操作能够使高桥君的最大收益至少下降 <spanclass="math inline">\(1\)</span> 円，所以答案为 <spanclass="math inline">\(1\)</span> 。</p><p>另外，将小镇 <span class="math inline">\(3\)</span> 的苹果单价从<span class="math inline">\(200\)</span> 円降至 <spanclass="math inline">\(199\)</span> 円也能够达到目的。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の町が一直線上に並んでいます。行商人の高橋君は町 $ 1 $から出発し、リンゴの売買をしながら町 $ N $ へと向かいます。</p><p>はじめ高橋君は町 $ 1 $ におり、リンゴを $ 1 $つも持っていません。高橋君は次のいずれかの行動を繰り返し行います。</p><ul><li>移動: 町 $ i $ ($ i &lt; N $) にいるとき、町 $ i + 1 $へ移動する。</li><li>リンゴの売買: リンゴを好きな個数だけ売買する。ここで、町 $ i $ ($1 ≦ i ≦ N $) ではリンゴの買値も売値もともに $ A_i $ 円とする。ここで $A_i $ は相異なる整数です。</li></ul><p>$ 1 $つの町で売買するリンゴの個数に制限はありませんが、旅の中で売買するリンゴの個数は合計で(買う個数と売る個数を合わせて) $ T $ 個以下にしなくてはなりません。</p><p>高橋君は旅の利益、すなわちリンゴを売った代金から買った代金を引いた値を最大にするように旅をするとします。旅が終わったときに持っていたリンゴの価値は考えず、旅の中で売買した金額だけを考えます。</p><p>この旅に先立って、青木君は任意の町 $ i $ に対して $ A_i $を好きな非負整数 $ A_i' $に変えるという操作を好きなだけ行うことができます。ただし、この操作は行うごとに$ |A_i - A_i'| $のコストがかかります。操作後には異なる町の間でリンゴの値段が同じになっていても構いません。</p><p>青木君の目的はできるだけ少ない合計コストの操作で高橋君の利益を少なくとも$ 1 $ 円下げることです。合計コストの最小値を求めてください。</p><p>ただし、元の状態で高橋君が $ 1 $円以上の利益を上げられることは仮定して構いません。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T $ $ A_1 $ $ A_2 $ $ ... $ $ A_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>高橋君の収益を少なくとも $ 1 $円下げるために必要な合計コストの最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">100 50 200</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">50 30 40 10 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">7 10 4 5 9 3 6 8 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1 ≦ N ≦ 10^5 $</li><li>$ 1 ≦ A_i ≦ 10^9 $ ($ 1 ≦ i ≦ N $)</li><li>$ A_i $ は相異なる</li><li>$ 2 ≦ T ≦ 10^9 $</li><li>入力の状態では高橋君は $ 1 $円以上の利益を上げられることが保証される</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>この入力の状態では、高橋君は次のようにして最大の利益である $ 150 $円を達成することができます。 1. 町 $ 1 $ から町 $ 2 $ へ移動する。 2. 町$ 2 $ で $ 50 $ 円を支払い、リンゴを $ 1 $ 個買う。 3. 町 $ 2 $ から町 $3 $ へ移動する。 4. 町 $ 3 $ で $ 200 $ 円でリンゴを $ 1 $ 個売る。たとえば、青木君が町 $ 2 $ のリンゴの値段を $ 50 $ 円から $ 51 $円に変えると、高橋君はどのようにしても $ 150 $円の利益を上げることができなくなります。すなわち、コスト $ 1 $で高橋君の利益を少なくとも $ 1 $ 円下げることが可能であり、答えは $ 1 $となります。 他にも、町 $ 3 $ のリンゴの値段を $ 200 $ 円から $ 199 $円に変えることでもコスト $ 1 $で高橋君の利益を下げることが可能です。</p></blockquote><h2 id="思路-3">思路</h2><p>高木的理想情况就是最高售价-最低买价（记作<spanclass="math inline">\(MAX\)</span>），那么我们只需要找到所有的满足情况即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,t;cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    ll MAX=LONG_LONG_MIN,MIN=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll a;cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//b记录的是该方案对应的利润</span></span><br><span class="line">        b[i]=a-MIN;</span><br><span class="line">        <span class="comment">//MIN：最低购入价格</span></span><br><span class="line">        MIN=<span class="built_in">min</span>(MIN,a);</span><br><span class="line">        <span class="comment">//MAX最大利润</span></span><br><span class="line">        MAX=<span class="built_in">max</span>(MAX,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==MAX)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC046</title>
      <link href="/2024/03/22/ABC046/"/>
      <url>/2024/03/22/ABC046/</url>
      
        <content type="html"><![CDATA[<h1 id="abc046">ABC046</h1><blockquote><h1 id="abc046a-atcodeerくんとペンキ">[ABC046A]AtCoDeerくんとペンキ</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>AtCoDeer先生最近买了三个油漆罐。两天前他买的那一种颜色是A，他昨天买的颜色是B，他今天买的颜色是C。每个颜料的颜色可以用1到100之间的正整数来表示。</p><p>由于AtCoDeer先生出生健忘村，AtCoDeer先生可能买了一个以上的油漆罐颜色相同。计算这些油漆罐的不同颜色的数量并告诉AtCoDeer先生。</p><p>范围：</p><p>1&lt;=(a,b,c)&lt;=100</p><p>输入格式： 三个正整数a,b,c</p><p>输出格式： 一个正整数，表示不同颜色数量</p><h2 id="题目描述">题目描述</h2><p>シカのAtCoDeerくんはペンキをこれまでに$ 3$つ買いました。おととい買ったペンキの色は $ a $ , 昨日買ったペンキの色は$ b $ , 今日買ったペンキの色は $ c $ です。各ペンキの色は$ 1 <spanclass="math inline">\(以上\)</span> 100 $以下の整数で表されます。AtCoDeerくんはわすれんぼうなため、同じ色のペンキを買ってしまっていることがあります。AtCoDeerくんが買ったペンキの色の種類の個数を教えてあげてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>AtCoDeerくんが買ったペンキの色の種類の個数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 33</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦a,b,c≦100 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>色 $ 1 <span class="math inline">\(,\)</span> 3 <spanclass="math inline">\(,\)</span> 4 $ の $ 3 $ 種類です。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>色 $ 3 <span class="math inline">\(,\)</span> 33 $ の $ 2 $種類です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可，可以用map</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(m[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc046b-atcodeerくんとボール色塗り">[ABC046B]AtCoDeerくんとボール色塗り</h1><h2 id="题面翻译-1">题面翻译</h2><p>你有N个球，K种颜料</p><p>你要把N个球涂上颜料，但是为了美观相邻的两个球不能是一样颜色的。</p><p>问有多少种涂色方法？</p><p>样例1：输入 2 2 输出 2 样例解释：只有01和10这两种涂色方法</p><p>样例2:输入 1 10 输出 10 样例解释：有0,1,2,3,4,5,6,7,8和9这些方法</p><p>感谢@RioBlu 提供的翻译</p><h2 id="题目描述-1">题目描述</h2><p>シカのAtCoDeerくんは一列に並んだ $ N $ 個のボールをそれぞれ $ K $色のペンキの色のうちのどれかで塗ろうとしています。見栄えが悪くならないように、隣り合ったボールは別の色で塗ることにします。ボールの塗り方としてあり得るものの個数を求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>ボールの塗り方としてあり得るものの個数を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">322828856</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 2≦K≦1000 $</li><li>答えは $ 2^{31}-1 $ 以下</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>色を$ 0 <span class="math inline">\(,\)</span> 1 <spanclass="math inline">\(で表すと、左のボールを\)</span> 0 <spanclass="math inline">\(で塗り、右のボールを\)</span> 1 <spanclass="math inline">\(で塗る という方法と、 左のボールを\)</span> 1<span class="math inline">\(で塗り、右のボールを\)</span> 0 <spanclass="math inline">\(で塗る という方法の\)</span> 2$通りがあります。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>ボールは一つしか無いため,$ 10 <spanclass="math inline">\(色のうちどれを使っても良いので答えは\)</span> 10$通りです。</p></blockquote><h2 id="思路-1">思路</h2><p>简单的组合数学</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ll ans=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=(k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc046c-atcodeerくんと選挙速報">[ABC046C]AtCoDeerくんと選挙速報</h1><h2 id="题面翻译-2">题面翻译</h2><p>给定 <span class="math inline">\(n\)</span> 和 <spanclass="math inline">\(n\)</span> 对正整数 <spanclass="math inline">\(T_i,A_i\)</span>，已知正整数数列 <spanclass="math inline">\(t_i,a_i\)</span> 满足以下条件：</p><ul><li><span class="math inline">\(t_i\le t_{i+1}\)</span>，<spanclass="math inline">\(a_i\le a_{i+1}\)</span></li><li><span class="math inline">\(t_i/a_i=T_i/A_i\)</span></li></ul><p>求 <span class="math inline">\(t_n+a_n\)</span>的最小值，保证答案不超过 <spanclass="math inline">\(10^{18}\)</span>。</p><h2 id="题目描述-2">题目描述</h2><p>シカのAtCoDeerくんは選挙速報を見ています。選挙には二人の候補高橋くんと青木くんが出ています。速報では、現在の二人の得票数の比が表示されていますが、得票数そのものは表示されていません。AtCoDeerくんは$ N $ 回画面を見て、 $ i(1≦i≦N) $ 回目に見たときに表示されている比は $T_i:A_i $ でした。ここで、AtCoDeerくんが選挙速報の画面を$ 1$回目に見た段階で既にどちらの候補にも少なくとも一票は入っていたことがわかっています。$ N $回目に画面を見たときの投票数(二人の得票数の和)として考えられるもののうち最小となるものを求めてください。ただし、得票数が途中で減ることはありません。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ A_1 $ $ T_2 $ $ A_2 $ $ : $ $ T_N $ $ A_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ N $回目に画面を見たときの投票数として考えられる最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">1 1</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">1 5</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 10</span><br><span class="line">48 17</span><br><span class="line">31 199</span><br><span class="line">231 23</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6930</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 1≦T_i,A_i≦1000 (1≦i≦N) $</li><li>$ T_i $ と $ A_i $ は互いに素 $ (1≦i≦N) $</li><li>答えが $ 10^{18} $ 以下になることは保証されている</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>二人の得票数が $ 2,3 $ -&gt; $ 3,3 $ -&gt; $ 6,4 $ と動くと投票数は $10 $ になって、これが最小値です。</p><h3 id="sample-explanation-2-2">Sample Explanation 2</h3><p>一度画面を見てからもう一度画面を見るまでに一票も入ってないことがありえます。</p></blockquote><h2 id="思路-2">思路</h2><p>有意思的一道题。</p><p>思路参考自<ahref="https://www.luogu.com.cn/article/5qxzbt31">AT2140题解 - 洛谷专栏(luogu.com.cn)</a></p><p>设<spanclass="math inline">\(u,v\)</span>为目前两个人的得票数，需要保证在以后的每一步中都有<spanclass="math inline">\(u:v=T_i:A_i\)</span></p><p>先设<span class="math inline">\(u,v\)</span>分别为<spanclass="math inline">\(T_i,A_i\)</span>的倍数。注意到总票数不会减少，所以<spanclass="math inline">\(u,v\)</span>应该变为大于他们的最小的<spanclass="math inline">\(T_i\)</span>或者<spanclass="math inline">\(A_i\)</span>的倍数。</p><p>所以接下来这一步：<spanclass="math inline">\(u=T_i*\lceil\frac{u}{T_i}\rceil，u=A_i*\lceil\frac{v}{A_i}\rceil\)</span>。</p><p>因为要一直保证<spanclass="math inline">\(u:v=T_i:A_i\)</span>，所以接下来需要比较<spanclass="math inline">\(\frac{u}{T_i}\)</span>和<spanclass="math inline">\(\frac{v}{A_i}\)</span>的大小：</p><p><spanclass="math inline">\(\frac{u}{T_i}\)</span>小，根据比例的基本性质，<spanclass="math inline">\(u=\frac{vT_i}{A_i}\)</span>。同理可得其他情况。</p><p>答案即<span class="math inline">\(u+v\)</span>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i]&gt;&gt;a[i];</span><br><span class="line">    ll u=t[<span class="number">1</span>],v=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        u=((u<span class="number">-1</span>)/t[i]+<span class="number">1</span>)*t[i],v=((v<span class="number">-1</span>)/a[i]+<span class="number">1</span>)*a[i];</span><br><span class="line">        <span class="keyword">if</span>(u/t[i]&lt;v/a[i])u=(v/a[i])*t[i];</span><br><span class="line">        <span class="keyword">else</span> v=(u/t[i])*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;u+v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc046d-atcodeerくんと変なじゃんけん">[ABC046D]AtCoDeerくんと変なじゃんけん</h1><h2 id="题面翻译-3">题面翻译</h2><p>你和对手都只有两种出拳方式：石头（<spanclass="math inline">\(g\)</span>）和布（<spanclass="math inline">\(p\)</span>），规则一样，赢了得一分，平局不得分，输了减一分。现给你对手的出拳方式，设你到 <span class="math inline">\(i\)</span>位置共出了 <span class="math inline">\(x_i\)</span> 次石头，<spanclass="math inline">\(y_i\)</span> 次布，在对于任意位置 <spanclass="math inline">\(i\)</span> 满足 <span class="math inline">\(x_i\geq y_i\)</span> 的条件下，输出你能得到的最大分数。</p><h2 id="题目描述-3">题目描述</h2><p>シカのAtCoDeerくんは友達のTopCoDeerくんとあるゲームをして対戦しています。このゲームは $ N $ターンからなります。各ターンではそれぞれのプレイヤーはじゃんけんのグーかパーを出します。ただし、各プレイヤーは次の条件を満たす必要があります。</p><p>(※) 各ターンの後で、(今までにパーを出した回数)$ ≦$(今までにグーを出した回数) を満たす</p><p>このゲームでの各プレイヤーの得点は、(勝ったターンの数) $ - $(負けたターンの数) です。AtCoDeerくんは特殊能力を持っているので、ゲームが始まる前にTopCoDeerくんの出す$ N $ ターンの手を全て知ることが出来ました。AtCoDeerくんの各ターンでの手を決めて、AtCoDeerくんの得点を最大化してください。TopCoDeerくんの出す手の情報は文字列 $ s $ で与えられます。 $ s $ の $i(1≦i≦N) $ 文字目が <code>g</code>のときは $ i $ターン目でTopCoDeerくんがグーを出すことを、<code>p</code>のときはパーを出すことを表します。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>AtCoDeerくんの得点の最大値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ggppgggpgg</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ N=|s| $</li><li>$ s $ の各文字は<code>g</code>か<code>p</code></li><li>$ s $ で表される手は、条件(※)を満たしている</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>常に相手とあいこになるように手を出すことで、$ 0$点を取ることができて、これが最大値です。</p><h3 id="sample-explanation-2-3">Sample Explanation 2</h3><p>例えばグー,パー,グー,パー,グー,グー,パー,パー,グー,パーと出すことで、 $ 3 <span class="math inline">\(回勝って\)</span> 1 <spanclass="math inline">\(回負けているので得点は\)</span> 2$点になり、これが最大値です。</p></blockquote><h2 id="思路-3">思路</h2><p>直接模拟，判断<span class="math inline">\(p\)</span>是否大于<spanclass="math inline">\(max_p\)</span>。再处理即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll p=<span class="number">0</span>,g=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>)p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll lose=<span class="number">0</span>,win=<span class="number">0</span>;</span><br><span class="line">    ll max_p=s.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;=max_p)lose+=(p-max_p);</span><br><span class="line">    <span class="keyword">else</span> win+=(max_p-p);</span><br><span class="line">    cout&lt;&lt;win-lose;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC044</title>
      <link href="/2024/03/21/ABC044/"/>
      <url>/2024/03/21/ABC044/</url>
      
        <content type="html"><![CDATA[<h1 id="abc044">ABC044</h1><p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr /><blockquote><h1 id="abc044a-高橋君とホテルイージー">[ABC044A]高橋君とホテルイージー</h1><h2 id="题面翻译">题面翻译</h2><p>有一家酒店，这家酒店住宿费的收取规则如下</p><ul><li>前K晚每晚X元</li><li>从K+1晚开始每晚Y元</li></ul><p>高橋老弟要在这里连续住N晚，问他的住宿费合计为多少元</p><h4 id="输入格式">输入格式</h4><p>第一行，N</p><p>第二行，K</p><p>第三行，X</p><p>第四行，Y</p><h4 id="输出格式">输出格式</h4><p>一行，住宿总费用</p><h2 id="题目描述">题目描述</h2><p>$ 1 $ 軒のホテルがあります。このホテルの宿泊費は、次のようになっています。</p><ul><li>最初の $ K $ 泊までは、$ 1 $ 泊あたり $ X $ 円</li><li>$ K+1 $ 泊目以降は、$ 1 $ 泊あたり $ Y $ 円</li></ul><p>高橋君は、このホテルに $ N $ 泊連続で宿泊することにしました。高橋君の宿泊費は合計で何円になるか求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ X $ $ Y $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>高橋君の宿泊費の合計金額を表す整数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48000</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20000</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1  N, K  10000 $</li><li>$ 1  Y $</li><li>$ N,,K,,X,,Y $ はいずれも整数である</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>宿泊費は次のようになります。 - $ 1 $ 泊目は $ 10000 $ 円 - $ 2 $泊目は $ 10000 $ 円 - $ 3 $ 泊目は $ 10000 $ 円 - $ 4 $ 泊目は $ 9000 $円 - $ 5 $ 泊目は $ 9000 $ 円 したがって、合計は $ 48000 $ 円です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k,x,y;cin&gt;&gt;n&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;n*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        ans+=k*x+(n-k)*y;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc044b-美しい文字列">[ABC044B] 美しい文字列</h1><h2 id="题面翻译-1">题面翻译</h2><p>输入一个字符串，判断每个字母出现的次数是否都为偶数</p><p>如果是，输出“Yes”，否则输出“No”</p><h2 id="题目描述-1">题目描述</h2><p>$ w $ を、英小文字のみからなる文字列とします。 $ w $が以下の条件を満たすならば、$ w $を<em>美しい文字列</em>と呼ぶことにします。</p><ul><li>どの英小文字も、$ w $ 中に偶数回出現する。</li></ul><p>文字列 $ w $ が与えられます。$ w $が美しい文字列かどうか判定してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ w $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ w $ が美しい文字列ならば <code>Yes</code> を、それ以外の場合は<code>No</code> を出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abaccaba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hthth</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1  |w|  100 $</li><li>$ w $ は英小文字 (<code>a</code>-<code>z</code>)のみからなる文字列である</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p><code>a</code> が $ 4 $ 回、<code>b</code> が $ 2 $回、<code>c</code> が $ 2 $ 回、それ以外の英小文字が $ 0 $回出現します。</p></blockquote><h2 id="思路-1">思路</h2><p>开个桶，直接统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        m[s[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i]%<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc044c-高橋君とカード">[ABC044C] 高橋君とカード</h1><h2 id="题面翻译-2">题面翻译</h2><p>高桥有n张卡。在i(1≤i≤n)的第一个磁卡上，卡上面写着整数x_i。</p><p>高桥从这些卡片中挑选1张以上，想把选择的卡片上写的整数的平均数变成等于A的数。问有几种方案。</p><p>读入： 第一行读入N,A； 接下来一行读入N个数</p><p>输出： 一个数，记得加回车</p><p>感谢@STEPHEN_ 提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>高橋君は、$ N $ 枚のカードを持っています。 $ i , (1  i  N) $番目のカードには、整数 $ x_i $ が書かれています。高橋君は、これらのカードの中から $ 1 $ 枚以上を選び、選んだカードに書かれた整数の平均をちょうど $ A $にしたいと考えています。そのようなカードの選び方が何通りあるか求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ x_1 $ $ x_2 $ $ ... $ $ x_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>書かれた整数の平均がちょうど $ A $となるようなカードの選び方の総数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 9 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 8</span><br><span class="line">6 6 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5</span><br><span class="line">3 6 2 8 7 6 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33 3</span><br><span class="line">3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8589934591</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1  N  50 $</li><li>$ 1  A  50 $</li><li>$ 1  x_i  50 $</li><li>$ N,,A,,x_i $ はいずれも整数である</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 1  N  16 $ を満たすデータセットに正解した場合は、$ 200 $点が与えられる。</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>- 平均が $ 8 $ となるカードの選び方は、以下の $ 5 $ 通りです。 - $ 3$ 枚目のカードのみを選ぶ。 - $ 1 $ 枚目と $ 2 $ 枚目のカードを選ぶ。 - $1 $ 枚目と $ 4 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 2 $ 枚目および $ 3$ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 3 $ 枚目および $ 4 $枚目のカードを選ぶ。</p><h3 id="sample-explanation-4">Sample Explanation 4</h3><p>- 答えは $ 32 $ ビット整数型に収まらない場合があります。</p></blockquote><h2 id="思路-2">思路</h2><p>转载自<a href="https://www.luogu.com.cn/article/z25wx5t7">AT2037 题解- 洛谷专栏 (luogu.com.cn)</a></p><p>计数型01背包。</p><p>一开始想的是只写<spanclass="math inline">\(f_{j}\)</span>，表示的是和为<spanclass="math inline">\(j\)</span>的方法数。</p><p>但是最后发现不行，因为有可能最后可能不同的组合组成的数为<spanclass="math inline">\(j\)</span>，所以得多加一个维度<spanclass="math inline">\(i\)</span>，表示的是取了<spanclass="math inline">\(i\)</span>个数</p><p>所以状态中存了两个值：<spanclass="math inline">\(f_{i,j}\)</span>表示取了<spanclass="math inline">\(i\)</span>个数，和为<spanclass="math inline">\(j\)</span>的方法数。</p><p>这样转移方程为：<spanclass="math inline">\(f_{i,j}=f_{i,j}+f_{i-1,j-a_k}\)</span>，<spanclass="math inline">\(i-1\)</span>是这个数还没取，也就是少取了一个，<spanclass="math inline">\(j-a_k\)</span>表示当前这个和减去现在的这个值，也就是之前的和。</p><p>注意就是枚举<span class="math inline">\(i\)</span>和<spanclass="math inline">\(j\)</span>时要反着枚举，初始化<spanclass="math inline">\(f[0][0]=1\)</span>，开<spanclass="math inline">\(long\ long\)</span>。</p><p>注意平均值不一定是整数哦。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">55</span>][<span class="number">2505</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//设初值。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">  <span class="comment">//注意这两重循环是反着的，否则会从已经改过的值转移来。</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)</span><br><span class="line">            sum+=(j*<span class="number">1.0</span>/i==<span class="built_in">double</span>(m))*f[i][j];</span><br><span class="line">  <span class="comment">//如果平均值等于 m 就将 sum 加上 f[i][j]。</span></span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;<span class="comment">//AT 加换行。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,A;cin&gt;&gt;n&gt;&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j*<span class="number">1.0</span>/i)==(<span class="type">double</span>)A)sum+=f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc044d-桁和">[ABC044D] 桁和</h1><h2 id="题面翻译-3">题面翻译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line"></span><br><span class="line">对于2以上的整数b和一个1以上的整数n，函数f(b,n)的定义如下：</span><br><span class="line"></span><br><span class="line">1.若n&lt;b,f(b，n)=n;</span><br><span class="line"></span><br><span class="line">2.若n&gt;=b,f(b,n)=f(b,floor(n/b))+(n%b).</span><br><span class="line"></span><br><span class="line">说白了就是即n在b进制下各位数的和 举个例子：</span><br><span class="line"></span><br><span class="line">f(10,87654)=8+7+6+5+4=30</span><br><span class="line"></span><br><span class="line">f(100,87654)=8+76+54=138</span><br><span class="line"></span><br><span class="line">设函数f(b,n)的值为s；</span><br><span class="line"></span><br><span class="line">输入输出格式</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line"></span><br><span class="line">输入包含两个数，代表n,s的值</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line"></span><br><span class="line">输出包含1个数，是b的值，如果找不到符合要求的b值，则输出-1</span><br></pre></td></tr></table></figure><p>注：此为<ahref="https://www.luogu.org/space/show?uid=118196">Over_The_Best</a>翻译，但他被禁言了，由我代发</p><h2 id="题目描述-3">题目描述</h2><p>$ 2 $ 以上の整数 $ b $ および $ 1 $ 以上の整数 $ n $ に対し、関数 $f(b,n) $ を次のように定義します。</p><ul><li>$ n &lt; b $ のとき $ f(b,n) = n $</li><li>$ n  b $ のとき $ f(b,n) = f(b,,{}(n / b)) + (n {} b) $</li></ul><p>ここで、$ {}(n / b) $ は $ n / b $ を超えない最大の整数を、 $ n {} b$ は $ n $ を $ b $ で割った余りを表します。</p><p>直感的に言えば、$ f(b,n) $ は、$ n $ を $ b $進表記したときの各桁の和となります。 例えば、</p><ul><li>$ f(10,,87654)=8+7+6+5+4=30 $</li><li>$ f(100,,87654)=8+76+54=138 $</li></ul><p>などとなります。</p><p>整数 $ n $ と $ s $ が与えられます。 $ f(b,n)=s $ を満たすような $ 2$ 以上の整数 $ b $ が存在するか判定してください。 さらに、そのような $ b$ が存在するならば、その最小値を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>$ f(b,n)=s $ を満たす $ 2 $ 以上の整数 $ b $が存在するならば、そのような $ b $ の最小値を出力せよ。 そのような $ b $が存在しないならば、代わりに <code>-1</code> を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">138</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">45678</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-4-1">样例 #4</h2><h3 id="样例输入-4-1">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-1">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">31415926535</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1  n  10^{11} $</li><li>$ 1  s  10^{11} $</li><li>$ n,,s $ はいずれも整数である</li></ul></blockquote><h2 id="思路-3">思路</h2><p>题解区都是一堆奇怪的显然，莫名其妙的就是<spanclass="math inline">\(O(\sqrt{n})\)</span>的时间复杂度。幸好在下面翻到一篇好文章，这里是原文链接：<ahref="https://www.luogu.com.cn/article/qkzeokn7">AT2038 - 洛谷专栏(luogu.com.cn)</a></p><p>其实是一道数学题</p><p>不妨设<spanclass="math inline">\(n=a_0+a_1b+a_2b^2+······\)</span>，则<spanclass="math inline">\(s=a_0+a_1+a_2+······\)</span>。</p><p>先考虑特殊情况 :</p><p>1、<span class="math inline">\(n=s\)</span>，则<spanclass="math inline">\(b=n+1\)</span></p><p>2、<span class="math inline">\(n&lt;s\)</span>，则无解。</p><p>我们用<span class="math inline">\(n\)</span>减去<spanclass="math inline">\(s\)</span>：</p><p><spanclass="math inline">\(n-s=a_1(b-1)+a_2(b^2-1)+a_3(b^3-1)+······\)</span>。</p><p>容易知道，<spanclass="math inline">\(b^n-1=(b-1)(b^{n-1}+b^{n-2}+b^{n-3}+······+1)\)</span>，所以说, 右式可以提出<span class="math inline">\(b-1\)</span>。</p><p>显然：<span class="math inline">\((b-1)|n-s\)</span>，那么<spanclass="math inline">\(b\)</span>可能的取值范围就缩成了<spanclass="math inline">\(\sqrt{n}\)</span>数量级，接下来直接调用函数，暴力枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n,s;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll b,ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(b,n/b)+n%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,n)==s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;s)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==s)&#123;</span><br><span class="line">        cout&lt;&lt;n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tot=n-s,ans=<span class="number">1e15</span>;</span><br><span class="line">    <span class="comment">//可以结合最基础的素数筛，理解为什么枚举到根号n即可</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=(ll)<span class="built_in">sqrt</span>(tot)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//注意是判断两个哦</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(tot/i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,tot/i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e15</span>)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC045</title>
      <link href="/2024/03/21/ABC045/"/>
      <url>/2024/03/21/ABC045/</url>
      
        <content type="html"><![CDATA[<h1 id="abc045">ABC045</h1><blockquote><h1 id="abc045a-台形">[ABC045A] 台形</h1><h2 id="题面翻译">题面翻译</h2><p>一个梯形，给出上底a，下底b，高h的长度，求它的面积~~~</p><h2 id="题目描述">题目描述</h2><p>上底の長さが $ a $、下底の長さが $ b $、高さが $ h $の台形があります。</p><p><imgsrc="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc045_a/695fd302082c8c27a3f1814f7489c8be1c4f74c9.png" />台形の例</p><p>この台形の面積を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ h $</p></blockquote><h2 id="输出格式">输出格式</h2><p>台形の面積を整数で出力せよ。面積が整数になることは保障されている。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1  a  100 $</li><li>$ 1  b  100 $</li><li>$ 1  h  100 $</li><li>入力で与えられる値はすべて整数</li><li>$ h $ は偶数</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>上底の長さ $ 3 $、下底の長さ $ 4 $、高さ $ 2 $ の台形の面積は、 $(3+4)×2/2 = 7 $ です。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>この例で与えられるのは平行四辺形ですが、平行四辺形も台形です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    ll a,b,h;cin&gt;&gt;a&gt;&gt;b&gt;&gt;h;</span><br><span class="line">    cout&lt;&lt;(a+b)*h/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc045b-3人でカードゲームイージー">[ABC045B]3人でカードゲームイージー</h1><h2 id="题面翻译-1">题面翻译</h2><h3 id="题面描述">题面描述</h3><p>Alice、Bob 和 Charlie 在玩 <em>Card Game for Three</em>。</p><ul><li>开始时，每名玩家有一叠由卡牌组成的牌堆。每张牌上有一个字母 <spanclass="math inline">\(\texttt a, \texttt b\)</span> 或 <spanclass="math inline">\(\texttt c\)</span>。 卡牌的顺序不能被改变。</li><li>Alice 先开始游戏。</li><li>玩家的牌堆中至少有一张牌，当前玩家从牌堆顶抽出一张牌，这张牌代表的玩家进行下一回合（<spanclass="math inline">\(\texttt a\)</span> 代表 Alice，<spanclass="math inline">\(\texttt c\)</span> 代表 Bob，<spanclass="math inline">\(\texttt c\)</span> 代表 Charlie）。</li><li><strong>从左往右抽牌</strong>（牌堆顶在左边）。</li><li>如果当前玩家的牌堆空了，游戏结束，这名玩家胜利。</li></ul><p>你得到了每名玩家最初的牌堆 <span class="math inline">\(S_a, S_b,S_c\)</span>，求出胜者。</p><h3 id="数据范围">数据范围</h3><p>对于 <span class="math inline">\(100 \%\)</span> 的数据，保证 <spanclass="math inline">\(1 \leq |S_a|, |S_b|, |S_c| \leq 100\)</span> 且<span class="math inline">\(S_a, S_b, S_c\)</span> 仅由 <spanclass="math inline">\(\texttt{abc}\)</span> 三个小写拉丁字母组成。</p><h2 id="题目描述-1">题目描述</h2><p>A さん、B さん、C さんの $ 3 $人が以下のようなカードゲームをプレイしています。</p><ul><li>最初、$ 3 $ 人はそれぞれ<code>a</code>、<code>b</code>、<code>c</code>いずれかの文字が書かれたカードを、何枚か持っている。これらは入力で与えられた順番に持っており、途中で並べ替えたりしない。</li><li>$ A $ さんのターンから始まる。</li><li>現在自分のターンである人がカードを $ 1 $枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人(例えば、カードに <code>a</code> と書かれていたならば A さん)のターンとなる。</li><li>現在自分のターンである人がカードを $ 1 $枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。</li></ul><p>$ 3 $ 人が最初に持っているカードがそれぞれ先頭から順に与えられます。具体的には、文字列 $ S_A <span class="math inline">\(、\)</span> S_B<span class="math inline">\(、\)</span> S_C $ が与えられます。文字列 $S_A $ の $ i $ 文字目 ( $ 1  i  |S_A| $ ) に書かれている文字が、Aさんの持っている中で先頭から $ i $ 番目のカードに書かれている文字です。文字列 $ S_B $、 $ S_C $ についても同様です。</p><p>最終的に誰がこのゲームの勝者となるかを求めてください。</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S_A $ $ S_B $ $ S_C $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>A さんが勝つなら <code>A</code>、B さんが勝つなら <code>B</code>、Cさんが勝つなら <code>C</code> と出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aca</span><br><span class="line">accc</span><br><span class="line">ca</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcb</span><br><span class="line">aacb</span><br><span class="line">bccc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1  S_A  100 $</li><li>$ 1  S_B  100 $</li><li>$ 1  S_C  100 $</li><li>$ S_A <span class="math inline">\(、\)</span> S_B <spanclass="math inline">\(、\)</span> S_C $ に含まれる文字はそれぞれ<code>a</code>、<code>b</code>、<code>c</code> のいずれか</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>ゲームは以下のように進行します。 - Aさんが、持っている中で最初のカード <code>a</code> を捨てる。次は Aさんの番となる。 - A さんが、持っている中で最初のカード <code>c</code>を捨てる。次は C さんの番となる。 - C さんが、持っている中で最初のカード<code>c</code> を捨てる。次は C さんの番となる。 - Cさんが、持っている中で最初のカード <code>a</code> を捨てる。次は Aさんの番となる。 - A さんが、持っている中で最初のカード <code>a</code>を捨てる。次は A さんの番となる。 - Aさんはもう持っているカードがない。よって Aさんの勝利となり、ゲームは終了する。</p></blockquote><h2 id="思路-1">思路</h2><p>其实是到模拟题，感觉有点像链表。</p><p>用<spanclass="math inline">\(p\)</span>代表每个字符串对应的指针，不断按照题意进行移动操作，直到当前牌堆空为止。</p><p>思路参考自[题解 AT2066 <ahref="https://www.luogu.com.cn/article/ssxcmj7y">ABC045B]3人でカードゲームイージー / Card Game for Three (ABC Edit) - 洛谷专栏(luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">3</span>];</span><br><span class="line">ll len[<span class="number">3</span>],p[<span class="number">4</span>],k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)cin&gt;&gt;s[i],len[i]=s[i].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(p[k]&lt;len[k])&#123;</span><br><span class="line">        k=s[k][p[k]++]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span>)(k+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc045c-たくさんの数式">[ABC045C] たくさんの数式</h1><h2 id="题面翻译-2">题面翻译</h2><p><strong>Translated by <ahref="https://www.luogu.org/space/show?uid=77834">aoweiyin</a></strong></p><h2 id="题意翻译">题意翻译</h2><p>有一个仅由字符<code>1</code>到<code>9</code>构成的字符串<spanclass="math inline">\(S(1\leq |S|\leq10)\)</span>，让你在中间添加<code>+</code>，使其变成一个加式。求所有方案的和值（详见样例解释）。</p><h4 id="样例解释1">样例解释1：</h4><p>输入<code>125</code>,输出<code>176</code>.</p><p>有4种：</p><ul><li>125</li><li>1+25=26</li><li>12+5=17</li><li>1+2+5=8</li></ul><h2 id="题目描述-2">题目描述</h2><p><code>1</code> 以上 <code>9</code> 以下の数字のみからなる文字列 $ S $が与えられます。この文字列の中で、あなたはこれら文字と文字の間のうち、いくつかの場所に<code>+</code> を入れることができます。 一つも入れなくてもかまいません。ただし、<code>+</code> が連続してはいけません。</p><p>このようにして出来る全ての文字列を数式とみなし、和を計算することができます。</p><p>ありうる全ての数式の値を計算し、その合計を出力してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>ありうる全ての数式の値の総和を $ 1 $ 行に出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">125</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">176</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999999999</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12656242944</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1|S| $</li><li>$ S $ に含まれる文字は全て <code>1</code> 〜 <code>9</code>の数字</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>考えられる数式としては、<code>125</code>、<code>1+25</code>、<code>12+5</code>、<code>1+2+5</code>の $ 4 $ 通りがあります。それぞれの数式を計算すると、 - $ 125 $ - $1+25=26 $ - $ 12+5=17 $ - $ 1+2+5=8 $ となり、これらの総和は $125+26+17+8=176 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>用DFS就可以解决了，将每一位进行拆分，用数组记录下来。</p><p><span class="math inline">\(+\)</span>的插入有两种情况：</p><p>DFS数字的每一位，可以将这一位与上一个数进行结合，也可以在中间加上一个<spanclass="math inline">\(+\)</span>，具体看代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">15</span>],ans,n;</span><br><span class="line"><span class="comment">//k表示当前是第几位数字，sum表示的是当前的总和，num表示的是当前新开的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll k,ll sum,ll num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果大于n位，则结束</span></span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">        <span class="comment">//加上答案和当前数字</span></span><br><span class="line">        ans+=sum+num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num=num*<span class="number">10</span>+a[k];</span><br><span class="line">    <span class="comment">//对应+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum+num,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//对应没有+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="comment">//分离每一位数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        a[i+<span class="number">1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//开始DFS</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//注意答案要除以2</span></span><br><span class="line">    cout&lt;&lt;ans/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有更好的方法：看看这篇文章</p><p>[题解 AT2067 【<ahref="https://www.luogu.com.cn/article/eevodhvs">ARC061A] たくさんの数式/ Many Formulas】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="abc045d-すぬけ君の塗り絵">[ABC045D] すぬけ君の塗り絵</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个 <span class="math inline">\(H\)</span> 行 <spanclass="math inline">\(W\)</span> 列的矩形，再给定矩形上 <spanclass="math inline">\(N\)</span> 个黑格子的坐标。对于每个 <spanclass="math inline">\(0\le j\le9\)</span> ，求出有多少个 <spanclass="math inline">\(3\times3\)</span>的子矩阵包含有<strong>恰好</strong> <spanclass="math inline">\(j\)</span> 个黑格子。</p><h2 id="题目描述-3">题目描述</h2><p>縦 $ H $ 行、横 $ W $列のマス目からなる盤があります。最初、どのマス目も白く塗られています。</p><p>すぬけ君が、このうち $ N $ マスを黒く塗りつぶしました。$ i $ 回目 ( $1  i  N $ ) に塗りつぶしたのは、 上から $ a_i $ 行目で左から $ b_i $列目のマスでした。</p><p>すぬけ君がマス目を塗りつぶした後の盤の状態について、以下のものの個数を計算してください。</p><ul><li>各整数 $ j $ ( $ 0  j  9 $ )について、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるもの。</li></ul><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ N $ $ a_1 $ $ b_1 $ : $ a_N $ $ b_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>出力は $ 10 $ 行からなる。 $ j+1 $ 行目 ( $ 0  j  9 $ )には、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるものの総数を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 8</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 20</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">2 5</span><br><span class="line">3 10</span><br><span class="line">4 2</span><br><span class="line">4 7</span><br><span class="line">5 9</span><br><span class="line">6 4</span><br><span class="line">6 6</span><br><span class="line">6 7</span><br><span class="line">7 1</span><br><span class="line">7 3</span><br><span class="line">7 7</span><br><span class="line">8 1</span><br><span class="line">8 5</span><br><span class="line">8 10</span><br><span class="line">9 2</span><br><span class="line">10 4</span><br><span class="line">10 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">26</span><br><span class="line">22</span><br><span class="line">10</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000 1000000000 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">999999996000000004</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 3  H  10^9 $</li><li>$ 3  W  10^9 $</li><li>$ 0  N  min(10^5,H×W) $</li><li>$ 1  a_i  H $ $ (1  i  N) $</li><li>$ 1  b_i  W $ $ (1  i  N) $</li><li>$ (a_i, b_i)  (a_j, b_j) $ $ (i  j) $</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>![](https://atcoder.jp/img/arc061/30326702be007759dce81231012a8353.png)この盤に含まれる $ 3×3 $ の正方形は全部で $ 6 $個ありますが、これらのうち $ 2 $ 個の内部には黒いマスが $ 3 $ 個、残りの$ 4 $ 個の内部には黒いマスが $ 4 $ 個含まれています。</p></blockquote><h2 id="思路-3">思路</h2><p>思路参考自<ahref="https://www.luogu.com.cn/article/9kz3t00a">AT2068题解 - 洛谷专栏(luogu.com.cn)</a></p><p>直接开数组模拟肯定<del>喜提</del>TLE,MLE。</p><p>这时候就要想到贡献法，就是每输入一个格子，计算它对包含它的九宫格的贡献（记得判边界）</p><p>所以我们只需维护一个答案数组，每次计算新格子对它的影响就行了</p><p>但是，又有个新问题：如何记录新加进来的格子所在的九宫格原来黑格子的个数呢？</p><p><del>显然</del>我们可以用 map 来解决，用它来维护以<spanclass="math inline">\(x,y\)</span>为中心的九宫格黑格子个数</p><p>完结撒花！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;<span class="comment">//用pair来维护二元组 </span></span><br><span class="line">map&lt;pii,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h,w;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">ans[<span class="number">0</span>]=(h<span class="number">-2</span>)*(w<span class="number">-2</span>);<span class="comment">//初始化，一开始一个黑格子都没有 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">-1</span>;k&lt;=<span class="number">1</span>;k++)<span class="comment">//遍历计算影响 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=a+j,y=b+k;<span class="comment">//九宫格的中心 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;<span class="number">1</span>&amp;&amp;y&lt;w)<span class="comment">//判断边界 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> now;<span class="comment">//now表示现在这个九宫格的黑格子的数量 </span></span><br><span class="line">now=++mp[&#123;x,y&#125;];</span><br><span class="line">                    <span class="comment">//now++,那么now-1肯定就是要--啦</span></span><br><span class="line">ans[now]++,ans[now<span class="number">-1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC043</title>
      <link href="/2024/03/20/ABC043/"/>
      <url>/2024/03/20/ABC043/</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr /><blockquote><h1 id="abc043a-キャンディーとn人の子供イージー">[ABC043A]キャンディーとN人の子供イージー</h1><h2 id="题面翻译">题面翻译</h2><p>幼儿园有N个孩子。教授决定给孩子们糖果，第一个人要一个糖果，第二个人要两个糖果……，第N个人要N个糖果。总共需要多少糖果？</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園には$ N <spanclass="math inline">\(人の子供がいます。えび先生は、子供たちを一列に並べ、一人目にはキャンディーを\)</span>1 <span class="math inline">\(個,二人目には\)</span> 2 <spanclass="math inline">\(個,...,\)</span> N <spanclass="math inline">\(人目には\)</span> N$個あげることにしました。必要なキャンディーの個数の合計は何個でしょう?</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>必要なキャンディーの個数の合計を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦100 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>$ 1+2+3=6 $が答えになります。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>$ 1 <span class="math inline">\(から\)</span> 10 <spanclass="math inline">\(までの和は\)</span> 55 $です。</p><h3 id="sample-explanation-3">Sample Explanation 3</h3><p>子供は一人しかいません。この時答えは$ 1 $になります。</p></blockquote><h2 id="思路">思路</h2><p>等差数列计算即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;(n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc043b-バイナリハックイージー">[ABC043B]バイナリハックイージー</h1><h2 id="题面翻译-1">题面翻译</h2><p><spanclass="math inline">\(Sig\)</span>已经打造了他自己的键盘。为了设计最简单，在这个键盘上面只有<spanclass="math inline">\(3\)</span>个按键：<spanclass="math inline">\(0\)</span>号键，<spanclass="math inline">\(1\)</span>号键和退格键。</p><p>首先，他正在用他的键盘使用纯文本编辑器。这个编辑器总是显示一个字符串（可能为空）。就在编辑开始的时候，这个字符串是空的。当键盘上的任意按键被按下时，字符串将发生以下变化：</p><ul><li><p><span class="math inline">\(0\)</span>号键：一个文字<spanclass="math inline">\(0\)</span>将被插入到字符串的右边。</p></li><li><p><span class="math inline">\(1\)</span>号键：一个文字<spanclass="math inline">\(1\)</span>将被插入到字符串的右边。</p></li><li><p>退格键：如果字符串是空的，什么都不会发生。否则字符串最右边的文字将被删除。</p></li></ul><p><spanclass="math inline">\(Sig\)</span>已经开始了编辑，并且按下了这些按键几次。你将被给予一个他敲击键盘的顺序字符串s。在这个字符串中，文字<spanclass="math inline">\(0\)</span>代表<spanclass="math inline">\(0\)</span>号键，文字<spanclass="math inline">\(1\)</span>代表<spanclass="math inline">\(1\)</span>号键，而字母<spanclass="math inline">\(B\)</span>则代表退格键。请问现在编辑器上会显示什么字符串呢？</p><h2 id="题目描述-1">题目描述</h2><p>しぐはキーボードを製作しました。シンプルさを極限まで追求したこのキーボードには、<code>0</code>キー、<code>1</code> キー、バックスペースキーの $ 3 $つしかキーがありません。</p><p>手始めに、しぐはこのキーボードで簡単なテキストエディタを操作してみることにしました。このエディタには常に一つの文字列が表示されます（文字列が空のこともあります）。エディタを起動した直後では、文字列は空です。キーボードの各キーを押すと、文字列が次のように変化します。</p><ul><li><code>0</code> キー: 文字列の右端に文字 <code>0</code>が挿入される。</li><li><code>1</code> キー: 文字列の右端に文字 <code>1</code>が挿入される。</li><li>バックスペースキー:文字列が空なら、何も起こらない。そうでなければ、文字列の右端の $ 1 $文字が削除される。</li></ul><p>しぐはエディタを起動し、これらのキーを何回か押しました。しぐが押したキーを順番に記録した文字列$ s $ が与えられます。$ s $ の中の文字 <code>0</code> は <code>0</code>キー、文字 <code>1</code> は <code>1</code> キー、文字 <code>B</code>はバックスペースキーを表します。いま、エディタの画面にはどのような文字列が表示されているでしょうか？</p><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>最終的にエディタに表示されている文字列を出力せよ。（「制約」セクションで述べたように、この文字列が空になるような入力は与えられない）</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01B0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0BB1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1 ≦ |s| ≦ 10 $ ($ |s| $ は $ s $ の長さを表す)</li><li>$ s $ は文字 <code>0</code>, <code>1</code>, <code>B</code>のみからなる。</li><li>正解は空文字列ではない。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>,<code>01</code>, <code>0</code>, <code>00</code> と変化します。</p><h3 id="sample-explanation-2-1">Sample Explanation 2</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>,<code>(空文字列)</code>, <code>(空文字列)</code>, <code>1</code>と変化します。</p></blockquote><h2 id="思路-1">思路</h2><p>使用deque模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;q.<span class="built_in">size</span>())q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>||s[i]==<span class="string">&#x27;1&#x27;</span>)q.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="arc059c-いっしょ">[ARC059C] いっしょ</h1><h2 id="题面翻译-2">题面翻译</h2><p>Evi有<span class="math inline">\(n\)</span>个整数，分别为<spanclass="math inline">\(a_1\)</span>，<spanclass="math inline">\(a_2\)</span>，直到<spanclass="math inline">\(a_n\)</span>。</p><p>他的目标是通过改变其中的一些数来使所有数相等。</p><p>对于每个整数，他最多可以变换一次。</p><p>将一个整数<span class="math inline">\(x\)</span>转换为一个整数<spanclass="math inline">\(y\)</span>会花费他<spanclass="math inline">\(\left(x-y\right)^2\)</span>美元。</p><p>即使第<span class="math inline">\(i\)</span>个数<spanclass="math inline">\(a_i\)</span>与第<spanclass="math inline">\(j\)</span>个数<spanclass="math inline">\(a_j\)</span> <spanclass="math inline">\(\left(i!=j\right)\)</span>相等，他仍需为了改变它们中的每个数分别花费代价(请见样例2)。</p><p>请找到能够实现他目标的最小花费。</p><h2 id="题目描述-2">题目描述</h2><p>$ N $ 個の整数 $ a_1,a_2,..,a_N $が与えられます。えび君はこれらを書き換えて全て同じ<strong>整数</strong>にしようとしています。各$a_i (1≦i≦N) <spanclass="math inline">\(は高々一回しか書き換えられません(書き換えなくても良い)。整数\)</span>x <span class="math inline">\(を整数\)</span> y <spanclass="math inline">\(に書き換えるとき、コストが\)</span> (x-y)^2 <spanclass="math inline">\(かかります。仮に\)</span> a_i=a_j (i≠j) <spanclass="math inline">\(だとしても、ひとつ分のコストで同時に書き換えることは出来ません(入出力例\)</span>2 $を参照)。えび君が目的を達成するのに必要なコストの総和の最小値を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ ... $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>えび君が全てを同じ整数に書き換えるのに必要なコストの総和の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-1">样例 #3</h2><h3 id="样例输入-3-1">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-100 -100 -100 -100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦100 $</li><li>$ -100≦a_i≦100 $</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>全てを$ 6 <spanclass="math inline">\(に書き換えると、コストの総和は\)</span>(4-6)<sup>2+(8-6)</sup>2=8 $となり、これが最小です。</p><h3 id="sample-explanation-2-2">Sample Explanation 2</h3><p>全てを$ 2 <span class="math inline">\(に書き換えると\)</span>(1-2)<sup>2+(1-2)</sup>2+(3-2)^2=3 <spanclass="math inline">\(となります。各\)</span> a_i <spanclass="math inline">\(ごとに書き換えるので、二つの\)</span> 1 <spanclass="math inline">\(を一度にコスト\)</span> (1-2)^2$で書き換えられるわけではないことに注意してください。</p><h3 id="sample-explanation-3-1">Sample Explanation 3</h3><p>$ 4 <span class="math inline">\(は書き換えずに、\)</span> 2 <spanclass="math inline">\(と\)</span> 5 <spanclass="math inline">\(を共に\)</span> 4 <spanclass="math inline">\(に書き換えることで\)</span>(2-4)<sup>2+(5-4)</sup>2=5 $が達成できて、これが最小です。</p><h3 id="sample-explanation-4">Sample Explanation 4</h3><p>何も書き換えなくともえび君は目的を達成しています。よってこの場合コストは$0 $です。</p></blockquote><h2 id="思路-2">思路</h2><p>因为范围实在是太小了，所以直接暴力枚举即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> MIN=<span class="number">200</span>,MAX=<span class="number">-200</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        MIN=<span class="built_in">min</span>(a[i],MIN);</span><br><span class="line">        MAX=<span class="built_in">max</span>(a[i],MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=MIN;i&lt;=MAX;i++)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            tmp+=(a[j]-i)*(a[j]-i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(tmp,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里是有规律的，答案只可能是平均值，或者离平均值最近的两个数（也就是是这三者中的其中一个），原理大概是利用均值不等式吧。</p><blockquote><h1 id="arc059d-アンバランス">[ARC059D] アンバランス</h1><h2 id="题面翻译-3">题面翻译</h2><p>给出字符串<span class="math inline">\(s\)</span>,求区间<spanclass="math inline">\([l,r]\)</span>,使得该子串中有一种字母出现的次数严格大于该子串长度的一半.<br />如果没有符合条件的子串,输出两个-1.</p><p>由 <span class="citation" data-cites="Fuko_Ibuki">@Fuko_Ibuki</span>提供翻译</p><h2 id="题目描述-3">题目描述</h2><p>文字列 $ t $ について、$ t $ の長さが $ 2 $ 以上であり、かつ $ t $の中の文字のうち過半数が同じ文字であるとき、$ t $を<em>アンバランス</em>であると呼ぶことにします。例えば、<code>voodoo</code>や <code>melee</code> はアンバランスであり、<code>noon</code> や<code>a</code> はアンバランスではありません。</p><p>小文字のアルファベットからなる文字列 $ s $ が与えられます。$ s $にアンバランスな (連続する)部分文字列が存在するか判定してください。存在する場合は、$ s $の中でそのような部分文字列が存在する位置を一つ示してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ s $にアンバランスな部分文字列が存在しない場合は、<code>-1 -1</code>と出力せよ。</p><p>$ s $にアンバランスな部分文字列が存在する場合は、そのような部分文字列の一つを$ s_a s_{a+1} ... s_{b} $ $ (1 ≦ a &lt; b ≦ |s|) $として、<code>$ a $ $ b $</code>と出力せよ。そのような部分文字列が複数存在する場合は、いずれも正解とみなされる。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">needed</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoder</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2 ≦ |s| ≦ 10^5 $</li><li>$ s $ は小文字のアルファベットのみからなる。</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 2 ≦ |s| ≦ 100 $ を満たすデータセットに正解した場合は、$ 200 $点が与えられる。</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>文字列 $ s_2 s_3 s_4 s_5 $ $ = $ <code>eede</code>はアンバランスな文字列です。他にもアンバランスな部分文字列は存在し、例えば<code>2 6</code> と出力しても正解となります。</p><h3 id="sample-explanation-2-3">Sample Explanation 2</h3><p>文字列 <code>atcoder</code>はアンバランスな部分文字列を持ちません。</p></blockquote><h2 id="思路-3">思路</h2><p>思维题吧，反正我是没什么思维qwq。</p><p>引用这位大佬的文章：[题解 AT2020 【<ahref="https://www.luogu.com.cn/article/55sca778">ARC059B] アンバランス /Unbalanced】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>思路大致如下，与其它题解的差不多：</p><blockquote><p>从字符串的开头搜索到结尾，如果该字符串与后面一个或者后面第二个是相同的，那么该字符与跟它相同的就是一个符合题目要求的子序列。</p></blockquote><blockquote><p>例如<span class="math inline">\(IIIAM\)</span>，虽然<spanclass="math inline">\(IIIAM\)</span>是一个符合要求的子序列，但是<spanclass="math inline">\(II\)</span>也符合，所以直接输出<spanclass="math inline">\(II\)</span>就可以了。</p></blockquote><blockquote><p>再举一个例子：<spanclass="math inline">\(IOIII\)</span>，它本身就是一个符合要求的子序列，但是，最前面的是<spanclass="math inline">\(IOI\)</span>，所以可以得出结论，答案不是两个长度的子序列就是三个长度的子序列。</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i项与第i+1项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断第i项与第i+2项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">2</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC042</title>
      <link href="/2024/03/20/ABC042/"/>
      <url>/2024/03/20/ABC042/</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr /><blockquote><h1 id="abc042a-和風いろはちゃんイージー">[ABC042A]和風いろはちゃんイージー</h1><h2 id="题面翻译">题面翻译</h2><p>给出三个数<span class="math inline">\(A,B,C\)</span>，<spanclass="math inline">\(1≤A,B,C≤10\)</span>，判断<spanclass="math inline">\(A,B,C\)</span>是否能重新排列为<spanclass="math inline">\(575\)</span>。</p><p>翻译由<a href="https://www.luogu.com.cn/user/793625"><spanclass="math inline">\(@PCT2506\)</span></a>提供</p><h2 id="题目描述">题目描述</h2><p>日本の誇る美しいリズムとして、五七五というものがあります。いろはちゃんは五七五が大好きです。</p><p>$ 3 $ つの文節の並びの長さがそれぞれ $ 5,7,5 $となるようにこの順番で並んでいるとき、その $ 3 $つの文節の並びは五七五であると言います。</p><p>並び替えたい $ 3 $ つの文節の長さを表す整数 $ A,B,C $が与えられるので、それらの文節を並び替えて五七五にできるか判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $</p></blockquote><h2 id="输出格式">输出格式</h2><p>文節の並びを五七五にすることができるなら <code>YES</code>、そうでないなら <code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦A,B,C≦10 $</li></ul><h3 id="sample-explanation-1">Sample Explanation 1</h3><p>与えられる文節の長さはそれぞれ $ 5,5,7 $ であり、$ 5,7,5 $となるように文節を並び替えることができます。したがって、文節の並びを五七五にすることは可能といえます。</p></blockquote><h2 id="思路">思路</h2><p>直接统计5和7的个数判断即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cnt5=<span class="number">0</span>,cnt7=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">5</span>)cnt5++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">7</span>)cnt7++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt5==<span class="number">2</span>&amp;&amp;cnt7==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="abc042b-文字列大好きいろはちゃんイージー">[ABC042B]文字列大好きいろはちゃんイージー</h1><h2 id="题面翻译-1">题面翻译</h2><p>题目描述： 有n个长为L的字符串</p><p>要求把他们按照字典序进行排序并在一行内输出</p><p>输入格式： 第一行两个正整数n，L 以下n行每行一个字符串</p><p>输出格式： 仅一行：排序过后的字符串</p><p>（注 ： 这次岛国的题末尾可以不换行）</p><p><del>输入输出不敲了</del></p><p>说明：约定：</p><p>1，1 &lt;= n,L &lt;= 100且n，L 都是正整数</p><p>2，对于第i(1 &lt;= i &lt;= n)个字符串，保证长度为L</p><p>3，所有字符串都由小写字母构成</p><p>感谢@lsy263 提供的翻译</p><h2 id="题目描述-1">题目描述</h2><p>いろはちゃんは 長さ $ L $ の文字列を $ N $ 個持っており、それぞれ $S_1, S_2, ..., S_N $ です。</p><p>それらの文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを求めてください。</p><p>なお、ある文字列 $ s=s_1s_2s_3 <spanclass="math inline">\(...\)</span> s_n $ と $ t=t_1t_2t_3 <spanclass="math inline">\(...\)</span> t_m $について、以下のどちらかを満たすとき、辞書順比較で $ s &lt; t $であるといいます。</p><ul><li>ある整数 $ i(1≦i≦min(n,m)) $ に関して、 $ 1≦j &lt; i $を満たす任意の整数 $ j $ において $ s_j = t_j $ が成立し、かつ $s_i &lt; t_i $ が成立する。</li><li>任意の整数 $ i(1≦i≦min(n,m)) $ に関して $ s_i = t_i $ が成立し、かつ$ n &lt; m $ が成立する。</li></ul><h2 id="输入格式-1">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ L $ $ S_1 $ $ S_2 $ : $ S_N $</p></blockquote><h2 id="输出格式-1">输出格式</h2><p>与えられる文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを出力せよ。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">dxx</span><br><span class="line">axx</span><br><span class="line">cxx</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axxcxxdxx</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><h3 id="制約-1">制約</h3><ul><li>$ 1 ≦ N, L ≦ 100 $</li><li>全ての $ i (1≦i≦N) $ に対し、$ S_i $ の長さは $ L $ に等しい。</li><li>各 $ i $ について, $ S_i $は全て半角英小文字のみから成る文字列である。</li></ul><h3 id="sample-explanation-1-1">Sample Explanation 1</h3><p>与えられた文字列を <code>axx</code>,<code>cxx</code>,<code>dxx</code>という順番に並び替えてから結合することで、辞書順最小を達成できます。</p></blockquote><h2 id="思路-1">思路</h2><p>直接排序即可，其实cmp函数可以不用写的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,l=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到题解区有大佬用了优先队列，可以看看qwq</p><p>[题解 AT1978 【<ahref="https://www.luogu.com.cn/article/8um5juk5">ABC042B]文字列大好きいろはちゃんイージー / Iroha Loves Strings (ABC Edition)】 -洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="arc058c-こだわり者いろはちゃん">[ARC058C]こだわり者いろはちゃん</h1><h2 id="题面翻译-2">题面翻译</h2><p>买家想买一个价格为N的物品，但他又讨厌k个数字，分别为D_1，D_2，……，D_K。问他最少出多少钱，才能在保证买下这个物品的同时使自己出的钱不包括自己讨厌的数字。</p><h2 id="题目描述-2">题目描述</h2><p>いろはちゃんはこだわりもので、嫌いな数字が $ K $ 個あり、それぞれ $D_1, D_2, ..., D_K $ です。</p><p>いろはちゃんはお店でお買い物をしていて、 $ N $円の品物を買おうとしています。 もちろん、この品物は $ N $円以上のお金を支払えば買うことができます。しかし、先ほど述べたようにいろはちゃんは強いこだわりがあるので、自分がお店に支払う金額の$ 10 $進表記にいろはちゃんの嫌いな数字が出現しないような最も少ない金額を支払おうとします。</p><p>いろはちゃんが支払う金額を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ D_1 $ $ D_2 $ … $ D_K $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>いろはちゃんが支払う金額を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 8</span><br><span class="line">1 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><h2 id="样例-2-1">样例 #2</h2><h3 id="样例输入-2-1">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1 ≦ N &lt; 10000 $</li><li>$ 1 ≦ K &lt; 10 $</li><li>$ 0 ≦ D_1 &lt; D_2 &lt; … &lt; D_K≦9 $</li><li>$ {D_1,D_2,...,D_K} ≠ {1,2,3,4,5,6,7,8,9} $</li></ul><h3 id="sample-explanation-1-2">Sample Explanation 1</h3><p>嫌いでない数字は $ 0 $ と $ 2 $ のみです。 $ N=1000 $以上の整数で、桁に $ 0 $ と $ 2 $ のみが含まれる最小の整数は $ 2000 $なのでそれを出力してください。</p></blockquote><h2 id="思路-2">思路</h2><p>这题想复杂了，其实直接枚举即可，从<spanclass="math inline">\(n\)</span>开始向上枚举，并将其进行逐位拆分，判断其中是否出现讨厌的数字即可。注意如果出现0的话，直接退出循环，输出<spanclass="math inline">\(num\)</span>即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//开个桶记录一下讨厌的数字</span></span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num=n;</span><br><span class="line">        <span class="comment">//进行逐位拆分，判断是否出现讨厌的数字</span></span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[num%<span class="number">10</span>])<span class="keyword">break</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为0，说明拆分完毕，满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，说明存在讨厌的数字，继续向上枚举</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="arc058d-いろはちゃんとマス目">[ARC058D]いろはちゃんとマス目</h1><h2 id="题面翻译-3">题面翻译</h2><h3 id="题意">题意</h3><p>有一个 <span class="math inline">\(H\times W\)</span> 的矩阵,现在你正位于左上角的格子, 并且你只能向右移动或向下移动, 不幸的是,矩阵的左下角 <span class="math inline">\(A\times B\)</span>的地方被划为了禁区, 即你不能在此行走,那么现在你有多少种方法从左上角走到右下角的格子呢?</p><h3 id="输入">输入</h3><p>一行四个整数 <span class="math inline">\(H,W,A,B\)</span>.</p><h3 id="输出">输出</h3><p>方案数. 由于方案数很大, 请对 <spanclass="math inline">\(10^9+7\)</span> 取模.</p><p>感谢@凌幽 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>縦 $ H $ マス、横 $ W $ マスのマス目があります。いろはちゃんは、今一番左上のマス目にいます。そして、右か下に1マス移動することを繰り返し、一番右下のマス目へと移動します。ただし、下から $ A $ 個以内、かつ左から $ B $個以内のマス目へは移動することは出来ません。</p><p>移動する方法は何通りあるか求めてください。</p><p>なお、答えは非常に大きくなることがあるので、答えは $ 10^9+7 $で割ったあまりを出力してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ A $ $ B $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>移動する方法の数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 7 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3570</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 99999 99999</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 44444 55555</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">738162020</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1 ≦ H, W ≦ 100,000 $</li><li>$ 1 ≦ A &lt; H $</li><li>$ 1 ≦ B &lt; W $</li></ul><h3 id="sample-explanation-1-3">Sample Explanation 1</h3><p>$ 2×3 $ マスありますが、左下の $ 1 $マスには移動することができません。「右右下」、「右下右」という $ 2 $つの移動の仕方があります。</p><h3 id="sample-explanation-2">Sample Explanation 2</h3><p>移動できないマスが $ 12 $ マスあります。</p></blockquote><h2 id="思路-3">思路</h2><p>其实是一道数学题，思路不难想，大致有两种：</p><p>1、从<span class="math inline">\((1,1)\)</span>到<spanclass="math inline">\((a-1,b)\)</span>，再从<spanclass="math inline">\((a-1,b+1)\)</span>到<spanclass="math inline">\((h,w)\)</span>走，具体怎么算？其实就是高中的组合数学。</p><p>2、先考虑从<span class="math inline">\((1,1)\)</span>到<spanclass="math inline">\((h,w)\)</span>的所有路径数，记作<spanclass="math inline">\(ans1\)</span>，不考虑任何要求。然后我们再考虑可能经过禁区的路径数：这时，问题相当于在前<spanclass="math inline">\(a+b-2\)</span>步中，向下走的步数大于或等于<spanclass="math inline">\(b-2\)</span>步，那我们只需要计算对应的每种情况：当走完向下走完<spanclass="math inline">\(i\)</span>步时，且走完前<spanclass="math inline">\(a+b-2\)</span>步时的所有路径数，并从当前位置开始，重新计算到<spanclass="math inline">\((h,w)\)</span>的所有路径数，注意两者需要一一对应相乘，然后把所有不合法的情况统计起来，记作<spanclass="math inline">\(ans2\)</span>。那么答案就是<spanclass="math inline">\(ans1-ans2\)</span>。</p><p>这里先贴上大佬的代码，自己写的没过qwq，而且大佬们的板子也挺漂亮的，可以整理作为自己的板子。</p><h3 id="思路1">思路1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[MAXN],inv[MAXN];</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==m||m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((fac[n]*inv[m])%mod*inv[n-m]%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x2+y2-x1-y1,x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> h,w,a,b;cin&gt;&gt;h&gt;&gt;w&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//注意记得初始化哦</span></span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算阶乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">        fac[i]=(i*fac[i<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[<span class="number">200000</span>]= <span class="built_in">qpower</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">199999</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        inv[i]=(inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h-a;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,i,b)*<span class="built_in">get</span>(i,b+<span class="number">1</span>,h,w)%mod;</span><br><span class="line">        <span class="comment">//注意这里还需要取模哦</span></span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2">思路2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = b; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * a % mod;</span><br><span class="line">a = (<span class="type">long</span> <span class="type">long</span>)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)jc[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>() - <span class="number">1</span>; m = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">a = n - <span class="built_in">read</span>() + <span class="number">1</span>; b = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">jc[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>; k = n + m + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求阶乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">jc[i] = (<span class="type">long</span> <span class="type">long</span>)jc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[k] = <span class="built_in">qpow</span>(jc[k], mod - <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = k - <span class="number">1</span>; i; --i)</span><br><span class="line">inv[i] = (<span class="type">long</span> <span class="type">long</span>)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有的情况</span></span><br><span class="line">    ans = <span class="built_in">c</span>(n + m, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减去走入禁区的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt;= b; ++i)</span><br><span class="line">ans = (ans - (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">c</span>(a + b, i) * <span class="built_in">c</span>(n + m - a - b, m - i) % mod * now + mod) % mod;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">write</span>(ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧拉定理</title>
      <link href="/2024/03/19/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/19/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧拉定理">拓展欧拉定理</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33):拓展欧拉定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><p>先介绍一下<strong>欧拉定理</strong>：</p><blockquote><p>若正整数<span class="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span>互质，则<spanclass="math inline">\(a^{\varphi(m)}\equiv 1(mod\ m)\)</span>。</p></blockquote><p>这里的<span class="math inline">\(\varphi(m)\)</span>指的是欧拉函数，即小于或等于<spanclass="math inline">\(m\)</span>且与<spanclass="math inline">\(m\)</span>互质的正整数个数。当<spanclass="math inline">\(m\)</span>是质数 <spanclass="math inline">\(p\)</span>时，欧拉定理退化成费马小定理<spanclass="math inline">\(a^{p-1}\equiv1(mod\ p)\)</span> 。</p><p>在算法竞赛中，我们常常会用到它的一个重要的推论：若正整数<spanclass="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span>互质，则</p><p><span class="math inline">\(a^b\equiv a^{b\ mod\ \varphi(m)}(mod\m)\)</span>。</p><p>（这是因为<span class="math inline">\(a^b=a^{\varphi(m)\lfloorb/\varphi(m)\rfloor+b\ mod\  \varphi (m)}\equiv 1·a^{b\ mod\\varphi(m)}(mod\ m)\)</span>）</p><p>利用这个推论，即使<spanclass="math inline">\(b\)</span>比较大，我们也可以轻松地算出<spanclass="math inline">\(a^b\ mod\ m\)</span>的值，但需要满足<spanclass="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span>互质的前提。</p><hr /><p>为了解决<span class="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span>不互质时的问题，我们引入了<strong>拓展欧拉定理</strong>：若<spanclass="math inline">\(b\geq\varphi(m)\)</span>，则：<spanclass="math inline">\(a^b\equiv a^{b\ mod\ \varphi(m)+varphi(m)}\ (mod\m)\ (*)\)</span></p><p>这里仍有前提条件，但影响不大，因为<spanclass="math inline">\(b\leq\varphi(m)\)</span>时直接用快速幂计算即可。</p><p>当<span class="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span><strong>互质</strong>时，由于<spanclass="math inline">\(a^b\equiv a^{b\ mod\ \varphi(m)}·1\equiv a^{b\mod\ \varphi(m)}·a^{\varphi(m)}\ (mod\ m)\ (*)\)</span>式显然成立。</p><p>当<span class="math inline">\(a\)</span>与<spanclass="math inline">\(m\)</span><strong>不互质</strong>时，我们考虑吧<spanclass="math inline">\(m\)</span><strong>质因数分解</strong>成<spanclass="math inline">\({p_1}^{q_1}{p_2}^{q_2}······{p_n}^{q_n}\)</span>，我们只需要证明的每个<spanclass="math inline">\({p_i}^{q_i}\)</span>，都有<spanclass="math inline">\(a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}(mod\{p_i}^{q_i})\)</span>即可。因为如果设<spanclass="math inline">\(m_1、m_2\)</span>互质，且<spanclass="math inline">\(x\equiv y\ (mod\ m_1)\)</span>同时<spanclass="math inline">\(x\equiv y\ (mod\ m_2)\)</span>，则<spanclass="math inline">\(x\equiv y(mod\ m_1m_2)\)</span>必成立（<spanclass="math inline">\(x-y\)</span>既是<spanclass="math inline">\(m_1\)</span>的倍数又是<spanclass="math inline">\(m_2\)</span>的倍数），所以这里可以进行合并。</p><p>现在分类讨论<span class="math inline">\({p_i}^{q_i}\)</span>：</p><p>若<span class="math inline">\(gcd(a,{p_i}^{q_i})=1\)</span>，则：</p><p><span class="math inline">\(a^b\equiv a^{\lfloorb/\varphi(m)\rfloor\varphi(m)+b\ mod\ \varphi(m)}\equiv a^{b\ mod\\varphi(m)}(mod\ {p_i}^{q_i})\)</span></p><p>（注意到<span class="math inline">\(\lfloorb/\varphi(m)\rfloor\varphi(m)\)</span>必然是<spanclass="math inline">\(\varphi({p_i}^{q_i})\)</span>的倍数，因为欧拉函数是<strong>积性函数</strong>）</p><p>若<spanclass="math inline">\(gcd(a,{p_i}^{q_i})\ne1\)</span>，则<spanclass="math inline">\(a\)</span>必然是<spanclass="math inline">\(p\)</span>的倍数。设<spanclass="math inline">\(a=np\)</span>，注意到<spanclass="math inline">\(\varphi({p_i}^{q_i})={p_i}^{q_i-1}(p_i-1)\)</span>，则可以证明<spanclass="math inline">\(\varphi ({p_i}^{q_i}\geq q_i)\)</span>。则：</p><p><span class="math inline">\(b\geq \varphi(m) \geq\varphi({p_i}^{q_i})\geq q_i\)</span></p><p>所以<span class="math inline">\({p_i}^{q_i}\)</span>是<spanclass="math inline">\(a^{b\ mod\ \varphi(m)+\varphi(m)}\)</span>的因数，也是<spanclass="math inline">\(a^b\)</span>的因数，即：</p><p><span class="math inline">\(a\equiv a^{b\ mod\\varphi(m)+\varphi(m)}\equiv 0(mod\ {p_i}^{q_i})\)</span></p><p>综上，<span class="math inline">\(a^b\equiv a^{b\ mod\\varphi(m)+\varphi(m)(mod\ m)}(b\geq\varphi(m))\)</span></p><p>代码实现时可以边读入边取模，另外一定要注意这个式子仅在<spanclass="math inline">\(b\geq \varphi(m)\)</span>时成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> large_enough = <span class="literal">false</span>; <span class="comment">// 判断是否有b &gt;= phi(m)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">(<span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>)</span> <span class="comment">// 快速读入稍加修改即可以边读入边取模，不取模时直接模一个大于数据范围的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= MOD)</span><br><span class="line">        &#123;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">            large_enough = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 求欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> MOD)</span> <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = <span class="number">1LL</span> * ans * a % MOD; <span class="comment">// 注意防止溢出</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">1LL</span> * a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), phiM = <span class="built_in">phi</span>(m), b = <span class="built_in">read</span>(phiM);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qpow</span>(a, b + (large_enough ? phiM : <span class="number">0</span>), m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr /><p>关于欧拉定理的证明我就不放上来了，实在是太难了┭┮﹏┭┮，如果感兴趣的话可以看看原文章：<ahref="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33):拓展欧拉定理 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢卡斯定理</title>
      <link href="/2024/03/18/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/18/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="卢卡斯定理">卢卡斯定理</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25):卢卡斯定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr /><p><strong>卢卡斯定理</strong>是一个与组合数有关的数论定理，在算法竞赛中用于求组合数对某质数的模。</p><p>这里接下来直接介绍卢卡斯定理，原文章的引入和证明不会涉及qwq。如果想看的话可以看看原作者的文章：<ahref="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25):卢卡斯定理 - 知乎 (zhihu.com)</a></p><hr /><p>直接根据定义<spanclass="math inline">\(\binom{m}{n}=\frac{m!}{n!(m-n)!}\)</span>计算，很容易溢出，当然我们可以边乘边除，但有点麻烦。于是我们有另外一种思路，利用递推式：<spanclass="math inline">\(\binom{m}{n}=\binom{m-1}{n-1}+\binom{m-1}{n}\)</span>（这个递推式可以从杨辉三角中得到），这种方法相对不容易溢出，时间复杂度为<spanclass="math inline">\(O(n^2)\)</span>。</p><p>但是，然而，实际上，组合数的增长速度是非常快的，如<spanclass="math inline">\(\binom{300}{150}\)</span>则有89位数字，比宇宙中的原子数还多。所谓递推不容易溢出，那如果结果本身就溢出了，你又怎么办呢？</p><p>所幸算法竞赛中的题目常常会要求将结果对某个质数<spanclass="math inline">\(p\)</span>取模，这样一来，溢出的问题就不用太担心了。我们干脆直接回到最原始的方法：<spanclass="math inline">\(\binom{m}{n}=\frac{m!}{n!(m-n)!}\)</span>。只不过，现在我们要把除法变成求<ahref="https://zhuanlan.zhihu.com/p/100587745">逆元</a>，也即：<spanclass="math inline">\(\binom{m}{n}=m!·inv(n!)·inv[(m-n)!](mod\p)\)</span>。</p><p>模<span class="math inline">\(p\)</span> 意义下阶乘和逆元都可以<spanclass="math inline">\(O(n)\)</span>预处理出来，然后直接<spanclass="math inline">\(O(1)\)</span>查询即可（实际上不预处理逆元直接<spanclass="math inline">\(O(log\n)\)</span>求也绰绰有余）。这基本上是<strong>最常用</strong>的求组合数方法。</p><p>绕了一圈，怎么还没提到卢卡斯定理呢？嗯……一般来说，这个方法够用了。偏偏，有时候，<spanclass="math inline">\(p\)</span>可能比<spanclass="math inline">\(m\)</span>小……</p><p>这下麻烦了。如果<span class="math inline">\(p\)</span>比<spanclass="math inline">\(m\)</span>小，就不能保证<spanclass="math inline">\(n\)</span>和<spanclass="math inline">\(m-n\)</span>的逆元存在了（它们可能是<spanclass="math inline">\(p\)</span>的倍数）。当然还是可以用杨辉三角递推，但<spanclass="math inline">\(O(n^2)\)</span>还是太不理想。于是，本文的主角——卢卡斯定理终于要出场了。</p><hr /><h2 id="卢卡斯定理-1">卢卡斯定理</h2><blockquote><p>对于非负整数<span class="math inline">\(m,n\)</span>和质数<spanclass="math inline">\(p\)</span> ，<spanclass="math inline">\(\binom{m}{n}\equiv \prod_{i=0}^k\binom{m_i}{n_i}(mod\ p)\)</span> ，其中<spanclass="math inline">\(m=m_kp^k+······+m_1p+m_0、n=n_kp^k+······+n_1p+n_0\)</span>是<spanclass="math inline">\(m\)</span>和<spanclass="math inline">\(n\)</span>的 <spanclass="math inline">\(p\)</span>进制展开。</p></blockquote><p>但其实，我们一般使用的是这个可以与之互推的式子：</p><blockquote><p><span class="math inline">\(\binom{m}{n}=\binom{m\ mod\ p}{n\ mod\p}·\binom{\lfloor m/p \rfloor}{\lfloor n/p \rfloor}(mod\ p)\)</span></p></blockquote><p>当<span class="math inline">\(m&lt;n\)</span>时，规定<spanclass="math inline">\(\binom{m}{n}=0\)</span>（待会讲这个定义的含义）。</p><p>就像辗转相除法那样，可以利用这个式子递归求解，递归出口是 <spanclass="math inline">\(n=0\)</span>。其实这篇文章只需要这个好记的公式就够了，你甚至可以马上写出卢卡斯定理的板子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要先预处理出fact[]，即阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m &lt; n ? <span class="number">0</span> : fact[m] * <span class="built_in">inv</span>(fact[n], p) % p * <span class="built_in">inv</span>(fact[m - n], p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lucas</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> % p : <span class="built_in">lucas</span>(m / p, n / p, p) * <span class="built_in">C</span>(m % p, n % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<span class="math inline">\(O(p+log_p\m)\)</span>，前提是：</p><p>阶乘和逆元都采取递推的方式预处理出来，（只需要预处理<spanclass="math inline">\(p\)</span>以内的即可），每次调用<spanclass="math inline">\(C\)</span>函数都是<spanclass="math inline">\(O(1)\)</span>，一共要调用<spanclass="math inline">\(log_p\ m\)</span>次，总的时间复杂度即为<spanclass="math inline">\(O(p+log_p\ m)\)</span>。</p><hr /><p>没想到吧o(*≧▽≦)ツ，全文只需要这个代码模板即可（ε=ε=ε=┏(゜ロ゜;)┛逃）。</p><p>定理的证明maybe以后会补充？？？因为都是数学符号，看得有点烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2024/03/18/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2024/03/18/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数">欧拉函数</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数- 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><h2 id="欧拉函数的引入及性质">欧拉函数的引入及性质</h2><p><strong>欧拉函数<spanclass="math inline">\(\varphi(x)\)</span></strong>是一个非常重要的函数，它定义为小于（或不大于，这里是一样的）<spanclass="math inline">\(x\)</span>但与<spanclass="math inline">\(x\)</span>互质的正整数的数量，例如<spanclass="math inline">\(\varphi(12)=4\)</span>，有1、5、7、11与之互质。特别地，规定<spanclass="math inline">\(\varphi (1)=1\)</span>。</p><p>主要性质如下：</p><blockquote><p>若<span class="math inline">\(p\)</span>是质数，则<spanclass="math inline">\(\varphi (p^n)=p^{n-1}(p-1)\)</span></p><p>若<span class="math inline">\(a|x\)</span>，则<spanclass="math inline">\(\varphi (ax)=a\varphi (x)\)</span></p><p>若<span class="math inline">\(a、b\)</span>互质，则<spanclass="math inline">\(\varphi(a)\varphi(b)=\varphi(ab)\)</span></p><p>（这里跳过证明，想要看证明的可以看看原文章：<ahref="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数- 知乎 (zhihu.com)</a>）（也许我自己以后会补充？）</p></blockquote><p>注意：符合第三个性质的函数称为积性函数。</p><hr /><p>我们把正整数<strong>质因数分解</strong>：</p><p><spanclass="math inline">\(x={p_1}^{k_1}{p_2}^{k_2}······{p_n}^{k_n}\)</span>。</p><p>所有<spanclass="math inline">\({p_i}^{k_i}\)</span>两两互质，由欧拉函数的性质得：</p><p><span class="math inline">\(\varphi(x)={p_1}^{k_1-1}(p_1-1){p_2}^{k_2-1}(p_2-1)······{p_n}^{k_n-1}(p_n-1)\)</span>.</p><p>即：</p><p><span class="math inline">\(\varphi(x)=x·\frac{p_1-1}{p_1}·\frac{p_2-1}{p_2}······\frac{p_n-1}{p_n}\)</span></p><p>我们可以利用这个方法以最坏的时间复杂度<spanclass="math inline">\(O(\sqrt{n})\)</span>内求出指定正整数的欧拉函数值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除再乘防止溢出</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) <span class="comment">// 每个质因数只处理一次，可以把已经找到的质因数除干净</span></span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>); <span class="comment">// 最后剩下的部分也是原来的n的质因数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>我们还可以把求欧拉函数与<strong>筛法</strong>结合起来，例如用类似埃氏筛的方法，求1~n的欧拉函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> phi[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        phi[i] = i; <span class="comment">// 除1外没有数的欧拉函数是本身，所以如果phi[i] = i则说明未被筛到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == i) <span class="comment">// 未被筛到</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 所有含有该因子的数都进行一次操作</span></span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以保证范围内每个数都能被它的所有质因数筛且只筛一次。注意一个正整数<spanclass="math inline">\(x\)</span>是质数的充要条件是</p><p><span class="math inline">\(\varphi(x)=x-1\)</span>，所以我们其实顺便求出了所有的素数。这个方法的时间复杂度是<spanclass="math inline">\(O(nloglog\ n)\)</span>，比一个一个求的<spanclass="math inline">\(O(n\sqrt{n})\)</span>更好。</p><p>当然也可以在欧拉筛途中顺便求出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i), phi[i] = i - <span class="number">1</span>; <span class="comment">// 性质一，指数为1的情形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[p * i] = phi[i] * p; <span class="comment">// 性质二</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                phi[p * i] = phi[p] * phi[i]; <span class="comment">// 这时肯定互质，用性质三</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有进行质因数分解，综合运用了开头提到的三种性质，时间复杂度为<spanclass="math inline">\(O(n)\)</span> 。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
      <url>/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>还没写好，可能这几天补好</p><hr /><h1 id="二次剩余">二次剩余</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/166123245">算法学习笔记(41): 二次剩余- 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><p><strong>二次剩余</strong>，常被称为模意义开根，是求满足<spanclass="math inline">\(n\equiv x^2(mod\ m)\)</span>的<spanclass="math inline">\(x\)</span>的值。</p><p>首先需要注意，并不是对每个<spanclass="math inline">\(n\)</span>而言上面的方程都有解。如果上面的方程有非零解，我们称<spanclass="math inline">\(n\)</span>是模<spanclass="math inline">\(m\)</span>的<strong>二次剩余</strong>。如果方程无解，则称<spanclass="math inline">\(n\)</span>是模<spanclass="math inline">\(m\)</span>的<strong>二次非剩余</strong>。</p><p>为了方便讨论，我们引入<strong>勒让德符号</strong>：</p>$ ()={<span class="math display">\[\begin{aligned}1     &amp;  \, 如果a是p的二次剩余\\0     &amp;  \, 如果a\ mod\ p=0\\{-1}  &amp;  \, 如果a是p的二次非剩余\end{aligned}\]</span><p>. $</p><p>接下来讨论如何求解二次剩余，一般只考虑奇素数的情况。</p><hr /><h2 id="欧拉准则">欧拉准则</h2><p>当模数是奇素数<span class="math inline">\(p\)</span>且与<spanclass="math inline">\(a\)</span>互质时，由费马小定理，<spanclass="math inline">\(a^{p-1}\equiv1\ (mod\ p)\)</span>，设<spanclass="math inline">\(p=2q+1\)</span>，</p><p>则有<span class="math inline">\(a^{2q}\equiv 1\ (mod\p)\)</span>，于是<span class="math inline">\((a^q-1)(a^q+1)\equiv 0\(mod\ p)\)</span>，故<span class="math inline">\(a^q\equiv \pm1 (mod\p)\)</span>，即<span class="math inline">\(a^{\frac{p-1}{2}}\equiv\pm1\(mod\ p)\)</span>。</p><p>所以只要<span class="math inline">\(a、p\)</span>互质，<spanclass="math inline">\(a^{\frac{p-1}{2}}\)</span>在模<spanclass="math inline">\(p\)</span>意义下就只可能等于<spanclass="math inline">\(1\)</span>或<spanclass="math inline">\({-1}\)</span>。到底是<spanclass="math inline">\(1\)</span>还是<spanclass="math inline">\({-1}\)</span>，这与二次剩余紧密相关，实际上，有以下公式：</p><blockquote><p><span class="math inline">\((\frac{a}{p})\equiva^{\frac{p-1}{2}}(mod\ p)\)</span></p></blockquote><p>以上公式被称为<strong>欧拉准则</strong>，我们只需要计算<spanclass="math inline">\(a^{\frac{p-1}{2}}\)</span>即可判断<spanclass="math inline">\(a\)</span>是否为<spanclass="math inline">\(p\)</span>的二次剩余。</p><hr /><p>这里实际上有一个<strong>证明</strong>：“<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余”是"<spanclass="math inline">\(a^{\frac{p-1}{2}}\equiv 1(mod\p)\)</span>"的充要条件。</p><p>但是目前没时间写，可能过两天再写。咕咕咕</p><hr /><p>由此可以有一个推论：当<spanclass="math inline">\(\frac{p-1}{2}\)</span>是奇数时，如果<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余，则<spanclass="math inline">\({-a}\)</span>是mo<spanclass="math inline">\(p\)</span>的二次非剩余。相反，当<spanclass="math inline">\(\frac{p-1}{2}\)</span>是偶数时，如果<spanclass="math inline">\(a\)</span>是模<spanclass="math inline">\(p\)</span>的二次剩余，则<spanclass="math inline">\({-a}\)</span>也是模<spanclass="math inline">\(p\)</span>的二次剩余。</p><hr />]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉筛">欧拉筛</h1><p>文章部分内容转载自<ahref="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 -知乎 (zhihu.com)</a>、<ahref="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏(luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr /><p>不想再写一遍原理了qwq（如果忘记原理就去看看大佬们的详细证明吧，感觉注释也说得很清楚了@w@）。</p><p><a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17):素数筛 - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 -洛谷专栏 (luogu.com.cn)</a></p><p>所以我就直接贴上欧拉筛的模板了。</p><hr /><blockquote><h1 id="模板线性筛素数">【模板】线性筛素数</h1><h2 id="题目背景">题目背景</h2><p>本题已更新，从判断素数改为了查询第 <spanclass="math inline">\(k\)</span> 小的素数<br />提示：如果你使用 <code>cin</code> 来读入，建议使用<code>std::ios::sync_with_stdio(0)</code> 来加速。</p><h2 id="题目描述">题目描述</h2><p>如题，给定一个范围 <span class="math inline">\(n\)</span>，有 <spanclass="math inline">\(q\)</span> 个询问，每次输出第 <spanclass="math inline">\(k\)</span> 小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,q\)</span>，分别表示查询的范围和查询的个数。</p><p>接下来 <span class="math inline">\(q\)</span> 行每行一个正整数 <spanclass="math inline">\(k\)</span>，表示查询第 <spanclass="math inline">\(k\)</span> 小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出 <span class="math inline">\(q\)</span>行，每行一个正整数表示答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【数据范围】<br />对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n = 10^8\)</span>，<span class="math inline">\(1\le q \le 10^6\)</span>，保证查询的素数不大于 <spanclass="math inline">\(n\)</span>。</p><p>Data by NaCly_Fish.</p></blockquote><p><strong>学委大佬的代码</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> isPrime[N];<span class="comment">//isPrime[i]==1表示：i是质数</span></span><br><span class="line"><span class="type">int</span> Prime[N], cnt = <span class="number">0</span>;<span class="comment">//Prime存质数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="number">1</span>, <span class="built_in">sizeof</span>(isPrime));</span><br><span class="line"><span class="comment">//以“每个数都是素数”为初始状态，逐个删去</span></span><br><span class="line">isPrime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//1不是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;<span class="comment">//没被筛掉</span></span><br><span class="line">Prime[++cnt] = i;<span class="comment">//i成为下一个素数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span></span><br><span class="line"><span class="comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span></span><br><span class="line">isPrime[i * Prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="built_in">getPrime</span>(n);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; Prime[k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pecco</strong>大佬的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isnp[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 质数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>两者的写法其实很相似了，如果忘记了原理，可以先看看<strong>学委大佬</strong>的，要写题的话，推荐用<strong>pecco</strong>大佬的板子。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="中国剩余定理">中国剩余定理</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/103394468">算法学习笔记(10):中国剩余定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><p><strong>中国剩余定理</strong>，也叫<strong>孙子定理</strong>，之所以叫这个名字，是因为《孙子算经》中有这样一个问题：</p><blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><p>实际上就是求解下面的<strong>同余方程组</strong>： <spanclass="math display">\[\left\{\begin{aligned}x &amp; \equiv b_1 &amp; (mod\ a_1)\\x &amp; \equiv b_2 &amp; (mod\ a_2)\\x &amp; \equiv b_n &amp; (mod\ a_n)\end{aligned}\right.\]</span> 这个方程组有解的一个<strong>充分条件</strong>是：<spanclass="math inline">\(a_1、a_2······a_n\)</span><strong>两两互质</strong>，可以使用构造法得到下面方程的通解，一下面这道模板题为例：</p><p>（<strong>洛谷P1495 曹冲养猪</strong>）</p><blockquote><p><strong>题目描述</strong>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有16头母猪，如果建了3个猪圈，剩下1头猪就没有地方安家了。如果建造了5个猪圈，但是仍然有1头猪没有地方去，然后如果建造了7个猪圈，还有2头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？<strong>输入格式</strong> 第一行包含一个整数<spanclass="math inline">\(n\ (n\leq10)——\)</span>建立猪圈的次数，解下来n行，每行两个整数<spanclass="math inline">\(a_i,b_i\ (b_i\leq a_i\leq1000)\)</span>表示建立了<spanclass="math inline">\(a_i\)</span>个猪圈，有<spanclass="math inline">\(b_i\)</span>头猪没有去处。你可以假定<spanclass="math inline">\(a_i,a_j\)</span>互质. <strong>输出格式</strong>输出包含一个正整数，即为曹冲至少养母猪的数目。</p></blockquote><p>(本质上就是给“物不知数”套了个背景)。</p><hr /><p>我们从“物不知数”这个具体问题出发。<strong>（接下来一大波数学公式，请做好心理再看）</strong></p><p>要想直接找到一个<span class="math inline">\(n\)</span>使得方程组<spanclass="math inline">\(\left\{\begin{aligned}x &amp; \equiv 2 &amp;(mod\ 3)\\y &amp; \equiv 3 &amp;(mod\ 5)\\z &amp; \equiv 2 &amp;(mod\ 7)\end{aligned}\right.\)</span> 成立时不容易的，但是要找到</p><p><span class="math inline">\(n_1,n_2,n_3\)</span>使得<spanclass="math inline">\(\left\{\begin{aligned}n_1 &amp; \equiv 2&amp; (mod\ 3) \\n_2 &amp; \equiv 3&amp; (mod\ 5) \\n_3 &amp; \equiv 2&amp; (mod\ 7)\end{aligned}\right.\)</span>是相对容易的。</p><p>直接令<spanclass="math inline">\(x=n_1+n_2+n_3\)</span>可以吗？恐怕未必。在什么情况下<spanclass="math inline">\(n_1\equiv 2(mod\ 3)\)</span>可以推出<spanclass="math inline">\(n_1+n_2\equiv2(mod\3)\)</span>呢？显然，那只有当<spanclass="math inline">\(n_2\)</span>是3的倍数时成立。同理，要想让<spanclass="math inline">\(n_1+n_2+n_3\)</span>也符合前式，也需要<spanclass="math inline">\(n_2\)</span>和<spanclass="math inline">\(n_3\)</span>都是3的倍数。</p><p>这样推导下来，<spanclass="math inline">\(x=n_1+n_2+n_3\)</span>符合方程组的条件是<spanclass="math inline">\(n_1\)</span>是35的倍数，<spanclass="math inline">\(n_2\)</span>是21的倍数，<spanclass="math inline">\(n_3\)</span>是15的倍数。也就是说，现在我们需要求三个同余方程：</p><p><span class="math inline">\(\left\{\begin{aligned}35m_1 &amp; \equiv 2 &amp; (mod\ 3) \\21m_2 &amp; \equiv 3 &amp; (mod\ 5) \\15m_3 &amp; \equiv 2 &amp; (mod\ 7)\end{aligned}\right.\)</span></p><p>注意到模数两两互质，则<spanclass="math inline">\(gcd(35,3)=gcd(21,5)=gcd(15,7)=1\)</span>，所以我们可以用拓展欧几里得的方法解（我愿称之为最妙的一步<strong>qwq</strong>，这里用的是求逆元的方法）：</p>$ {<span class="math display">\[\begin{aligned}35w_1 &amp; \equiv 1&amp; (mod\ 3) \\21w_2 &amp; \equiv 1&amp; (mod\ 5)\\15w_3 &amp; \equiv 1&amp; (mod\ 7)\end{aligned}\]</span><p>. $</p><p>解得<spanclass="math inline">\(w_1=2,w_2=1,w_3=1\)</span>，然后可得：<spanclass="math inline">\(\left\{\begin{aligned}m_1 &amp; =2w_1=4 \\m_2 &amp; =3w_2=3 \\m_3 &amp; =2w_3=2\end{aligned}\right.\)</span></p><p>于是：<span class="math inline">\(\left\{\begin{aligned}n_1 &amp; = 35m_1=140 \\n_2 &amp; = 21m_2=63 \\n_3 &amp; = 15m_3=30\end{aligned}\right.\)</span>。</p><p>三者相加，即得一<strong>特解233</strong>（这里的233不是网络意义下的233，但我算出来不禁233了）。所有与233在<strong>模</strong>105<strong>意义下同余</strong>的数都是这个方程组的解，要求<strong>最小正数解</strong>只需对105取模即可，这里得出来是<strong>23</strong>。</p><hr /><p>接下来将这个过程一般化（<strong>个人感觉严重劝退qwq</strong>）。设<spanclass="math inline">\(p=\prod_{i=1}^{n}a_i\)</span>（即所有模数的乘积），并设<spanclass="math inline">\(r_i=\frac{p}{a_i}\)</span>（在“物不知数”中即为35、21和15）。于是<spanclass="math inline">\(w_i={inv(r_i)|}_{a_i}\)</span>（表示<spanclass="math inline">\(r_i\)</span>在模<spanclass="math inline">\(a_i\)</span>意义下的逆元），<spanclass="math inline">\(m_i=b_iw_i\)</span>，而<spanclass="math inline">\(n_i=r_im_i\)</span>，所有<spanclass="math inline">\(n_i\)</span>相加得到<spanclass="math inline">\(x\)</span>。</p><p>以上这些综合起来就是：</p><p><span class="math inline">\(x\equiv\sum_{i=1}^nb_ir_i{[r_i]^{-1}|}_{a_i}\ (mod\ p)\)</span></p><p>下面贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span>  <span class="comment">// a是模数数组，b是余数数组，n是数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;   <span class="comment">// 逆元的求法参见上篇文章，或者下面有完整代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的是符合方程组的最小正整数解，一般题目要求的就是这个。</p><p>再附上曹冲养猪的完整AC代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, a[<span class="number">10</span>], b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, a + i, b + i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">CRT</span>(a, b, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>自己的实现（其实就是照抄作者的qwq）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(ll a[],ll b[],ll n)</span></span>&#123;</span><br><span class="line">    ll p=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p*=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll r=p/a[i];</span><br><span class="line">        x+=(b[i]*r*<span class="built_in">inv</span>(r,a[i]))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">CRT</span>(a,b,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元</title>
      <link href="/2024/03/18/%E9%80%86%E5%85%83/"/>
      <url>/2024/03/18/%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="逆元">逆元</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/100587745">算法学习笔记(9)：逆元 -知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr /><h2 id="逆元的引入">逆元的引入</h2><p>在数论中，如果<span class="math inline">\(ab\equiv1(mod\p)\)</span>，我们就说<span class="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>在模<spanclass="math inline">\(p\)</span>意义下互为乘法逆元，记作<spanclass="math inline">\(a=inv(b)\)</span>。</p><p>为什么要引入逆元？常常会遇到一些题目要求结果对一个大质数<spanclass="math inline">\(p\)</span>取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。<strong>加减法</strong>和<strong>乘法</strong>对取模运算都是<strong>封闭</strong>的，所以你可以处处取模来避免溢出。</p><p><img src="https://img2.imgtp.com/2024/03/18/RqrxFVdZ.png" /></p><p>但是遇到除法时，就麻烦了：</p><p><img src="https://img2.imgtp.com/2024/03/18/AdajgadB.png" /></p><p>为了解决模意义下的除法问题，我们引入了逆元。<spanclass="math inline">\(inv(a)\)</span>其实可以看作是模<spanclass="math inline">\(p\)</span>意义下的<spanclass="math inline">\(\frac{1}{a}\)</span>，那么在模<spanclass="math inline">\(p\)</span>意义下，<spanclass="math inline">\(\frac{a}{b}\)</span>就可以变成<spanclass="math inline">\(a*inv(b)(mod\ p)\)</span>。</p><p>实际上，在模10意义下的<spanclass="math inline">\(inv(3)=7\)</span>，所以上面的式子可以这样计算：</p><p><img src="https://img2.imgtp.com/2024/03/18/mah9Ky6H.png" /></p><p>这里介绍三种计算逆元的方法：<strong>拓展欧几里得</strong>，<strong>费马小定理</strong>，<strong>线性递推</strong>。</p><hr /><h2 id="拓展欧几里得">拓展欧几里得</h2><p>最常用的求逆元方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span><span class="comment">// 拓欧</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exgcd</span>(a, p, x, y) != <span class="number">1</span>) <span class="comment">// 无解的情形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="费马小定理">费马小定理</h2><p>费马小定理叙述如下：</p><blockquote><p>若<span class="math inline">\(p\)</span>是质数，且<spanclass="math inline">\(gcd(a,p)=1\)</span>，则有<spanclass="math inline">\(a^{p-1}\equiv1(mod\ p)\)</span></p></blockquote><p>从逆元的定义可以推导：<span class="math inline">\(a*inv(a)\equiva^{p-1}(mod\ p)\)</span>，于是有<span class="math inline">\(inv(a)\equiva^{p-2}(mod\ p)\)</span>。</p><p>于是对<spanclass="math inline">\(a^{p-2}\)</span>算一下<strong>快速幂</strong>即可。注意：这个方法的前提是：<spanclass="math inline">\(p\)</span>是质数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll p)</span><span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans % p * a % p;</span><br><span class="line">        a = a % p * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h2 id="线性递推">线性递推</h2><p>以上两种方法都是常用的求逆元方法，但是，洛谷上的这道毒瘤模板题，必须要用特殊的方法：</p><p>（<strong>洛谷P3811 【模板】乘法逆元</strong>）</p><blockquote><p><strong>题目背景</strong> 这是一道模板题 <strong>题目描述</strong>给定<span class="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span> ，求 <span class="math inline">\(1 \simn\)</span>中所有整数在模<spanclass="math inline">\(p\)</span>意义下的乘法逆元。<strong>输入格式</strong> 一行两个正整数<spanclass="math inline">\(n,p\)</span>。 <strong>输出格式</strong> 输出<spanclass="math inline">\(n\)</span>行，第<spanclass="math inline">\(i\)</span>行表示<spanclass="math inline">\(i\)</span>在模<spanclass="math inline">\(p\)</span>下的乘法逆元。</p></blockquote><p>因为这道题要求一系列的乘法逆元，而且数据范围是$1n*10^{6} $，常规方法是行不通的。这里介绍逆元的<strong>线性递推</strong>求法（需保证<spanclass="math inline">\(p\)</span>是质数）。</p><p>设<span class="math inline">\(p=aq+r\)</span>，即<spanclass="math inline">\(q=\lfloor p/a \rfloor，r=p\ mod\ a\)</span>。</p><p>在模<span class="math inline">\(p\)</span>意义下，有<spanclass="math inline">\(aq+r\equiv 0\ (mod\ p)\)</span>。</p><p>整理可得：<span class="math inline">\(a=-r*inv(q)\ (mod\p)\)</span>。</p><p>那么<span class="math inline">\(inv(a)=-q*inv(r)\ (mod\p)\)</span>。</p><p>即：<span class="math inline">\(inv(a)=-\lfloor p/a \rfloor *inv(p\mod\ a)\ (mod\ p)\)</span>。</p><p>其实和拓展欧几里得还是有不少相似之处的。我们可以用<strong>记忆化搜索</strong>的方法，减少多次查询的时间复杂度（空间换时间）。（<strong>递推</strong>亦可，其实就这题而言递推更好）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多次对不同的p使用需要清空Inv数组</span></span><br><span class="line">ll Inv[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mod</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Inv[a])</span><br><span class="line">        <span class="keyword">return</span> Inv[a];</span><br><span class="line">    Inv[a] = <span class="built_in">mod</span>(-p / a * <span class="built_in">inv</span>(p % a, p), p);</span><br><span class="line">    <span class="keyword">return</span> Inv[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;inv[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得</title>
      <link href="/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧几里得">拓展欧几里得</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a></p><p>如有侵权，请联系作者删除</p><hr /><h2 id="辗转相除法">辗转相除法</h2><p>在介绍拓展欧几里得算法之前，先看看<strong>欧几里得算法</strong>（又称<strong>辗转相除法</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除法，求两个数的最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理这里省略，详情请参考原作者的文章：<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a></p><hr /><h2 id="拓展欧几里得-1">拓展欧几里得</h2><p>拓展欧几里得是可以在<strong>辗转相除</strong>的途中求出不定方程<spanclass="math inline">\(ax+by=c\)</span>的一组解</p><p><img src="https://img2.imgtp.com/2024/03/17/US3JbpKq.png" /></p><p>可以发现：倒数第二行的<spanclass="math inline">\(3+6*3=21\)</span>，可以改写成<spanclass="math inline">\(3=6*(-3)+21\)</span>，也就是说：3可以被表示为6和21的线性组合。</p><p>倒数第三行，<spanclass="math inline">\(6+21*1=27\)</span>，说明6可以被表示为21和27的线性组合，那么3也可以被表示为21和27的线性组合。具体地：</p><p><spanclass="math inline">\(3=6*(-3)+21=(27-21)*(-3)+21=27*(-3)+21*4\)</span></p><p>这样一路推导下来，可以得到3表示为75和48的线性组合。那么<spanclass="math inline">\(75x+48y=3\)</span>就能找到解了。</p><p>由上文可以得到求解<spanclass="math inline">\(ax+by=gcd(a,b)\)</span>的一种方法。但如果<spanclass="math inline">\(c\)</span>是其他数呢？</p><p>实际上，<span class="math inline">\(c\)</span>必须是 <spanclass="math inline">\(gcd(a,b)\)</span>的倍数，因为我们由方程 <spanclass="math inline">\(ax+by=c\)</span> 两边除以 <spanclass="math inline">\(gcd(a,b)\)</span> 可得 <spanclass="math inline">\(\frac{a}{gcd(a,b)}x+\frac{b}{gcd(a,b)}y=\frac{c}{gcd(a,b)}\)</span>，方程左边当然是整数，那么方程右边也必须是整数。所以<spanclass="math inline">\(c\)</span>是<spanclass="math inline">\(gcd(a,b)\)</span>的倍数。</p><p>这其实上是一个数论定理：</p><blockquote><p><strong>裴蜀定理</strong></p><p>设<span class="math inline">\(a、b\)</span>为正整数，则关于<spanclass="math inline">\(x、y\)</span>的方程<spanclass="math inline">\(ax+by=c\)</span>有整数解当且仅当<spanclass="math inline">\(c\)</span>是<spanclass="math inline">\(gcd(a,b)\)</span>的倍数</p></blockquote><p><img src="https://img2.imgtp.com/2024/03/17/ohJDTt3U.png" /></p><p>可以发现，通过求<span class="math inline">\(bx_0+(a\ mod\b)y_0=c\)</span>的解，可以得出<spanclass="math inline">\(ax+by=c\)</span>的解。</p><p>前者等价于<span class="math inline">\(bx_0+(a-\lfloor a/b\rfloor)y_0=c\)</span>，也就是<spanclass="math inline">\(ay_0+b(x_0-\lfloor a/b \rfloory_0)=c\)</span>，可以对比两者的系数，可以让： <spanclass="math display">\[\left\{\begin{aligned}x &amp; =  y_0 \\y &amp; =  x_0-\lfloor a/b \rfloor y_0 \\\end{aligned}\right.\]</span> 当<spanclass="math inline">\(b==0\)</span>时递归结束即可，简化版如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">//这里交换了x和y</span></span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（这里其实有个普通版的，但是我偷懒了，直接搬了简化版qwq，若谷想看原版的，或者进一步探究原理的可以看看原文章：<ahref="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得- 知乎 (zhihu.com)</a>）</strong></p><hr /><p>这样我们求出来的<spanclass="math inline">\(ax+by=gcd(a,b)\)</span>的一组特解，那么通解是什么？</p><p>设除了已经求出来的<spanclass="math inline">\(x,y\)</span>之外还有一组解<spanclass="math inline">\(x_1=x+\delta\)</span>和<spanclass="math inline">\(y_1\)</span>，那么由<spanclass="math inline">\(ax_1-a\delta+by==gcd(a,b)\)</span>，可以得到<spanclass="math inline">\(ax_1+b(y-\frac{a\delta}{b})=gcd(a,b)\)</span>，可以得到：</p><p><span class="math inline">\(y_1=y-\frac{a\delta}{b}\)</span>。</p><p>注意：我们还需要保证<spanclass="math inline">\(\delta\)</span>和<spanclass="math inline">\(\frac{a\delta}{b}\)</span>都是整数，后者等于<spanclass="math inline">\(\frac{a&#39;}{b&#39;}\delta\)</span>，其中： <spanclass="math display">\[\left\{\begin{aligned}a&#39; &amp; =  \frac{a}{gcd(a,b)} \\b&#39; &amp; =  \frac{b}{gcd(a,b)} \\\end{aligned}\right.\]</span> 由于<spanclass="math inline">\(a&#39;、b&#39;\)</span>互质，<spanclass="math inline">\(\delta\)</span>应当等于<spanclass="math inline">\(kb&#39;\)</span>（<spanclass="math inline">\(k\)</span>是整数），即： <spanclass="math display">\[\left\{\begin{aligned}x_k &amp; =  x+k*\frac{b}{gcd(a,b)} \\y_k &amp; =  y-k*\frac{a}{gcd(a,b)} \\\end{aligned}\right.\]</span> 这就是该不定方程的解。一般题目求的符合某些条件的解。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>文章转载自<ahref="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 -知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr /><p><strong>快速幂</strong>（<strong>Exponentiation bysquaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以<spanclass="math inline">\(O(log_2n)\)</span>的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：</strong>最朴素的想法，7 * 7=49，49 * 7=343，...一步一步算，共进行了<strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：</strong>先算7的5次方，即7 * 7 * 7 * 7 *7，再算它的平方，共进行了<strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：</strong>先算7 * 7得49，则7的5次方为49 * 49 *7，再算它的平方，共进行了<strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在<span class="math inline">\(O(log_2n)\)</span>时间内计算出幂的算法，也就是快速幂。</p><hr /><h2 id="递归快速幂">递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：<span class="math display">\[a^n=\left\{\begin{aligned}a^n*a                               &amp;      &amp;if\ n\ is\ odd\\a^{\frac{n}{2}}*a^{\frac{n}{2}}     &amp;      &amp;if\ n\ is\ even\but\ not\ 0 \\1                                   &amp;      &amp;if\ n\ is\0               \end{aligned} \right.\]</span></p><p>对应的递归形式写法如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这个temp不能省略，如果写成了qpow(a,n/2) *qpow(a,n/2)，那会计算两次<spanclass="math inline">\(a^\frac{n}{2}\)</span>，时间复杂度会退化成<spanclass="math inline">\(O(n)\)</span></p><p>经常会遇到取模类的问题，这里我们的应对策略是在利用快速幂进行计算时也需要取模，此时应当注意：<strong>原则是步步取模</strong>，如果mod较大，还需开<strong>longlong</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归快速幂的缺点是：产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong></p><hr /><h2 id="非递归快速幂">非递归快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以<span class="math inline">\(7^{10}\)</span>为例，转换为计算<spanclass="math inline">\(7^{1010_{(2)}}\)</span>，我们可以把它拆成<spanclass="math inline">\(7^{1000_{(2)}}\)</span>和<spanclass="math inline">\(7^{10_{(2)}}\)</span>，由此类推，任何数都可以拆分成若干个<spanclass="math inline">\(a^{(100···)_{(2)}}\)</span>的形式相乘，恰好对应的就是<spanclass="math inline">\(a^1\)</span>、<spanclass="math inline">\(a^2\)</span>、<spanclass="math inline">\(a^4\)</span>······来计算，只需要<strong>不断地对底数平方即可算出它们</strong></p><p><img src="https://img2.imgtp.com/2024/03/17/HhfSbxa6.png" /></p><p>可以结合代码进行理解（如果实在看不懂只能看看原作者的文章了qwq）</p><hr /><h2 id="快速幂的拓展">快速幂的拓展</h2><p>快速幂算法的应用范围实际上不止于此：在计算<spanclass="math inline">\(a^{\frac{n}{2}}\)</span>时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的非递归快速幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">qpow</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a; <span class="comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>此时的时间复杂度不再是<span class="math inline">\(O(log_2\n)\)</span>，此时还与底数的乘法的时间复杂度有关。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法（第一弹）</title>
      <link href="/2024/03/17/Latex%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/17/Latex%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="latex-语法">Latex 语法</h1><p>先简单整理下Latex的语法，以后会经常用到 <ahref="https://blog.csdn.net/ccnice99/article/details/127507471?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Latex语法&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127507471.142%5Ev99%5Epc_search_result_base6&amp;spm=1018.2226.3001.4449">【自用】【持续更新】LaTeX常用基础语法大全_latex语法-CSDN博客</a></p><h2 id="基础语法">基础语法</h2><h3 id="段落">段落</h3><h4 id="居中">居中</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">要居中的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure><h4 id="排序列表">排序列表</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 原始模板</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 自定义排序列表的编号形式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(1)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a.]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 实心圆点列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="comment">% 短横杠列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span>[-] 第一小题</span><br><span class="line"><span class="keyword">\item</span>[-] 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本变量">文本、变量</h3><h4 id="加粗">加粗</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\textbf</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;我们&#125;、<span class="keyword">\textbf</span>&#123;我们&#125;、我们</span><br><span class="line">注意：boldsymbol会变斜体（可能仅限英文）</span><br></pre></td></tr></table></figure><p><span class="math display">\[\textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们\]</span></p><h4 id="斜体">斜体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\textit&#123;我们&#125;、\it&#123;我们&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\textit{我们}、\it{我们}\]</span></p><h4 id="向量顶有向量箭头">向量（顶有向量箭头）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\vec</span> v</span><br></pre></td></tr></table></figure><p><span class="math display">\[\vec v\]</span></p><h4 id="估计顶有尖头hat">估计（顶有尖头hat）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;y&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\hat{y}\]</span></p><h4 id="平均顶有横线">平均（顶有横线）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \overline的线稍长，能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\bar</span> x ，<span class="keyword">\overline</span> x，<span class="keyword">\bar</span>&#123;AB&#125; ，<span class="keyword">\overline</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% \overline的线稍长，能覆盖所有字符\bar x ，\overline x，\bar{AB} ，\overline{AB}\]</span></p><h4 id="顶有波浪号">顶有波浪号~</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \widetilde能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\tilde</span> x ，<span class="keyword">\widetilde</span> x，<span class="keyword">\tilde</span>&#123;AB&#125; ，<span class="keyword">\widetilde</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% \widetilde能覆盖所有字符\tilde x ，\widetilde x，\tilde{AB} ，\widetilde{AB}\]</span></p><h4 id="分式">分式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{分子}{分母}\]</span></p><h4 id="个希腊字母">24个希腊字母</h4><p><img src="https://img2.imgtp.com/2024/03/17/9AmVbzpN.png" /></p><h4 id="花体集合手写体">花体、集合手写体</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 花体</span></span><br><span class="line"><span class="keyword">\mathcal</span>&#123;X&#125; ，<span class="keyword">\mathcal</span>&#123;Y&#125; ，<span class="keyword">\mathcal</span>&#123;D&#125;</span><br><span class="line"><span class="comment">% 集合手写体</span></span><br><span class="line"><span class="keyword">\mathbb</span>&#123;N&#125; ，<span class="keyword">\mathbb</span>&#123;Z&#125; ，<span class="keyword">\mathbb</span>&#123;R&#125; ，<span class="keyword">\mathbb</span>&#123;C&#125; ，<span class="keyword">\mathbb</span>&#123;Q&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 花体\mathcal{X} ，\mathcal{Y} ，\mathcal{D}\]</span></p><p><span class="math display">\[% 集合手写体\mathbb{N} ，\mathbb{Z} ，\mathbb{R} ，\mathbb{C} ，\mathbb{Q}\]</span></p><h3 id="大型运算">大型运算</h3><h4 id="求和">求和</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在右边</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在正上、正下</span><br><span class="line"><span class="keyword">\\</span> 换行</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum_{i=1}^{n}x_i   \]</span></p><p><span class="math display">\[\sum\limits_{i=1}^{n}x_i\]</span></p><p>求和符号的上下位置也可以缺省</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>i <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">^</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\sum\limits_i \sum\limits^n\]</span></p><h3 id="数组矩阵">数组矩阵</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 无括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="comment">% 圆括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="comment">% 单竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="comment">% 双竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="comment">% 方括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="comment">% 花括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 无括号矩阵\begin{matrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{matrix}\\% 圆括号矩阵\begin{pmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{pmatrix}\\% 单竖线矩阵\begin{vmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{vmatrix}\\% 双竖线矩阵\begin{Vmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{Vmatrix}\\% 方括号矩阵\begin{bmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{bmatrix}\\% 花括号矩阵\begin{Bmatrix}-1 &amp; 1 &amp; 2\\0 &amp; 1 &amp; 4\\\end{Bmatrix}\]</span></p><h3 id="符号">符号</h3><h4 id="属于">属于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\in\]</span></p><h4 id="集合之间的各种运算关系">集合之间的各种运算关系</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">A<span class="keyword">\subset</span> B</span><br><span class="line">A<span class="keyword">\supset</span> B</span><br><span class="line">A<span class="keyword">\subseteq</span> B</span><br><span class="line">A<span class="keyword">\supseteq</span> B</span><br><span class="line">A<span class="keyword">\cap</span> B</span><br><span class="line">A<span class="keyword">\cup</span> B</span><br><span class="line"><span class="comment">% A减B</span></span><br><span class="line">A<span class="keyword">\setminus</span> B</span><br><span class="line"><span class="keyword">\emptyset</span></span><br></pre></td></tr></table></figure><p><span class="math inline">\(A\subset B\)</span> <spanclass="math inline">\(A\supset B\)</span> <spanclass="math inline">\(A\subseteq B\)</span> <spanclass="math inline">\(A\supseteq B\)</span> <spanclass="math inline">\(A\cap B\)</span> <span class="math inline">\(A\cupB\)</span> <span class="math inline">\(A\setminus B\)</span> <spanclass="math inline">\(\emptyset\)</span></p><h4 id="任意">任意</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\forall</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\forall\]</span></p><h4 id="存在">存在</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\exists</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\exists\]</span></p><h4 id="因为所以">因为、所以</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\because</span> 和 <span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure><p>注意：如果没有编译成功，需要在导言区导入宏包amssymb</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\because 和 \therefore\]</span></p><h4 id="无穷大">无穷大</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\infty</span>+<span class="keyword">\infty</span> -<span class="keyword">\infty</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\infty +\infty -\infty\]</span></p><h4 id="尖括号">尖括号</h4><p>注意与小于号&lt;，大于号&gt; 区别</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\rangle</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\langle\\\rangle\]</span></p><h4id="小于等于大于等于不等于恒等于恒不等于">小于等于、大于等于、不等于、恒等于、恒不等于</h4><p>巧记：等于equation，所以这几个符号都是从 <em>eq</em> 词根出发的</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\le</span> 或者 <span class="keyword">\leq</span></span><br><span class="line"><span class="keyword">\ge</span> 或者 <span class="keyword">\geq</span></span><br><span class="line"><span class="keyword">\ne</span> 或者 <span class="keyword">\neq</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\not</span><span class="keyword">\equiv</span>  <span class="params">#</span> 注意这里只能是拼接<span class="keyword">\not</span>和<span class="keyword">\equiv</span>，<span class="keyword">\nequiv</span>无效</span><br></pre></td></tr></table></figure><p><span class="math inline">\(\le 或者 \leq\)</span> <spanclass="math inline">\(\ge 或者 \geq\)</span> <spanclass="math inline">\(\ne 或者 \neq\)</span> <spanclass="math inline">\(\equiv\)</span> <spanclass="math inline">\(\not\equiv\)</span></p><h4 id="远小于远大于">远小于、远大于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ll</span>，<span class="keyword">\gg</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\ll，\gg\]</span></p><h4 id="约等于">约等于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\approx</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\approx\]</span></p><h4 id="向上取整向下取整">向上取整、向下取整</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lceil</span> x <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> x <span class="keyword">\rfloor</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\lceil x \rceil\\\lfloor x \rfloor\]</span></p><h4 id="绝对值">绝对值</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>|-2<span class="keyword">\right</span>| 或者 <span class="keyword">\vert</span> -2<span class="keyword">\vert</span> 或者  <span class="keyword">\lvert</span> -2<span class="keyword">\rvert</span> </span><br></pre></td></tr></table></figure><p>可以观察一下区别 <span class="math display">\[\left|-2\right| 或者 \vert -2\vert 或者  \lvert -2\rvert\]</span></p><h4 id="双竖线">双竖线</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span> A<span class="keyword">\|</span> 或者 <span class="keyword">\left</span><span class="keyword">\|</span>A<span class="keyword">\right</span><span class="keyword">\|</span> 或者 <span class="keyword">\Vert</span> A<span class="keyword">\Vert</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\| A\| 或者 \left\|A\right\| 或者 \Vert A\Vert\]</span></p><h4 id="花括号">花括号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\&#123;</span> A<span class="keyword">\&#125;</span> 或者 <span class="keyword">\left</span><span class="keyword">\&#123;</span> A <span class="keyword">\right</span><span class="keyword">\&#125;</span> </span><br></pre></td></tr></table></figure><p><span class="math display">\[\{ A\} 或者 \left\{ A \right\}\]</span></p><h4 id="乘号">乘号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\times</span> 或者 ×</span><br></pre></td></tr></table></figure><p><span class="math display">\[\times 或者 ×\]</span></p><h4 id="开n次方">开n次方</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>&#123;2&#125;、<span class="keyword">\sqrt</span>[4]&#123;16&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\sqrt{2}、\sqrt[4]{16}\]</span></p><h4 id="导数">导数</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;</span><br><span class="line"><span class="comment">% 高阶导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;<span class="built_in">^</span>&#123;n&#125; y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x<span class="built_in">^</span>&#123;n&#125;&#125;</span><br><span class="line"><span class="comment">% 求偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;Loss&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;w&#125;&#125;</span><br><span class="line"><span class="comment">% 二阶偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="built_in">^</span>&#123;2&#125;&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="keyword">\partial</span>&#123;y&#125;&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[% 求导\frac{\mathrm{d}y}{\mathrm{d}x}% 高阶导\frac{\mathrm{d}^{n} y}{\mathrm{d}x^{n}}% 求偏导\frac{\partial{Loss}}{\partial{w}}% 二阶偏导\frac{\partial^{2}z}{\partial{x}^{2}}\frac{\partial^{2}z}{\partial{x}\partial{y}}\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex多重奏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分、离散化</title>
      <link href="/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="深进1.例1求区间和"><ahref="https://www.luogu.com.cn/problem/P8218">【深进1.例1】求区间和</a></h1><blockquote><h1 id="深进1.例1求区间和-1">【深进1.例1】求区间和</h1><h2 id="题目描述">题目描述</h2><p>给定 <span class="math inline">\(n\)</span> 个正整数组成的数列 <spanclass="math inline">\(a_1, a_2, \cdots, a_n\)</span> 和 <spanclass="math inline">\(m\)</span> 个区间 <spanclass="math inline">\([l_i,r_i]\)</span>，分别求这 <spanclass="math inline">\(m\)</span> 个区间的区间和。</p><p>对于所有测试数据，<span class="math inline">\(n,m\le10^5,a_i\le10^4\)</span></p><h2 id="输入格式">输入格式</h2><p>第一行，为一个正整数 <span class="math inline">\(n\)</span> 。</p><p>第二行，为 <span class="math inline">\(n\)</span> 个正整数 <spanclass="math inline">\(a_1,a_2, \cdots ,a_n\)</span></p><p>第三行，为一个正整数 <span class="math inline">\(m\)</span> 。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行为两个正整数<span class="math inline">\(l_i,r_i\)</span> ，满足<spanclass="math inline">\(1\le l_i\le r_i\le n\)</span></p><h2 id="输出格式">输出格式</h2><p>共 <span class="math inline">\(m\)</span> 行。</p><p>第 <span class="math inline">\(i\)</span> 行为第 <spanclass="math inline">\(i\)</span> 组答案的询问。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>4 4 3 2 1 2 1 4 2 3</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>10 5</code></p><h2 id="提示">提示</h2><p>样例解释：第 <span class="math inline">\(1\)</span> 到第 <spanclass="math inline">\(4\)</span> 个数加起来和为 <spanclass="math inline">\(10\)</span>。第 <spanclass="math inline">\(2\)</span> 个数到第 <spanclass="math inline">\(3\)</span> 个数加起来和为 <spanclass="math inline">\(5\)</span>。</p><p>对于 <span class="math inline">\(50 \%\)</span> 的数据：<spanclass="math inline">\(n,m\le 1000\)</span>；</p><p>对于 <span class="math inline">\(100 \%\)</span> 的数据：<spanclass="math inline">\(1 \le n, m\le 10^5\)</span>，<spanclass="math inline">\(1 \le a_i\le 10^4\)</span></p></blockquote><h2 id="思路分析">思路分析</h2><p>简单的前缀和板子，不多说。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll =<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">200000</span>];</span><br><span class="line">ll pre[<span class="number">200000</span>], sum[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">pre[i] = a[i] + pre[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">sum[i] = pre[r] - pre[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cout &lt;&lt; sum[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大加权矩形"><ahref="https://www.luogu.com.cn/problem/P1719">最大加权矩形</a></h1><h2 id="题目描述-1">题目描述</h2><p>为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。</p><p>校长先给他们一个 <span class="math inline">\(n\times n\)</span>矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大。矩阵的每个元素属于 <span class="math inline">\([-127,127]\)</span>,例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 –2 –7  0 </span><br><span class="line"> 9  2 –6  2</span><br><span class="line">-4  1 –4  1 </span><br><span class="line">-1  8  0 –2</span><br></pre></td></tr></table></figure><p>在左下角：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9  2</span><br><span class="line">-4  1</span><br><span class="line">-1  8</span><br></pre></td></tr></table></figure><p>和为 <span class="math inline">\(15\)</span>。</p><p>几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？</p><h2 id="输入格式-1">输入格式</h2><p>第一行：<span class="math inline">\(n\)</span>，接下来是 <spanclass="math inline">\(n\)</span> 行 <spanclass="math inline">\(n\)</span> 列的矩阵。</p><h2 id="输出格式-1">输出格式</h2><p>最大矩形（子矩阵）的和。</p><h2 id="样例-1-1">样例 #1</h2><h3 id="样例输入-1-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line"> 9 2 -6 2</span><br><span class="line">-4 1 -4  1 </span><br><span class="line">-1 8  0 -2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="提示-1">提示</h2><p><span class="math inline">\(1 \leq n\le 120\)</span>其实是二维前缀和的板子，这里给出几份代码，看看不同的思路（大多都是细节上处理的方法不同）。</p><h2 id="ac代码">AC代码</h2><h3 id="code1">CODE1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-99999999</span>;</span><br><span class="line"><span class="type">int</span> squ[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> lin[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; squ[i][j];</span><br><span class="line"><span class="comment">//lin[i][j]表示的是第i行前j个（其实也就是第j列）数字的和</span></span><br><span class="line">lin[i][j] = lin[i][j - <span class="number">1</span>] + squ[i][j];</span><br><span class="line"><span class="comment">//sum[i][j]表示的是以第1行第1个数字为左上角，以第i行第j个数字为右下角的矩形的面积。</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + lin[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分别枚举左上角的坐标(x1,y1)和右下角(x2,y2)的坐标。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x1 = <span class="number">1</span>; x1 &lt;= n; x1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y1 = <span class="number">1</span>; y1 &lt;= n; y1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x2 = <span class="number">1</span>; x2 &lt;= n; x2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y2 = <span class="number">1</span>; y2 &lt;= n; y2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x2 &lt; x1||y2&lt;y1) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] +sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人对<span class="math inline">\(sum[x2][y2] - sum[x2][y1 - 1] -sum[x1 - 1][y2] +sum[x1-1][y1-1]\)</span>为什么是以<spanclass="math inline">\((x_1,y_1)\)</span>为左上角，以<spanclass="math inline">\((x_2,y_2)\)</span>为右下角的矩形的面积有点疑惑。画个图解释一下：<imgsrc="https://img-blog.csdnimg.cn/direct/3c6c29a63e80437eaf7b54057daf5860.png#pic_center"alt="在这里插入图片描述" /> 这下应该能看懂了吧qwq。</p><h3 id="code2">CODE2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//还是跟上面的操作一样</span></span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="comment">//预处理出以(i,j)为右下角的矩形的面积，画画图就懂了</span></span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="comment">//枚举左上角(i,j)，右下角(k,m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//注意k&gt;=i,m&gt;=j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=j;m&lt;=n;m++)&#123;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(i,j,k,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="code3">CODE3</h3><p>实际上是在枚举时优化了一下，降低时间复杂度。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>,sum;</span><br><span class="line">    <span class="comment">//这里改成了枚举矩形的上下边i与j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//k枚举的是第几列，从左往右扫描每一列的面积，并加到sum中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(i,k,j,k);</span><br><span class="line">                <span class="comment">//如果sum&gt;ans，说明在以i行为上界，j行为下界的，并且右界限为k的构成的连续矩形面积（即sum）更大，更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;ans)ans=sum;</span><br><span class="line">                <span class="comment">//如果sum&lt;0，那么只能另开一段，置sum为0</span></span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>或者可以理解成是矩阵压缩，可以看看题解的第一篇，本质其实是一样的。 <ahref="https://www.luogu.com.cn/problem/solution/P1719">P1719最大加权矩形</a></p><h1 id="语文成绩"><ahref="https://www.luogu.com.cn/problem/P2367">语文成绩</a></h1><blockquote><h1 id="语文成绩-1">语文成绩</h1><h2 id="题目背景">题目背景</h2><p>语文考试结束了，成绩还是一如既往地有问题。</p><h2 id="题目描述-2">题目描述</h2><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><h2 id="输入格式-2">输入格式</h2><p>第一行有两个整数 <span class="math inline">\(n\)</span>，<spanclass="math inline">\(p\)</span>，代表学生数与增加分数的次数。</p><p>第二行有 <span class="math inline">\(n\)</span> 个数，<spanclass="math inline">\(a_1 \sima_n\)</span>，代表各个学生的初始成绩。</p><p>接下来 <span class="math inline">\(p\)</span> 行，每行有三个数，<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(y\)</span>，<spanclass="math inline">\(z\)</span>，代表给第 <spanclass="math inline">\(x\)</span> 个到第 <spanclass="math inline">\(y\)</span> 个学生每人增加 <spanclass="math inline">\(z\)</span> 分。</p><h2 id="输出格式-2">输出格式</h2><p>输出仅一行，代表更改分数后，全班的最低分。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><p><code>3 2 1 1 1 1 2 1 2 3 1</code></p><h3 id="样例输出-1-2">样例输出 #1</h3><p><code>2</code></p><h2 id="提示-2">提示</h2><p>对于 <span class="math inline">\(40\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^3\)</span>。</p><p>对于 <span class="math inline">\(60\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^4\)</span>。</p><p>对于 <span class="math inline">\(80\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 10^5\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(n \le 5\times 10^6\)</span>，<spanclass="math inline">\(p \le n\)</span>，学生初始成绩 $ <spanclass="math inline">\(，\)</span>z $。</p></blockquote><h2 id="思路分析-1">思路分析</h2><p>差分的板子题，但是我经常忘记怎么操作了，贴上证明。 <imgsrc="https://img-blog.csdnimg.cn/direct/7348fc92b069475784845bf92f234e14.png#pic_center"alt="在这里插入图片描述" /> 这里贴的是<ahref="https://www.luogu.com.cn/blog/156353/solution-p2367">GoldenFishX大佬的博客</a>，可以看看（大佬如果觉得侵权，联系我删除即可qwq）。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll p, n, a[<span class="number">5000500</span>], d[<span class="number">5000500</span>];</span><br><span class="line">ll x, y, z, ans=<span class="number">9999999999</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//求出差分数组</span></span><br><span class="line">d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="comment">//上面讲得很清楚了</span></span><br><span class="line">d[x] += z;</span><br><span class="line">d[y + <span class="number">1</span>] -= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//差分的性质：a[i]=d[i]+d[i-1]+d[i-2]+······+d[1]</span></span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + d[i];</span><br><span class="line">ans = <span class="built_in">min</span>(ans, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地毯"><ahref="https://www.luogu.com.cn/problem/P3397">地毯</a></h1><h2 id="题目描述-3">题目描述</h2><p>在 <span class="math inline">\(n\times n\)</span> 的格子上有 <spanclass="math inline">\(m\)</span> 个地毯。</p><p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p><h2 id="输入格式-3">输入格式</h2><p>第一行，两个正整数 <spanclass="math inline">\(n,m\)</span>。意义如题所述。</p><p>接下来 <span class="math inline">\(m\)</span> 行，每行两个坐标 <spanclass="math inline">\((x_1,y_1)\)</span> 和 <spanclass="math inline">\((x_2,y_2)\)</span>，代表一块地毯，左上角是 <spanclass="math inline">\((x_1,y_1)\)</span>，右下角是 <spanclass="math inline">\((x_2,y_2)\)</span>。</p><h2 id="输出格式-3">输出格式</h2><p>输出 <span class="math inline">\(n\)</span> 行，每行 <spanclass="math inline">\(n\)</span> 个正整数。</p><p>第 <span class="math inline">\(i\)</span> 行第 <spanclass="math inline">\(j\)</span> 列的正整数表示 <spanclass="math inline">\((i,j)\)</span> 这个格子被多少个地毯覆盖。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 2 3 3</span><br><span class="line">3 3 5 5</span><br><span class="line">1 2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 0 0</span><br><span class="line">0 1 2 1 1</span><br><span class="line">0 0 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="样例解释">样例解释</h3><p>覆盖第一个地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr></tbody></table><p>覆盖第一、二个地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr></tbody></table><p>覆盖所有地毯后：</p><table><thead><tr class="header"><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span></th><th style="text-align: center;"><spanclass="math inline">\(0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(2\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="odd"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr><tr class="even"><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(0\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td><td style="text-align: center;"><spanclass="math inline">\(1\)</span></td></tr></tbody></table><hr /><h3 id="数据范围">数据范围</h3><p>对于 <span class="math inline">\(20\%\)</span> 的数据，有 <spanclass="math inline">\(n\le 50\)</span>，<span class="math inline">\(m\le100\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(n,m\le 1000\)</span>。 ## 思路分析这题其实可以暴力模拟水过去，但实际上正解是二维差分。（补学一下qwq）。设数组<span class="math inline">\(a\)</span>的差分数组为<spanclass="math inline">\(b\)</span>，则： <spanclass="math display">\[b[[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]\]</span>.（偷懒了，直接贴书上的内容qwq）</p><blockquote><figure><imgsrc="https://img-blog.csdnimg.cn/direct/268ddecc2f5c4e04bcbd0ab4d710df40.png#pic_center"alt="在这里插入图片描述" /><figcaption aria-hidden="true">在这里插入图片描述</figcaption></figure></blockquote><p>可以看到(a)，(b)图中，右下角的矩形中的各点都+1了，可以试着结合一维差分的证明理解一下wsm。(c)，(d)图其实就是相同的操作罢了。</p><h2 id="ac代码-1">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="comment">//上面提到的操作</span></span><br><span class="line">        mat[x1][y1]++;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y1]--;</span><br><span class="line">        mat[x1][y2+<span class="number">1</span>]--;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y2+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//求前缀和，处理出每个点的值</span></span><br><span class="line">            mat[i][j]+=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            cout&lt;&lt;mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="火烧赤壁"><ahref="https://www.luogu.com.cn/problem/P1496">火烧赤壁</a></h1><h2 id="题目背景-1">题目背景</h2><p>曹操平定北方以后，公元 208年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p><p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p><p>隆冬的十一月，天气突然回暖，刮起了东南风。</p><p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p><p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p><h2 id="题目描述-4">题目描述</h2><p>给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。</p><h2 id="输入格式-4">输入格式</h2><p>第一行一个整数，表示起火的信息条数 <spanclass="math inline">\(n\)</span>。<br />接下来 <span class="math inline">\(n\)</span> 行，每行两个整数 <spanclass="math inline">\(a,b\)</span>，表示一个着火位置的起点和终点（<strong>注意：左闭右开</strong>）。</p><h2 id="输出格式-4">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="数据规模与约定">数据规模与约定</h3><p>对于全部的测试点，保证 <span class="math inline">\(1 \leq n \leq 2\times 10^4\)</span>，<span class="math inline">\(-2^{31} \leq a \leq  b\lt 2^{31}\)</span>，且答案小于 <spanclass="math inline">\(2^{31}\)</span>。 ## 思路分析实际上这是一道离散化的题目，但是我当初做的时候还不会离散化qwq，看了题解区大佬的绝妙思路：<a href="https://wxwoo.blog.luogu.org/solution-p1496">大佬的题解</a><imgsrc="https://img-blog.csdnimg.cn/direct/dbcb14ba5ade43389d9fc5e8b3e94590.png#pic_center"alt="在这里插入图片描述" />可以发现，覆盖的范围是一样的，那么我们可以这样操作：1、将起点和终点排个序。 2、将他们按照从小到大的顺序一一匹配，计算长度。3、如果有重复的覆盖范围，减去即可。（也就是当前的终点坐标比下一个的起点坐标大时）## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">20200</span>], b[<span class="number">20200</span>], l;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">l += b[i] - a[i];</span><br><span class="line"><span class="comment">//注意i&lt;n,因为a[n]，b[n]是最后的起点和终点</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">l -= b[i] - a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="领地选择"><ahref="https://www.luogu.com.cn/problem/P2004">领地选择</a></h1><h2 id="题目描述-5">题目描述</h2><p>作为在虚拟世界里统帅千军万马的领袖，小 Z认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z来说是非常重要的。</p><p>首都被认为是一个占地 <span class="math inline">\(C\times C\)</span>的正方形。小 Z希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。</p><h2 id="输入格式-5">输入格式</h2><p>第一行三个整数 <spanclass="math inline">\(N,M,C\)</span>，表示地图的宽和长以及首都的边长。</p><p>接下来 <span class="math inline">\(N\)</span> 行每行 <spanclass="math inline">\(M\)</span>个整数，表示了地图上每个地块的价值。价值可能为负数。</p><h2 id="输出格式-5">输出格式</h2><p>一行两个整数 <spanclass="math inline">\(X,Y\)</span>，表示首都左上角的坐标。</p><h2 id="样例-1-5">样例 #1</h2><h3 id="样例输入-1-5">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="提示-5">提示</h2><p>对于 <span class="math inline">\(60\%\)</span> 的数据，<spanclass="math inline">\(N,M\le 50\)</span>。</p><p>对于 <span class="math inline">\(90\%\)</span> 的数据，<spanclass="math inline">\(N,M\le 300\)</span>。</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1\le N,M\le 10^3\)</span>，<spanclass="math inline">\(1\le C\le \min(N,M)\)</span>。 ## 思路分析二维前缀和的练习题，不解释了qwq。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m, c;</span><br><span class="line">ll map[<span class="number">1010</span>][<span class="number">1010</span>], sum[<span class="number">1010</span>][<span class="number">1010</span>], maxn = <span class="number">-999999999</span>, nx,ny;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; map[i][j];</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + map[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= m; j++) &#123;</span><br><span class="line">    <span class="comment">//枚举以(i,j)为右下角、边长为c的正方形的面积，注意更新坐标</span></span><br><span class="line"><span class="keyword">if</span> (sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c] &gt; maxn) &#123;</span><br><span class="line">maxn = sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c];</span><br><span class="line">nx = i - c + <span class="number">1</span>;</span><br><span class="line">ny = j - c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; nx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ny;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聪明的质检员"><ahref="https://www.luogu.com.cn/problem/P1314">聪明的质检员</a></h1><blockquote><h2 id="题目描述-6">题目描述</h2><p><code>小T</code>是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 <spanclass="math inline">\(n\)</span> 个矿石，从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 逐一编号，每个矿石都有自己的重量 <spanclass="math inline">\(w_i\)</span> 以及价值 <spanclass="math inline">\(v_i\)</span> 。检验矿产的流程是：</p><ol type="1"><li>给定$ m$ 个区间 <spanclass="math inline">\([l_i,r_i]\)</span>；</li><li>选出一个参数 <span class="math inline">\(W\)</span>；</li><li>对于一个区间 <spanclass="math inline">\([l_i,r_i]\)</span>，计算矿石在这个区间上的检验值<span class="math inline">\(y_i\)</span>：</li></ol><p><span class="math display">\[y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W]\times\sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j\]</span></p><p>其中 <span class="math inline">\(j\)</span> 为矿石编号。</p><p>这批矿产的检验结果 <span class="math inline">\(y\)</span>为各个区间的检验值之和。即：<spanclass="math inline">\(\sum\limits_{i=1}^m y_i\)</span></p><p>若这批矿产的检验结果与所给标准值 <spanclass="math inline">\(s\)</span>相差太多，就需要再去检验另一批矿产。<code>小T</code>不想费时间去检验另一批矿产，所以他想通过调整参数 <spanclass="math inline">\(W\)</span> 的值，让检验结果尽可能的靠近标准值<span class="math inline">\(s\)</span>，即使得 <spanclass="math inline">\(|s-y|\)</span> 最小。请你帮忙求出这个最小值。</p><h2 id="输入格式-6">输入格式</h2><p>第一行包含三个整数 <spanclass="math inline">\(n,m,s\)</span>，分别表示矿石的个数、区间的个数和标准值。</p><p>接下来的 <span class="math inline">\(n\)</span>行，每行两个整数，中间用空格隔开，第 <spanclass="math inline">\(i+1\)</span> 行表示 <spanclass="math inline">\(i\)</span> 号矿石的重量 <spanclass="math inline">\(w_i\)</span> 和价值 <spanclass="math inline">\(v_i\)</span>。</p><p>接下来的 <span class="math inline">\(m\)</span>行，表示区间，每行两个整数，中间用空格隔开，第 <spanclass="math inline">\(i+n+1\)</span> 行表示区间 <spanclass="math inline">\([l_i,r_i]\)</span> 的两个端点 <spanclass="math inline">\(l_i\)</span> 和 <spanclass="math inline">\(r_i\)</span>。注意：不同区间可能重合或相互重叠。</p><h2 id="输出格式-6">输出格式</h2><p>一个整数，表示所求的最小值。</p><h2 id="样例-1-6">样例 #1</h2><h3 id="样例输入-1-6">样例输入 #1</h3><p><code>5 3 15  1 5  2 5  3 5  4 5  5 5  1 5  2 4  3 3</code></p><h3 id="样例输出-1-6">样例输出 #1</h3><p><code>10</code></p><h2 id="提示-6">提示</h2><p>【输入输出样例说明】</p><p>当 <span class="math inline">\(W\)</span> 选 <spanclass="math inline">\(4\)</span> 的时候，三个区间上检验值分别为 <spanclass="math inline">\(20,5 ,0\)</span> ，这批矿产的检验结果为 <spanclass="math inline">\(25\)</span>，此时与标准值 <spanclass="math inline">\(S\)</span> 相差最小为 <spanclass="math inline">\(10\)</span>。</p><p>【数据范围】</p><p>对于 <span class="math inline">\(10\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤10\)</span>；</p><p>对于 <span class="math inline">\(30\%\)</span>的数据，有 <spanclass="math inline">\(1 ≤n ,m≤500\)</span> ；</p><p>对于 <span class="math inline">\(50\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤5,000\)</span>； 对于 <spanclass="math inline">\(70\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤10,000\)</span> ；</p><p>对于 <span class="math inline">\(100\%\)</span> 的数据，有 <spanclass="math inline">\(1 ≤n ,m≤200,000\)</span>，<spanclass="math inline">\(0 &lt; w_i,v_i≤10^6\)</span>，<spanclass="math inline">\(0 &lt;s≤10^{12}\)</span>，<span class="math inline">\(1 ≤l_i ≤r_i ≤n\)</span>## 思路分析直接暴力枚举求出这个点肯定不行，并且看到题目要求最小值，所以可以猜测：使用二分。二分的是<span class="math inline">\(W\)</span>的值，<spanclass="math inline">\(check(mid)\)</span>的判断条件是<spanclass="math inline">\(s-\sum\limits_{i=1}^my_i\)</span>是否大于0，由此缩减二分的范围，分析一下单调性：当<spanclass="math inline">\(W\)</span>减少时，<spanclass="math inline">\(\sum\limits_{i=1}^my_i\)</span>增大，反之，则变小，并且当<spanclass="math inline">\(W\)</span>足够小时，<spanclass="math inline">\(\sum\limits_{i=1}^m y_i\)</span>会大于<spanclass="math inline">\(s\)</span>,符合单调性，可以使用二分。具体看看注释。还需要先预处理出前缀和：包括个数和总价值，否则会TLE。 ## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],l[MAXN],r[MAXN],cnt_num[MAXN],cnt_val[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    ll sum,ans,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    ans=s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//w是矿石的重量，v是矿石的价值</span></span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//输入的是查询的区间</span></span><br><span class="line">        cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt_num,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt_val,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_val));</span><br><span class="line">        <span class="comment">//利用前缀和，预处理出合格品的个数和总价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;=mid)&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>]+v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>];</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计一下检测结果，也就是查询的各个区间总价值之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            sum+=(cnt_val[r[i]]-cnt_val[l[i]<span class="number">-1</span>])*(cnt_num[r[i]]-cnt_num[l[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意更新答案，得到的是最小值，注意ans初始化为无穷大</span></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-s));</span><br><span class="line">        <span class="comment">//说明这个解合法，将右端点确定下来</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=s)right=mid;</span><br><span class="line">        <span class="comment">//否则，将左端点确定下来</span></span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序自动分析"><ahref="https://www.luogu.com.cn/problem/P1955">程序自动分析</a></h1><blockquote><h1 id="noi2015-程序自动分析">[NOI2015] 程序自动分析</h1><h2 id="题目描述-7">题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设 <spanclass="math inline">\(x_1,x_2,x_3,\cdots\)</span>代表程序中出现的变量，给定 <span class="math inline">\(n\)</span> 个形如<span class="math inline">\(x_i=x_j\)</span> 或 <spanclass="math inline">\(x_i\neq x_j\)</span>的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：<spanclass="math inline">\(x_1=x_2,x_2=x_3,x_3=x_4,x_4\neqx_1\)</span>，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入格式-7">输入格式</h2><p>输入的第一行包含一个正整数 <spanclass="math inline">\(t\)</span>，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第一行包含一个正整数 <spanclass="math inline">\(n\)</span>，表示该问题中需要被满足的约束条件个数。接下来<span class="math inline">\(n\)</span> 行，每行包括三个整数 <spanclass="math inline">\(i,j,e\)</span>，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若<span class="math inline">\(e=1\)</span>，则该约束条件为 <spanclass="math inline">\(x_i=x_j\)</span>。若<spanclass="math inline">\(e=0\)</span>，则该约束条件为 <spanclass="math inline">\(x_i\neq x_j\)</span>。</p><h2 id="输出格式-7">输出格式</h2><p>输出包括 <span class="math inline">\(t\)</span> 行。</p><p>输出文件的第 <span class="math inline">\(k\)</span> 行输出一个字符串<code>YES</code> 或者 <code>NO</code>（字母全部大写），<code>YES</code>表示输入中的第 <span class="math inline">\(k\)</span>个问题判定为可以被满足，<code>NO</code> 表示不可被满足。</p><h2 id="样例-1-7">样例 #1</h2><h3 id="样例输入-1-7">样例输入 #1</h3><p><code>2 2 1 2 1 1 2 0 2 1 2 1 2 1 1</code></p><h3 id="样例输出-1-7">样例输出 #1</h3><p><code>NO YES</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>2 3 1 2 1 2 3 1 3 1 1 4 1 2 1 2 3 1 3 4 1 1 4 0</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>YES NO</code></p><h2 id="提示-7">提示</h2><p>【样例解释1】</p><p>在第一个问题中，约束条件为：<spanclass="math inline">\(x_1=x_2,x_1\neqx_2\)</span>。这两个约束条件互相矛盾，因此不可被同时满足。</p><p>在第二个问题中，约束条件为：<span class="math inline">\(x_1=x_2,x_1 =x_2\)</span>。这两个约束条件是等价的，可以被同时满足。</p><p>【样例说明2】</p><p>在第一个问题中，约束条件有三个：<spanclass="math inline">\(x_1=x_2,x_2= x_3,x_3=x_1\)</span>。只需赋值使得<spanclass="math inline">\(x_1=x_2=x_3\)</span>，即可同时满足所有的约束条件。</p><p>在第二个问题中，约束条件有四个：<spanclass="math inline">\(x_1=x_2,x_2= x_3,x_3=x_4,x_4\neqx_1\)</span>。由前三个约束条件可以推出 <spanclass="math inline">\(x_1=x_2=x_3=x_4\)</span>，然而最后一个约束条件却要求<span class="math inline">\(x_1\neq x_4\)</span>，因此不可被满足。</p><p>【数据范围】</p><p>所有测试数据的范围和特点如下表所示：</p><h3id="勘误测试点-8-sim-10-的-i-j-约束为-1-leq-i-j-leq-109而不是下图中的-1010">勘误：测试点<span class="math inline">\(8 \sim 10\)</span> 的 <spanclass="math inline">\(i, j\)</span> 约束为 <span class="math inline">\(1\leq i, j \leq 10^9\)</span>，而不是下图中的 <spanclass="math inline">\(10^{10}\)</span>。</h3><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/4a99dde45fc5970ecba60d38c39a3bc2.png" />## 思路分析这个其实是并查集+离散化，但是离散化我还不太熟，暂时没写。当初用了<spanclass="math inline">\(unordered-map\)</span>混过去了qwq。说正题，这道题有两个特征，查询和赋值，我们分析一下，这其实跟并查集的功能很相似，并查集维护的是一些元素的分组，用的是查询和合并两个操作。这里的赋值，我们其实可以用合并来实现：1、如果是赋值，合并为一组。2、如果是查询，那么我们只要看两者是否在同一组内即可。这里并查集写的是按秩合并，不会的可以用普通的并查集代替。 ## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;Rank;</span><br><span class="line"><span class="type">int</span> x[MAXN],y[MAXN],e[MAXN];</span><br><span class="line"><span class="comment">//并查集的查询功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=<span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的合并功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]&gt;=Rank[fy])pre[fy]=fx;</span><br><span class="line">    <span class="keyword">else</span> pre[fx]=fy;</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]==Rank[fy]&amp;&amp;fx!=fy)Rank[fx]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意清空数组，因为有多组数据输入，不然喜迎WA qwq</span></span><br><span class="line">    pre.<span class="built_in">clear</span>();</span><br><span class="line">    Rank.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//输入元素，以及对应的操作，注意在原题中指的是下标x，y</span></span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;e[i];</span><br><span class="line">        <span class="comment">//将并查集初始化</span></span><br><span class="line">        pre[x[i]]=x[i];</span><br><span class="line">        pre[y[i]]=y[i];</span><br><span class="line">        <span class="comment">//按秩合并才需要的初始化，其实这一行也可以不用写@~@</span></span><br><span class="line">        Rank[x[i]]=<span class="number">1</span>,Rank[y[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果是1，合并两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(e[i])<span class="built_in">join</span>(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果不是1，查看两者的祖先是否一样</span></span><br><span class="line">        <span class="keyword">if</span>(!e[i])&#123;</span><br><span class="line">            <span class="comment">//不一样的话，直接输出NO，return 0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x[i])==<span class="built_in">find</span>(y[i]))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经历重重困难，终于是YES了！！！</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="usaco11mar-brownie-slicing-g"><ahref="https://www.luogu.com.cn/problem/P3017">[USACO11MAR] BrownieSlicing G</a></h1><h2 id="题面翻译">题面翻译</h2><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由 <spanclass="math inline">\(R\times C(1\leq R,C\leq 500)\)</span>个小的巧克力蛋糕组成的。第 <span class="math inline">\(i\)</span> 行，第<span class="math inline">\(j\)</span> 列的蛋糕有 <spanclass="math inline">\(N_{i,j}(N_{i,j}\leq 4000)\)</span>块巧克力碎屑。</p><p>Bessie想把蛋糕分成 <span class="math inline">\(A\times B(1\leq A\leqR,1\leq B\leq C)\)</span> 块，:给 <span class="math inline">\(A\timesB\)</span> 只奶牛。蛋糕先水平地切 <spanclass="math inline">\(A-1\)</span>刀（只能切沿整数坐标切）来把蛋糕划分成 <spanclass="math inline">\(A\)</span> 块。然后再把剩下来的每一块独立地切<span class="math inline">\(B-1\)</span> 刀，也只能切沿整数坐标切。其他<span class="math inline">\(A\times B-1\)</span>只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个<spanclass="math inline">\(5\times4\)</span>的蛋糕，上面的碎屑分布如下图所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure> 这样，Bessie至少能获得 <spanclass="math inline">\(3\)</span> 块巧克力碎屑</p><h2 id="题目描述-8">题目描述</h2><p>Bessie has baked a rectangular brownie that can be thought of as anRxC grid (1 &lt;= R &lt;= 500; 1 &lt;= C &lt;= 500) of little browniesquares. The square at row i, column j contains N_ij (0 &lt;= N_ij &lt;=4,000) chocolate chips.</p><p>Bessie wants to partition the brownie up into A*B chunks (1 &lt;= A&lt;= R; 1 &lt;= B &lt;= C): one for each of the A*B cows. The brownieis cut by first making A-1 horizontal cuts (always along integer</p><p>coordinates) to divide the brownie into A strips. Then cut each strip*independently* with B-1 vertical cuts, also on integer</p><p>boundaries. The other A*B-1 cows then each choose a brownie piece,leaving the last chunk for Bessie. Being greedy, they leave Bessie thebrownie that has the least number of chocolate chips on it.</p><p>Determine the maximum number of chocolate chips Bessie can receive,assuming she cuts the brownies optimally.</p><p>As an example, consider a 5 row x 4 column brownie with chips</p><p>distributed like this: <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure></p><p>Bessie must partition the brownie into 4 horizontal strips, each withtwo pieces. Bessie can cut the brownie like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>Thus, when the other greedy cows take their brownie piece, Bessiestill gets 3 chocolate chips.</p><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由R*C(1 &lt;= R,C &lt;=500)个小的巧克力蛋糕组成的。第i行，第j列的蛋糕有N_ij(1&lt;= N_ij &lt;=4,000)块巧克力碎屑。</p><p>Bessie想把蛋糕分成A*B块，(1 &lt;= A&lt;= R,1 &lt;= B &lt;= C):给A*B只奶牛。蛋糕先水平地切A-1刀（只能切沿整数坐标切）来把蛋糕划分成A块。然后再把剩下来的每一块独立地切B-1刀，也只能切沿整数坐标切。其他A*B-1只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个5*4的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><h2 id="输入格式-8">输入格式</h2><p>* Line 1: Four space-separated integers: R, C, A, and B</p><p>* Lines 2..R+1: Line i+1 contains C space-separated integers: N_i1,..., N_iC</p><h2 id="输出格式-8">输出格式</h2><p>* Line 1: A single integer: the maximum number of chocolate chipsthat Bessie guarantee on her brownie</p><h2 id="样例-1-8">样例 #1</h2><h3 id="样例输入-1-8">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 4 2 </span><br><span class="line">1 2 2 1 </span><br><span class="line">3 1 1 1 </span><br><span class="line">2 0 1 3 </span><br><span class="line">1 1 1 1 </span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路分析-2">思路分析</h2><p>当初也没想出来怎么二分，看了题解区大佬的题解恍然大悟。蛋糕要分成<span class="math inline">\(A *B\)</span>块，注意可以先分成<spanclass="math inline">\(A\)</span>横块，每一块再分成<spanclass="math inline">\(B\)</span>条，也就是切条时可以不用一刀切！！！那么要统计一块蛋糕的巧克力屑，肯定就是使用前缀和了。我们也可以先预处理出前缀和，再进行二分。二分的是巧克力屑的数量，<spanclass="math inline">\(check(mid)\)</span>的是能否切出<spanclass="math inline">\(A*B\)</span>块蛋糕，具体<spanclass="math inline">\(check(mid)\)</span>怎么写可以看看代码+注释。 ##AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cake[<span class="number">510</span>][<span class="number">510</span>],line[<span class="number">510</span>][<span class="number">510</span>],pre[<span class="number">510</span>][<span class="number">510</span>],r,c,a,b,ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//我们先切一行，再将这一行切成B列，看看最终能否满足A*B块蛋糕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,sum_cake=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i枚举的是当前行，j枚举的是当前列，last记录的是上一块（行）蛋糕的最底行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="comment">//判断当前切的蛋糕的巧克力屑的数量是否大于x，也就是二分的值</span></span><br><span class="line">            <span class="comment">//我们一列一列的补充蛋糕，判断补充后，其巧克力屑数目是否大于x，不满足，则补充。</span></span><br><span class="line">            <span class="keyword">if</span>(sum_cake+(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>])&lt;x)&#123;</span><br><span class="line">                sum_cake+=(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足，另开一列，注意统计的蛋糕数目+1，蛋糕上的巧克力屑数目重置为0</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum_cake=<span class="number">0</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断这一行蛋糕，切出来是否有B块</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=b)&#123;</span><br><span class="line">        <span class="comment">//如果有B块，我们则记录这块蛋糕的最后一行，并且记录 行的蛋糕数量++，没有只能再加上一行继续切了，直到满足为止。</span></span><br><span class="line">            last=i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看看是否能不能切除A行蛋糕，满足return true，否则，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;a)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输入R、C、A、B</span></span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//输入蛋糕的巧克力屑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=MAXN;</span><br><span class="line">    <span class="comment">//二分，不多说了，重点在check(x)</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="海底高铁"><ahref="https://www.luogu.com.cn/problem/P3406">海底高铁</a></h1><h2 id="思路分析-3">思路分析</h2><p>先想想暴力怎么办？我们可以先统计每段铁路要经过几次，再贪心，看看是办卡优惠还是买票优惠。但是这样肯定会TLE，想想怎么改——————前缀和吗？不对，前缀和求的是多个元素之间的关系。差分吗？差分维护的是多个元素之间的逻辑关系，最终得到的是单个元素。那就是差分了！我们可以利用它来得出每段铁路经过的次数，想想差分的作用，O(1)修改区间的值，O(n)查询单个元素的值。基于此，我们可以先O(1)预处理区间总共要修改的值，再O(n)得到每段铁路经过的次数，最后贪心得出最小花费。具体可以看看注释。可以看看这篇<ahref="https://www.luogu.com.cn/article/srpjwp5w">搞笑的故事</a>，相信会有所收获。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll p[MAXN],a[MAXN],b[MAXN],c[MAXN],ans[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分，统计修改次数，注意相邻元素不一定是从小到大，所以可能得交换顺序</span></span><br><span class="line">    <span class="comment">//一般来说，是d[l]++,d[r+1]--。l指的是左端点，r指的是右端点，但是我们这里d[l]++,d[r]--即可，因为其实从r城市出发的铁路我们根本不需要经过。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans[<span class="built_in">min</span>(p[i],p[i+<span class="number">1</span>])]++;</span><br><span class="line">        ans[<span class="built_in">max</span>(p[i],p[i+<span class="number">1</span>])]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得出每段铁路需要经过的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//贪心，看看每一段铁路是买票优惠还是买卡优惠</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">min</span>(ans[i]*a[i],ans[i]*b[i]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="poetize6-incdec-sequence"><ahref="https://www.luogu.com.cn/problem/P4552">[Poetize6] IncDecSequence</a></h1><blockquote><h1 id="poetize6-incdec-sequence-1">[Poetize6] IncDec Sequence</h1><h2 id="题目描述-9">题目描述</h2><p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <spanclass="math inline">\({a_1,a_2,\cdots,a_n}\)</span>，每次可以选择一个区间<spanclass="math inline">\([l,r]\)</span>，使这个区间内的数都加 <spanclass="math inline">\(1\)</span> 或者都减 <spanclass="math inline">\(1\)</span>。请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p><h2 id="输入格式-9">输入格式</h2><p>第一行一个正整数 <span class="math inline">\(n\)</span> 接下来 <spanclass="math inline">\(n\)</span> 行,每行一个整数,第 $i+1 $行的整数表示<span class="math inline">\(a_i\)</span>。</p><h2 id="输出格式-9">输出格式</h2><p>第一行输出最少操作次数 第二行输出最终能得到多少种结果</p><h2 id="样例-1-9">样例 #1</h2><h3 id="样例输入-1-9">样例输入 #1</h3><p><code>4 1 1 2 2</code></p><h3 id="样例输出-1-9">样例输出 #1</h3><p><code>1 2</code></p><h2 id="提示-8">提示</h2><p>对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(n\le 100000, 0 \le a_i \le 2^{31}\)</span>。 ##思路分析先想想元素相同？其实就是他们的差都是0，我们关注的是单个元素，并且是各元素之间的逻辑关系问题，所以我们使用差分来求解。那么问题就变成了怎么让差分数组全为0（除了<spanclass="math inline">\(diff[1]\)</span>不为0，因为<spanclass="math inline">\(a[0]\)</span>为0），对一个区间<spanclass="math inline">\([l,r]\)</span>进行修改，其实就是<spanclass="math inline">\(diff[l]++\)</span>、<spanclass="math inline">\(dff[r+1]--\)</span>。而一个差分数组里元素肯定有正有负，最好的情况是，一次修改，可以让一个负数加1，一个正数减1，这样操作步骤就是最少的。但是如果只剩下正数或者负数，就只能一次一次进行了。至于有多少可能结果，其实就是最后只剩正数或者负数时，一步步修改的操作次数了。为什么？前面修改的时候，我们修改的是<spanclass="math inline">\([l,r]\)</span>，对<spanclass="math inline">\(diff[1]\)</span>无影响，而只剩正数或者负数时，我们可以<spanclass="math inline">\(diff[1]++\)</span><spanclass="math inline">\(diff[x]--\)</span>了，也可以<spanclass="math inline">\(diff[1]--\)</span><spanclass="math inline">\(diff[x]++\)</span>，也可以不动，所以可能的结果就是：剩余的正数/负数+1，因为本身不修改，也要加上。## AC代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,x=<span class="number">0</span>,y=<span class="number">0</span>,d;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//求差分数组：x统计正数，y统计负数</span></span><br><span class="line">        d=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">0</span>)x+=d;</span><br><span class="line">        <span class="keyword">else</span> y-=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格的证明是:ans1=min(x,y)+abs(x-y),所以ans1=max(x,y)。</span></span><br><span class="line">    ll ans1=<span class="built_in">max</span>(x,y);</span><br><span class="line">    <span class="comment">//不解释了，看看上面</span></span><br><span class="line">    ll ans2=<span class="built_in">abs</span>(x-y)+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="noip2012-提高组-借教室"><ahref="https://www.luogu.com.cn/problem/P1083">[NOIP2012 提高组]借教室</a></h1><h2 id="题目描述-10">题目描述</h2><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来 <span class="math inline">\(n\)</span>天的借教室信息，其中第 <span class="math inline">\(i\)</span> 天学校有<span class="math inline">\(r_i\)</span> 个教室可供租借。共有 <spanclass="math inline">\(m\)</span>份订单，每份订单用三个正整数描述，分别为 <spanclass="math inline">\(d_j,s_j,t_j\)</span>，表示某租借者需要从第 <spanclass="math inline">\(s_j\)</span> 天到第 <spanclass="math inline">\(t_j\)</span> 天租借教室（包括第 <spanclass="math inline">\(s_j\)</span> 天和第 <spanclass="math inline">\(t_j\)</span> 天），每天需要租借 <spanclass="math inline">\(d_j\)</span> 个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供<span class="math inline">\(d_j\)</span>个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第<span class="math inline">\(s_j\)</span> 天到第 <spanclass="math inline">\(t_j\)</span> 天中有至少一天剩余的教室数量不足<span class="math inline">\(d_j\)</span> 个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><h2 id="输入格式-10">输入格式</h2><p>第一行包含两个正整数 <spanclass="math inline">\(n,m\)</span>，表示天数和订单的数量。</p><p>第二行包含 <span class="math inline">\(n\)</span> 个正整数，其中第<span class="math inline">\(i\)</span> 个数为 <spanclass="math inline">\(r_i\)</span>，表示第 <spanclass="math inline">\(i\)</span> 天可用于租借的教室数量。</p><p>接下来有 <span class="math inline">\(m\)</span>行，每行包含三个正整数 <spanclass="math inline">\(d_j,s_j,t_j\)</span>，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 <spanclass="math inline">\(1\)</span> 开始的整数编号。</p><h2 id="输出格式-10">输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 <spanclass="math inline">\(0\)</span>。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数 <spanclass="math inline">\(-1\)</span>，第二行输出需要修改订单的申请人编号。</p><h2 id="样例-1-10">样例 #1</h2><h3 id="样例输入-1-10">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">2 5 4 3 </span><br><span class="line">2 1 3 </span><br><span class="line">3 2 4 </span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-9">提示</h2><p>【输入输出样例说明】</p><p>第 <span class="math inline">\(1\)</span>份订单满足后，<spanclass="math inline">\(4\)</span>天剩余的教室数分别为 <spanclass="math inline">\(0,3,2,3\)</span>。第 <spanclass="math inline">\(2\)</span> 份订单要求第 <spanclass="math inline">\(2\)</span>天到第 <spanclass="math inline">\(4\)</span> 天每天提供<spanclass="math inline">\(3\)</span>个教室，而第 <spanclass="math inline">\(3\)</span> 天剩余的教室数为<spanclass="math inline">\(2\)</span>，因此无法满足。分配停止，通知第<spanclass="math inline">\(2\)</span> 个申请人修改订单。</p><p>【数据范围】</p><p>对于10%的数据，有<span class="math inline">\(1≤ n,m≤10\)</span>；</p><p>对于30%的数据，有<span class="math inline">\(1≤n,m≤1000\)</span>；</p><p>对于 70%的数据，有<span class="math inline">\(1 ≤ n,m ≤10^5\)</span>；</p><p>对于 100%的数据，有<span class="math inline">\(1 ≤ n,m ≤ 10^6,0 ≤r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n\)</span>。</p><p>NOIP 2012 提高组 第二天 第二题</p><p>2022.2.20 新增一组 hack 数据 ## 思路分析（这道当初也不会qwq，看了题解<ahref="https://www.luogu.com.cn/article/sncheqxz">大佬——皎月半洒花</a>的博客）还是想想暴力，可以暴力先枚举订单数量，然后减少可以使用的教室数目，直到超过上限为止，但是这肯定会TLE。想想怎么办？我们修改的是教室的数目，并且是一个区间，所以想到的是差分。因为需要找到哪一个不满足，所以加上二分进行查询即可。 引用大佬的话：</p><blockquote><p>一般来说，二分是个很有用的优化途径，因为这样会直接导致减半运算，而对于能否二分，有一个界定标准：状态的决策过程或者序列<strong>是否满足单调性或者可以局部舍弃性</strong>。而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p></blockquote><h2 id="ac代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">ll r[MAXN],d_j[MAXN],s_j[MAXN],t_j[MAXN],diff[MAXN],need[MAXN],ans,n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(diff,<span class="number">0</span>,<span class="built_in">sizeof</span>(diff));</span><br><span class="line">    <span class="comment">//利用差分进行区间修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        diff[s_j[i]]+=d_j[i];</span><br><span class="line">        diff[t_j[i]+<span class="number">1</span>]-=d_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得到每天需要的教室数目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        need[i]=need[i<span class="number">-1</span>]+diff[i];</span><br><span class="line">        <span class="comment">//看看每天的教室数目能否满足需求</span></span><br><span class="line">        <span class="keyword">if</span>(need[i]&gt;r[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;d_j[i]&gt;&gt;s_j[i]&gt;&gt;t_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以先判断是否能全部满足，如果能输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">1</span>,right=m;</span><br><span class="line">    <span class="comment">//二分的是订单号，check的是每天的教室数目能否满足</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4391</title>
      <link href="/2024/03/13/Luogu%20P4391/"/>
      <url>/2024/03/13/Luogu%20P4391/</url>
      
        <content type="html"><![CDATA[<h1 id="boi2009-radio-transmission-无线传输">[BOI2009] RadioTransmission 无线传输</h1><blockquote><h2 id="题目描述">题目描述</h2><p>给你一个字符串 <spanclass="math inline">\(s_1\)</span>，它是由某个字符串 <spanclass="math inline">\(s_2\)</span> 不断自我连接形成的（保证至少重复<span class="math inline">\(2\)</span> 次）。但是字符串 <spanclass="math inline">\(s_2\)</span>是不确定的，现在只想知道它的最短长度是多少。</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 <spanclass="math inline">\(L\)</span>，表示给出字符串的长度。</p><p>第二行给出字符串 <span class="math inline">\(s_1\)</span>的一个子串，全由小写字母组成。</p><h2 id="输出格式">输出格式</h2><p>仅一行，表示 <span class="math inline">\(s_2\)</span>的最短长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 cabcabca</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>3</code></p><h2 id="提示">提示</h2><h4id="样例输入输出-1-解释-对于样例我们可以利用-textttabc-不断自我连接得到-textttabcabcabcabc读入的-textttcabcabca是它的子串">样例输入输出1 解释 对于样例，我们可以利用 <spanclass="math inline">\(\texttt{abc}\)</span> 不断自我连接得到 <spanclass="math inline">\(\texttt{abcabcabcabc}\)</span>，读入的 <spanclass="math inline">\(\texttt{cabcabca}\)</span>，是它的子串。</h4><h4 id="规模与约定-对于全部的测试点保证-1-l-le-106">规模与约定对于全部的测试点，保证 <span class="math inline">\(1 &lt; L \le10^6\)</span>。</h4></blockquote><p>按照题意，我们要求的是<spanclass="math inline">\(s_2\)</span>的最短长度，也就是<spanclass="math inline">\(s_1\)</span>最小的循环字串。这里实际上有一个结论：答案就是<spanclass="math inline">\(n-pmt[n-1]\)</span>。(可能有的结论是<spanclass="math inline">\(n-pmt[n]\)</span>，只是因为下标是从1开始)具体证明可以看这篇博客：（写得很清楚了） <ahref="https://lyyy.blog.luogu.org/p4391-boi2009radio-transmission-wu-xian-zhuan-shu-ti-xie">大佬的详解</a>下面贴上代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充证明">补充证明</h2><p><imgsrc="https://img-blog.csdnimg.cn/direct/444dc91cd4ed450f93fd37e51a114e9d.png#pic_center"alt="在这里插入图片描述" /> 上面的前后缀是<spanclass="math inline">\(max(border)\)</span>。不妨记上面的前缀为<spanclass="math inline">\(s_1\)</span>，下面的后缀为<spanclass="math inline">\(s_2\)</span>。 我们可以发现<imgsrc="https://img-blog.csdnimg.cn/direct/be681483c20c45ec91851a924eecfe1b.png#pic_center"alt="在这里插入图片描述" /> 箭头联系起来的各部分是相等的，也就是<spanclass="math inline">\(s_1[1]=s_2[2]、s_1[2]=s_2[3]、s_1[3]=s_2[4]······\)</span>，由此类推。同时，又因为<spanclass="math inline">\(s_1[1]=s_2[1]、s_1[2]=s_2[2]、s_1[3]=s_2[3]······\)</span>，将两者联系起来，我们可以得到：<spanclass="math display">\[s_1[i]=s_2[j]|1&lt;=i&lt;=5，1&lt;=j&lt;=5\]</span>那有没有可能：更一般的情况是：<spanclass="math inline">\(s_1\)</span>红色部分的后面加上一小段普通的字符串<spanclass="math inline">\(t\)</span>。我们可以分析一下：实际上这是可能的。我们可以结合样例进行分析。（这里不写了，样例的解释很清楚，可以认为：最后的循环节被强行切割了一部分。）所以我们总结一下上面的内容：红色部分的字符串就是我们要求的最小循环节了。所以问题转化为：求<span class="math inline">\(max(border)\)</span>。只需要求出<span class="math inline">\(pmt[n-1]\)</span>即可，那么<spanclass="math inline">\(n-pmt[n-1]\)</span>就是答案了。</p><h2 id="ac代码">AC代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 929(Div.3)</title>
      <link href="/2024/03/13/Codeforces%20Round%20929(Div.3)/"/>
      <url>/2024/03/13/Codeforces%20Round%20929(Div.3)/</url>
      
        <content type="html"><![CDATA[<h1 id="problem-a"><ahref="https://codeforces.com/contest/1933/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接累计各元素绝对值即可 ## AC代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans+=x;</span><br><span class="line">        <span class="keyword">else</span> ans-=x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> # <ahref="https://codeforces.com/contest/1933/problem/B">Problem B</a> ##思路分析 两种操作：去除一个元素，或者某个元素+1。 其实可以发现，<spanclass="math inline">\(sum\)</span>%<spanclass="math inline">\(3\)</span>结果只有<spanclass="math inline">\(0,1,2\)</span>. <spanclass="math inline">\(0：\)</span>直接输出0即可。 <spanclass="math inline">\(1：\)</span>要不删去一个元素(其取模结果为1)，要不加2，所以可以用个<spanclass="math inline">\(flag\)</span>，看看有没有这样的元素存在。 <spanclass="math inline">\(2：\)</span>要不删去一个元素，要不加1，无所谓，都是两次操作。## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,flag=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)flag=<span class="number">1</span>;</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-c"><ahref="https://codeforces.com/contest/1933/problem/C">Problem C</a></h1><h2 id="思路分析-1">思路分析</h2><p>坐牢的开始qwq，自己想得太复杂了，其实直接用快速幂枚举<spanclass="math inline">\(x,y\)</span>即可（看了队里大佬的代码）。这里去重有个小技巧，可以用<spanclass="math inline">\(set\)</span>，这样就可以不用写判断是否重复的条件（set可以直接去重），最后输出<spanclass="math inline">\(set.size()\)</span>即可。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpower</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans*=a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,l;cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;<span class="built_in">quickpower</span>(a,x)&lt;=l;x++)&#123;</span><br><span class="line">        <span class="comment">//注意y的枚举条件是quickpower(a,x)*quickpower(b,y)&lt;=l</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; <span class="built_in">quickpower</span>(a,x)*<span class="built_in">quickpower</span>(b,y)&lt;=l;y++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">quickpower</span>(a,x)* <span class="built_in">quickpower</span>(b,y);</span><br><span class="line">            <span class="keyword">if</span>(l%num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//将l/num存入set中</span></span><br><span class="line">                s.<span class="built_in">insert</span>(l/num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-d"><ahref="https://codeforces.com/contest/1933/problem/D">Problem D</a></h1><h2 id="思路分析-2">思路分析</h2><p>看看样例，可以大胆猜测一下，先从小到大排序，可以发现，<spanclass="math inline">\(SmallElememt\)</span>%<spanclass="math inline">\(BigElememt\)</span>肯定不为0，那么这样贪心排序下来，如果可以得到结果不为0，满足题意，直接<spanclass="math inline">\(return\)</span>即可。但是，需要特判是否有相同的情况，只需要考虑<spanclass="math inline">\(a_0、a_1\)</span>即可，后面是否连续无影响，如果<spanclass="math inline">\(a_0==a_1\)</span>，则不满足题意。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//元素按照从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=a[<span class="number">0</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果%!=0，输出yes</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%a[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="problem-e"><ahref="https://codeforces.com/contest/1933/problem/E">Problem E</a></h1><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 928(Div.4)</title>
      <link href="/2024/03/13/Codeforces%20Round%20928(Div.4)/"/>
      <url>/2024/03/13/Codeforces%20Round%20928(Div.4)/</url>
      
        <content type="html"><![CDATA[<h1 id="problem-a"><ahref="https://codeforces.com/contest/1926/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接模拟即可 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">5</span>-a)cout&lt;&lt;<span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-b"><ahref="https://codeforces.com/contest/1926/problem/B">Problem B</a></h1><h2 id="思路分析-1">思路分析</h2><p>我的思路是：当统计每一行1的个数，当第<spanclass="math inline">\(i\)</span>与第<spanclass="math inline">\(i-1\)</span>行中统计到的1的个数（前提是这两行中1的个数不为0）不同时，就是三角形，否则是正方形。</p><p>一开始的时候WA了一次，就是没考虑到第<spanclass="math inline">\(i\)</span>行与第<spanclass="math inline">\(i+1\)</span>行中1的个数都得不为0 ## WA代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚写博客的时候想到可以改进一下，如果<spanclass="math inline">\(flag==1\)</span>了，那么后面的输入其实都是没有意义的，也就不需要统计和判断了，修改如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;!flag;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i]&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-c"><ahref="https://codeforces.com/contest/1926/problem/C">Problem C</a></h1><h2 id="思路分析-2">思路分析</h2><p>其实是一个见过很多次的操作了qwq，先离线处理计算（没错，就是你想的暴力计算<spanclass="math inline">\(qwq\)</span>）出所有在数据范围内的答案，然后用一个数组将其存下即可。这样可以做到<spanclass="math inline">\(O(1)询问\)</span>，预处理时间是<spanclass="math inline">\(O(MAXN)\)</span>，总的时间复杂度为<spanclass="math inline">\(O(MAXN+n)\)</span> ## AC代码 具体细节看看代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x的各位数字拆解，并统计各位数字总和</span></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        tot+=(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//直接输出计算好的ans[n]即可</span></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">        <span class="comment">//需要用前缀和数组存下来，因为后面有多次询问，所以需要对应记录哪个i，对应哪个ans[i]</span></span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]+<span class="built_in">cal</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-d"><ahref="https://codeforces.com/contest/1926/problem/D">Problem D</a></h1><h2 id="思路分析-3">思路分析</h2><p>题目的意思：将给的数字分成若干组，同一组中的若干个数字之间，他们的二进制形式的每一位必须都是不同的，求最小组数我们可以先分析同一组中的数字有什么特点： <imgsrc="https://img-blog.csdnimg.cn/direct/064ba75fccfd477c99803f52409a641e.png#pic_center"alt="在这里插入图片描述" />那么我们可以根据这个性质，来求解这道题了，具体还得看代码。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LUOGU_RID: 148392530</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//book：输入的数字x的个数，可以理解为存放x的库</span></span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//查看存放 x对应的异或数（记作y）的库 是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x])&#123;</span><br><span class="line">            <span class="comment">//如果存在，那么book[y]的数量--</span></span><br><span class="line">            book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x]--;</span><br><span class="line">            <span class="comment">//说明可以创建出一组满组（也就是有x，y的组），ans++，统计一下</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，book[x]++，说明x库中x的数量增加了一个</span></span><br><span class="line">        <span class="keyword">else</span> book[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再遍历一下无法找到 对应的y 的x，那么他们只能单独成组了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:book)&#123;</span><br><span class="line">        ans+=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="problem-e"><ahref="https://codeforces.com/contest/1926/problem/E">Problem E</a></h1><h2 id="思路分析-4">思路分析</h2><p>可以先模拟一下题目说的流程： <imgsrc="https://img-blog.csdnimg.cn/direct/c675e02c15524d56a0222edca40eef9e.png#pic_center"alt="在这里插入图片描述" /> ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意得向上取整</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;(n+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tot=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        k-=tot;</span><br><span class="line">        <span class="comment">//注意总数/2</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//轮数++</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说实话，我也没太懂为什么是2*k-1</span></span><br><span class="line">    <span class="comment">//owo 我们每一次删除的时候删的是K*(1,3,5······)，所以这里2*k-1，才是对应删的奇数（K泛指系数）</span></span><br><span class="line">    cout&lt;&lt;((<span class="number">2</span>*k<span class="number">-1</span>)&lt;&lt;cnt)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Edu 162</title>
      <link href="/2024/03/13/Codeforces%20Edu%20162/"/>
      <url>/2024/03/13/Codeforces%20Edu%20162/</url>
      
        <content type="html"><![CDATA[<h2 id="problem-a"><ahref="https://codeforces.com/contest/1923/problem/A">Problem A</a></h2><h3 id="思路分析">思路分析</h3><p>贪心，因为<spanclass="math inline">\(chips\)</span>只能左移到最近的空格子，所以其实只需要考虑在最长的以1开头和以1结尾的串内（记作<spanclass="math inline">\(s\)</span>）移动即可（其他部分没用，不然只会做多余的移动）。至于怎么移，可以想象把从第一个1串右端的所有1串保持成串的形式，轮流滚近第一个1串，恰好接上为止，可以证明，滚的次数恰好就是<spanclass="math inline">\(s\)</span>内0的个数。 画个图比较好理解： <imgsrc="https://img-blog.csdnimg.cn/direct/52b551df24b94fe297337faaa27b22d7.png#pic_center"alt="在这里插入图片描述" /> 不难发现：答案就是<spanclass="math inline">\(s\)</span>中0的个数，可以多结合几个样例分析一下。### 代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l=MAXN,r,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//预处理出最长的$s$串的左右端点，注意l初始化为MAXN，并且统计出1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;    </span><br><span class="line">            r=i;</span><br><span class="line">            l=<span class="built_in">min</span>(l,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r-l+<span class="number">1</span>-cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//求出0的个数，也就是最少的移动次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-b"><ahref="https://codeforces.com/contest/1923/problem/B">Problem B</a></h2><h3 id="思路分析-1">思路分析</h3><p>贪心，很显然，肯定是需要先打举例我们最近的怪物，再打次近的怪物，依此类推，只要在其中，有一个怪物打不死，那么我们就输了。所以这里可以用到前缀和，预处理出前<spanclass="math inline">\(i\)</span>个最近的怪物们的总血量（记作<spanclass="math inline">\(pre[i]\)</span>），如果在对应的这段时间内，（也就是<spanclass="math inline">\(abs(a[i].pos)\)</span>），我们打出的子弹数<spanclass="math inline">\(k*abs(a[i].pos)&lt;pre[i]\)</span>，那么我们就输出<spanclass="math inline">\(NO\)</span>直接判掉。注意得先派个序，按距离从小到大，可以用结构体+<spanclass="math inline">\(cmp\)</span>。 ### 代码实现</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll hp,pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.pos)&lt;<span class="built_in">abs</span>(b.pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,k,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].hp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].pos;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=a[i].hp;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;k*<span class="built_in">abs</span>(a[i].pos))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="problem-c"><ahref="https://codeforces.com/contest/1923/problem/C">Problem C</a></h2><h3 id="思路分析-2">思路分析</h3><p>其实就是看能否根据给出的子数组，构造出一个好数组（被翻译坑了）。怎么构造？？？总和相同，但是相同位置的元素不同，并且元素都大于0。有一个比较容易实现的想法：就是在原有的基础上，部分元素加1，显然，有一些元素需要减少，但是又不能减太多（不然就小于0了）。这其中就有一个比较特别的元素：1。1只能加，不能减，那么要加多少个1（记作<spanclass="math inline">\(x\)</span>）就只能由其他非一元素（能够贡献的记作<spanclass="math inline">\(y\)</span>）贡献了。</p><h3 id="代码实现">代码实现</h3><p>可以用前缀和，预处理出在各个区间内1的个数，以及各个区间内非一元素的最大贡献。这里有用到一些小技巧：可以先在输入<spanclass="math inline">\(a[i]\)</span>时，将<spanclass="math inline">\(a[i]--\)</span>，这样求出来<spanclass="math inline">\(sum[r]-sum[l-1]\)</span>就是<spanclass="math inline">\(y\)</span>了。 需要注意特判一下：如果<spanclass="math inline">\(l==r\)</span>，那么我们就无法构造出好数组（很显然）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,q,l,r,tot;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">cnt</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];       <span class="comment">//预处理出前i个元素的最大贡献</span></span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);  <span class="comment">//预处理出前i个元素中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ll x=cnt[r]-cnt[l<span class="number">-1</span>];</span><br><span class="line">        ll y=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==r||x&gt;y)cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;  <span class="comment">//无法满足或者长度为1，就NO，否则YES</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="problem-d"><ahref="https://codeforces.com/contest/1923/problem/D">Problem D</a></h2><h3 id="思路分析-3">思路分析</h3><p>分析题意，很容易想到<spanclass="math inline">\(i-nd\)</span>史莱姆只能被左边的或者右边的吃掉，先分析左边的情况。假设<span class="math inline">\(i\)</span>（偷懒，其实是<spanclass="math inline">\(i-nd\)</span>史莱姆，下面也一样）被左边的史莱姆吃掉，先做一些定义：<span class="math inline">\(ans[i]\)</span>：被吃掉的最小操作次数。<span class="math inline">\(l[i]\)</span>：第<spanclass="math inline">\(i\)</span>个数字的上一个与<spanclass="math inline">\(a[i]\)</span>不同的位置。 <spanclass="math inline">\(left\)</span>：记录一个区间的左端点。</p><p>如果存在<span class="math inline">\(left\)</span>，使得： 1、<spanclass="math inline">\([left,i-1]\)</span>区间的和&gt;<spanclass="math inline">\(ans[i]\)</span>。 2、<spanclass="math inline">\([left,i-1]\)</span>区间数字种类<spanclass="math inline">\(&gt;=2\)</span>（因为相同不能互相吞并，那么最少需两种大小不同的史莱姆）。那么操作次数就是:<span class="math inline">\(i-left\)</span>。</p><p>可以发现<spanclass="math inline">\(i-1\)</span>其实是固定的（对于每一个<spanclass="math inline">\(i\)</span>来说）,并且<spanclass="math inline">\(left\)</span>越小，区间和越大，反之，区间和越小，所以想到可以用二分。那么我们就需要用前缀和求出区间和，再用二分求出端点位置。</p><p>但是怎么判断<spanclass="math inline">\([left,i-1]\)</span>区间数字种类<spanclass="math inline">\(&gt;=2\)</span>，这时候<spanclass="math inline">\(l[i]\)</span>就派上用场了。二分的左右端点分别为<spanclass="math inline">\(left\)</span>（这里的<spanclass="math inline">\(left\)</span>与上面的<spanclass="math inline">\(left\)</span>无关，是完全不同的两个），<spanclass="math inline">\(right\)</span>。中间值为<spanclass="math inline">\(mid\)</span>。 如果<spanclass="math inline">\(mid&gt;l[i-1]\)</span>，那么第二个条件就不成立（此时区间数字种类只有1）.</p><p>基本上就分析完了，但是如果是右边怎么办，我们只需要将数组反转即可。</p><h3 id="代码实现-1">代码实现</h3><p>一些细节可以看注释 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(MAXN)</span>,<span class="title">pre</span><span class="params">(MAXN)</span>,<span class="title">l</span><span class="params">(MAXN)</span>,<span class="title">ans</span><span class="params">(MAXN)</span>,<span class="title">b</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//其实跟下面的条件2判断一样，也就是前面的一段全都是同一个数字</span></span><br><span class="line">    <span class="comment">//思路是参考RegenFallen大佬的，但我感觉这一行不用加上去，因为不可能二分到位置为0，试了一下，删去也AC了，所以加不加无所谓</span></span><br><span class="line">    <span class="comment">//if(x&lt;=0)return 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件2：区间内数字种类小于2</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;l[i<span class="number">-1</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//条件1</span></span><br><span class="line">    <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[x<span class="number">-1</span>]&gt;a[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[n-i+<span class="number">1</span>]=a[i];    <span class="comment">//先反转，存起来</span></span><br><span class="line">        ans[i]=<span class="number">1e9</span>;       <span class="comment">//ans[i]先预处理为1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];         <span class="comment">//预处理出前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];  <span class="comment">//预处理出l[i],可以举几个例子：0333332222</span></span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右端点都得判，先判右，再判左，可以保证求出来ans[i]最小，并且有可能右端点不满足（check==false），所以左端点也必须得判断。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[i]=<span class="built_in">min</span>(ans[i],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[i]=<span class="built_in">min</span>(ans[i],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来就是相同的操作，但是注意ans数组的下标要反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[n-i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans[i]==<span class="number">1e9</span>?<span class="number">-1</span>:ans[i])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="problem-e"><ahref="https://codeforces.com/contest/1923/problem/E">Problem E</a></h2><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1029A</title>
      <link href="/2024/03/13/CF1029A/"/>
      <url>/2024/03/13/CF1029A/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="many-equal-substrings">Many Equal Substrings</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>你有一个字符串t，它由n个字母组成。</p><p>定义一个字符串s的子串为s[l...r]，表示从位置l到r构成的一个新的串。</p><p>你的目标是构造一个字符串s，使得它的可能长度最小，要求s中存在k个位置i,可以找到k个以i为出发点的子串t。</p><p>输入： 第一行输入两个整数n和k，表示t的长度和需要k个子串</p><p>第二行输入字符串t</p><p>输出：</p><p>输出满足条件的长度最小的s。题目保证答案唯一。</p><h2 id="题目描述">题目描述</h2><p>You are given a string $ t $ consisting of $ n $ lowercase Latinletters and an integer number $ k $ .</p><p>Let's define a substring of some string $ s $ with indices from $ l $to $ r $ as $ s[l r] $ .</p><p>Your task is to construct such string $ s $ of minimum possiblelength that there are exactly $ k $ positions $ i $ such that $ s[i i +n - 1] = t $ . In other words, your task is to construct such string $ s$ of minimum possible length that there are exactly $ k $ substrings of$ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="输入格式">输入格式</h2><p>The first line of the input contains two integers $ n $ and $ k $ ( $1 n, k $ ) — the length of the string $ t $ and the number ofsubstrings.</p><p>The second line of the input contains the string $ t $ consisting ofexactly $ n $ lowercase Latin letters.</p><h2 id="输出格式">输出格式</h2><p>Print such string $ s $ of minimum possible length that there areexactly $ k $ substrings of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 4 aba</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababababa</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>3 2 cat</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>catcat</code></p></blockquote><p>看到这道题要求的答案，想到了熟悉的循环节问题，就从这入手吧。还是先求出来<spanclass="math inline">\(t\)</span>的最小的循环节（记作<spanclass="math inline">\(p\)</span>），并根据<spanclass="math inline">\(k\)</span>进行多次构造。</p><p>但是，通过样例一可以发现，构造出来的<spanclass="math inline">\(s\)</span>可能不是恰好由整数个<spanclass="math inline">\(p\)</span>构成。看样例一，可以发现最后恰好是由<spanclass="math inline">\(pmt[n-1]\)</span>构成。</p><p>根据题意，可以总结出：前面输出<spanclass="math inline">\(k-1\)</span>个循环节，后面输出<spanclass="math inline">\(t\)</span>即可。 因为前面的<spanclass="math inline">\(k-1\)</span>个循环节首尾相连，已经是构成了<spanclass="math inline">\(k-1\)</span>个<spanclass="math inline">\(t\)</span>结构了。 ## AC代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>()-pmt[s.<span class="built_in">length</span>()<span class="number">-1</span>];j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF45D</title>
      <link href="/2024/03/13/CF54D/"/>
      <url>/2024/03/13/CF54D/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="writing-a-song">Writing a Song</h1><h2 id="题面翻译">题面翻译</h2><p><strong>题目大意</strong></p><p>求一个字符串s，满足该串长度为n，只出现字母表中前k个字母，并且在指定位置必须出现指定字符串p</p><p><strong>输入格式</strong></p><p>第一行 n，k。(n为所需字符串的长度 n&lt;=100，k为相应的字母大小2&lt;=k&lt;=26)</p><p>第二行 p。（一个长度小于n，只包含字母表中前k个字母的字符串）</p><p>第三行01串。（在第i个位置的数字1表示p的出现应该从s的第i个位置开始，而0表示从这里开始没有出现。）</p><p><strong>输出格式</strong></p><p>输出任意一个符合题意的字符串s</p><p>若无，输出“No solution”</p><h2 id="题目描述">题目描述</h2><p>One of the Hedgehog and his friend's favorite entertainments is totake some sentence or a song and replace half of the words (sometimeseven all of them) with each other's names.</p><p>The friend's birthday is approaching and the Hedgehog decided to makea special present to his friend: a very long song, where his name willbe repeated many times. But try as he might, he can't write a decentsong!</p><p>The problem is that the Hedgehog has already decided how long theresulting sentence should be (i.e. how many letters it should contain)and in which positions in the sentence the friend's name should occur,and it must not occur in any other position in the sentence. Besides,the Hedgehog decided to limit himself to using only the first $ K $letters of an English alphabet in this sentence (so it will be not evena sentence, but one long word).</p><p>The resulting problem is indeed quite complicated, that's why theHedgehog asks you to help him and write a program that will make thedesired word by the given name $ P $ , the length $ N $ of the requiredword, the given positions of the occurrences of the name $ P $ in thedesired word and the alphabet's size $ K $ . Note that the occurrencesof the name can overlap with each other.</p><h2 id="输入格式">输入格式</h2><p>The first line contains numbers $ N $ and $ K $ which are the lengthof the required string and the alphabet size accordingly. Thelimitations are: $ 1&lt;=N&lt;=100 $ , $ 2&lt;=K&lt;=26 $ .</p><p>The second line contains the name $ P $ which is a non-empty stringwhose length does not exceed $ N $ characters. The string consists onlyof the first $ K $ lowercase symbols of an English alphabet.</p><p>The third line contains the string of length $ N-length(P)+1 $ ,consisting only of numbers zero and one. A number one in the $ i $ -thposition means that an occurrence of the name $ P $ should start from $i $ -th position of the desired word, while a zero means that there isno occurrence starting here.</p><h2 id="输出格式">输出格式</h2><p>Print the desired word $ S $ . If there are several answers, printany of them.</p><p>If there is no solution, then print "No solution".</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>5 2 aba 101</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababa</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>5 2 a 10001</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>abbba</code></p><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><p><code>6 2 abba 101</code></p><h3 id="样例输出-3">样例输出 #3</h3><p><code>No solution</code></p></blockquote><p>可怕的构造题，不会qwq，只能看题解区大佬了（大佬讲得很清楚）：https://www.luogu.com.cn/problem/solution/CF54D构造这方面得加强qwq，贴上AC代码：</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    string p;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> lenp=p.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> lens=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i+j]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ans[i+j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p[j]==<span class="string">&#x27;a&#x27;</span>)ans[i+j]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                        <span class="keyword">else</span> ans[i+j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])ans[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉还是得多想想特殊情况：1、搜索1的时候：有没有重复占位，也就是<spanclass="math inline">\(ans[i+j]\)</span>存在，并且<spanclass="math inline">\(ans[i+j]!=p[j]\)</span>，如果存在，说明该位已经被占领了，直接<spanclass="math inline">\(No\)</span> <spanclass="math inline">\(solution\)</span>。2、搜索0的时候：看看有没有<spanclass="math inline">\(ans[i+j]\)</span>存在，并且<spanclass="math inline">\(ans[i+j]!=p[j]\)</span>，如果存在，则该位构造成功，直接<spanclass="math inline">\(break\)</span>，不用做重复的判断。3、如果2的情况没有发生，我们发现这里实际上只有两种情况（与上面相对应）：<spanclass="math inline">\(ans[i+j]==0\)</span> <spanclass="math inline">\(or\)</span> <spanclass="math inline">\(ans[i+j]==p[j]\)</span>。第二种情况已经没办法改变了（因为我们在上面的构造时已经确定<spanclass="math inline">\(ans[i+j]==p[j]\)</span>），那么我们只能改变第一种情况，看看<spanclass="math inline">\(s[j]\)</span>是什么，那么<spanclass="math inline">\(ans[i+j]\)</span>构造时只需要注意不等于<spanclass="math inline">\(s[j]\)</span>即可（这里情况一存在的话，可以直接构造后<spanclass="math inline">\(break\)</span>掉，提高一点效率，后面输出时再简单构造即可）。4、如果情况一也没有发生呢？？？很不幸，那就只能<spanclass="math inline">\(No\)</span> <spanclass="math inline">\(solution\)</span>了。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF126B</title>
      <link href="/2024/03/13/CF126B/"/>
      <url>/2024/03/13/CF126B/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="password">Password</h1><h2 id="题面翻译">题面翻译</h2><p>Asterix，Obelix 和他们的临时伙伴 Suffix、Prefix已经最终找到了和谐寺。然而和谐寺大门紧闭，就连 Obelix的运气也没好到能打开它。</p><p>不久他们发现了一个字符串 <span class="math inline">\(S\(1\leqslant\vertS\vert\leqslant1000000)\)</span>，刻在和谐寺大门下面的岩石上。Asterix猜想那一定是打开寺庙大门的密码，于是就大声将字符串朗读了出来，然而并没有什么事发生。于是Asterix 又猜想密码一定是字符串 <span class="math inline">\(S\)</span>的子串 <span class="math inline">\(T\)</span>。</p><p>Prefix 认为 <span class="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的前缀，Suffix 认为 <spanclass="math inline">\(T\)</span> 是 <spanclass="math inline">\(S\)</span> 的后缀，Obelix 却认为 <spanclass="math inline">\(T\)</span> 应该是 <spanclass="math inline">\(S\)</span> 中的某一部分，也就是说，<spanclass="math inline">\(T\)</span> 既不是 <spanclass="math inline">\(S\)</span> 的前缀，也不是 <spanclass="math inline">\(S\)</span> 的后缀。</p><p>Asterix 选择子串 <span class="math inline">\(T\)</span>来满足所有伙伴们的想法。同时，在所有可以被接受的子串变形中，Asterix选择了最长的一个。当 Asterix 大声读出子串 <spanclass="math inline">\(T\)</span>时，寺庙的大门开了。（也就是说，你需要找到既是 <spanclass="math inline">\(S\)</span> 的前缀又是 <spanclass="math inline">\(S\)</span> 的后缀同时又在 <spanclass="math inline">\(S\)</span> 中间出现过的最长子串）</p><p>现在给你字符串 <spanclass="math inline">\(S\)</span>，你需要找到满足上述要求的子串 <spanclass="math inline">\(T\)</span>。</p><h3 id="输入格式">输入格式</h3><p>一行一个只包含小写字母的字符串 <spanclass="math inline">\(S\)</span>。</p><h3 id="输出格式">输出格式</h3><p>输出子串 <span class="math inline">\(T\)</span>，如果 <spanclass="math inline">\(T\)</span> 不存在，输出<code>Just a legend</code>。</p><h2 id="题目描述">题目描述</h2><p>Asterix, Obelix and their temporary buddies Suffix and Prefix hasfinally found the Harmony temple. However, its doors were firmly lockedand even Obelix had no luck opening them.</p><p>A little later they found a string $ s $ , carved on a rock below thetemple's gates. Asterix supposed that that's the password that opens thetemple and read the string aloud. However, nothing happened. ThenAsterix supposed that a password is some substring $ t $ of the string $s $ .</p><p>Prefix supposed that the substring $ t $ is the beginning of thestring $ s $ ; Suffix supposed that the substring $ t $ should be theend of the string $ s $ ; and Obelix supposed that $ t $ should belocated somewhere inside the string $ s $ , that is, $ t $ is neitherits beginning, nor its end.</p><p>Asterix chose the substring $ t $ so as to please all his companions.Besides, from all acceptable variants Asterix chose the longest one (asAsterix loves long strings). When Asterix read the substring $ t $aloud, the temple doors opened.</p><p>You know the string $ s $ . Find the substring $ t $ or determinethat such substring does not exist and all that's been written above isjust a nice legend.</p><h2 id="输入格式-1">输入格式</h2><p>You are given the string $ s $ whose length can vary from $ 1 $ to $10^{6} $ (inclusive), consisting of small Latin letters.</p><h2 id="输出格式-1">输出格式</h2><p>Print the string $ t $ . If a suitable $ t $ string does not exist,then print "Just a legend" without the quotes.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>fixprefixsuffix</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>fix</code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>abcdabc</code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>Just a legend</code></p></blockquote><p>看到这题的第一眼，想到的肯定是KMP（因为需要求最长公共前后缀嘛，将其记作<spanclass="math inline">\(t\)</span>，母串记作<spanclass="math inline">\(s\)</span>）。 但是，<spanclass="math inline">\(t\)</span>还需要是<spanclass="math inline">\(s\)</span>的中间部分，这个怎么办？？？我们可以将它转化为熟悉的问题，画个图解释一下： <imgsrc="https://img-blog.csdnimg.cn/direct/3fa1ee27e9eb4e6d8580999418d6f7b0.png#pic_center"alt="在这里插入图片描述" />这样就一目了然了吧，<spanclass="math inline">\(t\)</span>也是中间的橙色串的最长前后缀，这就转化成了我们熟悉的问题。</p><p>那么我们只要<span class="math inline">\(2\)</span>遍历到<spanclass="math inline">\(n-2\)</span>，只要<spanclass="math inline">\(pmt[i]==pmt[n-1]\)</span>，那么我们就找到最长的<spanclass="math inline">\(t\)</span>了。</p><p>但是，实际上可能是找不到的（看题意就知道了），如果<spanclass="math inline">\(pmt[n-1]\)</span>比<spanclass="math inline">\(max(pmt[i])\)</span>还大，所以这时<spanclass="math inline">\(t\)</span>的长度就得缩小了（也就是不断地往回跳：<spanclass="math inline">\(pmt[pmt[n-1]]\)</span>，<spanclass="math inline">\(pmt[pmt[pmt[n-1]]]······\)</span>，直到小于<spanclass="math inline">\(max(pmt[i])\)</span>，注意<spanclass="math inline">\(i&lt;=n-2\)</span>）。</p><p>可能有点混乱，将上述的步骤总结一下： 1、先预处理出<spanclass="math inline">\(max(pmt[i])，i&lt;=n-2\)</span>。 2、判断<spanclass="math inline">\(pmt[n-1]\)</span>与<spanclass="math inline">\(max(pmt[i])\)</span>的大小关系，如果<spanclass="math inline">\(pmt[n-1]&gt;=max(pmt[i])\)</span>，就得往回跳，直到小于<spanclass="math inline">\(max(pmt[i])\)</span>为止（记作<spanclass="math inline">\(len\)</span>吧)，当然有可能跳到0，那么这时候就无解了。3、如果有解，那么我们只需要输出<spanclass="math inline">\(0\)</span>~<spanclass="math inline">\(len-1\)</span>即可，毕竟<spanclass="math inline">\(len\)</span>是字符串的长度。</p><p>我们可以在第二步开始前加上特判<spanclass="math inline">\(pmt[n-1]==0\)</span>是否成立，如果成立，就说明前后缀不同，肯定无解。</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],maxn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,pmt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len=pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;maxn)&#123;</span><br><span class="line">            len=pmt[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                cout&lt;&lt;s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA1328</title>
      <link href="/2024/03/13/UVA1328/"/>
      <url>/2024/03/13/UVA1328/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="period">Period</h1><h2 id="题面翻译">题面翻译</h2><p>对于给定字符串 <span class="math inline">\(S\)</span>的每个前缀，我们想知道它是否为周期串（周期串定义为由若干最小循环节拼接而成的字符串），若是，输出前缀长度和循环节数量。</p><p><strong>【输入格式】</strong></p><p>多组数据，每组数据第一行一个整数 <spanclass="math inline">\(n\)</span>，表示字符串 <spanclass="math inline">\(s\)</span> 的长度，若 <spanclass="math inline">\(n=0\)</span> 则结束输入。</p><p>若 <span class="math inline">\(n\ne0\)</span>，则第二行一个字符串<span class="math inline">\(S\)</span>，如题意。</p><p><strong>【输出格式】</strong></p><p>对于第 <span class="math inline">\(i\)</span>组输出，第一行一个字符串 <code>Test case #i</code>。</p><p>之后若干行一行两个整数，表示如果字符串 <spanclass="math inline">\(S\)</span>的一个前缀是周期串，它的长度和循环节数量（注意这里的循环节是指<strong>长度最小的</strong>循环节）。</p><p>之后再空一行。</p><p><strong>【说明】</strong></p><p><span class="math inline">\(n\leq10^6\)</span>，字符串 <spanclass="math inline">\(S\)</span> 均由小写字母构成。</p><h2 id="题目描述">题目描述</h2><p><ahref="https://uva.onlinejudge.org/external/13/p1328.pdf">PDF</a></p><h2 id="输入格式">输入格式</h2><h2 id="输出格式">输出格式</h2><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 aaa 12 aabaabaabaab 0</code></p><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><figcaption><span>case #1 2 2 3 3</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Test case #2 2 2 6 2 9 3 12 4 ```</span><br><span class="line"></span><br><span class="line">还是熟悉的最小循环节问题，需要注意的是，前缀长度需要大于1，所以需要从2开始判断，最大前缀长度就是$S$的长度。</span><br><span class="line"></span><br><span class="line">判断有没有循环节，看$pmt[i-1]$是否存在，计算循环节数量，看$n$%$(n-pmt[n-1])$是否等于0（因为$S$的前缀串$t$需要作为周期串）。</span><br><span class="line"></span><br><span class="line">每个测试点之间的空行特判一下即可，看$i==len$是否成立。</span><br><span class="line"></span><br><span class="line">## AC代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll=long long;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">int pmt[MAXN],n,cnt;</span><br><span class="line">string s;</span><br><span class="line">void get_pmt(const string&amp; s)&#123;</span><br><span class="line">   for(int i=1,j=0;i&lt;s.length();i++)&#123;</span><br><span class="line">       while(j&amp;&amp;s[i]!=s[j])j=pmt[j-1];</span><br><span class="line">       if(s[i]==s[j])j++;</span><br><span class="line">       pmt[i]=j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">   ios::sync_with_stdio(0),cin.tie(0);</span><br><span class="line">   while(1)&#123;</span><br><span class="line">       cin&gt;&gt;n;</span><br><span class="line">       if(n==0)break;</span><br><span class="line">       cin&gt;&gt;s;</span><br><span class="line">       int len=s.length();</span><br><span class="line">       memset(pmt,0,sizeof(pmt));</span><br><span class="line">       get_pmt(s);</span><br><span class="line">       cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;++cnt&lt;&lt;&quot;\n&quot;;</span><br><span class="line">       for(int i=2;i&lt;=len;i++)&#123;</span><br><span class="line">           if(pmt[i-1]&amp;&amp;i%(i-pmt[i-1])==0)&#123;</span><br><span class="line">               cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i/(i-pmt[i-1])&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           if(i==len)&#123;</span><br><span class="line">               cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA10298</title>
      <link href="/2024/03/13/UVA10298/"/>
      <url>/2024/03/13/UVA10298/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="power-strings">Power Strings</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题意简述">题意简述：</h3><p>求一个字符串由多少个重复的子串连接而成。</p><p>例如 <code>ababab</code> 由三个 <code>ab</code>连接而成，<code>abcd</code> 由 <code>abcd</code> 由一个<code>abcd</code> 连接而成。</p><h3 id="输入格式">输入格式</h3><p><strong>本题多组数据</strong>。</p><p>每一组数据仅有一行，这一行仅有一个字符串 <spanclass="math inline">\(s\)</span>。</p><p>输入的结束标志为一个 <code>.</code>。</p><h3 id="输出格式">输出格式</h3><p>对于每一组数据，输出这组字符串由多少个重复的子串连接而成。</p><h3 id="说明提示">说明/提示</h3><p><span class="math inline">\(1\le |s|\le 10^6\)</span>。</p><h2 id="题目描述">题目描述</h2><p><ahref="https://uva.onlinejudge.org/external/102/p10298.pdf">PDF</a></p><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/5a89b1b5be26ca2d032d51c4fc5e18d2.png" /></p><h2 id="输入格式-1">输入格式</h2><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/aa5c61819fa5b54135f8b7236af00a7e.png" /></p><h2 id="输出格式-1">输出格式</h2><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/795c5ef49846eb46a838271a5812fff1.png" /></p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>abcd aaaa ababab .</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 4 3</code></p></blockquote><p>其实方法还是一样的，求出最短的循环节(记作<spanclass="math inline">\(p\)</span>)，也就是<spanclass="math inline">\(n-pmt[n-1]\)</span>，然后就是<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>。但是，这里需要注意的是：<spanclass="math inline">\(s\)</span>可能不是由整数个<spanclass="math inline">\(p\)</span>构成的，可能存在最后的<spanclass="math inline">\(p\)</span>被切割的情况。（一开始没考虑到这点，看了题解才反应过来）。那么这里就需要进行特叛了：如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])==0\)</span>，说明恰好整除，那么<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>就是答案了。 如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])!=0\)</span>，那么只能以<spanclass="math inline">\(s\)</span>自身作为循环节了，答案也就是1。具体的证明可以看看评论区的大佬，写的很好：https://www.luogu.com.cn/blog/hzz/solution-uva10298</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">get_pmt</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%(n-pmt[n<span class="number">-1</span>])==<span class="number">0</span>)cout&lt;&lt;n/(n-pmt[n<span class="number">-1</span>])&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>因为这道题目是有多个数据输入，且一行一个<spanclass="math inline">\(s\)</span>，所以我们可以用<spanclass="math inline">\(getlin(cin,s)\)</span>，只需要当<spanclass="math inline">\(s\)</span>为"<spanclass="math inline">\(.\)</span>"时结束即可。</p><h2 id="结论总结">结论总结：</h2><p>设字符串的长度为<spanclass="math inline">\(n\)</span>，最长相同前后缀的长度为<spanclass="math inline">\(pmt[n-1]\)</span>。如果<spanclass="math inline">\(n\)</span>%<spanclass="math inline">\((n-pmt[n-1])==0\)</span>，则答案为<spanclass="math inline">\(n/(n-pmt[n-1])\)</span>，否则为1。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3375</title>
      <link href="/2024/03/13/Luogu%20P3375/"/>
      <url>/2024/03/13/Luogu%20P3375/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="模板kmp">【模板】KMP</h1><h2 id="题目描述">题目描述</h2><p>给出两个字符串 <span class="math inline">\(s_1\)</span> 和 <spanclass="math inline">\(s_2\)</span>，若 <spanclass="math inline">\(s_1\)</span> 的区间 <spanclass="math inline">\([l, r]\)</span> 子串与 <spanclass="math inline">\(s_2\)</span> 完全相同，则称 <spanclass="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中出现了，其出现位置为 <spanclass="math inline">\(l\)</span>。 现在请你求出 <spanclass="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中所有出现的位置。</p><p>定义一个字符串 <span class="math inline">\(s\)</span> 的 border 为<span class="math inline">\(s\)</span> 的一个<strong>非 <spanclass="math inline">\(s\)</span> 本身</strong>的子串 <spanclass="math inline">\(t\)</span>，满足 <spanclass="math inline">\(t\)</span> 既是 <spanclass="math inline">\(s\)</span> 的前缀，又是 <spanclass="math inline">\(s\)</span> 的后缀。 对于 <spanclass="math inline">\(s_2\)</span>，你还需要求出对于其每个前缀 <spanclass="math inline">\(s&#39;\)</span> 的最长 border <spanclass="math inline">\(t&#39;\)</span> 的长度。</p><h2 id="输入格式">输入格式</h2><p>第一行为一个字符串，即为 <span class="math inline">\(s_1\)</span>。第二行为一个字符串，即为 <span class="math inline">\(s_2\)</span>。</p><h2 id="输出格式">输出格式</h2><p>首先输出若干行，每行一个整数，<strong>按从小到大的顺序</strong>输出<span class="math inline">\(s_2\)</span> 在 <spanclass="math inline">\(s_1\)</span> 中出现的位置。 最后一行输出 <spanclass="math inline">\(|s_2|\)</span> 个整数，第 <spanclass="math inline">\(i\)</span> 个整数表示 <spanclass="math inline">\(s_2\)</span> 的长度为 <spanclass="math inline">\(i\)</span> 的前缀的最长 border 长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>ABABABC ABA</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 3 0 0 1</code></p><h2 id="提示">提示</h2><h3 id="样例-1-解释">样例 1 解释</h3><p><imgsrc="https://img-blog.csdnimg.cn/img_convert/3c98caa2ee905bfada0eb2516ba7b8cc.png" />。对于 <span class="math inline">\(s_2\)</span> 长度为 <spanclass="math inline">\(3\)</span> 的前缀 <code>ABA</code>，字符串<code>A</code> 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为<span class="math inline">\(1\)</span>。</p><h3 id="数据规模与约定">数据规模与约定</h3><p><strong>本题采用多测试点捆绑测试，共有 3 个子任务</strong>。</p><ul><li>Subtask 1（30 points）：<span class="math inline">\(|s_1| \leq15\)</span>，<span class="math inline">\(|s_2| \leq 5\)</span>。</li><li>Subtask 2（40 points）：<span class="math inline">\(|s_1| \leq10^4\)</span>，<span class="math inline">\(|s_2| \leq10^2\)</span>。</li><li>Subtask 3（30 points）：无特殊约定。</li></ul><p>对于全部的测试点，保证 <span class="math inline">\(1 \leq |s_1|,|s_2|\leq 10^6\)</span>，<span class="math inline">\(s_1, s_2\)</span>中均只含大写英文字母。</p></blockquote><p>这道题就是妥妥的KMP模板题，具体原理可以参考知乎Pecco大佬的文章，链接贴上：https://zhuanlan.zhihu.com/p/105629613</p><p>需要注意的一点是：Pecco大佬的KMP写法与我所看到的大部分写法有细节上的不同，所以做题的时候，如果打算用Pecco大佬的码作为模板，你需要经常琢磨到底哪一点需要修改，就当是锻炼自己是否真正理解了KMP算法吧。</p><h2 id="ac代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> pmt[MAXN];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;  </span><br><span class="line">        pmt[i]=j;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">const</span> string &amp;p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])j++;  </span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">length</span>())&#123;  </span><br><span class="line">            cout&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">            j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    string s,p;  </span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;  </span><br><span class="line">    <span class="built_in">get_pmt</span>(p);  </span><br><span class="line">    <span class="built_in">kmp</span>(s,p);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        cout&lt;&lt;pmt[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3435</title>
      <link href="/2024/03/12/Luogu%20P3435/"/>
      <url>/2024/03/12/Luogu%20P3435/</url>
      
        <content type="html"><![CDATA[<hr /><h1 id="poi2006-okr-periods-of-words">[POI2006] OKR-Periods ofWords</h1><blockquote><h2 id="题面翻译">题面翻译</h2><p>对于一个仅含小写字母的字符串 <spanclass="math inline">\(a\)</span>，<span class="math inline">\(p\)</span>为 <span class="math inline">\(a\)</span> 的前缀且 <spanclass="math inline">\(p\ne a\)</span>，那么我们称 <spanclass="math inline">\(p\)</span> 为 <spanclass="math inline">\(a\)</span> 的 proper 前缀。</p><p>规定字符串 <span class="math inline">\(Q\)</span> 表示 <spanclass="math inline">\(a\)</span> 的周期，当且仅当 <spanclass="math inline">\(Q\)</span> 是 <spanclass="math inline">\(a\)</span> 的 proper 前缀且 <spanclass="math inline">\(a\)</span> 是 <spanclass="math inline">\(Q+Q\)</span> 的前缀。若这样的字符串不存在，则<span class="math inline">\(a\)</span> 的周期为空串。</p><p>例如 <code>ab</code> 是 <code>abab</code> 的一个周期，因为<code>ab</code> 是 <code>abab</code> 的 proper 前缀，且<code>abab</code> 是 <code>ab+ab</code> 的前缀。</p><p>求给定字符串所有前缀的最大周期长度之和。</p><h2 id="题目描述">题目描述</h2><p>A string is a finite sequence of lower-case (non-capital) letters ofthe English alphabet. Particularly, it may be an empty sequence, i.e. asequence of 0 letters. By A=BC we denotes that A is a string obtained byconcatenation (joining by writing one immediately after another, i.e.without any space, etc.) of the strings B and C (in this order). Astring P is a prefix of the string !, if there is a string B, that A=PB.In other words, prefixes of A are the initial fragments of A. Inaddition, if P!=A and P is not an empty string, we say, that P is aproper prefix of A.</p><p>A string Q is a period of Q, if Q is a proper prefix of A and A is aprefix (not necessarily a proper one) of the string QQ. For example, thestrings abab and ababab are both periods of the string abababa. Themaximum period of a string A is the longest of its periods or the emptystring, if A doesn't have any period. For example, the maximum period ofababab is abab. The maximum period of abc is the empty string.</p><p>Task Write a programme that:</p><p>reads from the standard input the string's length and the stringitself,calculates the sum of lengths of maximum periods of all itsprefixes,writes the result to the standard output.</p><h2 id="输入格式">输入格式</h2><p>In the first line of the standard input there is one integer <spanclass="math inline">\(k\)</span> (<span class="math inline">\(1\le k\le1\ 000\ 000\)</span>) - the length of the string. In the following linea sequence of exactly <span class="math inline">\(k\)</span> lower-caseletters of the English alphabet is written - the string.</p><h2 id="输出格式">输出格式</h2><p>In the first and only line of the standard output your programmeshould write an integer - the sum of lengths of maximum periods of allprefixes of the string given in the input.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 babababa</code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>24</code></p></blockquote><p>先理解清楚题意：proper前缀可以配合下图理解 <imgsrc="https://img-blog.csdnimg.cn/direct/2c12d9db942e46608af09d0f84a0255d.png#pic_center"alt="在这里插入图片描述" />这里我们不难看出：abcabcab的最长proper字串为abcabc，长度是6。记原来的字符串为<spanclass="math inline">\(s\)</span>，proper子串为<spanclass="math inline">\(t\)</span>。想想看，如果是要使得proper字串最长，那么恰好就是<spanclass="math inline">\(len(s)-min(border)\)</span>。我们可以大致感受一下，如果<spanclass="math inline">\(border\)</span>越大，那么对应的<spanclass="math inline">\(len(t)\)</span>越小，可以结合上面的例子。那么我们的问题就变成了怎么求最小的<spanclass="math inline">\(border\)</span>。 问题是，在KMP算法中，<spanclass="math inline">\(pmt\)</span>求出来的是<spanclass="math inline">\(max(border)\)</span>。我们可以利用KMP算法的一个性质：<spanclass="math inline">\(pmt[i]、pmt[pnt[i]]、pmt[pmt[pmt[i]]]······\)</span>直到为0，以上这些都是<span class="math inline">\(s\)</span>的<spanclass="math inline">\(border\)</span>的长度，并且越来越小。利用这个性质，我们就可以求出来<spanclass="math inline">\(min(border)\)</span>。</p><p>因为题目是求所有前缀的最大周期长度之和，所以我们令<spanclass="math inline">\(j=i+1\)</span>。（因为我个人的KMP写得比较奇怪，题解区的大佬是令<spanclass="math inline">\(j=i\)</span>）。然后在<spanclass="math inline">\(j&gt;0\)</span>的情况下不断令<spanclass="math inline">\(j=pmt[j-1]\)</span>，直到<spanclass="math inline">\(j\)</span>最小为止。此时<spanclass="math inline">\(ans+=i-j+1\)</span>。 这里有一个技巧：当<spanclass="math inline">\(j\)</span>求出来后，令<spanclass="math inline">\(pmt[i]=j\)</span>，相当于记忆化，否则可能会T。</p><p>思路参考：https://www.luogu.com.cn/problem/solution/P3435</p><p>贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pmt[j<span class="number">-1</span>])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pmt[i])pmt[i]=j;</span><br><span class="line">        ans+=i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
