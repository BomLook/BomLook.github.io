<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树状数组模板题</title>
      <link href="/2024/05/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
      <url>/2024/05/15/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组模板题">树状数组模板题</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/3079#problems">树状数组模板题 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>可以先看这篇文章学习或者复习一下：</p><p><a href="https://zhuanlan.zhihu.com/p/344360991">【朝夕的ACM笔记】数据结构-树状数组 - 知乎 (zhihu.com)</a></p><hr><h4 id="P3374-【模板】树状数组-1-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="comment">//树状数组</span></span><br><span class="line"><span class="comment">//树状数组：数组的每个位置储存的应当是一个区间的信息</span></span><br><span class="line"><span class="comment">//这些区间应当包容而不相交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单点修改</span></span><br><span class="line"><span class="comment">//首先修改的是单个元素</span></span><br><span class="line"><span class="comment">//其次修改的是包含这个元素的区间</span></span><br><span class="line"><span class="comment">//需要修改的区间(y,x],(x,x+lowbit(x)]------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询</span></span><br><span class="line"><span class="comment">//查询的是从[1,x]区间的和</span></span><br><span class="line"><span class="comment">//[1,x]=(y,x]+(y&#x27;,y]+(y&#x27;&#x27;,y&#x27;]+------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树 O(n)建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=a[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)    t[j]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt,x,y;    std::cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(x,y,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P5057-CQOI2006-简单题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P5057">P5057 [CQOI2006] 简单题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll d[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        t[x]=t[x]%<span class="number">2</span>;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        ans%=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[j]+=t[i];</span><br><span class="line">            t[j]=t[j]%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;    std::cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="built_in">update</span>(l,<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">update</span>(r+<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(x,n)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3368-【模板】树状数组-2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="comment">//树状数组</span></span><br><span class="line"><span class="comment">//这里要求实现的是单点查询 区间修改</span></span><br><span class="line"><span class="comment">//我们可以发现 我们进行求一个差分数组 然后在树状数组上维护即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树 O(n)建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)    t[j]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y,k;  std::cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">update</span>(x,k,n);</span><br><span class="line">            <span class="built_in">update</span>(y+<span class="number">1</span>,-k,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(x)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2068-统计和-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll d[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[j]+=t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,w;    std::cin&gt;&gt;n&gt;&gt;w;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> opt;   std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;  std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">update</span>(a,b,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;  std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(b)-<span class="built_in">query</span>(a<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4939-Agent2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;    std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">update</span>(a,<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">update</span>(b+<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a;  std::cin&gt;&gt;a;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(a)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2880-USACO07JAN-Balanced-Lineup-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2880">P2880 [USACO07JAN] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll t1[MAXN];</span><br><span class="line">ll t2[MAXN];</span><br><span class="line"><span class="comment">//学到了树状数组的新用法 维护区间max和区间min</span></span><br><span class="line"><span class="comment">//update函数还是差不多的 只不过t[i]+=k 改成了t[i]=max(t[i],k) 这里的k对应的就是a[i]</span></span><br><span class="line"><span class="comment">//但是query的时候需要考虑l和r 不像以前那样[1,r]-[1,l]</span></span><br><span class="line"><span class="comment">//我们知道 树状数组是将数组分为若干个区间 进而往上爬更新实现的 区间只包含而不相交</span></span><br><span class="line"><span class="comment">//那么我们可以按照熟悉的方法 一直从r-=lowbit(r)进行更新 只需要&gt;=l即可</span></span><br><span class="line"><span class="comment">//但是需要注意 可能最后的块不是完整的一块 所以我们需要在不满足的条件下从r-&gt;l 直接暴力即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[x]=std::<span class="built_in">max</span>(t1[x],k);</span><br><span class="line">        t2[x]=std::<span class="built_in">min</span>(t2[x],k);</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxn=<span class="number">0</span>;</span><br><span class="line">    ll minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(r-<span class="built_in">lowbit</span>(r)&gt;=l)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=std::<span class="built_in">max</span>(maxn,t1[r]);</span><br><span class="line">            minn=std::<span class="built_in">min</span>(minn,t2[r]);</span><br><span class="line">            r-=<span class="built_in">lowbit</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        maxn=std::<span class="built_in">max</span>(maxn,a[r]);</span><br><span class="line">        minn=std::<span class="built_in">min</span>(minn,a[r]);</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn-minn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(i,a[i],n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(t2,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(t2));</span><br><span class="line">    <span class="type">int</span> n,q;    std::cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;    std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        std::cout&lt;&lt;<span class="built_in">query</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6225-eJOI2019-异或橙子-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6225">P6225 [eJOI2019] 异或橙子 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//思路都想对了 可是不会写qwq</span></span><br><span class="line"><span class="comment">//这题求的是^</span></span><br><span class="line"><span class="comment">//不难发现 如果区间包含的元素个数是偶数 那么它们的区间异或和一定为0</span></span><br><span class="line"><span class="comment">//反之 只跟 a[i]^a[i+2]^...^a[j] 有关</span></span><br><span class="line"><span class="comment">//那么我们可以在此基础上分奇偶项建立树状数组维护</span></span><br><span class="line"><span class="comment">//注意将a[i]修改为j的时候 t[x]^=(a[i]^k) 这个是异或的性质 注意一下即可</span></span><br><span class="line"><span class="comment">//query时直接异或和即可 因为分了奇偶</span></span><br><span class="line"><span class="comment">//至于query时 是奇数项的树状数组还是偶数项的树状数组 我们对l&amp;1即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">    ll t[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[x]^=k;</span><br><span class="line">            x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans^=t[x];</span><br><span class="line">            x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BIT tree[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;    std::cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        tree[i&amp;<span class="number">1</span>].<span class="built_in">update</span>(i,a[i],n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i,j;  std::cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            tree[i&amp;<span class="number">1</span>].<span class="built_in">update</span>(i,a[i]^j,n),    a[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;    std::cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="keyword">if</span>((l+r)&amp;<span class="number">1</span>)     std::cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>    std::cout&lt;&lt;(tree[l&amp;<span class="number">1</span>].<span class="built_in">query</span>(r)^tree[l&amp;<span class="number">1</span>].<span class="built_in">query</span>(l<span class="number">-1</span>))&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1908-逆序对-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val!=b.val)    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//求解逆序对</span></span><br><span class="line"><span class="comment">//只需要从左往右遍历，寻找左侧比当前元素大的元素个数，叠加即可</span></span><br><span class="line"><span class="comment">//左侧比当前元素大的元素个数=左侧元素个数-左侧小于等于当前元素的元素个数</span></span><br><span class="line"><span class="comment">//后者可以使用桶排的方法</span></span><br><span class="line"><span class="comment">//需要涉及到离散化 暂时还不熟悉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);   <span class="comment">//相当于桶排中的t[b[i]]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans+=i-<span class="built_in">query</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1774-最接近神的人-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1774">P1774 最接近神的人 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val!=b.val)    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//求解逆序对</span></span><br><span class="line"><span class="comment">//只需要从左往右遍历，寻找左侧比当前元素大的元素个数，叠加即可</span></span><br><span class="line"><span class="comment">//左侧比当前元素大的元素个数=左侧元素个数-左侧小于等于当前元素的元素个数</span></span><br><span class="line"><span class="comment">//后者可以使用桶排的方法</span></span><br><span class="line"><span class="comment">//需要涉及到离散化 暂时还不熟悉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);   <span class="comment">//相当于桶排中的t[b[i]]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans+=i-<span class="built_in">query</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4378-USACO18OPEN-Out-of-Sorts-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4378">P4378 [USACO18OPEN] Out of Sorts S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//一道逆序对的变式题 但是题目有点意思 自己犯了一些小错误</span></span><br><span class="line"><span class="comment">//这道题其实求的还是逆序对 但是我们可以发现</span></span><br><span class="line"><span class="comment">//前面那些大的数肯定会被当前数的后面，且只有这些数会跑到当前数的后面，所以这个点肯定只会被更新有限次</span></span><br><span class="line"><span class="comment">//那么我们取最大的即可</span></span><br><span class="line"><span class="comment">//1 update时 是b[i]而不是i query也是一样</span></span><br><span class="line"><span class="comment">//2 需要边建树 边更新答案</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.val==b.val)  <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">        <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,node::cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,i-<span class="built_in">query</span>(b[i],n));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换根DP</title>
      <link href="/2024/05/13/%E6%8D%A2%E6%A0%B9DP/"/>
      <url>/2024/05/13/%E6%8D%A2%E6%A0%B9DP/</url>
      
        <content type="html"><![CDATA[<h1 id="换根DP">换根DP</h1><p>复习或者学习可以参考以下两篇文章：</p><p><a href="https://zhuanlan.zhihu.com/p/348349531">【朝夕的ACM笔记】动态规划-换根DP - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com/article/c8ov8ekf">[学习笔记]换根dp - 洛谷专栏 (luogu.com)</a></p><p>下面是对应的一些练习题目：（题单链接）</p><p><a href="https://www.luogu.com.cn/training/513240#information">换根DP - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><p>有一些题实在是太板子了，所以我就没怎么写注释了。</p><h4 id="P3478-POI2008-STA-Station-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI2008] STA-Station - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line"><span class="comment">//遇到换根dp了 学习一下</span></span><br><span class="line"><span class="comment">//关键是有两个dfs</span></span><br><span class="line"><span class="comment">//dfs1负责统计每个节点u距离根节点1的深度 以及以u为根的子树的大小</span></span><br><span class="line"><span class="comment">//dfs2负责计算dp数组  dp[u]表示以u为根节点的深度和</span></span><br><span class="line"><span class="comment">//状态转移方程就是</span></span><br><span class="line"><span class="comment">//dp[v]=g[v]+(dp[u]-(g[v]+size[v]))+(size[1]-size[v])</span></span><br><span class="line"><span class="comment">//g[u] 表示子树里所有节点到u的深度和</span></span><br><span class="line"><span class="comment">//size[u] 表示的是以u为根节点的子树大小</span></span><br><span class="line"><span class="comment">//depth[u]表示从u到1的深度(以后有用)</span></span><br><span class="line"><span class="comment">//v是u的子节点</span></span><br><span class="line"><span class="comment">//那么当根从u-&gt;v时 我们就要更新dp数组 dp[v]=g[v]+dp[u]-(g[v]+size[v])+(size[1]-size[v])</span></span><br><span class="line"><span class="comment">//显然的 g[v]需要加上去 而原来的dp[u]就要减去v子树里的信息</span></span><br><span class="line"><span class="comment">//一开始我也认为为什么是减去g[v]+size[v] 而不是减去g[v]</span></span><br><span class="line"><span class="comment">//我们可以这样想 u是v的父节点 那么v的子树里的所有点到u的距离都要额外+1 全部的额外和就是size[v]</span></span><br><span class="line"><span class="comment">//总共算出来就是g[v]+size[v]</span></span><br><span class="line"><span class="comment">//后面的减去size[1]-size[v]也是依此类推</span></span><br><span class="line"><span class="comment">//其实化简后就可以发现是dp[to]=dp[x]-2*size[to]+size[1];</span></span><br><span class="line"><span class="comment">//根本用不到g数组</span></span><br><span class="line"><span class="comment">//原题中没有确定根节点 那么我们不妨假设根节点是1 需要预处理出dp[1]</span></span><br><span class="line"><span class="comment">//先dfs1 预处里出depth数组 全部累加就可以得到dp[1]</span></span><br><span class="line"><span class="comment">//后面dfs2就是正规的状态转移了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一个小细节 注意得开long long </span></span><br><span class="line"><span class="comment">//因为可能在计算的过程中溢出了 虽然数据范围1e6乍一看人畜无害的样子</span></span><br><span class="line"><span class="comment">//这个细节一定要留意</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dp[i];</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABC348E-Minimize-Sum-of-Distances-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/AT_abc348_e">[ABC348E] Minimize Sum of Distances - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*a[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">min</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Painting-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1187E">Tree Painting - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//这道题题意看上去很难 其实是绕 关键是弄清楚要求什么就好了</span></span><br><span class="line"><span class="comment">//题目要求的是数量的贡献值 所以不需要求边长</span></span><br><span class="line"><span class="comment">//题目要求进行n次操作 其实答案只跟第一次操作 也就是将哪个点染为黑色有关</span></span><br><span class="line"><span class="comment">//wsm？</span></span><br><span class="line"><span class="comment">//一个点的贡献来源于以它为根的子树和它的祖先中能达到的白点数。</span></span><br><span class="line"><span class="comment">//当这个点的父亲已被染成黑色，该点的祖先颜色已无法对该点贡献造成影响，只与子树有关，而子树不受顺序影响。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实预处理都是一样的</span></span><br><span class="line"><span class="comment">//dp[i] 表示以i为根节点的答案</span></span><br><span class="line"><span class="comment">//不妨还是以1为根开始预处理</span></span><br><span class="line"><span class="comment">//这里dp[1]+=size[i]</span></span><br><span class="line"><span class="comment">//其中size[i]表示的是以i为根的子树的大小</span></span><br><span class="line"><span class="comment">//显然的 以1为根节点时 答案就是dp[1]</span></span><br><span class="line"><span class="comment">//接下来就是换根dp的转移了</span></span><br><span class="line"><span class="comment">//具体的推导还是看之前的文章</span></span><br><span class="line"><span class="comment">//这里直接丢了：dp[to]=dp[x]+size[1]-2*size[to];</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=size[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-with-Maximum-Cost-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1092F">Tree with Maximum Cost - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*a[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Centroids-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF708C">Centroids - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="P2986-USACO10MAR-Great-Cow-Gathering-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll c[MAXN];</span><br><span class="line"><span class="comment">//其实就是加了权值 但是自己还是犯了不少低级错误</span></span><br><span class="line"><span class="comment">//size[x]改为以x为根的子树所拥有的奶牛数目</span></span><br><span class="line"><span class="comment">//depth 表示的是以1为根节点 x到1的深度</span></span><br><span class="line"><span class="comment">//问题如下</span></span><br><span class="line"><span class="comment">//1 dp[to]=dp[x]-(2*size[to]-size[1])*t.val;</span></span><br><span class="line"><span class="comment">//第一个就是把t.val写成了c[to] 其实应该很容易就明白是t.val才对</span></span><br><span class="line"><span class="comment">//因为算的是总距离 自然是数量*距离 结果却变成了数目*数目</span></span><br><span class="line"><span class="comment">//第二个就是 dp[1]+=depth[i]*c[i];</span></span><br><span class="line"><span class="comment">//这里dp的定义改为总距离 所以需要*c[i]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=c[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+t.val;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>])*t.val;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,l;    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;a,b,l&#125;);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(&#123;b,a,l&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*c[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">1e15</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">min</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3647-APIO2014-连珠线-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3647">P3647 [APIO2014] 连珠线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="ABC220F-Distance-Sums-2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/AT_abc220_f">[ABC220F] Distance Sums 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1395-会议-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1395">P1395 会议 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;dp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dp[i];</span><br><span class="line">            p=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3047-USACO12FEB-Nearby-Cows-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3047">P3047 [USACO12FEB] Nearby Cows G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">//一道略有变式的换根dp</span></span><br><span class="line"><span class="comment">//这里需要考虑距离根节点的距离 所以需要添加一个维度k 表示到根节点距离&lt;=k的节点数权值和</span></span><br><span class="line"><span class="comment">//我们还是进行一样的预处理 以1为根</span></span><br><span class="line"><span class="comment">//先预处理出size数组 size[u][i]表示以u为根节点的子树 距离其&lt;=i的节点数</span></span><br><span class="line"><span class="comment">//注意这里是先默认整棵树是以1为根节点的 需要与上面的dp数组区分开来</span></span><br><span class="line"><span class="comment">//size[x][i]+=size[to][i-1] 1&lt;=i&lt;=k 先预处理出size数组 这是dfs1的任务</span></span><br><span class="line"><span class="comment">//接下来考虑dfs2 我们开始进行换根的操作</span></span><br><span class="line"><span class="comment">//dp[to][i]+=dp[x][i-1]-size[to][i-2] 2&lt;=i&lt;=k</span></span><br><span class="line"><span class="comment">//还得考虑dp[to][1]+=size[x][0] 不然会RE并且少算情况</span></span><br><span class="line"><span class="comment">//为什么还要减去size[to][i-2]呢？ 因为dp[x][i-1]一开始是从1为根节点开始的</span></span><br><span class="line"><span class="comment">//所以我们要减去重复的部分 对应的也就是size[to][i-2]（注意这里还是以1为根哦，所以是size数组，而不是dp数组）</span></span><br><span class="line"><span class="comment">//然后我们再dfs2更新即可</span></span><br><span class="line"><span class="comment">//记得dp数组的预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line"><span class="comment">//1 dfs1是以1为根的总树进行预处理 size数组和dp数组本质上是一样的 只不过size数组加了一个以1为根作为总树的前提</span></span><br><span class="line"><span class="comment">//我们可以根据dp数组的设计 来得出size数组的设计（其实一模一样 只不过加了一个限制条件）</span></span><br><span class="line"><span class="comment">//2 在换根的时候需要考虑清楚各种细节 这道题就是算重的情况</span></span><br><span class="line">ll dp[MAXN][<span class="number">25</span>];</span><br><span class="line">ll size[MAXN][<span class="number">25</span>];</span><br><span class="line">ll c[MAXN];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)   size[x][i]=c[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            size[x][i]+=size[to][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to][<span class="number">1</span>]+=size[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[to][i]+=dp[x][i<span class="number">-1</span>]-size[to][i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;c[i];</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=size[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i][k]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6419-COCI2014-2015-1-Kamp-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6419">P6419 [COCI2014-2015#1] Kamp - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="Maximum-White-Subtree-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1324F">Maximum White Subtree - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//做了这么多道题目 对换根dp也有了自己的体会</span></span><br><span class="line"><span class="comment">//1 size数组的定义和dp数组定义一样 所以可以根据dp数组的设计来推导出size数组的设计</span></span><br><span class="line"><span class="comment">//size数组多了一个限制条件 就是它是以为1整棵树的根节点的</span></span><br><span class="line"><span class="comment">//2 根据dp数组的定义 我们也可以对size数组进行预处理 不过偏简单暴力</span></span><br><span class="line"><span class="comment">//这里size的定义是最大化cnt1-cnt2 显然的 我们可以贪心</span></span><br><span class="line"><span class="comment">//if(size[to]&gt;0)    size[x]+=size[to];</span></span><br><span class="line"><span class="comment">//这一步是由dfs1完成的 换句话说dfs1是完成以1为根的整棵树的工作</span></span><br><span class="line"><span class="comment">//dfs2就是换根 建议在推导如何换根时 以x作为整棵树的根节点来进行推导 比较好理解</span></span><br><span class="line"><span class="comment">//那么 换根时 不难想到 可能是由x继承过来 也可能是直接继承自己的size</span></span><br><span class="line"><span class="comment">//但是可能 自己的size可能是负值 所以还得再分类讨论</span></span><br><span class="line"><span class="comment">// if(size[to]&gt;0)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //直接继承自己的size或者dp[x]（也就是父亲的dp）</span></span><br><span class="line"><span class="comment">//            //为什么是这样子？因为如果size[to]大于0 那么肯定包括了 </span></span><br><span class="line"><span class="comment">//            dp[to]=std::max(size[to],dp[x]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //如果不大于0 父亲肯定不包括 但是儿子又必须包括 </span></span><br><span class="line"><span class="comment">//            //所以dp[to]就是max(dp[x]+size[to],size[to])</span></span><br><span class="line"><span class="comment">//            //注意size[to]是最优的情况（前提是以1为根）</span></span><br><span class="line"><span class="comment">//            dp[to]=std::max(size[to],dp[x]+size[to]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            size[x]+=size[to];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[to]=std::<span class="built_in">max</span>(size[to],dp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[to]=std::<span class="built_in">max</span>(size[to],dp[x]+size[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>) a[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(dp,-0x3f,sizeof(dp));</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    dp[<span class="number">1</span>]=size[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 换根DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划3】区间与环形动态规划</title>
      <link href="/2024/05/10/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923%E3%80%91%E5%8C%BA%E9%97%B4%E4%B8%8E%E7%8E%AF%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/05/10/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%923%E3%80%91%E5%8C%BA%E9%97%B4%E4%B8%8E%E7%8E%AF%E5%BD%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="【动态规划3】区间与环形动态规划">【动态规划3】区间与环形动态规划</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/213#problems">【动态规划3】区间与环形动态规划 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><h4 id="P1435-IOI2000-回文字串-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI2000] 回文字串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>这道题还有另外一种做法，利用LCS求解，可以看另外一篇文章：<a href="https://www.heavenhold.cn/2024/05/06/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E3%80%91%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">【动态规划2】线性状态动态规划 | Heavenhold</a>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//有两种做法 一种是最长上升子序列 在另外一篇文章讲了</span></span><br><span class="line"><span class="comment">//这里介绍区间dp的做法</span></span><br><span class="line"><span class="comment">//dp[i][j] 表示要把从i到j的字符串变成回文串需要插入的最少字符数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=dp[i+1][j-1] id(s[i]==s[j])</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=len;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])  dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>    dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][len]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1775-石子合并（弱化版）-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1775">P1775 石子合并（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示将从第i堆到第j堆的所有石子合并需要的最小代价</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i][k]+dp[k+1][j]+sum[j]-sum[k]+sum[k]-sum[i-1],dp[i][j]);</span></span><br><span class="line"><span class="comment">//其中k表示的是分段点</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">310</span>];</span><br><span class="line"><span class="comment">//sum表示的前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;=j &amp;&amp; j&lt;=n ;p++)    <span class="comment">//p表示分段点 注意j要&lt;=n 否则可能会越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Zuma-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF607B">Zuma - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示将从第i堆到第j堆的所有珠子取走需要的最小时间</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i+1][j-1],dp[i][j]) if(a[i]==a[j])</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i][k]+dp[k+1][j],dp[i][j]);</span></span><br><span class="line"><span class="comment">//wsm会是下面的这个呢 我们分析一下区间DP的原理</span></span><br><span class="line"><span class="comment">//区间DP其实是以某一个区间为中心 往其两边不断添加点或者区间 从而扩展的</span></span><br><span class="line"><span class="comment">//也就是  &lt;---[====]---&gt;</span></span><br><span class="line"><span class="comment">//而通过枚举分段点 我们可以得到每一种情况 取min 从而得到最小的情况 也就是答案</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>]=<span class="number">1</span>+(a[i]!=a[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j] &amp;&amp; i+<span class="number">1</span>&lt;=j<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//注意这里需要取min 因为在两边添加不一定是最优的</span></span><br><span class="line">                    dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;dp[i][j]&lt;&lt;&quot; 1 \n&quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]);</span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;dp[i][j]&lt;&lt;&quot; 2 \n&quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3205">P3205 [HNOI2010] 合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[i][j][opt] 表示从第i个位置到第j个位置之间 最后一个人是从左边/右边插入的方案数</span></span><br><span class="line"><span class="comment">//0 表示从左边插入 1 表示从右边插入</span></span><br><span class="line"><span class="comment">//根据题意 我们不难得出状态转移方程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[i+1])     dp[i][j][0]+=dp[i+1][j][0];</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[j])   dp[i][j][0]+=dp[i+1][j][1];</span></span><br><span class="line"><span class="comment">if(a[j]&gt;a[j-1])     dp[i][j][1]+=dp[i][j-1][1];</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[j])   dp[i][j][1]+=dp[i][j-1][0];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//考虑初始化 dp[i][i][0]=1 我们默认一开始是从左边插入</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>])     dp[i][j][<span class="number">0</span>]+=dp[i+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[j])   dp[i][j][<span class="number">0</span>]+=dp[i+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j<span class="number">-1</span>])     dp[i][j][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[j])   dp[i][j][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][j][<span class="number">0</span>]%=mod;</span><br><span class="line">                dp[i][j][<span class="number">1</span>]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(dp[<span class="number">1</span>][n][<span class="number">0</span>]+dp[<span class="number">1</span>][n][<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4170">P4170 [CQOI2007] 涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示从第i个位置到第j个位置需要的操作次数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//if(s[i]==s[j])  dp[i][j]=std::min(dp[i+1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">//原来一开始还加了一个 dp[i+1][j-1] </span></span><br><span class="line"><span class="comment">//也就是：dp[i][j]=std::min(dp[i+1][j],dp[i][j-1],dp[i+1][j-1]);</span></span><br><span class="line"><span class="comment">//但是这个是不对的 其实很显然 如果需要添加一种新的颜色 那么就需要加1了</span></span><br><span class="line"><span class="comment">//但是如果这样问题就很麻烦了 我们还得记录出现的颜色种类 其实上面的状态转移方程已经一步步转移过来了</span></span><br><span class="line"><span class="comment">//不再需要考虑这种特别复杂的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;n)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])  dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示从第i个位置到第j个位置 可以释放的最多能量</span></span><br><span class="line"><span class="comment">//区间dp 因为涉及到环 所以拆环成链 具体是a[i+n]=a[i]这一步操作</span></span><br><span class="line"><span class="comment">//注意最长的长度是n 所以k的枚举范围是2-n 并且j&lt;=2*n</span></span><br><span class="line"><span class="comment">//注意枚举分段点时 p是从i开始的 一开始我也是从i开始 后来改成从i+1开始 样例就错了</span></span><br><span class="line"><span class="comment">//确实是得从i开始 因为1个两珠子的串是可能从2个珠子合成的</span></span><br><span class="line"><span class="comment">//这里一开始是打算开一个结构体 记录头标记 尾标记 其实没必要 因为首位相连 所以直接取下一个珠子的头标记即可</span></span><br><span class="line"><span class="comment">//注意最后获取答案 长度是n</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],a[i+n]=a[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//if(j&gt;2*n)   std::cout&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">max</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]+a[i]*a[p+<span class="number">1</span>]*a[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//if(p&gt;2*n)   std::cout&lt;&lt;p&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   ans=std::<span class="built_in">max</span>(ans,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1880-NOI1995-石子合并-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp1[<span class="number">210</span>][<span class="number">210</span>];  <span class="comment">//最大得分</span></span><br><span class="line"><span class="type">int</span> dp2[<span class="number">210</span>][<span class="number">210</span>];  <span class="comment">//最小得分</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">210</span>];</span><br><span class="line"><span class="comment">//要被自己的sb错误笑死了 一直把k当作枚举点 这已经是第二次了</span></span><br><span class="line"><span class="comment">//还是相同的方法 环拆成链 枚举断点</span></span><br><span class="line"><span class="comment">//需要预处理出前缀和</span></span><br><span class="line"><span class="comment">//注意单独一个堆是不能合成的 所以它的得分是0</span></span><br><span class="line"><span class="comment">//最后答案取长度为n的区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)     dp2[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp1[i][j]=std::<span class="built_in">max</span>(dp1[i][j],dp1[i][p]+dp1[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp2[i][j]=std::<span class="built_in">min</span>(dp2[i][j],dp2[i][p]+dp2[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxAns=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minAns=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxAns=std::<span class="built_in">max</span>(maxAns,dp1[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        minAns=std::<span class="built_in">min</span>(minAns,dp2[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;minAns&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;maxAns;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP学习（一）</title>
      <link href="/2024/05/09/%E6%95%B0%E4%BD%8DDP%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2024/05/09/%E6%95%B0%E4%BD%8DDP%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="数位DP学习">数位DP学习</h1><p>我是参考Pecco大佬的这篇文章学习的：<a href="https://zhuanlan.zhihu.com/p/348851463">算法学习笔记(68): 数位DP - 知乎 (zhihu.com)</a>，可以先看看，或者复习后再看看下面的题。</p><p>题单是这个：<a href="https://www.luogu.com.cn/training/82023#problems">（提高）『数位DP』从入门到入土 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>，目前写了十多道，会慢慢补的。</p><p>也许以后会再补充一些其他OJ上的题目？</p><hr><h2 id="数位DP文章例题">数位DP文章例题</h2><p>先附上文章里的题目吧~~~</p><h4 id="不要62-HDU-2089-Virtual-Judge-vjudge-net"><a href="https://vjudge.net/problem/HDU-2089">不要62 - HDU 2089 - Virtual Judge (vjudge.net)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],dp[<span class="number">8</span>][<span class="number">12</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;    <span class="comment">//记录原来的数字中的位数</span></span><br><span class="line"><span class="comment">//dp[pos][last][limit]</span></span><br><span class="line"><span class="comment">//dp[pos][last][limit] 表示在第pos位时 所有符合要求的方案数</span></span><br><span class="line"><span class="comment">//limit是用来限制当前位最多可以枚举到哪一位</span></span><br><span class="line"><span class="comment">//true 说明只能枚举到原来的数字中这一位的值 否则就是0-9</span></span><br><span class="line"><span class="comment">//last是用来记录上一位的数字 判断当前解是否合法</span></span><br><span class="line"><span class="comment">//一般来说pos 和 limit是必要的 其他根据题目要求增加维度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> last,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)<span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">if</span>(dp[pos][last][limit]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][last][limit];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span> || i==<span class="number">4</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,limit&amp;&amp;i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][last][limit]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="literal">true</span>);  <span class="comment">//last设置为11 表示不存在上一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,(x||y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2602-ZJOI2010-数字计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digit=i;</span><br><span class="line">        ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Little-Girl-and-Maximum-XOR-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF276D">Little Girl and Maximum XOR - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],b[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//这里注意一下数组大小 因为是二进制 所以原本的20需要装换成对应的二进制数有几位</span></span><br><span class="line"><span class="comment">//dp[pos][limitl1][limitr1][limitl2][limitr2]</span></span><br><span class="line"><span class="comment">//pos含义一样 limitl1 表示当前位是否有下限制 limitr1 表示当前位是否有上限制</span></span><br><span class="line"><span class="comment">//limitl2 limitr2 同理</span></span><br><span class="line"><span class="comment">//因为是枚举2个数 并且不是计数 所以一个数需要设置上下限 总共4个limit</span></span><br><span class="line">ll cnt1,cnt2,cnt;</span><br><span class="line"><span class="comment">//cnt1 表示的是a数组的各位</span></span><br><span class="line"><span class="comment">//cnt2 表示的是b数组的各位</span></span><br><span class="line"><span class="comment">//cnt=max(cnt1,cnt2)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> limitl1,<span class="type">bool</span> limitr1,<span class="type">bool</span> limitl2,<span class="type">bool</span> limitr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//这里不太理解wsm是return 0;</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][limitl1][limitr1][limitl2][limitr2];</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=(limitl1?a[pos]:<span class="number">0</span>);i&lt;=(limitr1?b[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=(limitl2?a[pos]:<span class="number">0</span>);j&lt;=(limitr2?b[pos]:<span class="number">1</span>);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=std::<span class="built_in">max</span>(ans,((i^j)&lt;&lt;(cnt-pos<span class="number">-1</span>))+<span class="built_in">dfs</span>(pos+<span class="number">1</span>,limitl1 &amp;&amp; i==a[pos],limitr1 &amp;&amp; i==b[pos],limitl2 &amp;&amp; j==a[pos], limitr2 &amp;&amp; j==b[pos]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt1=<span class="number">0</span>;</span><br><span class="line">    cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt1++]=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        b[cnt2++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=std::<span class="built_in">max</span>(cnt1,cnt2);</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    std::<span class="built_in">reverse</span>(b,b+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">f</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的正解做法其实是贪心，后面会写一篇文章来介绍。</p><hr><h2 id="（提高）『数位DP』从入门到入土">（提高）『数位DP』从入门到入土</h2><h4 id="P4999-烦人的数学作业-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4999">P4999 烦人的数学作业 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">22</span>];</span><br><span class="line">ll dp[<span class="number">22</span>][<span class="number">200</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+i,limit &amp;&amp; i==a[pos]);</span><br><span class="line">        ans+=mod;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    <span class="comment">//需要注意最后+mod 再%mod</span></span><br><span class="line">    std::cout&lt;&lt;(r-l+mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6218-USACO06NOV-Round-Numbers-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6218">P6218 [USACO06NOV] Round Numbers S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cnt0][cnt1][limit]</span></span><br><span class="line"><span class="comment">//pos limit 含义一样 cnt0记录当前有多少个0  cnt1同理 lead 考虑当前位之前是否全为0</span></span><br><span class="line"><span class="comment">//奇怪的问题 多加了一维就过了??? 原来一直WA</span></span><br><span class="line"><span class="comment">//大概明白什么原因了 如果是原来直接减 里面会包含前导0 所以就错了</span></span><br><span class="line">ll cnt;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos,ll cnt0,ll cnt1,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt0&gt;=cnt1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cnt0][cnt1][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0,cnt1,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lead) ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0,cnt1+<span class="number">1</span>,limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0+(i==<span class="number">0</span>),cnt1+(i==<span class="number">1</span>),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2657-SCOI2009-windy-数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2657">P2657 [SCOI2009] windy 数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">12</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//数据出水了 这份码是有问题的</span></span><br><span class="line"><span class="comment">//加上特判应该就没问题了 可能是算重的问题</span></span><br><span class="line"><span class="comment">//有一个地方不太理解 1 200000 --&gt; 46859</span></span><br><span class="line"><span class="comment">//第二维度上限是10100</span></span><br><span class="line"><span class="comment">//大致明白了 ans+=----       d=ans</span></span><br><span class="line"><span class="comment">//得到的ans 和 sum 没有直接的关系 sum是一个底层的基本情况 ans是由底层dp来的</span></span><br><span class="line"><span class="comment">//因为其实只是0-9之间 所以底层实际上sum的数目只有0-9之间而已(也许有10)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">int</span> last,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][last][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发现了一件奇怪的事情 sum改成d 恰好是答案的负数</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-last)&gt;=<span class="number">2</span> || lead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较恶心的一点 一位数也是windy数</span></span><br><span class="line">            <span class="comment">//所以这里得讨论一下 如果abs(i-last)&gt;=2 或者 有前导0 都可能是windy数(个位数捣乱)</span></span><br><span class="line">            <span class="comment">//所以sum的更新需要判断 如果是个位数或者没有前导0 那么sum就+1 但是这样后面就得加上特判了</span></span><br><span class="line">            ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+((cnt==<span class="number">1</span>)) || (i || !lead),i,limit &amp;&amp; i==a[pos],lead &amp;&amp; i==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">10</span>&amp;&amp;y&lt;<span class="number">10</span>)    std::cout&lt;&lt;r-l<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2602-ZJOI2010-数字计数-洛谷-计算机科学教育新生态-luogu-com-cn-2"><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>看上面，这里不重复了。</p><h4 id="P1836-数页码-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1836">P1836 数页码 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">12</span>];</span><br><span class="line">ll dp[<span class="number">12</span>][<span class="number">90</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+i,limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4317-花神的数论题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4317">P4317 花神的数论题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">64</span>];</span><br><span class="line">ll dp[<span class="number">64</span>][<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>];</span><br><span class="line">ll ans[<span class="number">64</span>];</span><br><span class="line">ll dp2[<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//一开始没搞懂wsm要用快速幂</span></span><br><span class="line"><span class="comment">//大概明白了 求的是sum(1)*sum(2)*------*sum(n)</span></span><br><span class="line"><span class="comment">//可以转化成对应的二进制数中 1个1的个数 * 2个1的个数 * 3个1的个数 * 4个1的个数 * ...</span></span><br><span class="line"><span class="comment">//这个时候就可以使用快速幂了</span></span><br><span class="line"><span class="comment">//直接算应该也是可行的 但是dp方程就需要改变了</span></span><br><span class="line"><span class="comment">/*引用一下</span></span><br><span class="line"><span class="comment"> * 我们可以用数位DP求出二进制数中含有1的个数为k的数的数目sum，</span></span><br><span class="line"><span class="comment"> * 这样k的贡献就是sum个k连乘，也就是k的sum次方，</span></span><br><span class="line"><span class="comment"> * 这样我们枚举每一个二进制表示中可能含有的1的个数就可以得到最终的贡献</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//答案涉及到取模，但是需要注意的是我们仅仅能在加法减法或者乘法过程中随意取模，</span></span><br><span class="line"><span class="comment">//但是我们不能在求指数的过程中取模，否则会出现错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 又犯了一堆错误</span></span><br><span class="line"><span class="comment"> * 1 取模的时候只能在快速幂的时候取 否则ans[i]改变了</span></span><br><span class="line"><span class="comment"> * 2 又默认拆分成十进制了 数组也开小了 a[]开小了 dp[]却开对了------</span></span><br><span class="line"><span class="comment"> * 3 dfs中 ans赋值成1了</span></span><br><span class="line"><span class="comment"> * 4 P是 1e7+7 写成1e9+7 或者1e7+9了</span></span><br><span class="line"><span class="comment"> * 5 最后答案取模时又忘记+P 再%P了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cnt1,<span class="type">int</span> tot,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cnt1][tot][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt1==tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt1+(i==<span class="number">1</span>),tot,limit &amp;&amp; i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=a*ans%P;</span><br><span class="line">        a=a*a%P;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        ans[i]=<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,i+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=res*<span class="built_in">qpower</span>(i+<span class="number">1</span>,ans[i])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(res+P)%P&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有第二种方法 第一种我们算的是含有k个1的数的个数，然后我们在函数外面进行求解k的贡献</span></span><br><span class="line"><span class="comment">//我们现在其实可以直接计算 就可以不用在外面再累乘计算了</span></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cnt1,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp2[pos][cnt1][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(cnt1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans*<span class="built_in">dfs2</span>(pos+<span class="number">1</span>,cnt1+(i==<span class="number">1</span>),limit &amp;&amp; i==a[pos])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>)+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计问题-The-Counting-Problem-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/UVA1640">统计问题 The Counting Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,x||y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)     std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digit=i;</span><br><span class="line">            ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">            <span class="comment">//毒瘤问题 不能输出多余的空格</span></span><br><span class="line">            std::cout&lt;&lt;r-l&lt;&lt;(i&lt;<span class="number">9</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Salazar-Slytherin’s-Locket-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF855E">Salazar Slytherin’s Locket - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">1024</span>][<span class="number">2</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//理解错题意了 题目要求得是这个数转化成b进制后 判断0---b-1得个数是否都为偶数 如果是 则统计</span></span><br><span class="line"><span class="comment">//其实有一个很莽的写法 因为b最大到10 所以直接开到13维度</span></span><br><span class="line"><span class="comment">//但是正解是状压+数位</span></span><br><span class="line"><span class="comment">//我们可以将每个数字出现的个数进行二进制状态压缩</span></span><br><span class="line"><span class="comment">//0 表示出现偶数次</span></span><br><span class="line"><span class="comment">//1 表示出现奇数次</span></span><br><span class="line"><span class="comment">//dp[pos][state][limit][lead]</span></span><br><span class="line"><span class="comment">//pos lead limit 分别表示位置 有无前导0 当前位有无限制</span></span><br><span class="line"><span class="comment">//state 状压表示集合</span></span><br><span class="line"><span class="comment">//状态转移 只需要state ^ (1&lt;&lt;i)即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后再加一个维度 表示进制 这样dp数组只要初始化一次即可 否则会TLE</span></span><br><span class="line"><span class="comment">//注意要加在最前面 否则数组访问到其他非法元素</span></span><br><span class="line"><span class="comment">//好吧 不是这个原因 已经卡了两个多小时了 bzd为什么 已经无语了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ok 大致理解原理了 非常好的题 使我“浪费”了三个小时时间(但是 数位dp也进化了)</span></span><br><span class="line"><span class="comment"> * 由于在不同数的limit是不同的 这会阻止我们复用dp数组</span></span><br><span class="line"><span class="comment"> * 注意到limit等于1的状态出现的频率远远小于limit等于0的状态，</span></span><br><span class="line"><span class="comment"> * 所以我们可以选择只记忆化limit为0的状态，</span></span><br><span class="line"><span class="comment"> * 这样每次dp数组的意义就完全相同了 (来自Pecco)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ll cnt;</span><br><span class="line">ll b;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos,<span class="type">int</span> state,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][state][lead][b];</span><br><span class="line">    <span class="keyword">if</span>(!pos)    <span class="keyword">return</span> state==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span> &amp;&amp; !limit)  <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:b<span class="number">-1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="literal">false</span>,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,state^(<span class="number">1</span>&lt;&lt;i),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%b;</span><br><span class="line">        x/=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MDIGITS-Counting-Digits-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/SP3928">MDIGITS - Counting Digits - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,x||y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)     std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digit=i;</span><br><span class="line">            ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">            <span class="comment">//毒瘤问题 不能输出多余的空格</span></span><br><span class="line">            std::cout&lt;&lt;r-l&lt;&lt;(i&lt;<span class="number">9</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Classy-Numbers-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1036C">Classy Numbers - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">22</span>],dp[<span class="number">22</span>][<span class="number">22</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> cntd&lt;=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd+(i!=<span class="number">0</span>),limit &amp;&amp; i==a[pos],lead &amp;&amp; i==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4127-AHOI2009-同类分布-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4127#submit">P4127 [AHOI2009] 同类分布 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">22</span>],dp[<span class="number">22</span>][<span class="number">180</span>][<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="comment">//也是一道挺有意思的题目</span></span><br><span class="line"><span class="comment">//dp[pos][sum][num]表示pos是位，sum为和，num为原数</span></span><br><span class="line"><span class="comment">//但是由于范围太大 直接转移存在问题 所以不难想到取模</span></span><br><span class="line"><span class="comment">//但是取什么数 这是一个问题</span></span><br><span class="line"><span class="comment">//原来的要求就是sum%num==0 即可</span></span><br><span class="line"><span class="comment">//所以如果能够让num取模到最后为0 其实也就是sum为模数就好了</span></span><br><span class="line"><span class="comment">//这样其实看好像没啥区别(有一种废话做法的感觉，问题就在于范围太大了 可能会溢出 所以算的过程中取模)</span></span><br><span class="line"><span class="comment">//但是把又不知道是哪一个 所以可以暴力枚举(范围也很小 200内)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,ll num,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][num];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> num==<span class="number">0</span> &amp;&amp; sum==P;    <span class="comment">//最后结果 需要num==0 并且 sum==P (P是枚举的模数)</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意边算边取模</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,sum+i,(<span class="number">10ll</span>*num+i)%P,limit &amp;&amp; i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暴力枚举模数</span></span><br><span class="line">    <span class="keyword">for</span>(P=<span class="number">1</span>;P&lt;=<span class="number">9</span>*cnt;P++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//这里还得memset一下</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//memset(dp,-1,sizeof(dp));</span></span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PR003004-Digit-Sum-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/SP17247">PR003004 - Digit Sum - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt,digit;</span><br><span class="line">ll a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][lead]</span></span><br><span class="line"><span class="comment">//pos 表示位置 cntd 表示 统计到的digit的个数 lead 表示是否有前导0</span></span><br><span class="line"><span class="comment">//一开始的想法是对其进行取模运算 记录余数和倍数 但是后来发现这样搞也会MLE</span></span><br><span class="line"><span class="comment">//发现都是由0-9数字构成的 所以我们可以统计下0-9的数目 在加起来即可</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span> &amp;&amp; !limit)      <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digit=i;</span><br><span class="line">        ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        ans+=i*(r-l);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因为是保存在Typora上的，现在已经有5000多字了，已经开始卡了，所以会分多期。</p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP专题--数塔问题</title>
      <link href="/2024/05/08/DP%E4%B8%93%E9%A2%98--%E6%95%B0%E5%A1%94%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/08/DP%E4%B8%93%E9%A2%98--%E6%95%B0%E5%A1%94%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="DP专题——数塔问题">DP专题——数塔问题</h1><p>来源自这篇文章：<a href="https://zhuanlan.zhihu.com/p/111637733">【朝夕的ACM笔记】动态规划-数塔问题 - 知乎 (zhihu.com)</a></p><hr><h4 id="P1508-Likecloud-吃、吃、吃-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1508">P1508 Likecloud-吃、吃、吃 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到第i行 第j列可以得到的最大值</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=max(dp[i+1][j+1],dp[i+1][j-1],dp[i+1][j])+a[i][j]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里犯了一个错误 n是奇数 所以不需要n/2-1 直接n/2即可</span></span><br><span class="line">    dp[m][n/<span class="number">2</span>+<span class="number">1</span>]=a[m][n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    dp[m][n/<span class="number">2</span>+<span class="number">2</span>]=a[m][n/<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">    dp[m][n/<span class="number">2</span>]=a[m][n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(&#123;dp[i+<span class="number">1</span>][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]&#125;)+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1216-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1216">P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到第i行 第j列可以得到的最大值</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;  std::cin&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[r][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1004-NOIP2000-提高组-方格取数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k][l] 表示第一次走到(i,j) 第二次走到(k,l)可以获得的最大价值</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j][k][l]</span></span><br><span class="line"><span class="comment">//由于只能向下或者向右走</span></span><br><span class="line"><span class="comment">//所以一共有四种情况</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+num[i][j]+num[k][l]</span></span><br><span class="line"><span class="comment">//注意 走过了就num[i][j] 其数值变为0 所以需要判重</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//num数组表示迷宫</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c &amp;&amp; (a||b||c))</span><br><span class="line">    &#123;</span><br><span class="line">        num[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                    <span class="comment">//判重</span></span><br><span class="line">                    <span class="keyword">if</span>(i==k &amp;&amp; j==l)    dp[i][j][k][l]-=num[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n][n][n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1006-NOIP2008-提高组-传纸条-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1006">P1006 [NOIP2008 提高组] 传纸条 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">//跟方格取数很像 但是不能走重复的路</span></span><br><span class="line"><span class="comment">//所以可以让l 从j+1开始 就可以避免重复了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=j+<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意终点是(m,n)哦 不用算(m,n)的热心值</span></span><br><span class="line">    std::cout&lt;&lt;dp[m][n<span class="number">-1</span>][m<span class="number">-1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化方法</span></span><br><span class="line"><span class="comment">//我们可以发现，由于走的过程中只允许向右或向下走，所以每走一步不是行数加一就是列数加一。</span></span><br><span class="line"><span class="comment">//故在两条路径的长度一样时（也就是走的步数一样多时） 也就是i+j=k+l=步数+2</span></span><br><span class="line"><span class="comment">//所以可以开一个三维数组dp[n+m-2][x1][x2]</span></span><br><span class="line"><span class="comment">//第一维度表示步数 m行n列的矩阵步数从0~n+m-2</span></span><br><span class="line"><span class="comment">//第二维和第三维分别表示两条路径的横坐标，只要知道了步数和横坐标，就可以通过计算得出纵坐标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再考虑优化 其实每次都是只多走了一步 考虑01背包的优化 我们其实也可以把步数这一维度删去</span></span><br><span class="line"><span class="comment">//一开始数组也是简单的只开了60*60 结果WA了 问题出在压缩维度这里</span></span><br><span class="line"><span class="comment">//因为m+n&lt;=100 而num[i][k-i] k:1~m+n-2 所以这个时候 而i的范围是从1-m 所以可以到时候最大到90多</span></span><br><span class="line"><span class="comment">//所以我们可以只开105即可</span></span><br><span class="line"><span class="comment">//dp2不用改 影响的只是num2数组</span></span><br><span class="line"><span class="type">int</span> dp2[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> num2[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;num2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意i+j=k+l=步数+2</span></span><br><span class="line">    <span class="comment">//k枚举的是步数 所以注意num2数组那里要加2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n+m<span class="number">-2</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要处理不同的横坐标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;i;j--)    <span class="comment">//防止路径重复</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp2[i][j]=std::<span class="built_in">max</span>(&#123;dp2[i][j],dp2[i<span class="number">-1</span>][j],dp2[i][j<span class="number">-1</span>],dp2[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line">                dp2[i][j]+=num2[i][k-i+<span class="number">2</span>]+num2[j][k-j+<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp2[m<span class="number">-1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上一道强化版题目的链接：<a href="https://www.luogu.com.cn/problem/T35377">T35377 大教室中传纸条 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><h2 id="单调队列">单调队列</h2><h4 id="P1886-滑动窗口-【模板】单调队列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN],b[MAXN];</span><br><span class="line">std::deque&lt;ll&gt; dqmax;</span><br><span class="line">std::deque&lt;ll&gt; dqmin;</span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间的最小值 维护的是一个单调递增序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//超过滑动窗口的长度 直接弹出头部</span></span><br><span class="line">        <span class="keyword">if</span>(!dqmin.<span class="built_in">empty</span>() &amp;&amp; i-dqmin.<span class="built_in">front</span>()&gt;=k)    dqmin.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">//维护单调递增序列</span></span><br><span class="line">        <span class="keyword">while</span>(!dqmin.<span class="built_in">empty</span>() &amp;&amp; a[dqmin.<span class="built_in">back</span>()]&gt;a[i])   dqmin.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//都满足 则插入i 注意插入的是编号</span></span><br><span class="line">        dqmin.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//i超出k 开始输出</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)      std::cout&lt;&lt;a[dqmin.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间的最大值 维护的是一个单调递增的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//超过滑动窗口的长度 直接弹出头部</span></span><br><span class="line">        <span class="keyword">if</span>(!dqmax.<span class="built_in">empty</span>() &amp;&amp; i-dqmax.<span class="built_in">front</span>()&gt;=k)    dqmax.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">//维护单调递增序列</span></span><br><span class="line">        <span class="keyword">while</span>(!dqmax.<span class="built_in">empty</span>() &amp;&amp; a[dqmax.<span class="built_in">back</span>()]&lt;a[i])   dqmax.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//都满足 则插入</span></span><br><span class="line">        dqmax.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//i超出k 开始输出</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)      std::cout&lt;&lt;a[dqmax.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划2】线性状态动态规划</title>
      <link href="/2024/05/06/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E3%80%91%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2024/05/06/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E3%80%91%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="【动态规划2】线性状态动态规划">【动态规划2】线性状态动态规划</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/212#information">【动态规划2】线性状态动态规划 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><h4 id="P1020-NOIP1999-提高组-导弹拦截-洛谷-计算机科学教育新生态-luogu-com-cn">[P1020 <a href="https://www.luogu.com.cn/problem/P1020">NOIP1999 提高组] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示以i为长度时 最长不上升子序列的最后一项</span></span><br><span class="line"><span class="comment">//分为两种 可以直接插入在尾部 或者 插入在中间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt,x;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,MAXN,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=dp[len])    dp[++len]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//最长不上升子序列是插在最后一个 注意要加上greater&lt;int&gt;() 因为dp数组是递减的</span></span><br><span class="line">            <span class="comment">//注意解引用*</span></span><br><span class="line">            *std::<span class="built_in">upper_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,a[i],std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 dp[1]=a[1]</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    len=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dilworth定理</span></span><br><span class="line">    <span class="comment">//对于一个偏序集，最少链划分等于最长反链长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])    dp[++len]=a[i];     <span class="comment">//直接插入在尾部</span></span><br><span class="line">        <span class="comment">//最长上升子序列是插在找到的第一个 dp数组是递增的</span></span><br><span class="line">        <span class="keyword">else</span>    *std::<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,a[i])=a[i];     <span class="comment">//直接插入在中间</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2285-HNOI2004-打鼹鼠-洛谷-计算机科学教育新生态-luogu-com-cn">[P2285 <a href="https://www.luogu.com.cn/problem/P2285">HNOI2004] 打鼹鼠 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> t[MAXN],x[MAXN],y[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i只鼠鼠时 机器人能够打死多少只鼠鼠</span></span><br><span class="line"><span class="comment">//鼠鼠出现的时间是递增的 所以按顺序枚举即可</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i]=dp[j]+1 if(dis[i-&gt;j]&lt;=t[i]-t[j])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)   std::cin&gt;&gt;t[i]&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;    <span class="comment">//一开始从这个位置开始可以直接打死一只鼠鼠</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]+<span class="number">1</span>&gt;dp[i] &amp;&amp; std::<span class="built_in">abs</span>(x[i]-x[j])+std::<span class="built_in">abs</span>(y[i]-y[j])&lt;=t[i]-t[j])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1725-琪露诺-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">std::deque&lt;ll&gt; dq;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i]表示走到编号为i的格子时 最大冰冻之数 (因为原题中有i==0 也就是起点)</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[j]=max(dp[i])+a[j] (i+l&lt;=j&lt;=i+r)</span></span><br><span class="line"><span class="comment">//有点像一个滑动窗口 所以我们可以使用单调队列来解决</span></span><br><span class="line"><span class="comment">//根据自己的理解写了一下 挂了一些细节 RE啥的 hack暂时没通过(sb洛谷 我原来的答案是错的 居然能过)</span></span><br><span class="line"><span class="comment">//问题 1 没有注意到初始化dp数组 导致hack点没过</span></span><br><span class="line"><span class="comment">//    2 要输入的n+1个点 这个已经解决了</span></span><br><span class="line"><span class="comment">//    3 RE的问题:其实编号为0-&gt;l-1的点是没有dp值的 所以j得从l开始 对应的j编号也要减l</span></span><br><span class="line"><span class="comment">//    4 dp数组更新时没有条件需求 ans要赋值为无穷小</span></span><br><span class="line"><span class="comment">//    5 注意看清题意 j+r&gt;n就算到达 注意在这些范围内更新</span></span><br><span class="line"><span class="comment">//    6 dp[j]=-0x3f3f3f 但是bzd memset出错了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l,r;  std::cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],dp[i]=<span class="number">-0x3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> len=r-l+<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">-0x3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; j-dq.<span class="built_in">front</span>()&gt;=len)    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dp[dq.<span class="built_in">back</span>()]&lt;=dp[j-l])   dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(j-l);</span><br><span class="line">        dp[j]=dp[dq.<span class="built_in">front</span>()]+a[j];</span><br><span class="line">        <span class="keyword">if</span>(j+r&gt;n)   ans=std::<span class="built_in">max</span>(ans,dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4933-大师-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line">ll dp[<span class="number">1010</span>][N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//dp[i][d] 表示前i个塔中 高度差为d的方案数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][h[i]-h[j]]+=dp[j][h[i]-h[j]]+1 注意取模 由于d可能为负数 所以d可以加上一个常数</span></span><br><span class="line"><span class="comment">//ans 就是所有可能情况的和</span></span><br><span class="line"><span class="comment">//方案数 是+= 不是=</span></span><br><span class="line"><span class="comment">//还有一个问题 就是d是+N的 所以可能太大 数组第二维度需要开成2*N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][a[i]-a[j]+N]+=dp[j][a[i]-a[j]+N]+<span class="number">1</span>;</span><br><span class="line">            dp[i][a[i]-a[j]+N]%=mod;</span><br><span class="line">            <span class="comment">//这里先加原来的 再取模 否则会WA</span></span><br><span class="line">            ans+=dp[j][a[i]-a[j]+N]+<span class="number">1</span>;</span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记漏了一个也成立</span></span><br><span class="line">    std::cout&lt;&lt;(ans+n)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1439-【模板】最长公共子序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//dp[i] 表示以i为长度时 最长不上升子序列的最后一项</span></span><br><span class="line"><span class="comment">//分为两种 可以直接插入在尾部 或者 插入在中间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;b[i];</span><br><span class="line">    dp[<span class="number">1</span>]=mp[b[<span class="number">1</span>]];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[b[i]]&gt;dp[len])    dp[++len]=mp[b[i]];</span><br><span class="line">        <span class="keyword">else</span>    *(std::<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,mp[b[i]]))=mp[b[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1435-IOI2000-回文字串-洛谷-计算机科学教育新生态-luogu-com-cn">[P1435 <a href="https://www.luogu.com.cn/problem/P1435">IOI2000] 回文字串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//一开始以为这道题可以使用nlogn的二分优化方法做 后来发现是不可行的</span></span><br><span class="line"><span class="comment">//以样例为例 ab3bd--&gt;db3ba</span></span><br><span class="line"><span class="comment">//原来记录编号 12345-&gt;54321</span></span><br><span class="line"><span class="comment">//这么做 其实不可能构造出一个LIS的</span></span><br><span class="line"><span class="comment">//问题就在于它们之中有相同的元素 但是它们的位置标记却没有改变</span></span><br><span class="line"><span class="comment">//采取优化方法的前提是：序列其中的元素互不相同</span></span><br><span class="line"><span class="comment">//所以这道题只能使用普通方法做了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    std::string t;  t=s;</span><br><span class="line">    std::<span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    t=<span class="string">&#x27;@&#x27;</span>+t;</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])  dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减去它们的公共部分就是需要插入的字符数</span></span><br><span class="line">    std::cout&lt;&lt;n-dp[n][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1874-快速求和-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1874">P1874 快速求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>针对hack的一些看法：<a href="https://www.luogu.com/article/vr0vrkqs">P1874 快速求和 - 洛谷专栏 (luogu.com)</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int dp[45][MAXN];</span></span><br><span class="line"><span class="comment">int num[45][45];</span></span><br><span class="line"><span class="comment">std::string s;</span></span><br><span class="line"><span class="comment">int getNum(int l,int r)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int i=l;</span></span><br><span class="line"><span class="comment">    while(i&lt;=r &amp;&amp; s[i]==&#x27;0&#x27;)    i++;</span></span><br><span class="line"><span class="comment">    if(i&gt;r)return 0;</span></span><br><span class="line"><span class="comment">    if(r-i+1&gt;6) return INF;</span></span><br><span class="line"><span class="comment">    else return std::stoi(s.substr(i,r-i+1));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void solve()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    std::cin&gt;&gt;s;</span></span><br><span class="line"><span class="comment">    int n;  std::cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    s=&#x27;0&#x27;+s;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;s.length();i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=i;j&lt;s.length();j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            num[i][j]=getNum(i,j);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    memset(dp,0x3f,sizeof(dp));</span></span><br><span class="line"><span class="comment">    dp[0][0]=-1;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;s.length();i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int k=1;k&lt;=i;k++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if(j&gt;=num[i-k+1][i])    dp[i][j]=std::min(dp[i-k][j-num[i-k+1][i]]+1,dp[i][j]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if(dp[s.length()-1][n]&gt;=s.length()-1)   std::cout&lt;&lt;-1&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    else    std::cout&lt;&lt;dp[s.length()-1][n]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll num[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line">ll dp[<span class="number">45</span>][MAXN];</span><br><span class="line"><span class="comment">//dp[i][j] 表示前i个数中 和为j所需要添加的+</span></span><br><span class="line"><span class="comment">//num[i][j]表示从编号为i的数到编号为j的数 构成的数字</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=min(dp[i][j],dp[i-k+1][j-num[i-k][i]]+1)  k表示的区间的长度</span></span><br><span class="line"><span class="comment">//在这道题上花了很长时间了</span></span><br><span class="line"><span class="comment">//一个方面就是没想到num数组的更新的问题 不过后来解决了</span></span><br><span class="line"><span class="comment">//其实状态需转移方程不难想 问题在于预处理 这个预处理真的是毒瘤</span></span><br><span class="line"><span class="comment">//第一个就是 dp[0][0]的初始化 如果长度为0和为 不需要加加号就可以使和为0 但第一次算会加1 因此初始状态dp[0][0]设为-1</span></span><br><span class="line"><span class="comment">//dp 数组初始化 memset只能0-255 所以不要乱用memset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也许找到了一种方法? 看看num是否超出范围 如果超出 就赋值为INF</span></span><br><span class="line"><span class="comment">//其实就是上面文章提供的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    ll n;  std::cin&gt;&gt;n;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i][j]=num[i][j<span class="number">-1</span>]*<span class="number">10</span>+s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[1][num[1][1]]=0;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num[i-k][i])    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i-k<span class="number">-1</span>][j-num[i-k][i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][n]&gt;=len)     std::cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    std::cout&lt;&lt;dp[len][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大佬师兄指点后的代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll num[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line">ll dp[<span class="number">45</span>][MAXN];</span><br><span class="line"><span class="comment">//dp[0][j]没初始化导致WA</span></span><br><span class="line"><span class="comment">//然后num数组因为有些值会爆long long从而可能变成负值 导致dp转移式子中会越界 导致RE</span></span><br><span class="line"><span class="comment">//终于解决了一个困扰已久的问题</span></span><br><span class="line"><span class="comment">//memset(dp,0x3f,sizeof(dp)) memset是取赋值的后八位(也就是一个字节填充全部的字节,int就是由0x3f的后8位赋值全部的字节)</span></span><br><span class="line"><span class="comment">//0x3f:00111111     dp-&gt;00111111 00111111 00111111 001111111</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    ll n;  std::cin&gt;&gt;n;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i][j]=num[i][j<span class="number">-1</span>]*<span class="number">10</span>+s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x6f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num[i-k][i] &amp;&amp; num[i-k][i]&gt;=<span class="number">0</span>)    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i-k<span class="number">-1</span>][j-num[i-k][i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][n]&gt;=len)     std::cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    std::cout&lt;&lt;dp[len][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2758-编辑距离-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到a的第i个字符 b的第j个字符 使得a==b 的操作次数</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(a[i]!=b[j]))</span></span><br><span class="line"><span class="comment">//根据题意 初始化dp[i][0]=i,dp[0][j]=j 最基本的情况就是长度为0的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string a,b;    std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    a=<span class="string">&quot;@&quot;</span>+a;</span><br><span class="line">    b=<span class="string">&quot;@&quot;</span>+b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b.<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]!=b[j])&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[a.<span class="built_in">size</span>()<span class="number">-1</span>][b.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1091-NOIP2004-提高组-合唱队形-洛谷-计算机科学教育新生态-luogu-com-cn">[P1091 <a href="https://www.luogu.com.cn/problem/P1091">NOIP2004 提高组] 合唱队形 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>],g[<span class="number">110</span>];</span><br><span class="line"><span class="comment">//思路不难想 从1-&gt;n 求一遍LIS 再从n-&gt;1 求一遍LIS 枚举位置 就可以求出来了</span></span><br><span class="line"><span class="comment">//dp: 1-&gt;n</span></span><br><span class="line"><span class="comment">//g: 1-&gt;n</span></span><br><span class="line"><span class="comment">//不要忘记单独一个点初始化为1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])   dp[i]=std::<span class="built_in">max</span>(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要使用reverse 否则编号乱了</span></span><br><span class="line">    <span class="comment">//std::reverse(a+1,a+1+n);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])   g[i]=std::<span class="built_in">max</span>(g[j]+<span class="number">1</span>,g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]+g[i]<span class="number">-1</span>);<span class="comment">//-1 否则会把自己算重复了</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;n-ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1854-花店橱窗布置-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//dp[i][j]表示 以前i束花中 前j个花瓶中 可以获得的最大美学价值</span></span><br><span class="line"><span class="comment">//a[i][j]   花束i摆放在花瓶j中的美学值</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i][j],dp[i-1][j-1],dp[i-1][j-2].....dp[i-1][i-1])</span></span><br><span class="line"><span class="comment">void print(ll x,ll y)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(x)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ll p=x;</span></span><br><span class="line"><span class="comment">        while(dp[x][p]!=y)  p++;</span></span><br><span class="line"><span class="comment">        print(x-1,y-a[x][p]);</span></span><br><span class="line"><span class="comment">        std::cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void solve()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int f,v;    std::cin&gt;&gt;f&gt;&gt;v;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=f;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=v;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            std::cin&gt;&gt;a[i][j];</span></span><br><span class="line"><span class="comment">            dp[i][j]=-2E9;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    dp[0][0]=0;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=f;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=i;j&lt;=v;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //dp[i][j]=std::max(dp[i-1][j-1]+a[i][j],dp[i][j]);</span></span><br><span class="line"><span class="comment">            for(int k=1;k&lt;=j-i+1;k++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=std::max(dp[i][j],dp[i-1][j-k]+a[i][j]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ll ans=0;</span></span><br><span class="line"><span class="comment">    for(int i=f;i&lt;=v;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ans=std::max(ans,dp[f][i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    print(f,ans);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//上面的方法最后一个点WA了 下面的这种方法跟我一开始想的相似 但是有些地方又不太一样</span></span><br><span class="line"><span class="comment">//主要是学习一下如何用记录</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos[<span class="number">110</span>];       <span class="comment">//pos数组记录答案</span></span><br><span class="line">    <span class="type">int</span> p;      <span class="comment">//指针</span></span><br><span class="line">&#125;book[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f,v;    std::cin&gt;&gt;f&gt;&gt;v;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-127</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=f;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=v;i++)   dp[<span class="number">0</span>][i]=<span class="number">0</span>;     <span class="comment">//最初一朵花都没插 所以是0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=f;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]&gt;dp[i][j<span class="number">-1</span>])     <span class="comment">//这里的状态转移方程和上面不一样</span></span><br><span class="line">            <span class="comment">//这样理解 dp[i][j-1]表示 第i束花放在第j-1个花瓶可以获得的最大美学价值</span></span><br><span class="line">            <span class="comment">//原来这里可能有花并且摆法更好 也就是 dp[i-1][j-1]+a[i][j]&gt;dp[i][j-1] 那么就要让位了</span></span><br><span class="line">            <span class="comment">//注意下面更新的是dp[i][j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                book[i][j]=book[i<span class="number">-1</span>][j<span class="number">-1</span>];  <span class="comment">//从前一个情况继承过来</span></span><br><span class="line">                book[i][j].pos[++book[i][j].p]=j;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                book[i][j]=book[i][j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[f][v]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=book[f][v].p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;book[f][v].pos[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sth,stm,eth,etm,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    std::cin&gt;&gt;sth&gt;&gt;ch&gt;&gt;stm&gt;&gt;eth&gt;&gt;ch&gt;&gt;etm;</span><br><span class="line">    <span class="type">int</span> tot=eth*<span class="number">60</span>+etm-sth*<span class="number">60</span>-stm;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,c,p;  std::cin&gt;&gt;t&gt;&gt;c&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)    p=<span class="number">999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w[++cnt]=j*t;</span><br><span class="line">            v[cnt]=j*c;</span><br><span class="line">            p-=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)   w[++cnt]=p*t,v[cnt]=p*c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot;j&gt;=w[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[tot]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2340-USACO03FALL-Cow-Exhibition-G-洛谷-计算机科学教育新生态-luogu-com-cn">[P2340 <a href="https://www.luogu.com.cn/problem/P2340">USACO03FALL] Cow Exhibition G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">//ll dp[410][410];</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">410</span>],f[<span class="number">410</span>];</span><br><span class="line"><span class="comment">//两个限制条件的背包问题</span></span><br><span class="line"><span class="comment">//一开始的思路是dp[i][j] 表示情商和为i 智商和为j的 所取得的最大值</span></span><br><span class="line"><span class="comment">//但是发现数据范围有负数 并且是1&lt;=n&lt;=400 -1000&lt;=s(f)&lt;=1000</span></span><br><span class="line"><span class="comment">//为了处理这个问题数组会爆炸 所以不行</span></span><br><span class="line"><span class="comment">//换个思路 背包一般是求最大体积下的最大值</span></span><br><span class="line"><span class="comment">//那么我们可以类似设计出 最大智商和下的最大情商和</span></span><br><span class="line"><span class="comment">//dp[i] 表示智商和为i的情况下 可以获得的最大情商和</span></span><br><span class="line"><span class="comment">//为了处理负数的问题 我们可以一开始把智商都加上1000</span></span><br><span class="line"><span class="comment">//所以数组的范围是 400*1000*2=800000</span></span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">//状态转移方程 dp[j]=max(dp[j-s[i]]+f[i],dp[j])</span></span><br><span class="line"><span class="comment">//一开始想的是能否把s[i]都加上1000 再转移 但是这样需要记录路径 我自己写挂了</span></span><br><span class="line"><span class="comment">//所以采用题解的方法 干脆把整个数组进行偏移400 * 1000</span></span><br><span class="line"><span class="comment">//还需要注意一点 如果s[i]是负的 那么j-s[i]&gt;j了 这时就得改变for的顺序 改为正序枚举</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;s[i]&gt;&gt;f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">400000</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">800000</span>;j&gt;=s[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-s[i]]+f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里时 傻乎乎的犯了一个错误 这里需要从0开始 不能从400000开始</span></span><br><span class="line">            <span class="comment">//因为智商是有负的 我们只是进行了偏移而已 不能不更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">800000</span>+s[i];j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-s[i]]+f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">400000</span>;i&lt;=<span class="number">800000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=std::<span class="built_in">max</span>(ans,dp[i]+i<span class="number">-400000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4310-绝世好题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4310">P4310 绝世好题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示以第i个数为结尾 能够得到的子序列b的最长长度</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i]=dp[j]+1  if(dp[i]&lt;dp[j]+1 &amp;&amp; i&gt;j &amp;&amp; a[i]&amp;a[j]!=0)</span></span><br><span class="line"><span class="comment">// ok TLE一个点 果然还是太侥幸了 修改一下方法</span></span><br><span class="line"><span class="comment">// 其实可以发现 一直更新是非常耗时的 而且每次查询的区间是从1-&gt;i 1-&gt;i+1 1-&gt;i+2 长度 加一</span></span><br><span class="line"><span class="comment">//那么其实我们可以记录当前区间的最大值 然后再i++后 判断新的是否大于原来的dp[i]即可</span></span><br><span class="line"><span class="comment">//不用开数组 直接ans记录 更新即可</span></span><br><span class="line"><span class="comment">//其实这种方法不是正解 明天再补吧 太晚了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],     dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;ans)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;dp[j]+<span class="number">1</span> &amp;&amp; (a[i]&amp;a[j])!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1004-NOIP2000-提高组-方格取数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k][l] 表示第一次走到(i,j) 第二次走到(k,l)可以获得的最大价值</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j][k][l]</span></span><br><span class="line"><span class="comment">//由于只能向下或者向右走</span></span><br><span class="line"><span class="comment">//所以一共有四种情况</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+num[i][j]+num[k][l]</span></span><br><span class="line"><span class="comment">//注意 走过了就num[i][j] 其数值变为0 所以需要判重</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//num数组表示迷宫</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c &amp;&amp; (a||b||c))</span><br><span class="line">    &#123;</span><br><span class="line">        num[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                    <span class="comment">//判重</span></span><br><span class="line">                    <span class="keyword">if</span>(i==k &amp;&amp; j==l)    dp[i][j][k][l]-=num[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n][n][n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1541-NOIP2010-提高组-乌龟棋-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">360</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i个格子可以获得的最多分数</span></span><br><span class="line"><span class="comment">//dp[i]=max(dp[i],dp[i-1]+a[i],dp[i-2]+a[i],dp[i-3]+a[i],dp[i-4]+a[i])</span></span><br><span class="line"><span class="comment">//发现这个思路是错误的 因为题目中没有将其和方格中的分数绑定在一起</span></span><br><span class="line"><span class="comment">//因为需要考虑牌的数目 所以不妨设dp[a][b][c][d] 依次表示第一种牌 第二种牌 第三第四</span></span><br><span class="line"><span class="comment">//通过枚举牌的数量 可以进行状态转移</span></span><br><span class="line"><span class="type">int</span> mp[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意一开始的分数就是a[1]</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=4;i++)   std::cout&lt;&lt;mp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mp[<span class="number">1</span>];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=mp[<span class="number">2</span>];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=mp[<span class="number">3</span>];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=mp[<span class="number">4</span>];l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> &amp;d=dp[i][j][k][l];</span><br><span class="line">                    <span class="comment">//这里要特别注意加1 因为是从1开始的 要算上1这个开始的格子</span></span><br><span class="line">                    <span class="type">int</span> dis=<span class="number">1</span>*i+<span class="number">2</span>*j+<span class="number">3</span>*k+<span class="number">4</span>*l+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i)   d=std::<span class="built_in">max</span>(d,dp[i<span class="number">-1</span>][j][k][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(j)   d=std::<span class="built_in">max</span>(d,dp[i][j<span class="number">-1</span>][k][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(k)   d=std::<span class="built_in">max</span>(d,dp[i][j][k<span class="number">-1</span>][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(l)   d=std::<span class="built_in">max</span>(d,dp[i][j][k][l<span class="number">-1</span>]+a[dis]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[mp[<span class="number">1</span>]][mp[<span class="number">2</span>]][mp[<span class="number">3</span>]][mp[<span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3147-USACO16OPEN-262144-P-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3147">P3147 [USACO16OPEN] 262144 P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>题解链接：<a href="https://www.luogu.com.cn/article/pq62uvcs">题解 P3147 【[USACO16OPEN]262144】</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">61</span>][MAX];</span><br><span class="line"><span class="comment">//真难 这个dp真想不出来</span></span><br><span class="line"><span class="comment">//直接看题解吧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        dp[x][i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">58</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][dp[i<span class="number">-1</span>][j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j])    ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2679-NOIP2015-提高组-子串-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2679">P2679 [NOIP2015 提高组] 子串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder DP Contest</title>
      <link href="/2024/05/05/Atcoder%20DP%20Contest/"/>
      <url>/2024/05/05/Atcoder%20DP%20Contest/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-DP-Contest">Atcoder DP Contest</h1><p>这里是题单的链接：<a href="https://www.luogu.com.cn/training/244301#problems">AtCoder DP Contest - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>目前还有些题目没写 后续学完相关知识再补</p><h2 id="A">A</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;h[i];</span><br><span class="line">    <span class="comment">//dp[1]=h[1],不需要初始化dp[1]，本身就是0</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="built_in">abs</span>(h[<span class="number">2</span>]-h[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=std::<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-1</span>]),dp[i<span class="number">-2</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="B">B</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i]记作跳到第i块石头所花费的最小体力</span></span><br><span class="line"><span class="comment">//状态转移方程：</span></span><br><span class="line"><span class="comment">//dp[i]=min(dp[i-1]+abs(h[i]-h[i-1]) dp[i-2]+abs(h[i]-h[i-2])------)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> k;  std::cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;h[i],dp[i]=<span class="number">1e15</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[2]=abs(h[2]-h[1]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=std::<span class="built_in">min</span>(k,i<span class="number">-1</span>);j++)</span><br><span class="line">        dp[i]=std::<span class="built_in">min</span>(dp[i-j]+<span class="built_in">abs</span>(h[i]-h[i-j]),dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line">ll dp[MAXN][<span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[i][j]表示第i天，以第j种活动结束</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//假设j=1</span></span><br><span class="line"><span class="comment">// 1-a 2-b 3-c</span></span><br><span class="line"><span class="comment">//dp[i][1]=max(dp[i-1][2]+a[i],dp[i-1][3]+a[i])</span></span><br><span class="line"><span class="comment">//其他的同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)std::cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+a[i],dp[i<span class="number">-1</span>][j+<span class="number">2</span>]+a[i]);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">2</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i],dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+b[i]);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">3</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i],dp[i<span class="number">-1</span>][j<span class="number">-2</span>]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::<span class="built_in">max</span>(&#123;dp[n][<span class="number">1</span>],dp[n][<span class="number">2</span>],dp[n][<span class="number">3</span>]&#125;)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D">D</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//最初的想法是三个维度：容量，取到了第i个物品，以及是否取</span></span><br><span class="line"><span class="comment">//是否取对后面的状态转移没有任何影响，所以可以删去</span></span><br><span class="line"><span class="comment">//取到第i个物品的状态转移似乎也没有影响，所以可以删去</span></span><br><span class="line"><span class="comment">//保留容量维度</span></span><br><span class="line"><span class="comment">//dp[i]表示容量为i时，最大价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> W;  std::cin&gt;&gt;W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)<span class="comment">//注意要倒序枚举 否则是从更新后的状态转移过来的</span></span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[W]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E">E</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//一道很有趣的题目</span></span><br><span class="line"><span class="comment">//这道题的范围很大 看了一眼题解区 以为题目修改过 或者 翻译有误</span></span><br><span class="line"><span class="comment">//仔细一想 这道题是从一个新奇的角度分析背包问题</span></span><br><span class="line"><span class="comment">//注意到范围是1e9 即使是一维也无法解决</span></span><br><span class="line"><span class="comment">//要求的还是同样的问题 从另外一个角度入手</span></span><br><span class="line"><span class="comment">//仍然是一维</span></span><br><span class="line"><span class="comment">//dp[i] 表示的是总价值为i时 最小的体积 有点倒反天罡的趣味</span></span><br><span class="line"><span class="comment">//这里取最小值 是因为体积越小 越能容纳更多的物品 总价值也就越大 这是一种贪心的想法</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i]=min(dp[i],dp[i-v[j]]+w[i])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> W;  std::cin&gt;&gt;W;</span><br><span class="line">    <span class="type">int</span> V=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;w[i]&gt;&gt;v[i],V+=v[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">            dp[j]=std::<span class="built_in">min</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=V;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;=W)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="F">F</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//dp[i][j]表示以s[i] t[j]结尾的最长公共子序列长度</span></span><br><span class="line"><span class="comment">//状态转移方程：dp[i][j]=dp[i-1][j-1]+1 if s[i]==t[j] else max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line"><span class="comment">//这里注意需要先把字符串加上@，这样才避免预处理时候的麻烦</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s,t;    std::cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">    std::string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    s=<span class="string">&quot;@&quot;</span>+s,t=<span class="string">&quot;@&quot;</span>+t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])  dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用双指针实现</span></span><br><span class="line">    <span class="comment">//如果是正序 无法保证一定是最长的 需要倒序(因为已经知道了最长的长度，可以保证一定是最优的)</span></span><br><span class="line">    <span class="type">int</span> sp=n,tp=m;</span><br><span class="line">    <span class="keyword">while</span>(sp&gt;<span class="number">0</span>&amp;&amp;tp&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[sp]==t[tp])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[sp];</span><br><span class="line">            sp--;tp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[sp<span class="number">-1</span>][tp]&gt;dp[sp][tp<span class="number">-1</span>])   sp--;</span><br><span class="line">            <span class="keyword">else</span> tp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="G">G</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[MAXN],in[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i个节点的最长路径</span></span><br><span class="line"><span class="comment">//状态转移方称 dp[i]=max(dp[j]+1,dp[i]); j为i的父节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="comment">//记得搜索的顺序和dp是相反的</span></span><br><span class="line"><span class="comment">//dp是由起点-&gt;终点 而dfs是从终点-&gt;起点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto t:edge[x])</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(dp[t.to]&lt;dp[t.from]+1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            dp[t.to]=dp[t.from]+1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        dfs(t.to);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//这里写挂了，导致重复dfs了很多次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新问题</span></span><br><span class="line">    <span class="comment">//这里需要判断一下dp[x]是否为0 否则搜索太多次 也会TLE</span></span><br><span class="line">    <span class="keyword">if</span>(dp[x]==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t: edge[x]) &#123;</span><br><span class="line">            dp[x] = std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(t.to) + <span class="number">1</span>, dp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="comment">//in[v]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(i),ans);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="H">H</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">char</span> mp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h,w;    std::cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)std::cin&gt;&gt;mp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[i][<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[<span class="number">1</span>][i]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=w;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i<span class="number">-1</span>][j]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=(dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i<span class="number">-1</span>][j]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=dp[i<span class="number">-1</span>][j]%mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[i<span class="number">-1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i][j<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=dp[i][j<span class="number">-1</span>]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[h][w]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="I">I</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="type">double</span> p[<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示前i枚硬币中 有j枚正面朝上的概率</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1-p[i]);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[0][0]初始化 其他非法状态不考虑</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]*p[i]+dp[i<span class="number">-1</span>][j]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//题目要求的是正&gt;负 看清楚题目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i+i&gt;n;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dp[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意输出保留10位精度</span></span><br><span class="line">    std::cout&lt;&lt;std::fixed&lt;&lt;std::<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="J">J</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> dp[<span class="number">310</span>][<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//dp[i][j][k] 表示共有i个盘子中有1个寿司 j个盘子中有2个寿司 k个盘子中有3个寿司</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j][k]=n/(i+j+k)+i/(i+j+k)*dp[i-1][j][k]+j/(i+j+k)*dp[i+1][j-1][k]</span></span><br><span class="line"><span class="comment">//+k/(i+j+k)*dp[i][j+1][k-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> all=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要注意以下枚举的顺序</span></span><br><span class="line">    <span class="comment">//先枚举有3个寿司的盘子 再枚举有2个寿司的盘子 再枚举有一个寿司的盘子</span></span><br><span class="line">    <span class="comment">//因为寿司多的盘子 其寿司数目会减少 影响寿司少的盘子的情况</span></span><br><span class="line">    <span class="comment">//如果是1-&gt;2-&gt;3的顺序枚举 有一些更新的状态就没有参与到dp中了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i||j||k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k]=(<span class="type">double</span>)n/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(i)dp[i][j][k]+=i*dp[i<span class="number">-1</span>][j][k]/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(j)dp[i][j][k]+=j*dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(k)dp[i][j][k]+=k*dp[i][j+<span class="number">1</span>][k<span class="number">-1</span>]/(i+j+k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全部盘子都收集完了</span></span><br><span class="line">    std::cout&lt;&lt;std::fixed&lt;&lt;std::<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;dp[m[<span class="number">1</span>]][m[<span class="number">2</span>]][m[<span class="number">3</span>]]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="K">K</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//属于博弈论的dp</span></span><br><span class="line"><span class="comment">//dp[i] 表示到第i个石子的时候 当前者的胜负</span></span><br><span class="line"><span class="comment">//当i==0 f[0]=0;</span></span><br><span class="line"><span class="comment">//顺序推导 求出f[n]即可判断胜负</span></span><br><span class="line"><span class="comment">//认识到一个点 如果当前是必败态 那么它必然是从必胜态转移过来的</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i]+=!dp[i-a[j]] 注意这里是|或者+运算 因为可能是从多个状态转移过来的 只要有一种胜利即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很有Nim博弈的味道 DAG推导</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]|=!dp[i-a[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(dp[k]?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="L">L</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">3010</span>];</span><br><span class="line">ll dp[<span class="number">3010</span>][<span class="number">3010</span>],sum[<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//这道题目有合并的性质 所以我们可以考虑使用区间dp</span></span><br><span class="line"><span class="comment">//dp[i][j]表示 从i到j区间内 first的最大分数</span></span><br><span class="line"><span class="comment">//由于这是一道博弈论问题 所以需要从对手的状态转移过来</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(sum[i+1][j]-dp[i+1][j]+a[i],sum[i][j-1]-dp[i][j-1]+a[j])</span></span><br><span class="line"><span class="comment">//sum[i][j] 表示从i到j之间的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        dp[i][i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(sum[j]-sum[i]-dp[i+<span class="number">1</span>][j]+a[i],sum[j<span class="number">-1</span>]-sum[i<span class="number">-1</span>]-dp[i][j<span class="number">-1</span>]+a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;-(sum[n]<span class="number">-2</span>*dp[<span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="M">M</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">ll dp[MAXN],sum[MAXN];</span><br><span class="line"><span class="comment">//dp[i]表示前i颗糖分完的方案数</span></span><br><span class="line"><span class="comment">//dp[i]+=dp[i-(1,2,---a[j])]</span></span><br><span class="line"><span class="comment">//sum[i]是dp[i] dp[i-1] dp[i-2]-----的前缀和 否则会TLE</span></span><br><span class="line"><span class="comment">//所以就优化为dp[i]=sum[i]-sum[i-a[j]-1]</span></span><br><span class="line"><span class="comment">//需要注意的是i可能&lt;=a[j] 所以dp[i]=sum[i]了 注意分类讨论</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实直接比较好想的是dp[i][j] 表示前i个人分了j个糖果的情况 但是自己当时脑回路清奇 直接把第一维压缩了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;  std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>]=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j]=(sum[j<span class="number">-1</span>]+dp[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;a[i])dp[j]=(sum[j]-sum[j-a[i]<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">            <span class="keyword">else</span> dp[j]=sum[j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[k]%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="N">N</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">4010</span>];</span><br><span class="line">ll dp[<span class="number">4010</span>][<span class="number">4010</span>],sum[<span class="number">4010</span>];</span><br><span class="line"><span class="comment">//一道经典的区间dp题目</span></span><br><span class="line"><span class="comment">//dp[i][j]表示合并成区间[i,j]所需要的最大代价</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//[i,j]可以由[i,k],[k,j]合并得到 所以需要枚举k</span></span><br><span class="line"><span class="comment">//除了本身的代价外 还有[i,j]的区间和</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+sum[j]-sum[i-1],dp[i][j])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间dp三个步骤</span></span><br><span class="line">    <span class="comment">//枚举长度</span></span><br><span class="line">    <span class="comment">//枚举起点</span></span><br><span class="line">    <span class="comment">//枚举分段点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+l<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//注意枚举的分段点是从i开始 但是要小于j,否则有可能k+1&gt;j越界</span></span><br><span class="line">            <span class="comment">//原来一开始是写k=i+1 但是实际上可以是由一个数加上一个区间的合并</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="O">O</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//ll dp[25][MAXN];</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="comment">//一道状态压缩dp 涉及到二分图匹配</span></span><br><span class="line"><span class="comment">//为什么会用到状压呢? 这是个二分图匹配问题 涉及集合 所以可能想到用状压 另一方面就是n比较小</span></span><br><span class="line"><span class="comment">//dp[i][j]表示前i个男生 到由若干个女生构成的集合j中 一一匹配的方案数</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=dp[i][j]+dp[i-1][j-k]  (j-k)表示j中去掉元素k</span></span><br><span class="line"><span class="comment">//状压dp一般下标从0开始 方便位运算(这里就是a[i][j]中i j下标从0开始)</span></span><br><span class="line"><span class="comment">//遇到一个奇怪的问题 第二维度开太小了 应该是RE才对 结果却是WA</span></span><br><span class="line"><span class="comment">//猜测越位哪些被忽略了 从而导致答案错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//考虑优化 第一维可以省略</span></span><br><span class="line"><span class="comment">//优化后 dp[i]=dp[i]+dp[i-k] 含义一样</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void solve1()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int n;  std::cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            std::cin&gt;&gt;a[i][j];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    dp[0][0]=1;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;(1&lt;&lt;n);j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(__builtin_popcount(j)==i)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                for(int k=0;k&lt;n;k++)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    if(a[i][k]&amp;&amp;(j&amp;(1&lt;&lt;k))==0)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        dp[i+1][j|(1&lt;&lt;k)]=(dp[i][j]+dp[i+1][j|(1&lt;&lt;k)])%mod;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;dp[n][(1&lt;&lt;n)-1]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=__builtin_popcount(i);</span><br><span class="line">        <span class="comment">//原来是__builtin_popcount(j)==i 枚举i 看i与j是否完全配对</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[cnt][j]&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;j))==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=(dp[i|(<span class="number">1</span>&lt;&lt;j)]+dp[i])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P">P</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">ll dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//vis 其实跟记忆化搜索差不多</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="comment">//dp[i][0] 表示以第i号节点为根节点且第i号节点为白色时的方案数</span></span><br><span class="line"><span class="comment">//dp[i][1] 表示以第i号节点为根节点且第i号节点为黑色时的方案数</span></span><br><span class="line"><span class="comment">//dp[i][0]*=dp[j][0]+dp[j][1] 其中j指的是i的子节点</span></span><br><span class="line"><span class="comment">//dp[i][1]*=dp[j][0]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e.to;</span><br><span class="line">        <span class="keyword">if</span>(vis[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//注意的先vis标记 否则有些情况会重复计算</span></span><br><span class="line">        vis[y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        dp[x][<span class="number">0</span>]*=(dp[y][<span class="number">0</span>]+dp[y][<span class="number">1</span>]);</span><br><span class="line">        dp[x][<span class="number">0</span>]%=mod;</span><br><span class="line">        dp[x][<span class="number">1</span>]*=dp[y][<span class="number">0</span>];</span><br><span class="line">        dp[x][<span class="number">1</span>]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//没有确定根节点 所以建立双向边 首先遍历到的就是父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样 我们就可以默认1为根节点 直接dfs即可</span></span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(dp[<span class="number">1</span>][<span class="number">0</span>]+dp[<span class="number">1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Q">Q</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll be[<span class="number">1010</span>];   <span class="comment">//表示区间i的最大值</span></span><br><span class="line">ll b[MAXN];    <span class="comment">//单个元素dp[i]的max</span></span><br><span class="line"><span class="comment">//dp[i] 表示以第i个元素为结尾 可以得到的最大权值</span></span><br><span class="line"><span class="comment">//dp[i]=max(dp[j])+a[i] (1&lt;h[j]&lt;h[i])</span></span><br><span class="line"><span class="comment">//由于区间范围较大 所以需要优化一下 这里用分块</span></span><br><span class="line"><span class="comment">//因为是从1开始 所以前面直接枚举块 后面枚举零散的元素即可</span></span><br><span class="line"><span class="comment">//更新的时候 因为是单点更新 所以对应的点更新(记作A) 块也要更新(后面的元素寻找max时 A是在块中)</span></span><br><span class="line"><span class="comment">//总结一点 点要更新 所在的块也要更新</span></span><br><span class="line"><span class="type">int</span> h[MAXN],a[MAXN];</span><br><span class="line"><span class="type">int</span> block;  <span class="comment">//块长</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x]=std::<span class="built_in">max</span>(b[x],y);</span><br><span class="line">    be[x/block+<span class="number">1</span>]=std::<span class="built_in">max</span>(be[x/block+<span class="number">1</span>],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r/block;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,be[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r/block*block;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    block=std::<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="built_in">query</span>(h[i]<span class="number">-1</span>)+a[i];</span><br><span class="line">        <span class="built_in">update</span>(h[i],dp[i]);</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="R">R</h2><p>没写</p><h2 id="S">S</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10010</span>],dp[<span class="number">10010</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][sum][limit][lead]</span></span><br><span class="line"><span class="comment">//pos limit lead 含义不变</span></span><br><span class="line"><span class="comment">//sum 表示到当前位时的各位数字之和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原来一开始MLE了 最先优化 考虑删除掉 lead维度 但是还是有2个点WA了</span></span><br><span class="line"><span class="comment">//应该是出现了负数 最后结果加上mod 再取模即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以再进一步优化</span></span><br><span class="line"><span class="comment">//dp[pos][sum][limit]</span></span><br><span class="line"><span class="comment">//pos limit 含义不变</span></span><br><span class="line"><span class="comment">//sum 表示到当前位时的各位数字之和 </span></span><br><span class="line"><span class="comment">//考虑到D的范围是从0-100 所以其实sum的范围最大到100多即可 这里110</span></span><br><span class="line"><span class="type">int</span> cnt,D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum%D==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,(sum+i)%D,limit &amp;&amp; i==a[pos]);</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string k;</span><br><span class="line">    std::cin&gt;&gt;k&gt;&gt;D;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=k[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;cnt;i++)  std::cout&lt;&lt;a[i];</span></span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>)<span class="number">-1</span>+mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="T">T</h2><p>没写</p><h2 id="U">U</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//这是一道状压dp问题</span></span><br><span class="line"><span class="comment">//怎么看出来 1 n范围小 2 涉及到集合处理的问题</span></span><br><span class="line"><span class="comment">//但我对状压还是不太熟悉 所以还是看题解了 关键还是怎么枚举集合 进行位运算</span></span><br><span class="line"><span class="comment">//不难想到状态转移方为 dp[i]=max(dp[i],dp[j]+dp[k])   这里的i j k就表示集合</span></span><br><span class="line"><span class="comment">//j 和 k 是i的子集 其实有点像之前的二分图dp 感觉处理方式都是一样的 分成不同的集合来进行处理</span></span><br><span class="line"><span class="comment">// 难点是进行位运算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="comment">// i枚举集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举 存在两边的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断是否存在连边</span></span><br><span class="line">                <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span> &amp;&amp; (i&gt;&gt;k)&amp;<span class="number">1</span>)    dp[i]+=a[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举子集和</span></span><br><span class="line">        <span class="comment">//j=(j-1)&amp;i 这样可以保证j是越来越小的 且是i的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j;j=(j<span class="number">-1</span>)&amp;i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=std::<span class="built_in">max</span>(dp[i],dp[j]+dp[i^j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="V">V</h2><p>没写</p><h2 id="W">W</h2><p>没写</p><h2 id="X">X</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll w,s,v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w+s&lt;b.w+b.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//01背包 + 贪心</span></span><br><span class="line"><span class="comment">//对背包有了新的理解 限重可以抽象为当前背包的某个限制条件</span></span><br><span class="line"><span class="comment">//一开始在考虑怎么处理 限重的问题</span></span><br><span class="line"><span class="comment">//采用的是贪心的思路 如果两个货物i j 在题它们上面 想要堆叠更多的物品 不难想到 si-wj&lt;sj-wi</span></span><br><span class="line"><span class="comment">//这样可以保证可以堆叠更多的物品 转换得到 si+wi&lt;sj+wj</span></span><br><span class="line"><span class="comment">//那么可以这样处理</span></span><br><span class="line"><span class="comment">//原本的dp[i][j]方程表示的是 dp[i][j]表示前i个物品中 s+w为j时能得到的最大价值</span></span><br><span class="line"><span class="comment">//考虑优化 那么i维度就可以删去 --&gt; dp[j]</span></span><br><span class="line"><span class="comment">//状态转移方程基本一致 dp[j]=max(dp[j],dp[j-a[i].s]+a[i].v) 注意倒序枚举</span></span><br><span class="line"><span class="comment">//还需要注意j 不是枚举最大的MAX 而是当前箱子的w+s 并不是一开始能够容纳的上限就是最大的 而是所枚举的箱子的MAX</span></span><br><span class="line"><span class="comment">//之前的背包的上限是一个固定值 是唯一且确定的 但这个不是 根据箱子的枚举而改变MAX</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].w&gt;&gt;a[i].s&gt;&gt;a[i].v;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="comment">//memset(dp,-0x3f3f3f3f,sizeof(dp));</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ll MAX=a[n].s+a[n].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=a[i].w+a[i].s;j&gt;=a[i].w;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j-a[i].w]+a[i].v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//补充一点 这里还需要取max</span></span><br><span class="line">    <span class="comment">//原本的普通背包是不用的</span></span><br><span class="line">    <span class="comment">//这里wsm需要? </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Y">Y</h2><p>没写</p><h2 id="Z">Z</h2><p>没写</p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论研究</title>
      <link href="/2024/05/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%A0%94%E7%A9%B6/"/>
      <url>/2024/05/05/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论研究">博弈论研究</h1><p>前置知识这里不会细讲，可以看看这几位大佬的博客和文章，感觉讲得很好。</p><p>记住这句话，“<strong>每个必胜的状态都是从对手的上个必败状态推来的，必败也是同理。</strong>”。</p><p><a href="https://zhuanlan.zhihu.com/p/257013159">算法学习笔记(51): SG函数 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/flashhu/p/8665204.html">博弈论总结（只会打表，永不证明）（博弈论） - Flash_Hu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.luogu.com.cn/article/zvs3dsbt">题解 P2197 【【模板】nim游戏】 - 洛谷专栏 (luogu.com.cn)</a></p><p><a href="https://blog.csdn.net/A_Comme_Amour/article/details/79347291">[学习笔记]（博弈论）Nim游戏和SG函数_nim博弈-CSDN博客</a></p><p><a href="https://www.luogu.com.cn/article/shyocttb">浅谈SG函数和博弈论 - 洛谷专栏 (luogu.com.cn)</a></p><p><a href="https://blog.csdn.net/strangedbly/article/details/51137432">博弈论 SG函数_a1 ^ a2 ^ … ^ an != 0-CSDN博客</a></p><hr><p>这里先用$Nim$博弈引入：<a href="https://www.luogu.com.cn/problem/P2197">P2197 【模板】Nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>我们设计当$SG(x)=0$时，$x$为必败态，相反，$x$为必胜态。</p><p>对于单堆的$Nim$游戏，我们可以计算出$SG$值，$SG(x)$表示剩余石子数为$x$的状态值。</p><p>根据$SG$函数的定义：$SG(x)=mex((SG(y)|x-&gt;y))$,$mex$表示一个集合中未出现的最小自然数。</p><p>不难得到，我们可以得到：$SG(1)=1、SG(2)=2、SG(3)=3······SG(n)=n$。(从$SG(0)=0$递推过来)。</p><p>利用$SG$定理，我们可以将多个堆的状态转移到一个堆的状态，直接异或起来就行了。</p><p>参考代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 22635 on 2024/2/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        ans^=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题计划</title>
      <link href="/2024/05/04/%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/"/>
      <url>/2024/05/04/%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC070</title>
      <link href="/2024/04/21/ABC070/"/>
      <url>/2024/04/21/ABC070/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC070">ABC070</h1><blockquote><h1 id="ABC070B-Two-Switches">[ABC070B] Two Switches</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>Alice和Bob都有一个开关用来控制机器人。<br>Alice在A秒按下开关，移动机器人，并在B秒后释放开关。</p><p>Bob在C秒按下开关，移动机器人，并在D秒后释放开关。</p><p>求Alice和Bob都按下开关的秒数。</p><h2 id="输入格式">输入格式</h2><p>一行，有四个正整数A，B，C，D。分别代表Alice在第A秒按下开关，在第B秒释放开关。Bob在第C秒按下开关，在第D秒释放开关。</p><h2 id="输出格式">输出格式</h2><p>输出Alice和Bob都按下开关的秒数</p><h2 id="题目描述-2">题目描述</h2><p>Alice と Bob は、ロボットを制御するためのスイッチを1つずつ持っており、ロボットを動かしています。<br>Alice はロボットを動かし始めて $ A $ 秒後にスイッチを押し始め、ロボットを動かし始めて $ B $ 秒後にスイッチを離しました。<br>Bob はロボットを動かし始めて $ C $ 秒後にスイッチを押し始め、ロボットを動かし始めて $ D $ 秒後にスイッチを離しました。<br>Alice と Bob が、二人ともスイッチを押していた秒数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $ $ D $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>Alice と Bob が二人ともスイッチを押していた秒数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 75 25 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 33 66 99</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 90 20 80</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 0≦A\ &lt;\ B≦100 $</li><li>$ 0≦C\ &lt;\ D≦100 $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>ロボットを動し始めて $ 0 $ 秒後から $ 75 $ 秒後までの間、Alice はスイッチを押していました。 一方、ロボットを動し始めて $ 25 $ 秒後から $ 100 $ 秒後までの間、Bob はスイッチを押していました。 したがって、二人が同時にスイッチを押していた時間は、ロボットを動し始めて $ 25 $ 秒後から $ 75 $ 秒後までの $ 50 $ 秒です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>Alice と Bob が同時にスイッチを押していないので、答えは $ 0 $ 秒です。</p></blockquote><h2 id="思路">思路</h2><p>计算重合部分即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">max</span>(a,c);</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">min</span>(b,d);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(y-x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC070C-Multiple-Clocks">[ABC070C] Multiple Clocks</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>有N台钟表，第i个钟表的秒针经过T[i]秒绕表盘一周。最初，所有的钟表的秒针都指向上方。某人开始同时顺时针拨动所有时钟的秒针。下一次所有的时钟的秒针都向上是在几秒后？</p><h2 id="输入">输入</h2><p>第一行：N；</p><p>以下N行：每行一个T[i]。</p><h2 id="输出">输出</h2><p>一行，最少的拨动次数。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 台の時計があり、$ i(1≦i≦N) $ 番目の時計の針はちょうど $ T_i $ 秒で時計盤を $ 1 $ 周します。<br>最初、全ての時計の針は真っ直ぐ上に向いており、止まっています。<br>イルカは、全ての時計の針を同時に動かし始めました。<br>再び、全ての時計の針が真っ直ぐ上に向くのは何秒後でしょうか?</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ : $ $ T_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>時計の針を動かし始めてから、再び全ての時計の針が真っ直ぐ上に向くまでの秒数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1000000000000000000</span><br><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦100 $</li><li>$ 1≦T_i≦10^{18} $</li><li>入力は全て整数である。</li><li>答えは $ 10^{18} $ 秒以内である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 2 $ つの時計があり、各時計の針が真っ直ぐ上に向くのは以下の時刻です。 - $ 1 $ 番目の時計の針: 時計の針を動かし始めてから、$ 2 $ 秒後、$ 4 $ 秒後、$ 6 $ 秒後、$ … $ - $ 2 $ 番目の時計の針: 時計の針を動かし始めてから、$ 3 $ 秒後、$ 6 $ 秒後、$ 9 $ 秒後、$ … $ したがって、$ 2 $ つの時計の針が真っ直ぐ上に向くのにかかる秒数は $ 6 $ 秒となります。</p></blockquote><h2 id="思路-2">思路</h2><p>比较容易发现，其实要求的是所有$t$的最小公倍数。</p><p>直接利用$lcm(n,m)=\frac{n*m}{gcd(n,m)}$即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ull t[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ull ans=t[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans/__gcd(ans,t[i]))*t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC070D-Transit-Tree-Path">[ABC070D] Transit Tree Path</h1><h2 id="题面翻译-3">题面翻译</h2><p>给出一棵有N个结点的树，给出Q个询问，求结点xj过结点K到节点yj的最短距离</p><h2 id="题目描述-5">题目描述</h2><p>$ N $ 頂点の木が与えられます。<br>木とはグラフの一種であり、頂点の数を $ N $ とすると、辺の数が $ N-1 $ 本である閉路のない連結グラフです。<br>$ i(1≦i≦N-1) $ 番目の辺は 頂点 $ a_i $ と 頂点 $ b_i $ を距離 $ c_i $ で結びます。</p><p>また、$ Q $ 個の質問クエリと整数 $ K $ が与えられます。</p><ul><li>$ j(1≦j≦Q) $ 番目の質問クエリでは、頂点 $ x_j $ から 頂点 $ K $ を経由しつつ、頂点 $ y_j $ まで移動する場合の最短経路の距離を求めてください。</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ b_1 $ $ c_1 $ $ : $ $ a_{N-1} $ $ b_{N-1} $ $ c_{N-1} $ $ Q $ $ K $ $ x_1 $ $ y_1 $ $ : $ $ x_{Q} $ $ y_{Q} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>質問クエリの解答を $ Q $ 行出力せよ。<br>$ j(1≦j≦Q) $ 行目には、$ j $ 番目のクエリの答えを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 4 1</span><br><span class="line">3 5 1</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br><span class="line">1 4 5</span><br><span class="line">1 5 7</span><br><span class="line">1 6 9</span><br><span class="line">1 7 11</span><br><span class="line">3 2</span><br><span class="line">1 3</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">14</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 1000000000</span><br><span class="line">2 3 1000000000</span><br><span class="line">3 4 1000000000</span><br><span class="line">4 5 1000000000</span><br><span class="line">5 6 1000000000</span><br><span class="line">6 7 1000000000</span><br><span class="line">7 8 1000000000</span><br><span class="line">8 9 1000000000</span><br><span class="line">9 10 1000000000</span><br><span class="line">1 1</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17000000000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 3≦N≦10^5 $</li><li>$ 1≦a_i,b_i≦N\ (1≦i≦N-1) $</li><li>$ 1≦c_i≦10^9\ (1≦i≦N-1) $</li><li>与えられるグラフは木である。</li><li>$ 1≦Q≦10^5 $</li><li>$ 1≦K≦N $</li><li>$ 1≦x_j,y_j≦N\ (1≦j≦Q) $</li><li>$ x_j≠y_j\ (1≦j≦Q) $</li><li>$ x_j≠K,y_j≠K\ (1≦j≦Q) $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>与えられた $ 3 $ つの質問クエリに対する最短経路は以下の通りです。 - $ 1 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 4 $ : 距離 $ 1+1+1=3 $ - $ 2 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ : 距離 $ 1+1=2 $ - $ 3 $ つ目の質問クエリ: 頂点 $ 4 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ → 頂点 $ 5 $ : 距離 $ 1+1+1+1=4 $</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>質問クエリに対する最短経路は、必ず頂点 $ K=2 $ を通過する必要があります。</p></blockquote><h2 id="思路-3">思路</h2><p>从$x$节点经过$k$节点到$y$节点的方法分为两步：</p><p>1、从$x$节点走到$k$节点。</p><p>2、从$k$节点走到$y$节点。</p><p>只需要从$k$出发，跑一遍最短路即可，答案就是$dis[x]+dis[y]$。</p><p>涉及$m$次询问，直接离线处理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll n,m,k;</span><br><span class="line">ll dis[MAXN],inq[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll from,to,val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll from,ll to,ll val)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to,val&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用spfa求最短路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i]=<span class="number">1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[k]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(k);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> from=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[from]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[from])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[t.to]&gt;dis[from]+t.val)&#123;</span><br><span class="line">                dis[t.to]=dis[from]+t.val;</span><br><span class="line">                <span class="keyword">if</span>(inq[t.to]==<span class="number">0</span>)&#123;</span><br><span class="line">                    inq[t.to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ll x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;dis[x]+dis[y]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC067</title>
      <link href="/2024/04/21/ABC067/"/>
      <url>/2024/04/21/ABC067/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC067">ABC067</h1><blockquote><h1 id="ABC067B-Snake-Toy">[ABC067B] Snake Toy</h1><h2 id="题面翻译">题面翻译</h2><p>输入n个数，输出前k大的数的总和</p><h2 id="题目描述">题目描述</h2><p>すぬけくんは $ N $ 本の棒を持っています。 $ i $ 番目の棒の長さは $ l_i $ です。</p><p>すぬけくんは $ K $ 本の棒を選んでつなげて、ヘビのおもちゃを作りたいです。</p><p>ヘビのおもちゃの長さは選んだ棒たちの長さの総和で表されます。 ヘビのおもちゃの長さとしてありうる長さのうち、最大値を求めなさい。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ l_1 $ $ l_2 $ $ l_3 $ $ … $ $ l_{N} $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 14</span><br><span class="line">50 26 27 21 41 7 42 35 7 5 5 36 39 1 45</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">386</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ K\ \leq\ N\ \leq\ 50 $</li><li>$ 1\ \leq\ l_i\ \leq\ 50 $</li><li>$ l_i $ は整数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>長さ $ 3,4,5 $ の棒を選んでつなげると、長さ $ 12 $ のヘビのおもちゃを作ることが可能で、これがありうる長さのうち最大の値です。</p></blockquote><h2 id="思路">思路</h2><p>直接用优先队列即可解决。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll l[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l[i];</span><br><span class="line">        q.<span class="built_in">push</span>(l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        ans+=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC067C-Splitting-Pile">[ABC067C] Splitting Pile</h1><h2 id="题面翻译-2">题面翻译</h2><p>小狸和浣熊制作了 $N$ 张卡，并堆积成山。卡片山上第 $i$ 张卡片上写着整数 $a_i$。<br>小狸和浣熊决定分享 $N$ 张卡。小狸从卡片山上取了几张卡片后，浣熊会把剩下的全部卡片都取出来。此时，无论是小狸还是浣熊都必须取得 $1$ 张以上的卡。<br>如果小狸和浣熊所持有的卡片上写着的数的总和分别为 $x, y$。求出 $|x - y|$ 中可能值的最小值。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんとアライグマは $ N $ 枚のカードの山を作りました。カードの山の上から $ i $ 番目のカードには整数 $ a_i $ が書かれています。</p><p>$ N $ 枚のカードを分け合うことにしました。 すぬけくんがカードの山の上から何枚かのカードを取ったあと、アライグマは残ったカード全てを取ります。 このとき、すぬけくんもアライグマも $ 1 $ 枚以上のカードを取る必要があります。</p><p>すぬけくんとアライグマが持っているカードに書かれた数の総和をそれぞれ $ x,y $ として、$ |x-y| $ を最小化したいです。 $ |x-y| $ としてありうる値の最小値を求めなさい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_{N} $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10 -10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $</li><li>$ -10^{9}\ \leq\ a_i\ \leq\ 10^{9} $</li><li>$ a_i $ は整数</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>すぬけくんが上から $ 4 $ 枚のカードを、アライグマが残った $ 2 $ 枚のカードを取ったとき、$ x=10,y=11 $ となって、$ |x-y| $ は $ 1 $ となり、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>すぬけくんは上から $ 1 $ 枚のカードを、アライグマは残った $ 1 $ 枚を取るしかありえません。このとき $ x=10,y=-10 $ となって、$ |x-y| $ は $ 20 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>直接用前缀和即可解决。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum[n]<span class="number">-2</span>*sum[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC067D-Fennec-VS-Snuke">[ABC067D] Fennec VS. Snuke</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>$Fennec$ 和 $Snuke$ 正在玩棋盘游戏。</p><p>在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路， 编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。</p><p>第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 $Fennec$ 和后手 $Snuke$ 交替给格子涂色，两人依次执行以下操作：</p><p>$Fennec$：将一个与黑色格子相邻且未被涂色的格子涂成黑色。</p><p>$Snuke$：将一个与白色格子相邻且未被涂色的格子涂成白色。</p><p>如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 $Fennec$ 和 $Snuke$ 都采取最佳策略时，谁能获胜。</p><h2 id="输入格式-3">输入格式</h2><p>第一行一个整数 $n\ \ (2 ≤n≤1e5)$</p><p>接下来 $n-1$行，每行两个整数 $a_i$ 和 $b_i$，表示 $a_i$ 和 $b_i$ 间有一条边 $(1≤a_i ,b_i ≤n)$</p><h2 id="输出格式-3">输出格式</h2><p>若 Fennec 获胜，输出“Fennec”，否则输出“Snuke”（不包含引号）</p><h2 id="题目描述-4">题目描述</h2><p>フェネックとすぬけくんがボードゲームで遊んでいます。</p><p>このボードゲームには $ 1 $ 番から $ N $ 番までの番号がついた $ N $ 個のマスと、マスどうしをつなぐ $ N-1 $ 本の道が存在しています。 $ a_i $ 番のマスと $ b_i $ 番のマスは $ i $ 番目の道を介して隣り合っています。どの $ 2 $ つのマスも隣接するマスをいくつか辿って必ず辿り着くことが可能です。すなわち、グラフ理論の言葉を用いると、マスと道から構成されるグラフは木です。</p><p>はじめに $ 1 $ 番のマスは黒く、$ N $ 番のマスは白く塗られています。その他のマスはまだ色が塗られていません。 先手のフェネックと後手のすぬけくんは残りのマスに交互に色を塗ります。 自分の手番において、$ 2 $ 人はそれぞれ以下のような行動を行います。</p><ul><li>フェネック：<strong>黒く</strong> 塗られたマスに隣接したマスであって、色が塗られていないマスを $ 1 $ つ選んで <strong>黒く</strong> 塗る。</li><li>すぬけくん：<strong>白く</strong> 塗られたマスに隣接したマスであって、色が塗られていないマスを $ 1 $ つ選んで <strong>白く</strong> 塗る。</li></ul><p>手番のプレイヤーがマスに色を塗ることができなかったとき、敗者となります。フェネックとすぬけくんが最適に行動したとき勝者はどちらか判定してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ b_1 $ $ : $ $ a_{N-1} $ $ b_{N-1} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>勝者がフェネックならば <code>Fennec</code> と、すぬけくんならば <code>Snuke</code> と出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3 6</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">7 4</span><br><span class="line">5 7</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fennec</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4</span><br><span class="line">4 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Snuke</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ \leq\ N\ \leq\ 10^5 $</li><li>$ 1\ \leq\ a_i,\ b_i\ \leq\ N $</li><li>与えられるグラフは木</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>例えばフェネックがはじめに $ 2 $ 番のマスを黒く塗ると、すぬけくんがどのようにマスを白く塗ったとしてもフェネックが勝者となります。</p></blockquote><h2 id="思路-3">思路</h2><p>$dfs$。</p><p>不难想到最优的策略，就是围追堵截对方的路。</p><p>对于某一个点，我们可以统计黑棋和白棋到该点所需要的步数，如果黑棋距离更近，那么黑棋可以先占领，否则，则白棋占领，注意到黑棋具有先手优势，如果两者到该点的点数相等，还是黑棋先占领。</p><p>我们只需要$dfs$算出两者到每一个点的步数即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">ll dis[<span class="number">5</span>][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll to,ll from,ll id)</span></span>&#123;</span><br><span class="line">    dis[id][to]=dis[id][from]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[to])&#123;</span><br><span class="line">        <span class="comment">//注意可能遇到父节点 需要跳过</span></span><br><span class="line">        <span class="keyword">if</span>(t.to==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(t.to,to,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//黑棋开始dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//白棋开始dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//id为0是黑棋，1为白棋</span></span><br><span class="line">    <span class="comment">//ans1统计的是黑棋占领的个数，ans2统计的是白棋占领的个数</span></span><br><span class="line">    ll ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[<span class="number">0</span>][i]&lt;=dis[<span class="number">1</span>][i])&#123;</span><br><span class="line">            ans1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans1&gt;ans2)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Fennec&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Snuke&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC066</title>
      <link href="/2024/04/21/ABC066/"/>
      <url>/2024/04/21/ABC066/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC066">ABC066</h1><blockquote><h1 id="ABC066B-ss">[ABC066B] ss</h1><h2 id="题面翻译">题面翻译</h2><p>如果某个串可以由两个一样的串前后连接得到，我们就称之为“偶串”。比如说“xyzxyz”和“aaaaaa”是偶串，而“ababab”和“xyzxy”则不是偶串。</p><p>输入一个字符串S，查找可以通过从S的末尾删除一个或多个字符获得的最长偶数字符串的长度。确保给定输入存在这样的非空字符串。</p><p>输出这个非空字符串的长度</p><h2 id="题目描述">题目描述</h2><p>同じ文字列を $ 2 $ つ並べてできる文字列のことを偶文字列と呼ぶことにします。 例えば、 <code>xyzxyz</code> や <code>aaaaaa</code> は偶文字列ですが、<code>ababab</code> や <code>xyzxy</code> は偶文字列ではありません。</p><p>アルファベットの小文字からなる偶文字列 $ S $ が与えられます。 $ S $ の末尾の文字を $ 1 $ 文字以上消して作れる偶文字列のうち、最も長い偶文字列の長さを求めて下さい。 与えられる入力では、条件を満たす $ 1 $ 文字以上の文字列が存在することが保証されています。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えとなる文字列の長さを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abaababaab</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxx</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcabcabcabc</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akasakaakasakasakaakas</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ \leq\ |S|\ \leq\ 200 $</li><li>$ S $ は小文字のアルファベットのみからなる偶文字列である。</li><li>$ S $ に対して、条件を満たす $ 1 $ 文字以上の文字列が存在する。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>abaababaab</code> は偶文字列ですが、 $ 1 $ 文字も消していないので条件を満たしません。 <code>abaababaa</code> は偶文字列ではありません。 <code>abaababa</code> は偶文字列ではありません。 <code>abaabab</code> は偶文字列ではありません。 <code>abaaba</code> は偶文字列です。よって、答えは <code>abaaba</code> の長さである $ 6 $ です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p><code>xxx</code> は偶文字列ではありません。 <code>xx</code> は偶文字列です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>条件を満たす文字列は <code>abcabc</code> なので、答えは $ 6 $ です。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>条件を満たす文字列は <code>akasakaakasaka</code> なので、答えは $ 14 $ です。</p></blockquote><h2 id="思路">思路</h2><p>我们直接每次删去一个字符，暴力判断是否是偶字符串即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;s[<span class="number">0</span>]==s[<span class="number">1</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n/<span class="number">2</span>;i&lt;=n/<span class="number">2</span><span class="number">-1</span>,j&lt;=n<span class="number">-1</span>;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span>(i==n/<span class="number">2</span><span class="number">-1</span>)&#123;</span><br><span class="line">                        flag=n;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            cout&lt;&lt;flag;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用STL的写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">14e4</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">length</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i&gt;&gt;<span class="number">1</span>)==s.<span class="built_in">substr</span>(i&gt;&gt;<span class="number">1</span>,i&gt;&gt;<span class="number">1</span>))<span class="comment">//STL大法</span></span><br><span class="line">        &#123;</span><br><span class="line">            num=i;<span class="comment">//满足直接退出循环并输出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC066C-pushpush">[ABC066C] pushpush</h1><h2 id="题面翻译-2">题面翻译</h2><p>输入N，后面有N个数，代表:$a1,a2,a3, … ,aN$，我们将会对$b$这个空序列进行N个操作</p><p>第i个操作进行如下处理：</p><ul><li><p>在b序列的末尾加入a[i]</p></li><li><p>翻转b序列</p></li></ul><p>感谢@RioBlu的翻译</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ n $ の数列 $ a_1,\ …\ ,\ a_n $ が与えられます。 空の数列 $ b $ に対して、以下の操作を $ n $ 回行うことを考えます。</p><p>$ i $ 回目には</p><ol><li>数列の $ i $ 番目の要素 $ a_i $ を $ b $ の末尾に追加する。</li><li>$ b $ を逆向きに並び替える。</li></ol><p>この操作をしてできる数列 $ b $ を求めて下さい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ $ … $ $ a_n $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ n $ 個の整数を空白区切りで $ 1 $ 行に出力せよ。 $ i $ 番目には、 $ b_i $ を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 1 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 2</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 6 7 6 7 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6 6 0 7 7</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 2\times\ 10^5 $</li><li>$ 0\ \leq\ a_i\ \leq\ 10^9 $</li><li>$ n,a_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 1 $ となります。 $ 1 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 1 $ となります。 $ 2 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 1,\ 2 $ となります。 $ 2 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 2,\ 1 $ となります。 $ 3 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 2,\ 1,\ 3 $ となります。 $ 3 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 3,\ 1,\ 2 $ となります。 $ 4 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 3,\ 1,\ 2,\ 4 $ となります。 $ 4 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 4,\ 2,\ 1,\ 3 $ となります。 よって、答えは <code>4 2 1 3</code> です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>出力例 1 の説明の通り、 $ 3 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 3,\ 1,\ 2 $ となるので、 答えは <code>3 1 2</code> です。</p></blockquote><h2 id="思路-2">思路</h2><p>可以利用deque来实现。</p><p>反转本质上可以转化为数字的前后插入问题</p><p>比如说，第一次是向最后插入，反转后第二次就是在最前插入</p><p>所以用deque来存储数字（特别好用）,需要注意考虑最后是奇数串还是偶数串，注意输出顺序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],q1[MAXN],q2[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    deque&lt;ll&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//判断是前还是后输入</span></span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> d.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;<span class="comment">//从后输出</span></span><br><span class="line">        <span class="keyword">while</span>(d.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout&lt;&lt;d.<span class="built_in">back</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//从前输出</span></span><br><span class="line">        <span class="keyword">while</span>(d.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout&lt;&lt;d.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC066D-11">[ABC066D] 11</h1><h2 id="题面翻译-3">题面翻译</h2><p>长度为n+1的序列a.其中[1…n]每个数都至少出现一次.<br>（n&lt;=1e5）,对每个k从1到n，询问长度为k的不同的子序列有多少个?</p><h2 id="题目描述-3">题目描述</h2><p>$ 1,…,n $ の $ n $ 個の整数からなる長さ $ n+1 $ の数列 $ a_1,a_2,…,a_{n+1} $ が与えられます。 この数列には $ 1,…,n $ のどの整数もかならず $ 1 $ 回以上出現することが分かっています。</p><p>$ k=1,…,n+1 $ のそれぞれについて、与えられた数列の長さ $ k $ の（連続とは限らない）部分列の個数を求め、 $ 10^9+7 $ で割ったあまりを出力して下さい。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ … $ a_{n+1} $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>答えを $ n+1 $ 行に出力せよ。 $ k $ 行目には、長さ $ k $ の部分列の個数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">29 19 7 10 26 32 27 4 11 20 2 8 16 23 5 14 6 12 17 22 18 30 28 24 15 1 25 3 13 21 19 31 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">525</span><br><span class="line">5453</span><br><span class="line">40919</span><br><span class="line">237336</span><br><span class="line">1107568</span><br><span class="line">4272048</span><br><span class="line">13884156</span><br><span class="line">38567100</span><br><span class="line">92561040</span><br><span class="line">193536720</span><br><span class="line">354817320</span><br><span class="line">573166440</span><br><span class="line">818809200</span><br><span class="line">37158313</span><br><span class="line">166803103</span><br><span class="line">166803103</span><br><span class="line">37158313</span><br><span class="line">818809200</span><br><span class="line">573166440</span><br><span class="line">354817320</span><br><span class="line">193536720</span><br><span class="line">92561040</span><br><span class="line">38567100</span><br><span class="line">13884156</span><br><span class="line">4272048</span><br><span class="line">1107568</span><br><span class="line">237336</span><br><span class="line">40920</span><br><span class="line">5456</span><br><span class="line">528</span><br><span class="line">33</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="注意">注意</h3><ul><li>$ 2 $ つの部分列が数列として同じであれば、元の数列での位置が異なっていたとしても、$ 1 $ 通りと数えます。</li><li>数列 $ a $ の長さ $ k $ の部分列とは、$ a $ の要素のうち $ k $ 個を選んで、 それらを順番を変えずに取り出して並べた数列のことを指します。 例えば、数列 $ 1,2,3,4,5 $ の長さ $ 3 $ の部分列には、 $ 1,3,5 $ や $ 1,2,3 $ などがあります。 一方で、$ 3,1,2 $ や $ 1,10,100 $ はこの数列の部分列ではありません。</li></ul><h3 id="制約-3">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 10^5 $</li><li>$ 1\ \leq\ a_i\ \leq\ n $</li><li>$ 1,…,n $ のどの整数も必ず数列に出現する。</li><li>$ n,a_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>長さ $ 1 $ の部分列は $ 1 $、$ 2 $、$ 3 $ の $ 3 $ 通りです。 長さ $ 2 $ の部分列は $ 1,1 $、$ 1,2 $、$ 1,3 $、$ 2,1 $、$ 2,3 $ の $ 5 $ 通りです。 長さ $ 3 $ の部分列は $ 1,1,3 $、$ 1,2,1 $、$ 1,2,3 $、$ 2,1,3 $ の $ 4 $ 通りです。 長さ $ 4 $ の部分列は $ 1,2,1,3 $ の $ 1 $ 通りです。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>長さ $ 1 $ の部分列は $ 1 $ の $ 1 $ 通りです。 長さ $ 2 $ の部分列は $ 1,1 $ の $ 1 $ 通りです。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>$ 10^9+7 $ で割ったあまりを出力することに注意して下さい。</p></blockquote><h2 id="思路-3">思路</h2><p>这是一道排列组合的问题。</p><p>可以发现只有一个数会出现两次，其他数都只会出现一次。</p><p>先考虑不重复的情况，那么就是$C_{n+1}^{k}$即可。</p><p>但是得除掉重复的情况，思考一下，假设出现两次的数字，出现的位置分别记作$left,right$。</p><p>如果交换它们两个的位置，那么得到的序列还是一样的，也就是说，位于它们两者之间的数字是对可能的序列情况是没有任何影响的。</p><p>那么我们只需要考虑在$left$左边，$right$右边的序列情况即可，可以得到是$C_{(l-1)+(n-r+1)}^{k}$。</p><p>那么两者相减就是答案。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll fac[MAXN],vis[MAXN];</span><br><span class="line"><span class="comment">//费马小定理求组合数</span></span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||m&lt;=<span class="number">0</span>||n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*<span class="built_in">qpower</span>(fac[n-m]*fac[m]%mod,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    n++;</span><br><span class="line">    ll start=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//得到重复出现的数字</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line">            start=vis[x];</span><br><span class="line">            last=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vis数组记录数字出现的位置</span></span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll ans=<span class="built_in">C</span>(n,i)-<span class="built_in">C</span>(start+n-last<span class="number">-1</span>,i<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//这里+mod，防止结果为负数</span></span><br><span class="line">        ans=(ans+mod)%mod;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC065</title>
      <link href="/2024/04/20/ABC065/"/>
      <url>/2024/04/20/ABC065/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC065">ABC065</h1><blockquote><h1 id="ABC065A-Expired">[ABC065A] Expired?</h1><h2 id="题面翻译">题面翻译</h2><p>高桥君在保质期前 $a$ 天买了食物，$b$ 天后吃了，但是高桥君吃了过期 $x$ 天的食物不会胃痛，如果过了 $x$ 天吃，他就会胃痛。</p><p>给定 $x,a,b$，如果食物没有过期，输出 <code>delicious</code>。</p><p>如果食物过期了但吃了不会胃痛，输出 <code>safe</code>。</p><p>如果吃了会胃痛，输出 <code>dangerous</code>。</p><h2 id="题目描述">题目描述</h2><p>高橋君は胃が強いので、賞味期限を $ X $ 日まで過ぎた食品を食べてもお腹を壊しません。 賞味期限を $ X+1 $ 日以上過ぎた食品を食べると、お腹を壊します。</p><p>また、賞味期限を過ぎずに食べると、おいしく感じます。そうでない場合、おいしく感じません。</p><p>高橋君は、賞味期限の $ A $ 日前に食品を買ってきて、買ってから $ B $ 日後に食べました。</p><p>高橋君が食品をおいしく感じた場合 <code>delicious</code> を、おいしくは感じなかったがお腹は壊さなかった場合 <code>safe</code> を、お腹を壊した場合 <code>dangerous</code> を出力するプログラムを作成してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $ $ A $ $ B $</p></blockquote><h2 id="输出格式">输出格式</h2><p>高橋君が食品をおいしく感じた場合 <code>delicious</code> を、おいしくは感じなかったがお腹は壊さなかった場合 <code>safe</code> を、お腹を壊した場合 <code>dangerous</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">safe</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delicious</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 7 12</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dangerous</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ X,A,B\ ≦\ 10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>賞味期限を $ 3 $ 日過ぎて食べるので、おいしくは感じませんが、お腹も壊しません。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>賞味期限を過ぎていないので、おいしく感じます。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>賞味期限を $ 5 $ 日過ぎて食べるので、お腹を壊します。</p></blockquote><h2 id="思路">思路</h2><p>这题完全败在了理解上qwq。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;delicious&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b - a) &lt;= x) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;safe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;dangerous&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065B-Trained">[ABC065B] Trained?</h1><h2 id="题面翻译-2">题面翻译</h2><p>有一堆按钮，按钮的编号是从 $1$ 到 $n$ 。第 $i$ 个按钮对应第 $i$ 个灯。</p><p>你按下第 $i$ 个按钮时，如果你按下的按钮对应的灯是关闭的,那么灯 $a_i$ 会开启，灯 $i$ 会关闭； 如果按钮对应的灯是开启的,那么按下它就什么都不会发生。</p><p>最初，灯 $1$ 是关闭的，其他的灯都开着。 高桥君希望最后灯 $2$ 是关闭的。</p><p>输出他最少按下按钮的次数，如果不能则输出 $-1$ 。</p><h2 id="题目描述-2">题目描述</h2><p>筋力をつけたい高橋君は、AtCoder 社のトレーニング設備で、トレーニングをすることにしました。</p><p>AtCoder 社のトレーニング設備には $ N $ 個のボタンがついており、ちょうど $ 1 $ 個のボタンが光っています。 ボタンには、$ 1 $ から $ N $ までの番号がついています。 ボタン $ i $ が光っているときにそのボタンを押すと、ボタン $ i $ の明かりが消え、その後ボタン $ a_i $ が光ります。$ i=a_i $ であることもあります。 光っていないボタンを押しても、何も起こりません。</p><p>最初、ボタン $ 1 $ が光っています。高橋君は、ボタン $ 2 $ が光っている状態で、トレーニングをやめたいと思っています。</p><p>そのようなことは可能かどうか判定し、もし可能なら最低で何回ボタンを押す必要があるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ : $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>ボタン $ 2 $ を光らせることが不可能な場合、$ -1 $ を出力せよ。 そうでない場合、ボタン $ 2 $ を光らせるために必要なボタンを押す回数の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 10^5 $</li><li>$ 1\ ≦\ a_i\ ≦\ N $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ボタン $ 1,3 $ の順に押せばよいです。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>ボタン $ 1 $ を押すとボタン $ 3 $ 、ボタン $ 3 $ を押すとボタン $ 1 $ が光るので、ボタン $ 2 $ が光ることはありません。</p></blockquote><h2 id="思路-2">思路</h2><p>算是一个简单的链表？直接模拟即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="comment">//如果到达2点，直接输出操作次数</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;cnt;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=a[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065C-Reconciled">[ABC065C] Reconciled?</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>すぬけ君养了 $ N $ 只狗和 $M$ 只猴。すぬけ君想把这 $N+M$ 只动物排成一列。</p><p>すぬけ君希望狗与狗不能互相挨着，猴与猴不能互相挨着。</p><p>这样的排列方式有多少种？请输出答案对 $10^9+7$ 取模的结果。不过，狗与狗间，猴与猴间相互区别。</p><h2 id="数据范围">数据范围</h2><ul><li>$1 \leq N,M \leq 10^5 $</li></ul><h2 id="输入">输入</h2><p>输入按以下标准：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N M</span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><p>输出方案数对 $10^9+7$ 取模的结果</p><h2 id="样例1解释">样例1解释</h2><p>将每只狗分别记为<code>A</code>,<code>B</code>，将每只猴分别记为<code>C</code>,<code>D</code>，则共有<code>ACBD</code>,<code>ADBC</code>,<code>BCAD</code>,<code>BDAC</code>,<code>CADB</code>,<code>CBDA</code>,<code>DACB</code>,<code>DBCA</code> $8$ 种排列方法。</p><p>感谢@ミク 提供的翻译</p><h2 id="题目描述-4">题目描述</h2><p>すぬけ君は、犬を $ N $ 匹と猿を $ M $ 匹飼っています。すぬけ君は、この $ N+M $ 匹を一列に並べようと思っています。</p><p>文字通り犬猿の仲の犬たちと猿たちを仲直りさせたいすぬけ君は、犬同士、または猿同士が隣り合うところができないように並べようと思っています。</p><p>このような並べ方は何通りあるでしょうか。犬と猿は $ 10^9+7 $ 以上の数を理解できないので、並べ方の個数を $ 10^9+7 $ で割ったあまりを求めてください。 ただし、犬同士、また猿同士は互いに区別します。また、左右が反転しただけの列も異なる列とみなします。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>並べ方の個数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">530123477</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N,M\ ≦\ 10^5 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>犬をそれぞれ <code>A</code>,<code>B</code> とし、猿をそれぞれ <code>C</code>,<code>D</code> とすると、<code>ACBD</code>,<code>ADBC</code>,<code>BCAD</code>,<code>BDAC</code>,<code>CADB</code>,<code>CBDA</code>,<code>DACB</code>,<code>DBCA</code> の $ 8 $ 通りの並べ方があります。</p></blockquote><h2 id="思路-3">思路</h2><p>数学题。</p><p>如果猴子和狗的数目之差大于1，肯定不行，直接输出0即可。</p><p>如果小于或者等于1，需要分类讨论。</p><p>如果相等，那么狗和猴子的顺序可以颠倒，需要乘以2，不等则不行。</p><p>那么问题就变成了简单的排列组合问题，注意猴子和狗子是有区分的，那么答案就是狗子数目的阶乘和猴子数目阶乘的乘积。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll fac[MAXN];</span><br><span class="line"><span class="comment">//预处理出阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1e5</span>;i++)&#123;</span><br><span class="line">        fac[i]=(fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//之差大于1，直接输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(n-m)&gt;<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果相等，则可以交换位置，注意*2</span></span><br><span class="line">        <span class="keyword">if</span>(n==m)&#123;</span><br><span class="line">            ans=(fac[n]*fac[m]%mod)*<span class="number">2</span>%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不等则不行</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans=(fac[n]*fac[m]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065D-Built">[ABC065D] Built?</h1><h2 id="题面翻译-4">题面翻译</h2><h2 id="题目描述-5">题目描述</h2><p>平面上有 $N$ 个城市。第 $i$ 个城市的坐标为 $(x_i,y_i)$ 。同一个坐标上可能有多个城市。在坐标为 $(a,b)$ 的城市和坐标为 $(c,d)$ 的城市间建造一条道路需要 $min(|a-c|,|b-d|)$ 円。只能在城市与城市间建造道路。<br>要使任意两个城市之间有直接或间接道路相连，最少需要多少円？</p><h2 id="数据范围-2">数据范围</h2><ul><li>$2 \leq N \leq 10^5$</li><li>$0 \leq x_i,y_i \leq 10^9$</li><li>输入全为整数</li></ul><h2 id="输入-2">输入</h2><p>输入按以下形式：<br>$$ N $$<br>$$ x_1 \space y_1 $$<br>$$ x_2 \space y_2 $$<br>$$ : $$<br>$$ x_N \space y_N $$</p><h2 id="输出-2">输出</h2><p>请输出使任意两城市间有直接或间接道路连接所需最少钱数。</p><h2 id="样例1解释-2">样例1解释</h2><p>在城市 $1$ 与城市 $2$ 间建造一条道路，在城市 $2$ 与城市 $3$ 间建造一条道路，花费 $2+1=3$ 円。</p><p>感谢@ミク 提供的翻译</p><h2 id="题目描述-6">题目描述</h2><p>平面上に、$ N $ 個の街があります。$ i $ 個目の街は、座標 $ (x_i,y_i) $ にあります。同じ座標に、複数の街があるかもしれません。</p><p>座標 $ (a,b) $ にある街と座標 $ (c,d) $ にある街の間に道を造るのには、$ min(|a-c|,|b-d|) $ 円かかります。街と街の間以外に、道を造ることはできません。</p><p>任意の $ 2 $ つの街の間を、道を何本か通って行き来できるようにするためは、最低で何円必要でしょうか。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ x_1 $ $ y_1 $ $ x_2 $ $ y_2 $ : $ x_N $ $ y_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>任意の $ 2 $ つの街の間を道を何本か通って行き来できるようにするためにかかるお金の最小値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5</span><br><span class="line">3 9</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">8 3</span><br><span class="line">4 9</span><br><span class="line">12 19</span><br><span class="line">18 1</span><br><span class="line">13 5</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 10^5 $</li><li>$ 0\ ≦\ x_i,y_i\ ≦\ 10^9 $</li><li>入力は全て整数である</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>街 $ 1 $ と $ 2 $ 、街 $ 2 $ と $ 3 $ の間に道を造ると、かかるお金は $ 2+1=3 $ 円になります。</p></blockquote><h2 id="思路-4">思路</h2><p>比较容易地发现可以使用最小生成树。</p><p>但是如果直接建图的话，肯定会TLE。</p><p>不妨采取以下思路：题目要求的是$min(x_i-x_j,y_i-y_j)$。那么我们可以先对所有点的$x$坐标进行排序，得到的相邻两个差是最小的，所以我们只需要建$n-1$条边，每条边的权值为$x_i-x_{i-1}$。</p><p>同理，$y$也是进行一样的处理。</p><p>最后再在其中选择最小值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll fa[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll id;</span><br><span class="line">    ll x,y;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll from,to,val;</span><br><span class="line">&#125;b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x&lt;y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.y&lt;y.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp3</span><span class="params">(Edge x,Edge y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">        a[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据x坐标进行建边</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[++cnt].from=a[i<span class="number">-1</span>].id;</span><br><span class="line">        b[cnt].to=a[i].id;</span><br><span class="line">        b[cnt].val=a[i].x-a[i<span class="number">-1</span>].x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据y坐标进行建边</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[++cnt].from=a[i<span class="number">-1</span>].id;</span><br><span class="line">        b[cnt].to=a[i].id;</span><br><span class="line">        b[cnt].val=a[i].y-a[i<span class="number">-1</span>].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt,cmp3);</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//联通操作</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ll from=<span class="built_in">find</span>(b[i].from);</span><br><span class="line">        ll to=<span class="built_in">find</span>(b[i].to);</span><br><span class="line">        <span class="keyword">if</span>(from!=to)&#123;</span><br><span class="line">            fa[from]=to;</span><br><span class="line">            n--;</span><br><span class="line">            ans+=b[i].val;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC064</title>
      <link href="/2024/04/20/ABC064/"/>
      <url>/2024/04/20/ABC064/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC069</title>
      <link href="/2024/04/20/ABC069/"/>
      <url>/2024/04/20/ABC069/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC069">ABC069</h1><blockquote><h1 id="ABC069C-4-adjacent">[ABC069C] 4-adjacent</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>一个数列长为n。你的任务是将数列进行排列，使得当1 ≤ i ≤ N − 1 时，a[i]与a[i+1]的积是4的倍数。<br>请判断你是否能完成这个任务。</p><h2 id="输入格式">输入格式</h2><p>第一行包含一个正整数n，为数列的长度。<br>第二行包含n个正整数，为数列内的数。</p><h2 id="输出格式">输出格式</h2><p>如果你能完成这个任务，输出Yes，否则输出No。</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ N $ の数列 $ a\ =\ (a_1,\ a_2,\ …,\ a_N) $ があります。 各 $ a_i $ は正の整数です。</p><p>すぬけ君の目標は、$ a $ の要素を自由に並べ替え、次の条件が成り立つようにすることです。</p><ul><li>各 $ 1\ &lt;\ =\ i\ &lt;\ =\ N\ -\ 1 $ について、$ a_i $ と $ a_{i\ +\ 1} $ の積は $ 4 $ の倍数である。</li></ul><p>すぬけ君が目標を達成できるか判定してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>すぬけ君が目標を達成できるならば <code>Yes</code> を、できないならば <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 10 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 7 1 8 2 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ a_i $ は整数である。</li><li>$ 1\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>例えば、$ (1,\ 100,\ 10) $ と並べ替えればよいです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>どのように並べ替えても、条件が成り立つようにできません。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>最初から条件が成り立っています。</p></blockquote><h2 id="思路">思路</h2><p>不难想到有两种情况：</p><p>1、$a_n$为4的倍数。</p><p>2、$a_n$与$a_{n+1}$为2的倍数。</p><p>如果$a_n$为4的倍数，$a_{n+1}$没有任何要求，反之，如果$a_n$是2的倍数，那么$a_{n+1}$也需要是2的倍数。</p><p>需要计算一下贡献，判断是否大于$\frac{n}{2}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">4</span>==<span class="number">0</span>)cnt1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]%<span class="number">2</span>==<span class="number">0</span>)cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意cnt2需要除以2</span></span><br><span class="line">    <span class="keyword">if</span>(cnt1+cnt2/<span class="number">2</span>&gt;=n/<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC069D-Grid-Coloring">[ABC069D] Grid Coloring</h1><h2 id="题面翻译-2">题面翻译</h2><p>给你一个序列$a$,满足$\sum\limits^{n}_{i=1}a_i=WH$<br>请你够构造一个$W*H$的矩阵,满足:</p><ul><li>每一中颜色$i$,满足矩阵中出现了$a_i$次</li><li>要保证每一种颜色$i$都是相互联通的,即为一个联通块</li></ul><p>可以证明一定可以构造出这样的矩阵</p><h2 id="题目描述-3">题目描述</h2><p>縦 $ H $ 行、横 $ W $ 列のマス目があります。 すぬけ君は、このマス目を色 $ 1 $, $ 2 $, $ … $, $ N $ で塗り分けようとしています。 このとき、次の条件が成り立つようにします。</p><ul><li>各 $ i $ ($ 1\ &lt;\ =\ i\ &lt;\ =\ N $) について、色 $ i $ のマスはちょうど $ a_i $ 個存在する。 ただし、$ a_1\ +\ a_2\ +\ …\ +\ a_N\ =\ H\ W $ である。</li><li>各 $ i $ ($ 1\ &lt;\ =\ i\ &lt;\ =\ N $) について、色 $ i $ のマスは上下左右に連結である。 すなわち、どの色 $ i $ のマスからどの色 $ i $ のマスへも、上下左右に隣り合う色 $ i $ のマスのみを辿って行き来できる。</li></ul><p>条件を満たす塗り分け方をひとつ求めてください。 解は必ず存在することが示せます。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ N $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>条件を満たす塗り分け方をひとつ出力せよ。 塗り分け方は次のフォーマットで出力せよ。 ただし、$ c_{i\ j} $ は、上から $ i $ 行目、左から $ j $ 列目のマスの色である。</p><blockquote><p>$ c_{1\ 1} $ $ … $ $ c_{1\ W} $ $ : $ $ c_{H\ 1} $ $ … $ $ c_{H\ W} $</p></blockquote><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">3</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4 4 4 3</span><br><span class="line">2 5 4 5 3</span><br><span class="line">2 5 5 5 3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ &lt;\ =\ H,\ W\ &lt;\ =\ 100 $</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ H\ W $</li><li>$ a_i\ &gt;\ =\ 1 $</li><li>$ a_1\ +\ a_2\ +\ …\ +\ a_N\ =\ H\ W $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>例えば、次の塗り分け方は条件を満たしません。 色 $ 1 $ のマスが上下左右に連結でないからです。 <code>1 2 3 1</code></p></blockquote><h2 id="思路-2">思路</h2><p>不难想到蛇形构造，但是细节需要注意。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"><span class="type">int</span> g[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//将所有需要的数字存在数组a中，可以理解为每一块拼图都存入其中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;x;j++)</span><br><span class="line">            a.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">                g[i][j]=a[w*i+j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//注意反向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">                g[i][w-j<span class="number">-1</span>]=a[w*i+j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)&#123;</span><br><span class="line">            cout&lt;&lt;g[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC068</title>
      <link href="/2024/04/20/ABC068/"/>
      <url>/2024/04/20/ABC068/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC068">ABC068</h1><blockquote><h1 id="ABC068B-Break-Number">[ABC068B] Break Number</h1><h2 id="题面翻译">题面翻译</h2><p>输入一个不大于100的正整数，输出小于等于它且最大的二的幂</p><h2 id="题目描述">题目描述</h2><p>高橋君は $ 2 $ で割れる数が好きです。</p><p>正整数 $ N $ が与えられるので、$ 1 $ 以上 $ N $ 以下の整数のうち、最も $ 2 $ で割れる回数が多いものを求めてください。答えは必ず $ 1 $ つに定まります。</p><p>なお、$ 2 $ で割っていき、何回あまりが出ずに割れるかを、$ 2 $ で割れる回数と呼ぶことにします。</p><p>例えば</p><ul><li>$ 6 $ ならば、$ 6 $ -&gt; $ 3 $で、$ 1 $ 回 $ 2 $ で割れます。</li><li>$ 8 $ ならば、$ 8 $ -&gt; $ 4 $ -&gt; $ 2 $ -&gt; $ 1 $で、$ 3 $ 回 $ 2 $ で割れます。</li><li>$ 3 $ ならば、$ 0 $ 回 $ 2 $ で割れます。</li></ul><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>問題の答えを出力する。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 4 $ は $ 2 $ 回 $ 2 $ で割ることができ、これは $ 1 $, $ 2 $, …, $ 7 $ の中で最も多いです。</p></blockquote><h2 id="思路">思路</h2><p>直接暴力计算，并且更新即可。</p><p>注意考虑特判。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">double</span> r[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;tot)&#123;</span><br><span class="line">            ans=i;</span><br><span class="line">            tot=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC068C-Cat-Snuke-and-a-Voyage">[ABC068C] Cat Snuke and a Voyage</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题意">题意</h3><p>有很多小岛，编号$1$到$n$，某两个岛之间有船可以到达，每次从$1$号小岛出发，要到$n$号岛屿。规定只能做两次船，问是否能到达目标岛屿。</p><h3 id="输入">输入</h3><p>第一行第一个数字是要到达的岛屿$n$，第二行一个数字是$m$，表示有$m$个岛之间有船可以连通，接下来$m$行每行两个数（岛的编号 ），表示某两个岛连通。</p><h3 id="输出">输出</h3><p>如果能到达，输出<code>POSSIBLE</code>，否则输出<code>IMPOSSIBLE</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 题意</span><br><span class="line"></span><br><span class="line">有很多小岛，编号$1$到$n$，某两个岛之间有船可以到达，每次从$1$号小岛出发，要到$n$号岛屿。规定只能做两次船，问是否能到达目标岛屿。</span><br><span class="line"></span><br><span class="line">### 输入</span><br><span class="line"></span><br><span class="line">第一行第一个数字是要到达的岛屿$n$，第二行一个数字是$m$，表示有$m$个岛之间有船可以连通，接下来$m$行每行两个数（岛的编号 ），表示某两个岛连通。</span><br><span class="line"></span><br><span class="line">### 输出</span><br><span class="line"></span><br><span class="line">如果能到达，输出```POSSIBLE```，否则输出```IMPOSSIBLE```</span><br><span class="line"></span><br><span class="line">### 数据范围</span><br><span class="line"></span><br><span class="line">$3≤N≤200000$</span><br><span class="line"></span><br><span class="line">$1≤M≤200000$</span><br><span class="line"></span><br><span class="line">$1≤ai&lt;bi≤N$</span><br><span class="line"></span><br><span class="line">$(ai,bi)≠(1,N)$</span><br><span class="line"></span><br><span class="line">如果$i≠j$则$(ai,bi)≠(aj,bj).$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据范围">数据范围</h3><p>$3≤N≤200000$</p><p>$1≤M≤200000$</p><p>$1≤ai&lt;bi≤N$</p><p>$(ai,bi)≠(1,N)$</p><p>如果$i≠j$则$(ai,bi)≠(aj,bj).$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/abc068/tasks/arc079_a</span><br><span class="line"></span><br><span class="line">高橋キングダムには、高橋諸島という、$ N $ 個の島からなる諸島があります。 便宜上、これらの島を島 $ 1 $、島 $ 2 $、 ...、島 $ N $ と呼ぶことにします。</span><br><span class="line"></span><br><span class="line">これらの諸島の間では、船の定期便が $ M $ 種類運行されています。 定期便はそれぞれ $ 2 $ つの島の間を行き来しており、$ i $ 種類目の定期便を使うと、 島 $ a_i $ と島 $ b_i $ の間を行き来する事ができます。</span><br><span class="line"></span><br><span class="line">すぬけくんは今島 $ 1 $ にいて、島 $ N $ に行きたいと思っています。 しかし、島 $ 1 $ から島 $ N $ への定期便は存在しないことがわかりました。 なので、定期便を $ 2 $ つ使うことで、島 $ N $ に行けるか調べたいと思っています。</span><br><span class="line"></span><br><span class="line">これを代わりに調べてあげてください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ : $ a_M $ $ b_M $</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">定期便を $ 2 $ つ使いたどり着けるならば `POSSIBLE`、たどり着けないならば `IMPOSSIBLE` と出力する。</span><br><span class="line"></span><br><span class="line">## 样例 #1</span><br><span class="line"></span><br><span class="line">### 样例输入 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 2<br>1 2<br>2 3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #2</span><br><span class="line"></span><br><span class="line">### 样例输入 #2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4 3<br>1 2<br>2 3<br>3 4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IMPOSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #3</span><br><span class="line"></span><br><span class="line">### 样例输入 #3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>100000 1<br>1 99999</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IMPOSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #4</span><br><span class="line"></span><br><span class="line">### 样例输入 #4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5 5<br>1 3<br>4 5<br>2 3<br>2 4<br>1 4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POSSIBLE</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 提示</span><br><span class="line"></span><br><span class="line">### 制約</span><br><span class="line"></span><br><span class="line">- $ <span class="number">3</span>\ ≦\ N\ ≦\ <span class="number">200</span>,<span class="number">000</span> $</span><br><span class="line">- $ <span class="number">1</span>\ ≦\ M\ ≦\ <span class="number">200</span>,<span class="number">000</span> $</span><br><span class="line">- $ <span class="number">1</span>\ ≦\ a_i\ &lt;\ b_i\ ≦\ N $</span><br><span class="line">- $ (a_i,\ b_i)\ \neq\ (<span class="number">1</span>,\ N) $</span><br><span class="line">- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $</span><br><span class="line"></span><br><span class="line">### Sample Explanation <span class="number">2</span></span><br><span class="line"></span><br><span class="line">島 $ <span class="number">4</span> $ へ行くには、定期便を $ <span class="number">3</span> $ つ使う必要があります。</span><br><span class="line"></span><br><span class="line">### Sample Explanation <span class="number">4</span></span><br><span class="line"></span><br><span class="line">島 $ <span class="number">1</span> $、島 $ <span class="number">4</span> $、島 $ <span class="number">5</span> $ と移動すれば $ <span class="number">2</span> $ つの定期便で移動可能です。</span><br></pre></td></tr></table></figure></blockquote><h2 id="思路-2">思路</h2><p>注意到是要通过两条船到达，那么可以考虑：统计有那些点是从1到y，有哪些点是从x到n。</p><p>如果都满足的话，就可以到达。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)a[y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==n)b[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举所有的点，看看能否从1到i，又从i到n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&amp;&amp;b[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;POSSIBLE&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC068D-Decrease-Contestant-ver">[ABC068D] Decrease (Contestant ver.)</h1><h2 id="题面翻译-3">题面翻译</h2><p>对于一个长度为N的序列$a$,我们有这样的操作:</p><ul><li>从序列$a$中选出一个最大值,将其减$N$,对于剩下的$N-1$个元素,将其全部加$1$</li><li>可以证明操作$K$次之后，存在序列的最大值将小于或等于N-1。</li></ul><p>现在,给定一个正整数$K$,请构造出一个长度为$N$的序列$a$<br>使得满足操作$K$次之后满足序列的最大值将小于或等于N-1。</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ N $ の非負整数列 $ a_i $ に対し、数列の最大値が $ N-1 $ 以下になるまで以下の操作を繰り返し行うことを考えます。</p><ul><li>数列のうち最も大きい要素を求める、複数ある場合はどれか $ 1 $ つ選ぶ。この要素の値を $ N $ 減らす。これ以外の要素の値を $ 1 $ 増やす。</li></ul><p>なお、この操作を行い続けると、いつかは数列の最大値が $ N-1 $ 以下になることが証明できます。</p><p>ここで、整数 $ K $ が与えられるので、この操作を行う回数がちょうど $ K $ 回になるような数列 $ a_i $ を $ 1 $ つ求めてください。なお、この問題の入出力の制約下では、かならず $ 1 $ つは条件を満たすような数列が存在することが示せます。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ K $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>以下の形式で数列を出力する。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><p>ここで、$ 2\ ≦\ N\ ≦\ 50, $ $ 0\ ≦\ a_i\ ≦\ 10^{16}\ +\ 1000 $ でなければならない。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 3 3 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 0 3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">27 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567894848</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1000 193 256 777 0 1 1192 1234567891011 48 425</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 0\ ≦\ K\ ≦\ 50\ \times\ 10^{16} $</li></ul><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>\[2, 2\] -&gt; \[0, 3\] -&gt; \[1, 1\] と、$ 2 $ 回操作を行います。</p></blockquote><h2 id="思路-3">思路</h2><p>直接看这里：[<a href="https://www.luogu.com.cn/article/zxtp5vur">ABC068D] Decrease (Contestant ver.) - 洛谷专栏 (luogu.com.cn)</a></p><p>一道有趣的构造题。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll k;cin&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;<span class="number">50</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i+(k+i)/<span class="number">50</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC063</title>
      <link href="/2024/04/20/ABC063/"/>
      <url>/2024/04/20/ABC063/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC063">ABC063</h1><blockquote><h1 id="ABC063C-Bugged">[ABC063C] Bugged</h1><h2 id="题面翻译">题面翻译</h2><p>有 $N$ 道题，答对一道获得 $A_i$ 分，答错不得分。但是如果现在分数为 $10$ 的倍数将会显示 $0$ 分，问最高可以获得多少分？</p><h2 id="题目描述">题目描述</h2><p>あなたはコンピュータで試験を受けています。試験は $ N $ 問の問題からなり、$ i $ 問目の問題の配点は $ s_i $ です。それぞれの問題に対するあなたの解答は「正解」または「不正解」のいずれかとして判定され、正解した問題の配点の合計があなたの成績となります。あなたが解答を終えると、解答がその場で採点されて成績が表示される…はずでした。</p><p>ところが、試験システムに欠陥があり、成績が $ 10 $ の倍数の場合は、画面上で成績が $ 0 $ と表示されてしまいます。それ以外の場合は、画面に正しい成績が表示されます。この状況で、成績として画面に表示されうる最大の値はいくつでしょうか？</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ s_1 $ $ s_2 $ $ : $ $ s_N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>成績として画面に表示されうる最大の値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>入力値はすべて整数である。</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 100 $</li><li>$ 1\ &lt;\ =\ s_i\ &lt;\ =\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 10 $ 点の問題と $ 15 $ 点の問題に正解し、$ 5 $ 点の問題には正解しないことで成績が $ 25 $ となり、この成績は画面に正しく表示されます。$ 5 $ 点の問題にも正解すると成績が $ 30 $ となりますが、この成績は画面上では $ 0 $ と表示されてしまいます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>すべての問題に正解すると成績が $ 35 $ となり、この成績は画面に正しく表示されます。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>どのような解答状況でも成績は $ 10 $ の倍数となり、画面上では $ 0 $ と表示されてしまいます。</p></blockquote><h2 id="思路">思路</h2><p>比较容易想到的就是贪心：如果所有数字的和不是10的倍数，那么直接输出即可。但如果是10的整数倍，我们只有减去一个某一个数即可。</p><p>那么要减去谁呢？如果这个数是10的倍数，那么所有数之和减去该数后，还是10的整数倍，没有任何效果。</p><p>那么为了使得结果最大化，我们应该减去最小的、且不是10的整数倍的数。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> MIN=MAXN;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="comment">//选出符合情况的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">10</span>)&#123;</span><br><span class="line">            MIN=<span class="built_in">min</span>(MIN,a[i]);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意 可能选不出满足情况的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本身和不是10的整数倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">10</span>)cout&lt;&lt;sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本身和是10的整数倍</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;sum-MIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC063D-Widespread">[ABC063D] Widespread</h1><h2 id="题面翻译-2">题面翻译</h2><p>你散步的时候，突然$N$个魔物出现了。</p><p>各个魔物都有体力这个值，第$i$个魔物出现时的体力是$h_i$,而体力$0$以下的魔物立即消失。</p><p>幸运的是，你是一个熟练的魔法师，可以发动爆炸来攻击魔物。一次爆炸可以减少魔物的体力，如下所示。</p><p>选择生存的魔物，以魔物为中心引起爆炸。成为爆炸中心的魔物的体力$A$减少，其他魔物的体力$B$分别减少。</p><p>这里需要说明的是，$A$和$B$是预先确定的值，且$A&gt;B$。</p><p>为了消灭所有的魔物，你最少需要引起几次爆炸呢?</p><h2 id="题目描述-2">题目描述</h2><p>あなたが散歩していると、突然 $ N $ 体の魔物が出現しました。それぞれの魔物は <em>体力</em> という値を持ち、$ i $ 体目の魔物の出現時の体力は $ h_i $ です。体力が $ 0 $ 以下となった魔物は直ちに消滅します。</p><p>幸い、あなたは熟練の魔法使いであり、爆発を引き起こして魔物を攻撃できます。一回の爆発では、以下のように魔物の体力を減らすことができます。</p><ul><li>生存している魔物を一体選び、その魔物を中心に爆発を引き起こす。爆発の中心となる魔物の体力は $ A $ 減り、その他の魔物の体力はそれぞれ $ B $ 減る。ここで、$ A $ と $ B $ はあらかじめ定まった値であり、$ A\ &gt;\ B $ である。</li></ul><p>すべての魔物を消し去るためには、最小で何回の爆発を引き起こす必要があるでしょうか？</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ h_1 $ $ h_2 $ $ : $ $ h_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>すべての魔物を消し去るために必要な最小の爆発の回数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 3</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 10 4</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2 1</span><br><span class="line">900000000</span><br><span class="line">900000000</span><br><span class="line">1000000000</span><br><span class="line">1000000000</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">800000000</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力値はすべて整数である。</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ 1\ &lt;\ =\ B\ &lt;\ A\ &lt;\ =\ 10^9 $</li><li>$ 1\ &lt;\ =\ h_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>以下のようにして、$ 2 $ 回の爆発ですべての魔物を消し去ることができます。 - まず、体力が $ 8 $ の魔物を中心に爆発を引き起こす。$ 4 $ 体の魔物の体力はそれぞれ $ 3 $, $ 4 $, $ 1 $, $ -1 $ となり、最後の魔物は消滅する。 - 次に、残りの体力が $ 4 $ の魔物を中心に爆発を引き起こす。残っていた $ 3 $ 体の魔物の体力はそれぞれ $ 0 $, $ -1 $, $ -2 $ となり、すべての魔物が消滅する。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>それぞれの魔物を中心に $ 2 $ 回ずつ、合計で $ 4 $ 回の爆発を引き起こす必要があります。</p></blockquote><h2 id="思路-2">思路</h2><p>思考，可以发现存在明显的分界点情况，在某一个临界次数值下，可以消灭全部怪物，具有单调性，所以可以考虑二分。</p><p>这里根据题目要求，二分的是次数。重心放在check函数怎么写。</p><p>不难想到使用贪心的思想，对于一个怪物来说，如果你能使用伤害为b的攻击，将其消灭，则使用b。</p><p>否则就只能使用爆炸了，统计一下爆炸的次数，然后和mid比较即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll h[MAXN],n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来解决取整问题</span></span><br><span class="line"><span class="function">ll <span class="title">Ceil</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%y==<span class="number">0</span>)<span class="keyword">return</span> x/y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x/y+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;=mid*b)<span class="keyword">continue</span>;</span><br><span class="line">        cnt+=<span class="built_in">Ceil</span>(h[i]-mid*b,a-b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较爆炸次数cnt和mid的值</span></span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll MAX=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;h[i],MAX=<span class="built_in">max</span>(MAX,h[i]);</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="built_in">Ceil</span>(MAX,b);</span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(l))cout&lt;&lt;l;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块入门by hzwer</title>
      <link href="/2024/04/15/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8by%20hzwer/"/>
      <url>/2024/04/15/%E5%88%86%E5%9D%97%E5%85%A5%E9%97%A8by%20hzwer/</url>
      
        <content type="html"><![CDATA[<h1 id="分块入门-by-hzwer">分块入门 by hzwer</h1><p>文章内容来自于<a href="http://hzwer.com/8053.html">「分块」数列分块入门1 – 9 by hzwer - 分块 - hzwer.com</a>，如有侵权，请联系作者删除</p><hr><h2 id="入门1">入门1</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，单点查值。</strong></p><p>这是一道能用许多数据结构优化的经典题，可以用于不同数据结构训练。</p><p>数列分块就是把数列中每m个元素打包起来，达到优化算法的目的。</p><p>以此题为例，如果我们把每m个元素分为一块，共有$O(\frac{n}{m})$块，每次<strong>区间加的操作会涉及$O(\frac{n}{m})$个整块，以及区间两侧两个不完整的块中至多2m个元素。</strong></p><p>我们给每个块设置一个加法标记（就是记录这个块中元素一起加了多少），每次操作对每个整块直接O(1)标记，而不完整的块由于元素比较少，暴力修改元素的值。</p><p>每次询问时返回元素的值加上其所在块的加法标记。</p><p>这样每次操作的复杂度是$O(\frac{n}{m})+O(m)$，根据均值不等式，当$m$取$\sqrt{n}$时总复杂度最低，为了方便，我们都默认下文的分块大小为$\sqrt{n}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,blo;</span><br><span class="line"><span class="type">int</span> v[<span class="number">50005</span>],bl[<span class="number">50005</span>],atag[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//修改每个元素的值</span></span><br><span class="line">    <span class="comment">//从a开始</span></span><br><span class="line">    <span class="comment">//如果a与b属于同一块，那么直接修改即可</span></span><br><span class="line">    <span class="comment">//不属于同一块，修改从a开始，到a所在块的右边界的区间元素，暴力修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">        v[i]+=c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断a与b是否处于同一块中</span></span><br><span class="line">    <span class="comment">//不属于同一块</span></span><br><span class="line">    <span class="comment">//修改从b所在块的左边界开始，到b的区间元素，暴力修改</span></span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">            v[i]+=c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a到b之间的元素块整块加值</span></span><br><span class="line">    <span class="comment">//如果a与b位于同一个块内，则不会进入循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">        atag[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//n表示有多少个元素，blo表示的分块的大小</span></span><br><span class="line">    n=<span class="built_in">read</span>();blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入n个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个元素分配到对应的块中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)bl[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n表示n次操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//f表示操作的类型，a表示区间的左端点，b表示区间的右端点，c表示加上的值</span></span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区间修改</span></span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)<span class="built_in">add</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单点查询，这里的b表示查询的单点值</span></span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v[b]+atag[bl[b]]);</span><br><span class="line">            cout&lt;&lt;v[b]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;atag[bl[b]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="入门2">入门2</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的元素个数。</strong></p><p>有了上一题的经验，我们可以发现，数列简单分块问题实际上有三项东西要我们思考：</p><p>对于每次区间操作：</p><p>1.<strong>不完整的块</strong> 的$O(\sqrt{n})$个元素怎么处理？</p><p>2.$O(\sqrt{n})$个 <strong>整块</strong> 怎么处理？</p><p>3.要预处理什么信息（复杂度不能超过后面的操作）？</p><p>我们先来思考只有询问操作的情况，不完整的块枚举统计即可；而要在每个整块内寻找小于一个值的元素数，于是我们不得不要求块内元素是有序的，这样就能使用二分法对块内查询，需要预处理时每块做一遍排序，复杂度$O(nlog\ n)$，每次查询在$\sqrt{n}$个块内二分，以及暴力$2\sqrt{n}$个元素，总复杂度$O(nlog\ n+n\sqrt{n}log\sqrt{n})$。</p><p><strong>可以通过均值不等式计算出更优的分块大小，就不展开讨论了</strong></p><p>那么区间加怎么办呢？</p><p>套用第一题的方法，维护一个加法标记，略有区别的地方在于，不完整的块修改后可能会使得该块内数字乱序，所以头尾两个不完整块需要重新排序，复杂度分析略。</p><p>在加法标记下的询问操作，块外还是暴力，查询小于（x – 加法标记）的元素个数，块内用（x – 加法标记）作为二分的值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> aa[MAXN],be[MAXN],tag[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[MAXN];</span><br><span class="line"><span class="type">int</span> n,block;</span><br><span class="line"><span class="comment">//重构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先清空数组</span></span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对该块内的元素进行重构</span></span><br><span class="line">    <span class="comment">//注意最后一块可能不是完整的一块 所以需要取min(n,x*block)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(x<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(n,x*block);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(aa[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对块中的元素进行重构 排序 方便后续的二分查找</span></span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//修改从a到b的区间内的元素</span></span><br><span class="line">    <span class="comment">//可能从a到b会跨块 所以取min(be[a]*block,b)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(b,be[a]*block);i++)&#123;</span><br><span class="line">        aa[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重构块</span></span><br><span class="line">    <span class="built_in">reset</span>(be[a]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 那么需要重构b所在的块</span></span><br><span class="line">    <span class="comment">//注意是从b所在块的左边开始重构</span></span><br><span class="line">    <span class="keyword">if</span>(be[a]!=be[b])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(be[b]<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">            aa[i]+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//别忘了重构块</span></span><br><span class="line">        <span class="built_in">reset</span>(be[b]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对从a到b之间的块进行重构</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 则需要将位于它们之间的块打上标记</span></span><br><span class="line">    <span class="comment">//注意不需要重构块 因为块中的元素值都加上了c</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=be[a]+<span class="number">1</span>;i&lt;=be[b]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查询从a到b的区间内大于c的元素</span></span><br><span class="line">    <span class="comment">//可能从a到b会跨块 所以取min(be[a]*block,b)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(be[a]*block,b);i++)&#123;</span><br><span class="line">        <span class="comment">//be[a]改成be[i]可行吗</span></span><br><span class="line">        <span class="comment">//可行</span></span><br><span class="line">        <span class="keyword">if</span>(aa[i]+tag[be[i]]&lt;c)ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断a与b是否位于同一块</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 那么需要重构b所在的块</span></span><br><span class="line">    <span class="comment">//注意这里只是询问，不需要重构</span></span><br><span class="line">    <span class="keyword">if</span>(be[a]!=be[b])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=block*(be[b]<span class="number">-1</span>)+<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">            <span class="comment">//be[b]改成be[i]也可行</span></span><br><span class="line">            <span class="keyword">if</span>(aa[i]+tag[be[i]]&lt;c)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对从a到b之间的块进行重构</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 则需要将位于它们之间的块中的元素进行二分查找</span></span><br><span class="line">    <span class="comment">//注意不需要重构块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=be[a]+<span class="number">1</span>;i&lt;=be[b]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=c-tag[i];</span><br><span class="line">        ans+=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),x)-v[i].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回答案</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 输入n个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;aa[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分块大小确定</span></span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个数确定其对应的块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        be[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">        v[be[i]].<span class="built_in">push_back</span>(aa[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个块内的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=be[n];i++)&#123;</span><br><span class="line">        <span class="comment">//wsm要重构</span></span><br><span class="line">        <span class="comment">//为了后面询问的需要，我们使用的是二分查找，但是不一定所有的块都会被重构</span></span><br><span class="line">        <span class="comment">// 所有我们需要提前对每个块进行重构 也就是对块中的元素进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n此询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,a,b,c;cin&gt;&gt;f&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)<span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)cout&lt;&lt;<span class="built_in">query</span>(a,b,c*c)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="入门3">入门3</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的前驱（比其小的最大元素）。</strong></p><p>n&lt;=100000其实是为了区分暴力和一些常数较大的写法。</p><p>接着第二题的解法，其实只要把块内查询的二分稍作修改即可。</p><p>不过这题其实想表达：可以在块内维护其它结构使其更具有拓展性，比如放一个 <strong>set</strong> ，这样如果还有插入、删除元素的操作，会更加的方便。</p><p><strong>分块的调试检测技巧：</strong></p><p>可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], be[MAXN], tag[MAXN];</span><br><span class="line"><span class="type">int</span> n, block;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s[<span class="number">1050</span>];</span><br><span class="line"><span class="comment">//修改加值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= <span class="built_in">min</span>(y, be[x]*block); i++) &#123;</span><br><span class="line">        <span class="comment">//需要先删除 再修改元素 再存入块中</span></span><br><span class="line">        s[be[i]].<span class="built_in">erase</span>(a[i]);</span><br><span class="line">        a[i] += z;</span><br><span class="line">        s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">if</span> (be[x] != be[y]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = block * (be[y] - <span class="number">1</span>) + <span class="number">1</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            s[be[i]].<span class="built_in">erase</span>(a[i]);</span><br><span class="line">            a[i] += z;</span><br><span class="line">            s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跨块 整块加上标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = be[x] + <span class="number">1</span>; i &lt;= be[y] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tag[i] += z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//询问</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="comment">//注意这里的val是值+标记</span></span><br><span class="line">    <span class="comment">//a[i]如果被修改了 则一定不会被加上tag</span></span><br><span class="line">    <span class="comment">//若加上tag 则不会被加上值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= <span class="built_in">min</span>(y, be[x]*block); i++) &#123;</span><br><span class="line">        <span class="type">int</span> val = a[i] + tag[be[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; z)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">if</span> (be[x] != be[y]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = block * (be[y] - <span class="number">1</span>) + <span class="number">1</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            <span class="type">int</span> val = a[i] + tag[be[i]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val &lt; z)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跨块</span></span><br><span class="line">    <span class="comment">//注意num得改为z-tag[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = be[x] + <span class="number">1</span>; i &lt;= be[y] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = z - tag[i];</span><br><span class="line">        <span class="comment">//找到第一个值为num的元素 因为set是自动排序的</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator it = s[i].<span class="built_in">lower_bound</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找不到则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (it == s[i].<span class="built_in">begin</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得要找比它小的 所以要减1</span></span><br><span class="line">        --it;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, *it + tag[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//获取分块大小</span></span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分块 将元素加到对应的块中</span></span><br><span class="line">    <span class="comment">// 这里的块用堆实现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        be[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> f, x, y, z;</span><br><span class="line">        cin &gt;&gt; f &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x, y, z) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始Qt</title>
      <link href="/2024/04/07/%E5%88%9D%E5%A7%8BQt/"/>
      <url>/2024/04/07/%E5%88%9D%E5%A7%8BQt/</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-初识Qt">第1章 初识Qt</h2><h3 id="1-1-Qt简介">1.1 Qt简介</h3><p>这一部分跳过</p><h3 id="1-2-Qt的安装">1.2 Qt的安装</h3><p>这一部分跳过</p><h3 id="1-3-Qt的编写一个Hello-World程序">1.3 Qt的编写一个Hello World程序</h3><p>这里涉及到了很多专业知识，打算写一下，但是内容太多了，后续找找看有没有比较好的电子书可以下载的。</p><p>只找到了Qt5.9的电子书，先凑合吧。</p><p>前面涉及到的基本是Qt的页面介绍，以及如何创建一个新项目。</p><p>具体看看这里：<a href="https://github.com/BomLook/QT-1/blob/master/QT%E7%AC%94%E8%AE%B0%E5%90%88%E9%9B%86.md">Qt快速入门</a>。</p><p>接下来就是按照书上的要求一步一步操作了，如下：（其实就是简单的贴上一些东西）</p><p><img src="https://img2.imgtp.com/2024/04/07/OamnrBHC.png" alt=""></p><p>效果如下：</p><p><img src="https://img2.imgtp.com/2024/04/07/Ig3bXmob.png" alt=""></p><p>但是在Run时遇到一点小问题，我一开始在给项目设置开发套件的时候，点得太快，可能导致全部的开发套件都选上了。</p><p>一开始用的是MSVC2019，但是这个时候就提示not exist。尝试改成用Min-GW开发套件就可以了。</p><p><img src="https://img2.imgtp.com/2024/04/07/ZknftNPF.png" alt=""></p><p>补充一点，由于一开始的时候是中文版本，由于翻译的问题，中文的内容可能不够准确，所以建议使用英文页面。</p><p>这里书上给的是点击Tool-Option进行修改。但在新版本中，需要点击Edit-Preference-Environment来进行修改。</p><p>基本就这样，没了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt6 C++开发指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载：string类</title>
      <link href="/2024/04/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9Astring%E7%B1%BB/"/>
      <url>/2024/04/05/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%EF%BC%9Astring%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="C-How-to-Program">C++ How to Program</h1><h2 id="运算符重载：string类">运算符重载：string类</h2><p>主要包含string类的一些函数，具体可以看黑马的STL部分，这里不重复了。</p><p>主要注意以下部分：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="comment">//这是调用string类的拷贝构造函数，并s1的副本对其进行初始化。</span></span><br><span class="line"></span><br><span class="line">s4=s2;</span><br><span class="line"><span class="comment">//这是string类重载的&quot;=&quot;运算符，可以进行正确的赋值操作，正确处理自我赋值的情况，详情以后补充。</span></span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是重载[]来访问string中的元素，注意这不会进行任何越界检查（也就是有越界的风险）</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;s.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//at函数与上述[]一样，但是会检查是否在有效范围之内（越界会抛出error）</span></span><br></pre></td></tr></table></figure><h3 id="运算符重载的基本知识">运算符重载的基本知识</h3><p>通过像往常编写非静态成员函数或者非成员函数定义就可以实现运算符的重载，只不过现在的名字是operator加上重载的运算符。这些函数必须由类的对象来调用，并作用到这个对象上。</p><p>有如下的三个例外：<br>1、绝大多数类可以使用=对其数据成员进行逐个赋值操作，但是我们前面说到，如果数据成员包含指针，这将带来严重的问题。</p><p>因此，我们将显式地重载赋值运算符。</p><p>2、取址（&amp;）运算符返回对象的地址，这个运算符也能被重载。</p><p>3、逗号（，）运算符从左到右对表达式进行求值，并返回表达式的值，也可以重载。</p><h4 id="不能被重载的运算符">不能被重载的运算符</h4><p>以下四个</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>.</td><td>.*</td><td>::</td><td>?:</td></tr></tbody></table><p>第二个是pointer to member。</p><h4 id="重载运算符的规则和限制">重载运算符的规则和限制</h4><p>1、优先级不变。（当然圆括号可以改变表达式中重载运算符的求值顺序）</p><p>2、结合性不变。（如果是从左到右结合，那么它的重载版本仍是这样）</p><p>3、元数不变。（也就是一元运算符，还是二元运算符保持不变，特别的是&amp;，+，-，*即可作为一元、也可以作为二元，这些一元和二元的版本都可以被单独重载）。</p><p>4、不能创造新的运算符，只能重载现有运算符。</p><p>5、运算符作用在基本类型上的方法不可以被重载改变（比方说+不可以称之为两个int相减）。</p><p>运算符重载仅限于用户定义类型或者用户定义类型和基本类型的混合。</p><p>6、关系运算符必须被单独重载。</p><p>7、重载（）、[]、-&gt;或者任何赋值运算符时，重载函数都必须声明为类成员，其他无所谓。</p><p>建议：</p><p>对类类型进行运算符重载，应该使得重载的运算符尽可能仿效内置运算符对基本类型的作用方式。</p><h3 id="二元运算符的重载">二元运算符的重载</h3><p>有两种：<br>1、带有一个参数的非静态成员函数。</p><p>2、带有两个参数的非成员函数（需要被声明为类的友元）。</p><h4 id="作为成员函数的二元重载运算符">作为成员函数的二元重载运算符</h4><p>仅当左操作数是该类的对象，且重载函数是一个成员时，二元运算符的重载函数才能作为成员函数。</p><p>注意左操作数是调用该成员函数的对象。</p><h4 id="作为非成员函数的二元重载运算符">作为非成员函数的二元重载运算符</h4><p>必须带有两个参数，其中一个必须是与重载运算符有关系的类对象或者是类对象的引用，例子如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String&amp;,<span class="type">const</span> String&amp;);</span><br></pre></td></tr></table></figure><h3 id="重载二元流插入运算符和流提取运算符">重载二元流插入运算符和流提取运算符</h3><p>可以实现用户自定义的输入和输出。</p><p>这里通过例子简单见到介绍一下注意事项：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output,<span class="type">const</span> PhoneNumber &amp;number)</span><br><span class="line">&#123;</span><br><span class="line">    output&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;number.areaCode&lt;&lt;<span class="string">&quot;)&quot;</span></span><br><span class="line">        &lt;&lt;number.exchange&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;number.line;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;input,PhoneNumber &amp;number)</span><br><span class="line">&#123;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">4</span>)&gt;&gt;number.areaCode;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">5</span>)&gt;&gt;number.exchange;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">6</span>)&gt;&gt;number.line;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到函数的返回值都是引用，这样才可以实现级联调用（这和前面的串联调用很像）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PhoneNumber t1,t2; </span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br></pre></td></tr></table></figure><p>因为该类的对象在全局中只能有一个，所以参数列表中的第一个参数都是以引用的形式传递的（流对象不能复制，只能引用）。</p><p>ostream也是同理，注意只能用非成员函数实现，因为如果用非静态成员函数实现：那么调用该成员函数的对象将位于重载运算符的左边，与实际要求矛盾。</p><p>这里的setw限制了读到每个字符数组的字符个数，如setw(n)设置允许读入n个字符。</p><p>istream还有一个ignore函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream &amp;input;</span><br><span class="line">input.<span class="built_in">ignore</span>()</span><br><span class="line"><span class="comment">//将圆括号、空格、破折号等字符全部跳过。</span></span><br><span class="line"><span class="comment">//ignore丢弃输入流中指定个数的字符（默认为一个字符）。</span></span><br></pre></td></tr></table></figure><h4 id="重载流插入-运算符">重载流插入(&lt;&lt;)运算符</h4><p>和上面基本一致。</p><h4 id="作为非成员友元函数的重载运算符">作为非成员友元函数的重载运算符</h4><p>这个已经在前面解释过了，不再多解释。</p><h4 id="为什么流插入和流提取运算符必须被重载为非成员函数">为什么流插入和流提取运算符必须被重载为非成员函数</h4><p>这个已经在前面解释过了，不再多解释。</p><p>假设一定要用成员函数，那么得修改C++标准库中的数据类型，这是非常危险的（也不允许）。</p><h3 id="重载一元运算符">重载一元运算符</h3><p>有两种（就是上面说的两种）。</p><h5 id="作为成员函数的一元重载运算符">作为成员函数的一元重载运算符</h5><p>以重载!为例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!()<span class="type">const</span>;</span><br></pre></td></tr></table></figure><p>这样，当编译器遇到表达式!s时，将会生成函数调用s.operator!()。</p><h4 id="作为非成员函数的一元重载运算符">作为非成员函数的一元重载运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!(<span class="type">const</span> String &amp;)</span><br></pre></td></tr></table></figure><p>!s将被处理为operator!()。</p><h3 id="重载一元前置和后置运算符：-和–">重载一元前置和后置运算符：++和–</h3><p>自增自减运算符的前置和后置形式都可以进行重载，下面以自增为例介绍如何区分前置和后置形式。</p><p>为了使得编译器能够正确地识别要使用的是哪一种++模式，每个重载地运算符函数都必须有各自明显的特征。</p><p>假设前置的自增运算符为我们Date对象d1的天数+1。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">Date &amp;<span class="keyword">operator</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态成员函数</span></span><br><span class="line"><span class="comment">//当编译器遇到：++d1时，等价于</span></span><br><span class="line">d1.<span class="keyword">operator</span>++()。</span><br><span class="line"></span><br><span class="line"><span class="comment">//非成员函数类型</span></span><br><span class="line"><span class="comment">//编译器遇到++d1，等价于</span></span><br><span class="line"><span class="keyword">operator</span>++(d1)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在类中的声明为</span></span><br><span class="line">Date &amp;<span class="keyword">operator</span>++(Date &amp;);</span><br></pre></td></tr></table></figure><h4 id="重载后置的自增运算符">重载后置的自增运算符</h4><h5 id="非静态成员函数类型">非静态成员函数类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//编译器遇到表达式d1++时。</span><br><span class="line">//调用如下：</span><br><span class="line">d1.operator++(0)</span><br><span class="line"></span><br><span class="line">//对应的函数原型为</span><br><span class="line">Date operator++(int)</span><br></pre></td></tr></table></figure><p>这里的0其实是个哑巴，只是为了让编译器能够区分前置和后置而已。</p><h5 id="非成员函数类型">非成员函数类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数调用</span><br><span class="line">operator++(d1,0);</span><br><span class="line"></span><br><span class="line">//函数原型</span><br><span class="line">Date operator(Date &amp;,int);</span><br></pre></td></tr></table></figure><p>这里的0作用和上面一样。</p><p>注意：后置的运算符按值返回对象，而前置的运算符按引用返回对象。这是因为在自增前，后置的运算符通常先返回一个包含对象原始数据的临时对象，C++将其作为右值，不能用在赋值运算符的左侧。前置的自增运算符返回实际自增后的具有新值的对象，可以放在赋值运算符的左侧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        num=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        num=num+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    node a;</span><br><span class="line">    node b;</span><br><span class="line">    b=a++;</span><br><span class="line">    b.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//输出为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：使用前置的自增或者自减运算符，后置会对性能造成更大的影响。</p><h3 id="实例研究：Date类">实例研究：Date类</h3><p>（跳过）</p><p>注意不能返回局部变量的引用，否则会编译错误（因为可能该对象被析构了）。</p><h3 id="动态内存管理">动态内存管理</h3><p>通过运算符new和delete实现。</p><p>可以使用new运算符在执行期间为对象或者数组动态分配所需要的内存，对象和数组被存储在堆中（这是一个专门用来存储动态分配对象的内存区域）。一旦内存中的自由存储区被分配，那么就可以通过new运算符返回的指针进行访问。当不再需要内存时，则可以使用delete来释放内存，从而内存返回给堆区，以便供将来的new操作复用。</p><h4 id="使用new来动态获取内存">使用new来动态获取内存</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time *timePtr=<span class="keyword">new</span> <span class="built_in">Time</span>();</span><br></pre></td></tr></table></figure><p>上面的new运算符为一个Time类型的对象分配大小合适的内存空间，调用默认的构造函数来初始化这个对象并返回一个指向new运算符右侧类型的指针（也即是Time*）。</p><p>如果new无法在内存中为该对象找到足够的空间，则会抛出异常（一般会抛出一个bad_alloc异常）。</p><h4 id="使用delete动态释放内存">使用delete动态释放内存</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> timePtr;</span><br></pre></td></tr></table></figure><p>这将先调用timePtr指向对象的析构函数，早收回对象所占用的内存空间，把内存返回给自由存储区。</p><p>注意：</p><p>1、当动态内存分配的空间不再使用时，要及时释放。</p><p>2、不要删除不是new分配的内存。</p><p>3、delete一个动态分配的内存块后确保不要对同一块内存再次delete，一个建议是：立即将delete过的指针的值设置为nullptr，delete一个nullptr是没有影响的。</p><p>补充：可以重载new和delete运算符，两者必须在同一作用域内重载。（以后再详细补充）</p><h4 id="动态内存的初始化">动态内存的初始化</h4><p>可以为新建立的基本类型变量提供初始化值：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> *ptr=<span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure><p>同样的语法也可以用来将由逗号分隔开的参数列表指定给对象的构造函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time *timePtr=<span class="keyword">new</span> <span class="built_in">Time</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="使用new-动态分配内置数组">使用new[]动态分配内置数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *Array=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure><p>这声明了一个指针Array，并将指向一个动态分配的10元素的整数数组第一个元素的指针赋给它。</p><p>new int[10]值后面的括号初始化数组元素——基本数据类型设置为0，bool为flase，指针为nullptr，对象则通过其默认构造函数进行初始化，注意：在编译时确定数组的大小时必须用常量整数表达式确定，动态分配数组的大小可以用在执行期间求值的任何非负整数表达式来指定。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> *ptr=<span class="keyword">new</span> <span class="type">int</span>[a];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        cin&gt;&gt;*(ptr+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        cout&lt;&lt;*(ptr+i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//样例</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="C-11使用列表初始化动态分配内存的数组">C++11使用列表初始化动态分配内存的数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>默认初始化列表——对基本类型来说，就是将每个元素置为0。</p><h4 id="使用delete-动态释放内置数组">使用delete[]动态释放内置数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []Array;</span><br></pre></td></tr></table></figure><p>注意：如果上面语句中的指针指向一个内置数组，则语句先调用数组中每个对象的析构函数，后回收空间。</p><p>如果不包含[]，且指针指向一个对象的数组，则结果是未知的，可能会只为数组的首对象调用析构函数。</p><p>对空指针进行delete，或者delete[]操作并无任何效果。</p><h4 id="C-11使用unique-ptr管理动态分配的内存">C++11使用unique_ptr管理动态分配的内存</h4><p>unique_ptr是一个智能指针，当一个unique_ptr超出范围时，它的析构函数将自动把其管理的内存返还到自由存储区中。</p><h3 id="实例研究：Array类">实例研究：Array类</h3><p>（跳过）</p><h3 id="运算符作为成员函数或非成员函数的比较">运算符作为成员函数或非成员函数的比较</h3><p>一个特定类的运算符成员函数仅在以下两种情形中被调用，当二元运算符的左操作数是该类的对象时，或者一元运算符唯一的操作数是该类的对象时。</p><h4 id="可交换的运算符">可交换的运算符</h4><p>一般由非成员函数实现，这样可以使得运算符具有交换性。</p><h3 id="类型转换">类型转换</h3><p>程序员必须指出如何转换，编译器才能执行。</p><h4 id="转换运算符">转换运算符</h4><p>又称为强制类型转换运算符，可用于将某一类的对象转换为另外一个类的对象，这种转换运算符必须是非static成员函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass::<span class="keyword">operator</span> <span class="type">char</span> *()<span class="type">const</span></span><br></pre></td></tr></table></figure><p>可以将用户自定义吧类型Myclass的对象转换为一个临时的char*对象，这个运算符函数声明为const，因为不修改原始的对象。</p><p>不需要指定转换类型，因为返回类型就时目标类型。</p><p>当编译器遇到：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(s);</span><br></pre></td></tr></table></figure><p>会产生函数调用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">operator</span> <span class="type">char</span>*();</span><br></pre></td></tr></table></figure><p>这将把操作数转换为char*类型。</p><h4 id="重载强制类型转换运算符">重载强制类型转换运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function">MyClass::<span class="keyword">operator</span> <span class="title">OtherClass</span><span class="params">()</span><span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h4 id="强制类型转换运算符和转换构造函数的隐式调用">强制类型转换运算符和转换构造函数的隐式调用</h4><p>两者优点之一是：必要时，编译器可以隐式地调用这些函数来创建临时的对象。</p><p>如：String类的对象s出现在本来一个应该出现字符数组char*的位置上，那么</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;s</span><br></pre></td></tr></table></figure><p>编译器可以使用重载的强制类型转换运算符operator char*将对象转换为char *,并在表达式中使用这个转换结果char *。</p><p>这样就可以不必重载&lt;&lt;运算符了。</p><h3 id="explicit构造函数与转换运算符">explicit构造函数与转换运算符</h3><p>任何单参数且不被声明为explict的构造函数可以被编译器识别用来进行隐式类型转换，除了拷贝构造函数。</p><p>构造函数中的实参被转换为函数中定义的类对象，这种转换是自动进行的。</p><p>但某种情况下，这样会带来麻烦和问题。从而产生歧义。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Array <span class="title">integers</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="built_in">outArray</span>(integers);</span><br><span class="line"><span class="built_in">outArray</span>(<span class="number">3</span>);<span class="comment">//发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outArray</span><span class="params">(<span class="type">const</span> Array &amp;arrayOutPut)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下数组中的元素都为0。</p><p>本来，第一行是创建了一个integers的Array类对象（有7个元素，默认为0），然后输出。</p><p>但是由于没有提供接受一个int作为参数的outArray函数，所以编译器先确定Array类是否提供了一个将int转换为Array的转换构造函数，由于任何接受单参数的构造函数都可以被认为是转换构造函数，所以编译器认为接受单个int参数的Array构造函数是一个转换构造函数，并将参数3转换为一个包含了3个元素的临时Array对象，然后再将它传递给函数outArray，输出内容。乌龙就这么产生了。</p><p>为了解决这个问题，所以有了关键字explicit。</p><h4 id="防止无意中调用将单参数的构造函数作为转换构造函数">防止无意中调用将单参数的构造函数作为转换构造函数</h4><p>我们在声明每个单参数的构造函数时，前面加上explicit关键字，目的是禁止不应该允许的由转换构造函数完成的隐式转换。</p><p>这样上面的程序应该修改为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Array <span class="title">integers</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="built_in">outArray</span>(integers);</span><br><span class="line"><span class="built_in">outArray</span>(<span class="number">3</span>);<span class="comment">//不会发生隐式类型转换，会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">outArray</span>(<span class="built_in">Array</span>(<span class="number">3</span>))<span class="comment">//显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outArray</span><span class="params">(<span class="type">const</span> Array &amp;arrayOutPut)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了问题。</p><p>建议在单参数的构造函数中总是使用explicit关键字，除非打算将它们用作转换构造函数。</p><h4 id="C-11：explicit转换运算符">C++11：explicit转换运算符</h4><p>同样，也可以声明explicit的转换运算符来防止编译器使用它们进行隐式转换。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explicit</span> MyClass::<span class="keyword">operator</span> <span class="type">char</span>*()<span class="type">const</span> </span><br></pre></td></tr></table></figure><h3 id="重载函数调用运算符">重载函数调用运算符</h3><p>这个非常灵活多变，也非常重要，因为函数能够接受任意数量的逗号分隔参数。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">String::operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> index,<span class="type">size_t</span> length)</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><p>这里想要的是检查起始位置越界或者负长度的功能，注意必须是一个const成员变量，不应该修改原始的String对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String s1=<span class="string">&quot;AEIOU&quot;</span>;</span><br><span class="line">s1.<span class="built_in">operator</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这将会得到字串&quot;IOU&quot;。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的深入剖析：抛出异常</title>
      <link href="/2024/04/05/%E7%B1%BB%E7%9A%84%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2024/04/05/%E7%B1%BB%E7%9A%84%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="类的深入剖析：抛出异常">类的深入剖析：抛出异常</h2><h3 id="Time类实例研究">Time类实例研究</h3><h4 id="Time类的定义">Time类的定义</h4><p>这里涉及到一个C++软件工程的概念：在头文件中使用“包含防护”，从而避免头文件中的代码被多次包含到同一个源代码文件中的情况，具体写法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里详细解释一下：</p><p>在构建大型程序时，头文件中还会放入其他的定义和声明。</p><p>当前述的“包含防护”在TIME_H已被定义时，可以阻止将#ifndef和#endif之间的代码包含到文件中。</p><p>如果在这些指令之间的代码先前没有包含到应用程序中，那么TIME_H这个名字将会被#define定义，并且包含该头文件的语句。</p><p>如果已经包含，那么TIME_H已经有定义，将不会包含该头文件。</p><p>建议：<br>1、使用预处理器指令#ifndef、#define、#endif等构成包含防护，从而避免头文件在一个程序中被多次包含。</p><p>2、按照惯例，在#ifndef和#define中，应该使用大写的头文件名，并且用下划线代替圆点。</p><h3 id="Time类的成员函数">Time类的成员函数</h3><p>可以使用类内初始化器，在类定义中声明为任何数据成员之处对此数据成员进行初始化。</p><p>其实就是{}：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(): a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;<span class="comment">//具体的实现逻辑&#123;&#125; //C++11, 初始化数组成员  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Time类的成员函数setTime和异常的抛出">Time类的成员函数setTime和异常的抛出</h4><p>看以下这条语句：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，throw语句创建了一个类型为invalid_argument的新对象，而跟在类名称后面的圆括号表示对该invalid_argument对象构造函数的一个调用，这里需要加入头文件#include<stdexcept>。</p><h4 id="Time类的成员函数printUniversal">Time类的成员函数printUniversal</h4><p>这里注意一个setfill流操作符。可以用于指定当输出域宽大于输出整数值中的数字个数时所需要的显示的填充字符。</p><p>默认情况下，数的输出是右对齐的，那么填充字符出现在数中数字的左边，如果是左对齐，则出现在右边。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">3</span>)&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>输出结果为001。</p><p>如果将要输出的数填满了指定的域宽，则不显示填充字符。</p><p>注意：一旦使用了setfill指定了填充字符，则该字符将应用在后续的显示中，只要显示的域宽大于要被显示数所需要的的实际宽度。（实际上setfill是一个黏性设置，当每个黏性设置不再需要使用时，则应当将它恢复到以前的模式，否则在后续中输出可能会存在问题）。</p><h4 id="Time类的成员函数printStandard">Time类的成员函数printStandard</h4><p>还是上面一样的问题，跳过。</p><h4 id="在类定义外部定义成员函数与类的作用域">在类定义外部定义成员函数与类的作用域</h4><p>即使声明在类定义中的成员函数可以在类定义的外部定义（并且通过二元作用域分辨运算符“绑定”到该类），这样的成员函数仍在该类的作用域中。（二元作用域分辨运算符就是::）</p><h4 id="成员函数与全局函数（又称自由函数）">成员函数与全局函数（又称自由函数）</h4><p>跳过，讲的是成员函数的优点。</p><h4 id="使用Time类">使用Time类</h4><p>定义了一个类，即可将他用于对象，数组，指针，引用中：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time sunset;</span><br><span class="line">array&lt;Time,5&gt;arrayOfTimes;</span><br><span class="line">Time &amp;dinnerTime=sunset;</span><br><span class="line">Time *timePtr=&amp;dinnerTime;</span><br></pre></td></tr></table></figure><h4 id="用无效值调用setTime">用无效值调用setTime</h4><p>主要涉及try…catch语句。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try语句块是用来判断是否有异常；</p><p>catch语句块捕捉异常，并进行处理；</p><p>throw是抛出异常；</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fuc</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>                        <span class="comment">//定义函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> y;                                    <span class="comment">//除数为0，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x/y;                                    <span class="comment">//否则返回两个数的商</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line">    <span class="keyword">try</span>                                            <span class="comment">//定义异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="built_in">fuc</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The result of x/y is : &quot;</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        res=<span class="built_in">fuc</span>(<span class="number">4</span>,<span class="number">0</span>);                                <span class="comment">//出现异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">double</span>)                                    <span class="comment">//捕获并处理异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;error of dividing zero.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                    <span class="comment">//异常退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里转载自：[C++：try catch语句用法_c++ try catch用法-CSDN博客](<a href="https://blog.csdn.net/sss_369/article/details/92179738?ops_request_misc=%7B%22request%5Fid%22%3A%22171225794616800188521498%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171225794616800188521498&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-92179738-null-null.142%5Ev100%5Epc_search_result_base6&amp;utm_term=c%2B%2B">https://blog.csdn.net/sss_369/article/details/92179738?ops_request_misc={&quot;request_id&quot;%3A&quot;171225794616800188521498&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=171225794616800188521498&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-92179738-null-null.142^v100^pc_search_result_base6&amp;utm_term=c%2B%2B</a> try catch用法&amp;spm=1018.2226.3001.4187)</p><p>一般格式如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">try</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="comment">// 这里的程序代码完成真正复杂的计算工作，这些代码在执行过程中</span></span><br><span class="line">　　　　<span class="comment">// 有可能抛出DataType1、DataType2和DataType3类型的异常对象。</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType1&amp; d1)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType2&amp; d2)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType3&amp; d3)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">　　注意上面try block中可能抛出的DataType1、DataType2和DataType3三</span></span><br><span class="line"><span class="comment">　　种类型的异常对象在前面都已经有对应的catch block来处理。但为什么</span></span><br><span class="line"><span class="comment">　　还要在最后再定义一个catch(…) block呢？这就是为了有更好的安全性和</span></span><br><span class="line"><span class="comment">　　可靠性，避免上面的try block抛出了其它未考虑到的异常对象时导致的程</span></span><br><span class="line"><span class="comment">　　序出现意外崩溃的严重后果，而且这在用VC开发的系统上更特别有效，因</span></span><br><span class="line"><span class="comment">　　为catch(…)能捕获系统出现的异常，而系统异常往往令程序员头痛了，现</span></span><br><span class="line"><span class="comment">　　在系统一般都比较复杂，而且由很多人共同开发，一不小心就会导致一个</span></span><br><span class="line"><span class="comment">　　指针变量指向了其它非法区域，结果意外灾难不幸发生了。catch(…)为这种</span></span><br><span class="line"><span class="comment">　　潜在的隐患提供了一种有效的补救措施。</span></span><br><span class="line"><span class="comment">　　*********************************************************/</span></span><br><span class="line"> </span><br><span class="line">　　<span class="built_in">catch</span>(…)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再看看这篇文章深究：<a href="https://www.cnblogs.com/MrYuan/p/4800257.html">c++中try catch的用法 - 超酷小子 - 博客园 (cnblogs.com)</a>。</p><h4 id="组成和继承概念介绍">组成和继承概念介绍</h4><p>组成：包含类对象作为其他类的成员。</p><p>继承：从已有的类派生出来的新的类。</p><h4 id="对象大小">对象大小</h4><p>实际上，对象只包含数据。编译器只创建独立于类的所有对象的一份成员函数的副本，该类的所有对象都共享这份副本。</p><h3 id="类的作用域和类成员的访问">类的作用域和类成员的访问</h3><p>类的数据成员和成员函数都属于该类的作用域。默认情况下，非成员函数在全局命名空间作用域中定义。</p><h4 id="类作用域和块作用域">类作用域和块作用域</h4><p>成员函数中声明的变量具有块作用域，只有该函数知道他们。如果成员函数定义了与类作用域内变量同名的另外一个变量，则函数中块作用域中的变量将隐藏在类作用域中的变量，需要使用类名+::进行访问。</p><h4 id="圆点成员选择运算符-和箭头成员选择运算符">圆点成员选择运算符(.)和箭头成员选择运算符(-&gt;)</h4><p>(.)前面+对象名、对象引用，则可以直接访问该对象的成员。</p><p>(-&gt;)前面+对象指针，则可以访问该对象的成员。</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Account account;</span><br><span class="line">Account &amp;accountRef;</span><br><span class="line">Account *accountPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用如下</span></span><br><span class="line">account.<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br><span class="line">accountRef.<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br><span class="line">accountPtr-&gt;<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br></pre></td></tr></table></figure><h3 id="访问函数与工具函数">访问函数与工具函数</h3><p>访问函数：可以读取和显示数据。</p><p>工具函数：一个用来支持类的其他成员函数操作的private成员函数。</p><h4 id="Time类实例研究：具有默认实参的构造函数">Time类实例研究：具有默认实参的构造函数</h4><p>一个默认所有实参的构造函数也是一个默认的构造函数，即一个调用时不需要带任何实参的构造函数，每个类最多只有一个默认构造函数。</p><p>注意：对默认实参值的任何修改都要求重新编译用户代码（保证程序正常运行）。</p><h4 id="关于Time类的设置函数、获取函数、构造函数的补充说明">关于Time类的设置函数、获取函数、构造函数的补充说明</h4><p>类内的一些成员函数的实现可由设置函数和获取函数构成，这样，当private数据成员发生改变时（如数据成员减少），只需要修改哪些直接访问private数据的函数体（尤其是设置函数和获取函数），而其他没有直接访问的函数则不需要修改。这样可以降低因改变类的实现方法而造成编程错误的可能性。</p><p>建议：<br>1、如果成员函数已经实现了类的构造函数所需要的部分或全部功能，则可以在构造函数中调用这样的成员函数。既可以简化代码的维护，也可以减少由修改代码实现方法所引起出差的可能性。</p><p>2、构造函数应当适当地初始化后，再调用其他成员函数。</p><h4 id="C-11：使用列表初始化器调用构造函数">C++11：使用列表初始化器调用构造函数</h4><p>格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">Time t3&#123;<span class="number">21</span>,<span class="number">34</span>&#125;;</span><br><span class="line">Time t4&#123;<span class="number">12</span>,<span class="number">25</span>,<span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-11：重载的构造函数和委托构造函数">C++11：重载的构造函数和委托构造函数</h4><p>构造函数也可以重载：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Time</span>();</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span> <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>构造函数也可以使用同一个类中的其他构造函数，这称为委托构造函数。</p><p>例子如下：使用Time(int,int,int)来构造其他三个构造函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">:<span class="built_in">Time</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> hour)</span><br><span class="line">:<span class="built_in">Time</span>(hour,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> hour,<span class="type">int</span> minute)</span><br><span class="line">:<span class="built_in">Time</span>(hour,minute,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="析构函数">析构函数</h3><p>析构函数不接受任何参数，也不返回任何值。</p><p>本身不释放对象占用的内存空间，它只是再系统回收对象的内存空间之前执行扫尾工作，这样内存可以用于重新保存新的对象。</p><h3 id="何时调用构造和析构">何时调用构造和析构</h3><p>（需要再复习）</p><p>编译器隐式地调用构造和析构函数，一般两者的调用顺序相反，但是，对象的存储类别也可以该改变调用析构函数的顺序。</p><p>取决于程序进入和离开实例化对象所在作用域的顺序。</p><h3 id="返回private数据成员的引用或者指针">返回private数据成员的引用或者指针</h3><p>如果让类的public成员函数返回对该类private数据成员的引用，注意函数返回的如果是一个const引用，则这个引用不可以作为可供修改的左值（读起来好绕口）。</p><p>换句话说，这么做是非常不合理的，因为这样，我们可以直接访问private数据成员，并且进行修改，（返回一个private类型的数据成员的引用或指针破坏了类的封装性），当然在某些情况下是合理的。</p><h3 id="默认的逐个赋值">默认的逐个赋值</h3><p>赋值运算符可以将一个对象赋给另外一个相同类型的对象。默认情况下是逐个成员进行赋值。</p><p>但是，当类的数据成员包含指向动态分配内存的指针时，将会引发严重的问题。以后会提到怎么解决。</p><p>复制构造函数由编译器默认提供，功能和赋值运算符基本一致，但是也存在相同的问题。</p><h3 id="const对象和const成员函数">const对象和const成员函数</h3><p>对于const对象，编译器不允许进行成员函数的调用，除非成员函数也声明为const。</p><p>一个const成员函数需要在两处同时指明const限定符：</p><p>1、函数原型的参数列表后面插入关键字const</p><p>2、在函数定义时在函数体开始时的左括号之前。</p><p>注意：</p><p>1、将修改对象的数据成员的成员函数定义为const将导致编译错误。</p><p>2、定义为const的成员函数如果又调用同一类的同一实例的非const成员函数，将导致编译错误。</p><p>3、在const对象上调用非const成员函数将导致编译错误。</p><p>4、一个const对象的常量性是从构造函数完成初始化到析构函数被调用为止。</p><h4 id="使用const和非const成员函数">使用const和非const成员函数</h4><p>尽管构造函数必须是非const函数，但是它仍可以用来初始化const对象。</p><p>有趣的是，在构造函数中，调用非const成员函数来完成const对象的初始化是允许的，与上面的内容不谋而合。</p><h3 id="组成：对象作为类的成员">组成：对象作为类的成员</h3><p>（后续补充）</p><h3 id="friend函数和friend类">friend函数和friend类</h3><p>类的friend函数在类的作用域外被定义，却具有访问类的非public成员的权限。</p><p>单独的函数、整个类、或其他类的成员函数都可以被声明为另一个类的友元。</p><h4 id="friend的声明">friend的声明</h4><p>友元声明可以出现在类的任何地方。</p><p>如果要让ClassTwo的所有成员函数都作为ClassOne的友元，则在ClassOne的定义中加入以下这句话：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ClassTwo</span>;</span><br></pre></td></tr></table></figure><p>注意，若使B成为A的友元，则A必须显式地声明为B是它的友元。并且友元关系不是对称的、传递的。</p><h4 id="重载友元函数">重载友元函数</h4><p>可以指定重载函数为类的友元，每个打算成为友元的重载函数都必须在类的定义里面显式地声明为类地一个友元。</p><p>注意：</p><p>1、友元不是成员函数</p><p>2、public、private、protected这些成员访问说明符标志与友元声明无关。</p><p>3、把所有的友元关系放在最前面，并且不要添加任何成员访问说明符。</p><h3 id="使用this指针">使用this指针</h3><p>每个对象都可以使用一个称为this的指针来访问自己的地址，对象的this指针不是对象本身的一部分，也就是this指针占用的内存大小不会反映在对对象进行sizeof运算得到的结果中。</p><p>并且，this指针作为一个隐式的参数传递给对象的每个非静态成员函数。</p><h4 id="使用this指针来避免名字冲突">使用this指针来避免名字冲突</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::setHour</span><span class="params">(<span class="type">int</span> hour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;=<span class="number">0</span>&amp;&amp;hour&lt;<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour=hour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在该函数定义中，参数名和数据成员hour名字相同。在setHour的作用域内，参数hour将隐藏数据成员，所以我们可以使用this指针访问该数据成员hour，并且赋值。</p><h4 id="this指针的类型">this指针的类型</h4><p>一般情况下，this指针的类型为classtype *const，如果对象的类型及使用this的成员函数被声明为const时，this指针的类型为const classtype *const。</p><h4 id="隐式和显式地使用this指针来访问对象的数据成员">隐式和显式地使用this指针来访问对象的数据成员</h4><p>分为两种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用this指针和-&gt;进行访问修改</span></span><br><span class="line"><span class="keyword">this</span>-&gt;x=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用*this和.进行访问修改</span></span><br><span class="line">(*<span class="keyword">this</span>).x=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//注意这对圆括号是必须的，因为*的优先级高于.,不加圆括号，将被识别为*(this.x);</span></span><br></pre></td></tr></table></figure><p>this指针的一个有趣的用法是防止对象自我赋值，后续补充。</p><h4 id="使用this指针使得串联函数成为可能">使用this指针使得串联函数成为可能</h4><p>this指针的另一个用法是串联的成员函数调用成为可能，也就是多个函数在一条语句中被重复调用。</p><p>关键是这些调用函数的返回值是*this（这一点在重载运算符中有所体现）。</p><h3 id="static类成员">static类成员</h3><p>static类成员属于类（所有对象共享一份数据），不属于某个具体的对象，某个对象修改static的类成员，也会影响其他对象。</p><p>这样的优点是：所有对象都只需要一份数据副本即可，使用static数据成员可以节省存储空间。</p><h4 id="静态数据成员的作用域和初始化">静态数据成员的作用域和初始化</h4><p>类的static数据成员只在类的作用域内起作用，且必须被精确地初始化。</p><p>基本类型的static数据成员默认情况下将被初始化为0。</p><p>注意如果有静态成员函数，则不需要初始化，因为它们的默认构造函数将被调用。</p><h4 id="访问静态数据成员">访问静态数据成员</h4><p>即使在没有任何类的对象时，类的static成员仍然存在。</p><p>private，protected：通常使用类的public成员函数或者类的友元访问。</p><p>没有类的对象存在时，只需在静态数据成员前加上类名和::即可。</p><p>当没有类的对象时而需要访问private或protected的static类成员时，应该提供public static成员函数，并且在函数名前加上类名和::来调用该函数。</p><p>因为类的static成员需要被任何访问文件的客户代码使用时，所以不能在.cpp文件中将它们声明为static，而只在.h文件中将它们声明为static。</p><p>如果成员函数不访问类的非static的数据成员或非static的成员函数，则应该将其声明为static。</p><p>static函数不具有this指针，因为static数据成员和成员函数独立于类的任何对象而存在，而this指针必须指向具体的对象。</p><p>注意：<br>1、static成员函数中不能使用this指针</p><p>2、static成员函数不能声明为const，const限定符指示函数不能修改它操作的对象的内容，但是static成员函数独立于类的任何对象而存在并且进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/2024/04/05/%E6%8C%87%E9%92%88/"/>
      <url>/2024/04/05/%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="指针">指针</h2><h3 id="指针变量的声明和初始化">指针变量的声明和初始化</h3><h4 id="间接引用">间接引用</h4><p>指针变量存储的是内存的地址，间接引用一个值。</p><h4 id="指针的声明">指针的声明</h4><p>指针的声明如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type *countptr，count    <span class="comment">//type指的是类型，说明countptr是一个指向类型为type的指针，而count是一个类型为type的变量</span></span><br></pre></td></tr></table></figure><p>注意每一个指针变量名前面都必须有前缀的星号，建议每个声明只声明一个变量。</p><h4 id="指针的初始化">指针的初始化</h4><p>应该初始化为nullptr，或者为一个相应类型的地址。nullptr指的是空指针。</p><h3 id="指针运算符">指针运算符</h3><h4 id="地址运算符">地址运算符&amp;</h4><p>&amp;是一个一元运算符，它获得操作数的内存地址。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *yPtr=<span class="literal">nullptr</span>;</span><br><span class="line">yPtr=&amp;<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>这样，yPtr将获得y的地址，yPtr间接引用变量y的值。</p><p>注意这里与引用变量声明中的&amp;用法不同，后者的前面总是有一个type，在声明一个引用时，&amp;是变量的一部分。</p><h4 id="间接运算符">间接运算符*</h4><p>又称为间接引用运算符，返回的当前指针指向的变量。借助上例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;*yPtr&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>两者的显示结果都是5。</p><p>也可以在赋值时使用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*yPtr=<span class="number">9</span>;</span><br><span class="line">cin&gt;&gt;*yPtr;</span><br></pre></td></tr></table></figure><p>这将把输入的值存放到y中。</p><p>注意不要间接引用一个未初始化的指针，否则可能会产生严重后果（不小心修改重要的数据），也不要间接引用一个空指针。</p><h3 id="使用指针的按引用传递方式">使用指针的按引用传递方式</h3><p>指针也可以像引用传递一样，将指向大型数据的对象的指针传递给函数，减少值传递对象所需要的开销。</p><p>注意：传递的是指向这个变量的指针（以值传递的方式，被复制到了函数对应的指针形参中），然后被调用的函数就可以通过间接引用这个指针来访问这个变量，从而完成了按引用传递。</p><h3 id="内置数组">内置数组</h3><h4 id="声明内置数组">声明内置数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type name [size]</span><br><span class="line"><span class="comment">//类型 数组名 [数组大小]</span></span><br></pre></td></tr></table></figure><h4 id="访问内置数组的元素">访问内置数组的元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用[]来访问内置数组中的单个元素</span><br><span class="line">int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">cout&lt;&lt;a[0]&lt;&lt;a[1];</span><br></pre></td></tr></table></figure><h4 id="初始化内置数组">初始化内置数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用初始化列表中的值初始化这些元素，若提供的初始化值数目少于元素的个数，则剩下的元素是有值的初始化</span></span><br><span class="line"><span class="comment">//bool:false</span></span><br><span class="line"><span class="comment">//指针：nullptr</span></span><br><span class="line"><span class="comment">//基本的数值类型：0</span></span><br><span class="line"><span class="comment">//类：根据默认构造函数初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的大小也可以忽略，前提是声明时有初始化列表</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//创建了包含5个元素的数组</span></span><br></pre></td></tr></table></figure><h4 id="将内置数组传递给函数">将内置数组传递给函数</h4><p>注意：内置数组的名字可以隐式地转换为这个内置数组第一个元素的内存地址。</p><p>若数组名为arrayName，则它可以隐式地转换为&amp;arrayName[0]。</p><p>所以将其传递到函数时，只需要将简单地传递其数组名即可，这样，函数就可以修改数组中的任意一个元素，除非在数组名前面加上const，表明这些元素不可以被修改。（这样可以防止在函数体中修改原始的内置数组）</p><h4 id="声明内置数组形参">声明内置数组形参</h4><p>格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> values[])</span></span></span><br></pre></td></tr></table></figure><p>这将表明这个数组不应该被这个函数修改。</p><p>还可以写成：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *values)</span></span></span><br></pre></td></tr></table></figure><p>注意：编译器是无法区分接受一个指针的函数和接受一个内置数组的函数，因为当编译器遇到const int values[]的一维内置数组的函数形参时，它将转换为指针表示形式的const int *values。</p><p>这两种形式是可以互换的，但建议：当实参是一个内置数组时，还是使用[]。</p><h4 id="C-11：标准库函数begin和end">C++11：标准库函数begin和end</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>这表明a的整个数组都应该被排序（vector类或者array类）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(<span class="built_in">begin</span>(n),<span class="built_in">end</span>(n));</span><br></pre></td></tr></table></figure><p>也可以对内置数组进行排序，注意n是内置数组名。</p><h4 id="内置数组的局限性">内置数组的局限性</h4><p>1、无法使用关系运算符和相等运算符进行比较</p><p>2、不能相互赋值</p><p>3、不知道自己的大小</p><p>4、不提供自动边界检查的功能，可能会越界。</p><p>所以推荐使用array和vector。</p><h3 id="使用const修饰指针">使用const修饰指针</h3><p>考虑一个情况，打印一个数组，所以其中的元素和数组的大小不应该改变。</p><p>注意内置数组很容易按引用的方式被传递，很容易在被调函数中被修改，所以需要const关键字修饰。</p><p>建议：</p><p>1、如果一个值在它被传递到的函数中没有（或不应该）改变，那么这个参数应该被声明为从const。</p><p>2、在使用一个函数前，确定哪些值需要被修改，哪些值则不需要。</p><p>将指针传递给函数的方式有4种：</p><p>1、指向非const数据的非const指针</p><p>2、指向const数据的非const指针</p><p>3、指向非const数据的const指针</p><p>4、指向const数据的const指针</p><h4 id="指向非const数据的非const指针">指向非const数据的非const指针</h4><p>访问权限最高，可以通过指针间接修改数据，也可以修改指针，使其指向其他数据。</p><p>声明一般为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type *ptr;</span><br></pre></td></tr></table></figure><h4 id="指向const数据的非const指针">指向const数据的非const指针</h4><p>可以被修改以指向任何适当类型的其他数据项，但是不能通过该指针来修改它所指向的数据</p><p>声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr</span><br></pre></td></tr></table></figure><p>其实很好理解，const修饰的是int，所以它不能修改它所指向的数据。</p><p>当一个函数被调用时，其实参为内置数组，则实参的内容将被有效地按引用传递给函数。当传递的是指向对象的指针时，只会复制对象的地址，然而对象本身并没有被复制。</p><p>建议：</p><p>1、如果大型对象不需要在被调用函数中修改，则使用指向const数据的指针或者const数据的引用来传递它们，避免按值传递的复制开销</p><p>2、使用指向const数据的指针或者const数据的引用来传递大型对象，可以获得按值传递的安全性</p><p>3、应该采用按值传递的方式向函数传递基本类型的实参（如int、double等），除非调用者明确要求被调函数可以直接修改调用者中的值</p><h4 id="指向非const数据的const指针">指向非const数据的const指针</h4><p>它始终指向同一个内存位置，通过该指针可以修改这个位置上的数据。</p><p>注意：声明为const的指针必须在它们被声明时被初始化，但如果这样的指针是函数的形参，那么就可以用传递给函数的指针来初始化它</p><p>声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr</span><br></pre></td></tr></table></figure><p>const修饰的是*</p><h4 id="指向const数据的const指针">指向const数据的const指针</h4><p>它具有最小的访问权限：总是指向内存中的相同位置，并且不能用指针修改这个内存位置的数据。</p><p>建议：如果一个内置数组作为实参，并且该实参只是作为可读，那么就应该使用该类型的指针。</p><h3 id="sizeof运算符">sizeof运算符</h3><p>可以用于在编译期间确定内置数组或者其他任意数据类型、变量或者常量的字节大小。</p><p>当用于一个内置数组时，将返回该内置数组的字节大小，返回值是size_t类型。</p><p>注意：在一个函数中，使用sizeof关键字来获得一个内置数组形参的字节数，结果会得到一个指针的字节数，而不是该内置数组的字节数</p><p>可以使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> numbers/<span class="built_in">sizeof</span>(numbers[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>来获得一个内置数组的元素个数。</p><h4 id="确定基本类型、内置数组和指针字节大小">确定基本类型、内置数组和指针字节大小</h4><p>使用sizeof运算符，可以计算用于大部分标准数据类型的字节数。</p><p>sizeof运算符可以用于任何表达式或者任何类型名。</p><p>当sizeof用于一个变量名时（不是一个内置数组时）或其他表达式时，返回的用于存储该表达式的特定类型的字节数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有在类型名作为sizeof的操作数时，才需要使用圆括号</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当操作数是表达式时，则不用圆括号</span></span><br><span class="line"><span class="type">int</span> a</span><br><span class="line"><span class="keyword">sizeof</span> a</span><br></pre></td></tr></table></figure><p>注意，sizeof是一个编译时的运算符，不会对操作数进行求值，其所得的值是一个size_t类型的常量表达式。</p><p>建议：在不同的系统中，用来存储一个特定数据类型的字节数可能不同，如果编写的程序依赖于数据类型的字节大小，则需要总是使用sizeof来确定存储数据类型所需要的字节数。</p><h3 id="指针表达式和指针算术运算">指针表达式和指针算术运算</h3><p>指针算术运算只适用于指向内置数组元素的指针。</p><p>一个指针可以++、–、+=（+）一个整数、-=(-)一个整数、或者一个指针可以减去另外一个同类型指针（注意只适用于指向同一内置数组元素的两个指针）。</p><p>注意：指针算术运算的结果取决于指针所指向的对象的大小，所以指针算术运算是与机器有关的。</p><p>以下两种写法是等效的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *vPtr=v;</span><br><span class="line"><span class="type">int</span> *vPtr=&amp;v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="指针加上与减去整数">指针加上与减去整数</h4><p>当指针加上或者减去一个整数时，它是加上或者减去这个整数与该指针指向对象的字节大小的乘积，字节数取决于对象的数据类型。</p><p>如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *vPtr=&amp;v[<span class="number">0</span>];</span><br><span class="line">vPtr+=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>此时vPtr指针指向的是v[2]。</p><p>假设vPtr原本指向的v[0]的内存地址为3000，因为一个int数据占据4字节内存，所以vPtr现在指向的地址为3008，也就是v[2]的地址。</p><p>如果vPtr增加到了3016，则指向的是v[4]。</p><p>也可以进行回退，只需要vPtr-=4即可，此时指针指向的是v[0]，也就是这个数组的开始地址。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vPtr-=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>如果指针+1或者-1，则可以使用自增或者自减运算符。++指向下一个元素，–指向前一个元素。</p><p>注意：指针的算术运算符是没有边界检查功能的，所以必须确保在指针指向的元素在内置数组的范围内。</p><h4 id="指针相减">指针相减</h4><p>指向同一个内置数组的指针变量可以相减，如：</p><p>vPtr包含地址3000(v[0])，vPtr2包含地址3008(v[2])，则：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x=vPtr2-vPtr;</span><br></pre></td></tr></table></figure><p>恰好对应的就是这段区间内有几个元素（注意是v[0]、v[1]）。</p><p>指针算术运算只有在指向内置数组的指针上进行时才有意义，否则这是一个逻辑错误。</p><h4 id="指针赋值">指针赋值</h4><p>两个指针为同一类型时，则可以将一个指针赋值给另外一个指针，否则必须使用强制类型转换（通常是reinterpret_cast），这将把赋值运算符右侧的指针值转换为左侧的指针类型。</p><p>但是存在例外，即void指针（void*）,这是一种通用指针，可以表示任何类型的指针。</p><p>任何指向基本类型或者类类型的指针都可以被赋值给void*类型的指针，而不需要强制类型转换。</p><p>但是，void*类型的指针是不能直接赋值给其他类型的指针的，必须先把void * 类型的指针强制转换为合适的指针类型。</p><h4 id="不能间接引用void-指针">不能间接引用void*指针</h4><p>因为void指针只是一个包含未知数据类型的内存地址，编译器不知道该指针所指向的确切字节数和数据类型（编译器必须知道这两个才能正常编译，否则无法确定特定指针的数据类型，对于void指针来说，无法确定字节数），所以会报错。</p><p>注意：将一个类型的指针赋值给另外一个类型的指针时，需要将前者强制类型转换。</p><p>对于void*指针的合法操如下：</p><p>1、将void*指针与其他指针进行比较。</p><p>2、将void*指针强制类型转换为其他类型的指针和将地址赋值给void *指针。</p><p>除上述外，其他均是非法操作。</p><h4 id="指针比较">指针比较</h4><p>可以使用相等和关系运算符进行比较。</p><p>只有在指针指向同一数组的元素时，使用关系运算符才是有意义的。</p><p>指针比较的是存储在内存中的地址。在一个数组中，指向内置数组中下表编号大一些的元素的指针比指向内置数组中下表编号小一些的元素的指针大。</p><p>一个常用的指针比较是判定其是否为0、nullptr或者NULL。</p><h3 id="指针和内置数组的关系">指针和内置数组的关系</h3><p>用以下的声明进行介绍：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *bPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两者是等价的</span></span><br><span class="line">bPtr=b;</span><br><span class="line">bPtr=&amp;b[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="指针-偏移量表示法">指针/偏移量表示法</h4><p>b[i]可等价表示为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(b+i);</span><br></pre></td></tr></table></figure><p>这里的i指的是偏移量，联系前面的指针加法、减法运算可以很好理解，注意*优先级大于+，所以需要加上圆括号。</p><p>当然，&amp;b[i]也可以写成</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b+i;</span><br></pre></td></tr></table></figure><h4 id="以内置数组名作为指针的指针-偏移量表示法">以内置数组名作为指针的指针/偏移量表示法</h4><p>其实本质跟上面是一样的，这里我们就直接用数组名即可，因为数组名就是执行数组首元素的指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(b+i)</span><br></pre></td></tr></table></figure><p>等价于b[i]。</p><h4 id="指针-下标表示法">指针/下标表示法</h4><p>和内置数组一样，指针也可以带下标，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bPtr[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这和b[1]是等价的。</p><h4 id="内置数组名不可以修改">内置数组名不可以修改</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b+=<span class="number">3</span>；</span><br></pre></td></tr></table></figure><p>上述是一个非法操作，试图用算术运算来修该内置数组名的值。</p><p>这也说明，数组名是一个指向非const数据的const指针。</p><p>建议：使用内置数组表示法，不要使用指针表示法。</p><h3 id="基于指针的字符串">基于指针的字符串</h3><h4 id="字符与字符常量">字符与字符常量</h4><p>字符是C++源程序的基本构建块。</p><p>一个字符常量是一个整数，表示为用一对单引号引起来的一个字符。</p><h4 id="字符串">字符串</h4><p>一个字符串可以看作一个被视为整体的字符序列，包含字母、数字、特殊字符。</p><h4 id="基于指针的字符串-2">基于指针的字符串</h4><p>是一个以’\0’结尾的内置字符数组，'\0’标记了字符串在内存中结束的位置。</p><p>可以通过指向字符串第一个字符的指针来访问该字符串，对其进行sizeof运算得到的是包括空字符在内的这个字符串的长度。</p><p>数组名也是指向该内置数组第一个元素的指针。</p><h4 id="字符串文字作为初始化值">字符串文字作为初始化值</h4><p>以下两者等效：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> color[]=<span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *colorPtr=<span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意两者都包含以’\0’作为结尾。</p><p>注意字符串文字是static存储类别的，在程序执行时一致存在，可以被共享，也可以不被共享。</p><p>建议：如果要修改字符串文字的内容，先将它存储到一个内置数组中。</p><h4 id="字符常量作为初始化值">字符常量作为初始化值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> color[]=&#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这是初始化列表的形式，编译器会根据初始化列表中的初始化值的个数，来决定上述内置数组的大小。</p><p>建议：</p><p>1、需要分配好足够的空间，来存储结束字符串的空字符。</p><p>2、要时刻记得包含结束的空字符。</p><h4 id="访问C字符串的字符">访问C字符串的字符</h4><p>可以使用内置数组的下标表示法直接访问字符串中单个的字符。</p><h4 id="使用cin读取字符串到char类型的内置数据中">使用cin读取字符串到char类型的内置数据中</h4><p>可以使用cin通过流提取读取一个字符串到一个内置字符数组中，例子如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;word</span><br></pre></td></tr></table></figure><p>这将读取一个字符串到名为word的内置字符数组中，该数组有20个元素。</p><p>用户输入的字符串存储到word中，直到遇到空白字符或者文件结束符为止，注意，该字符数组的长度不能超过19个字符，以便为结束空字符流出空间。</p><p>可以使用setw流操纵符来保证不超过读入word的字符串不会超过内置字符数组的长度</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;<span class="built_in">setw</span>(<span class="number">20</span>)&gt;&gt;word;</span><br></pre></td></tr></table></figure><p>这样将指定最多只有19个字符到word中，留下一个用于存储结束空字符。</p><p>注意setw只作用于下一个要输入的值，如果输入多了，那么剩下的字符不会被存储到word中。</p><h4 id="使用cin-getline-读取文本行到char类型的内置数据中">使用cin.getline()读取文本行到char类型的内置数据中</h4><p>getline（）函数有三个参数：一个存储该行文本的内置字符数组，一个长度，一个定界字符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> sentence[<span class="number">80</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(sentence,<span class="number">80</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这将读取一行文本到内置数组中。</p><p>当遇到定界字符’\n’，或者输入了文件结束符，或者已经读入的字符数比长度参数小1时，函数将停止读取。</p><p>第三个参数的默认值时’\n’，并且内置数组的最后一个字符是留给结束空字符的，如果遇到定界字符，则会读取并丢弃它（这个时候将会结束继续输入字符到内置数组中，不管是否继续输入字符串）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">50</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(a,<span class="number">50</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="number">12345678</span> \\ <span class="number">666</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h4 id="显示字符串">显示字符串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;sentence;</span><br><span class="line"><span class="comment">//这样即可直接输出</span></span><br></pre></td></tr></table></figure><p>cout不关心字符数组的大小，直到遇到终止符为止，空字符不会输出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Way to Practice Competitive Programming</title>
      <link href="/2024/04/03/A%20Way%20to%20Practice%20Competitive%20Programming/"/>
      <url>/2024/04/03/A%20Way%20to%20Practice%20Competitive%20Programming/</url>
      
        <content type="html"><![CDATA[<h1 id="一种程序设计竞赛的训练方法（译）">一种程序设计竞赛的训练方法（译）</h1><p>文章转载自：<a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html">一种程序设计竞赛的训练方法（译） - wawcac - 博客园 (cnblogs.com)</a>，如有侵权，请联系作者删除。</p><hr><p><a href="https://codeforces.com/blog/entry/66909">原文</a></p><p>[PDF]([<a href="https://drive.google.com/file/d/1J2x8pIYQ3MXANgvzOgBciWd3d79j_Exa/view">Tutorial] A Way to Practice Competitive Programming.pdf - Google 云端硬盘</a>)</p><blockquote><p>Rating从1000到2400+</p><p>2019年5月7日</p><p>Masataka Yoneda/E869120</p></blockquote><p>目录</p><ul><li><ol><li>自我介绍</li></ol><ul><li><a href="http://codeforces.com/">2-1. Codeforces </a></li><li><a href="https://atcoder.jp/">2-2. AtCoder </a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#2-3-topcoder">2-3. TopCoder</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#2-4-%E8%BF%99%E9%83%A8%E5%88%86%E7%9A%84%E6%80%BB%E7%BB%93">2-4. 这部分的总结</a></li></ul></li><li><ol start="3"><li>训练方法介绍</li></ol><ul><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-1-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-10001400">3-1. 训练技巧 rating 1000~1400</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-2-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-14001900">3-2. 训练技巧 rating 1400~1900</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-3-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-19002200">3-3. 训练技巧 rating 1900~2200</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-4-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-22002400">3-4. 训练技巧 rating 2200~2400</a></li></ul></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#4%E8%AE%AD%E7%BB%83%E5%BF%83%E7%90%86">4.训练心理</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#5-%E8%99%9A%E6%8B%9F%E8%B5%9B%E6%8E%A8%E8%8D%90">5. 虚拟赛推荐</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#6-%E6%9C%AA%E6%9D%A5%E6%84%BF%E6%99%AF">6. 未来愿景</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#7-%E6%80%BB%E7%BB%93">7. 总结</a></p></li></ul><h2 id="1-自我介绍">1. 自我介绍</h2><p>亲爱的CF社区：</p><p>2019年4月20日，在14场比赛后，我终于达到了grandmaster，rating 2426。在最后一场比赛之前，我很遗憾rating是2399，距离成为粉名只差1分。所以上一场比赛(Forethought Future Cup Elimination Round) 是我印象最深的比赛之一。感谢CF举办这些比赛，感谢友善、出色且给人留下深刻印象的CF社区接受我的博客。</p><p>如今，我也想给CF社区做一点贡献，因为我之前在CF社区收获了很多，心里十分感激。我思考了很长时间“如何给CF做贡献”，或者说以一种合适的方式给CF做贡献。我想到了：介绍一种从灰名到粉名的练习方法。</p><p>现在，我要解释如何成为一个红名大佬。</p><p>2017年7月，我写了一篇博客解释如何到紫名<a href="http://codeforces.com/blog/entry/53341">紫名秘籍</a> 。凭借这篇博客，我得到了181个赞，但那里面有很多语法错误，而且还有几个地方没有解释清楚。我很抱歉自己不擅长英语，也不是一个很好的作者。这次的博客可能还是有一些错误，但我努力使它更易读易懂。感谢你的合作、陪伴。</p><p>这次，我要分几个步骤进行讲解，因为rating范围有好几个，大部分人并不能一步就从灰名到达粉名，我也不能。所以这次我要分成下面的四个步骤：</p><ul><li>Rating 1000→1400，从灰名到青名</li><li>Rating 1400→1900，从青名到前10%的选手</li><li>Rating 1900→2200，从前10%选手到表现优异的Div1选手</li><li>Rating 2200→2400，从表现优异的Div1选手到粉名</li></ul><p>另外，在解释如何练习之前，因为CF用户很多，其中一些并不知道其他的OJ，所以我想介绍一下其他的在线比赛网站（AtCoder、TopCoder等）。</p><p>还有，很高兴你们阅读我的博客。非常感谢CF。</p><p>永田正彦</p><p>## 2. 常识介绍——一些打比赛的网站</p><p>世界上有很多OJ。为了成为粉名，我切了很多OJ上的很多题目。这次，为了 explain the post sections，我想先介绍一些比赛。</p><h3 id="2-1-Codeforces">2-1. <a href="http://codeforces.com/">Codeforces</a></h3><p>Codeforces是世界上最有名的OJ之一，目前有五千多题。</p><p>利用CF的最好方式之一是“题目Rating”。例如，1146H Satanic Panic 的Rating是2800，这意味着，如果你的rating大于等于2800，那么你应该<strong>在比赛中</strong>切掉这个题。</p><p>另外，CF分成三个部分（Div1、Div2、Div3）。</p><p>再往后，我会使用下面两种简称：</p><ul><li>Div1A, Div2E等等：代表Div1的A题、Div2的E题。通常，第一题是最简单的，最后一题是最难的。</li><li>难度R2800什么的：“难度R2800”代表这题难度被标成2800。例如，1146G Zoning Restriction 难度R2600，1146A Love &quot;A&quot;难度R600。</li></ul><h3 id="2-2-AtCoder">2-2. <a href="https://atcoder.jp/">AtCoder</a></h3><p>AtCoder是一个“拥有很多好题”的比赛网站。这只是个人意见，但如果你想变强，就要刷AtCoder。</p><p>AtCoder有三种类型的比赛：</p><ul><li>AtCoder Beginner Contest (ABC) : 有4道题。<ul><li>ABC难度一般为R500-R700-R900-R1400。</li></ul></li><li>AtCoder Regular Contest (ARC) : 有4道题。通常ARC的前两题和ABC的后两题是相同的。<ul><li>ARC难度一般为R900-R1400-R2100-R2600，因比赛而异。</li></ul></li><li>AtCoder Grand Contest (AGC) : 有6道题。<ul><li>AGC难度一般是 R1200- R1900- R2200- R2500-R3000-R3300</li></ul></li></ul><p>还有个很方便的网站——<a href="https://kenkoooo.com/atcoder#/table//">AtCoder problems</a>。</p><p>在这个网站，你可以看到自己AtCoder的切题列表，知道自己哪些题还没做，哪些题做了。AC的被标成绿色，尝试过但没AC的被标成黄色。</p><h3 id="2-3-TopCoder">2-3. TopCoder</h3><p>TopCoder也是一个著名的比赛网站。Single Round Match (SRM) 有两个部分：</p><ul><li>Division 2：有三道题，R600-R1300-R2100，被称为Div2简单、Div2中等、Div2困难。</li><li>Division 1：有三道题，R1800-R2400-R3000，被称为Div1简单、Div1中等、Div1困难。</li></ul><p>我为了到粉名，也用TopCoder训练。尽管主要是数学题，但都是好题（我尤其喜欢SRM600-699）。</p><h3 id="2-4-这部分的总结">2-4. 这部分的总结</h3><p>我主要用3个OJ训练：Codeforces、AtCoder、TopCoder。如果你了解了这3个OJ，就可以去阅读下一个部分了。在这些比赛网站训练是很重要也很有效的，而且我觉得这是最快的进步方式。</p><hr><p>在第3部分，我会写很多要点，但都只是我的个人观点，不信任我也是可以的。很多人遵循我的方法，取得了很大的进步，但也有很多人没遵循我的方法依然取得很大进步。用我的方法训练是挺好，但不一定对所有人都有效。</p><hr><h2 id="3-训练方法介绍">3. 训练方法介绍</h2><p>可能有很多人读过我上一篇教程博客，但现在和两年前不一样了。这两年我有很多遗憾。很多事情我没做，但我在想，如果我做了，是不是可以进步更快？因此，这篇博客和我之前那篇有很多不同之处。</p><p><strong>此外，在rating到达2200前和到达2200后，我的训练方式完全不同。</strong></p><p>还有一件事，这篇博客只是我的个人观点，训练方法因人而异，所以我认为你不一定按照我的方法训练。但我觉得我的方法对一些人来说是最有效的。</p><p>如果你理解了这一点，就可以继续往下读了。进入正题……3、2、1，走起！</p><h3 id="3-1-训练技巧-rating-1000-1400">3-1. 训练技巧 rating 1000~1400</h3><p>CF上有很多灰名、绿名，他们很想成为青名、蓝名，但依然在苦苦挣扎中。</p><p>尽管如此，到达青名（1400）只需要做到三点。</p><ul><li>能够快速写出模拟题（5到10分钟内）</li><li>能够快速写出暴力（5到10分钟内）</li><li>能够在脑子里或草稿纸上把问题分情况讨论（例如，N=2、N=3、N&gt;=4）</li></ul><p>举个例子，在Codeforces Round #556中，如果你可以做到以上三点，就可以很惊喜地在Div2中达到200名，这是一个很夸张的例子。但在Codeforces Round #554 (Div. 2)中，你只能达到3400名，rating1250及以下的参赛者可以上分。</p><p>平均来说，如果你可以做到以上三点，rating就可以达到1400。</p><p><strong>[[如何训练]]</strong></p><p>首先，我建议你打ABC。</p><p>尽管CF上有很多好题，但如果你想更容易地练习编程，最好去刷AtCoder。</p><p>特别地，我推荐做ABC中的B题和C题。做B题可以学到如何更快地写模拟和暴力，做C题可以学到如何想题、如何用草稿纸更快地想出解决方案。</p><p>从ABC 042开始，出题人加入了英文题面。目前最新的一场是ABC 125，所以共有84场可做的ABC。如果你切了所有的B题和C题，就会学到很多，变得更强。</p><p>可以借助<a href="https://kenkoooo.com/atcoder#/table//">AtCoder problems</a>的帮助刷AtCoder，你能从这个网站知道自己做了哪些题。</p><p>当你刷AtCoder时，有几点很重要：</p><ul><li>当你想不出解决方案时，应该在思考B题15分钟、思考C题30分钟后再看题解。可悲的是，最近几场ABC没有英文题解，但你可以读标程（题解中很可能包含标程的链接）。</li><li>即使你AC了某道题，在习惯快速写代码前，还是可以通过阅读大佬的源代码学到一些东西。所以我建议看一些简单的源代码。</li><li>特别是当你做C题时，我推荐你用草稿纸辅助思考。不用纸的话，用白板打草稿也可以。</li></ul><p>我是高中一个计算机社团的社长，有很多社员用这样的方法获得了进步。</p><h3 id="3-2-训练技巧-rating-1400-1900">3-2. 训练技巧 rating 1400~1900</h3><p>CF上人数最多的rating区间是[1400, 1500]。他们都很想上分，但从1500开始上分比较困难，很多人放弃了。但也有很多人坚持训练，成功上分。</p><p>要达到1900，需要下面的技巧：</p><ul><li><p>掌握并能够使用以下主要算法：</p><ul><li>暴力</li><li>动态规划</li><li>深度优先搜索</li><li>广度优先搜索</li><li>迪杰斯特拉</li><li>树状数组</li><li>排列数、组合数</li><li>乘法逆元</li><li>位掩码</li><li>二分查找</li></ul><p>注意：我认为在rating 1800前，线段树不是必须的。我上紫以后才学的线段树。</p></li><li><p>提高手速（例如，R1100的题目5分钟写好，R1400的题目10分钟写好）。手速在CF很重要，因为一般来说，如果题目难度范围很大，手速会在很大程度上影响rating。</p></li></ul><p><strong>[[如何训练]]</strong></p><p>**如果你不擅长快速写代码、快速调试，**就应该刷AtCoder。事实上，从统计学上讲，很多日本选手手速很快，但不擅长解决难题，我觉得是AtCoder的锅。</p><p>我推荐做ABC的C题和D题。<strong>平均来说</strong>，如果能在10分钟内解决C题，在20分钟内解决D题，你就是手速场中的Div1 😃</p><p><strong>如果你不擅长解难度高于R1400的题</strong>，就应该学一些上面提到的算法，做做CF上的板题。举个例子，如果你觉得自己不擅长DP，就刷CF上R1200到R1400的DP标签的题。让人惊讶的是，只有约50道难度小于等于R1400的DP标签的题。</p><p>有趣的是，板题都集中在只有Div2的那些比赛中。如果你不擅长只有Div2的比赛，那么很可能是你不擅长使用典型算法，尤其是上面提到的10种算法。</p><p><strong>如果你能做板题，但不擅长做难度高于R1500的题</strong>，就要开始在TopCoder刷题。这类练习对擅长只有Div2的比赛但不擅长Div1+Div2一体的、分开的比赛的人十分有效。</p><p>有时候，尤其是在Div1+Div2的比赛中，一些题目需要数学概念或者思考。因为TopCoder上有很多题用到这些（另外还有简便的实现！），所以你应该刷TopCoder。</p><p>我推荐刷最近100场SRM的Div1简单。但有些题真的太难了（甚至粉名都切不掉），所以刷之前，你应该看一下题目的通过率。你可以利用<a href="https://competitiveprogramming.info/">奇怪的插件？</a>来获取一些信息。</p><p>不幸的是，我不知道有没有像AtCoder Problems那样，能够看自己在TopCoder SRM中做过哪些题的网站。所以，如果你想记录自己刷过那些题，应该做一个电子表格或者表格。</p><p>当我还是个蓝名时，数学思维也很糟糕。在切了50题Div1简单以后，我在TopCoder成了蓝名，在CF成了紫名。</p><p><strong>如果你擅长切题，但在比赛中发挥不好</strong>，就应该多打虚拟赛。你知道CF的虚拟赛系统吗？你可以虚拟参赛！</p><h3 id="3-3-训练技巧-rating-1900-2200">3-3. 训练技巧 rating 1900~2200</h3><p>如果你想达到2200，首先，你应该是Div1，并且参加Div1的比赛。这意味着你应该刷很多难题（R1900或更高）。</p><p>即使你手速快或者十分擅长切板题，打Div1比赛也是很难的。可悲的是，有很多选手在蓝名和紫名之间摇摆</p><p>要达到2200，需要以下技巧：</p><ul><li>知道并且会用上面提到的10种算法，还要加个线段树（包括懒标记）</li><li>非常快的手速：R1100 5分钟，R1500 10分钟，R1800 15分钟，R2000 40分钟。</li><li>相当好的数学思维和思考问题的能力。</li><li>强大的思维，可以支持超过1小时的思考，即使在Div1比赛中途落后了也不放弃。</li></ul><p><strong>[[如何训练]]</strong></p><p>这只是我的训练方式：在rating2000时打了很多虚拟比赛。在这里，虚拟比赛并不意味着“虚拟参与”，而是选择4到5道难度在自己rating附近的题目（举个例子，目前rating是2000，那么选择CF中R2000的题目），并且在2小时内切掉。</p><p>你可以利用<a href="https://vjudge.net/">vjudge</a>。在这个网站，你可以从很多OJ上（AtCoder、CF、Hackerrank、Codechef、POJ……）拉题组一场虚拟赛。</p><p>如果你在虚拟赛中不能切掉这些题，而且没有想出解决方案，就应该去谷歌查题解（举个例子，如果你想找Codeforces Round #556 (Div. 1)的题解，就去谷歌搜“Codeforces Round #556 editorial”）。</p><p>在CF上分还有一件重要的事。为了更快的手速，你应该准备一些板子。例如，我认为线段树板子、懒标记线段树板子、CRT的板子、FFT的板子、计算几何板子等等都是很有效的。</p><h3 id="3-4-训练技巧-rating-2200-2400">3-4. 训练技巧 rating 2200~2400</h3><p>这是本博客关于训练技巧的最后一部分。事实上，我卡在橙名很久了，就连在虚拟赛中，我的平均表现也是橙名。这是因为我之前的训练方法在橙名遇到了障碍。</p><p>Rating 2200到2400事实上非常难——如果你平均表现2200，如果你练习赛打得更多，上粉（到2400）看上去也没那么难。但是平均表现2400比你想象的要难得多。如果你的rating正好是2400，那么在Div1的比赛上，你一般要打进前20%（例如，如果有525人参加，那么你应该最差在105名）才能上分。</p><p>要达到2400，需要以下技巧：</p><ul><li>Rating达到2200</li><li>在Div1比赛中切掉AC少于100人的<strong>难题</strong></li></ul><p>如果你想切难题和用ad-hoc临时方法的题，根据TozanSoutherPacks在我上一篇博客下的评论<a href="http://codeforces.com/blog/entry/53341?#comment-373965">大佬的文章</a>，“要达到2600分乃至更高，你应该切Boss题，所有这些都是临时问题或者步骤很多的问题。”我觉得那是对的，但是对我来说，我觉得即使你只想达到2400分，切步骤很多的临时问题也是有必要的。</p><p><strong>[[如何训练]]</strong></p><p>达到2400分最安全的方法是“切4000道题”。我就在TopCoder、AtCoder、CF和一些日本OJ上切了超过4000题。</p><p>事实上，有一个传说（或者说是事实）是，最NB的选手tourist在他这辈子切了一万多题。</p><p>但是可能很多人觉得自己没时间。所以我会给你一些更高效的途径。</p><p>首先，AtCoder上有很多教育题。我推荐你做<strong>ARC尤其是ARC058到ARC090</strong>的E题和F题（尤其是AtCoder中700到900点的题目）。尽管以前的ARC在“思维”和“模板”之间是平衡的，但可悲的是，我认为AGC和最近的ARC实际上太偏向思维了，所以如果你的目标是在CF上分，我不推荐它们（尽管如果你想达到2600乃至更高，还是要刷AGC）。</p><p>对我来说，实际上，刷了ARC以后，我在CF虚拟赛的平均表现从2100提高到了2300（I could not reach 2400 because start was early）。</p><p>如果你切不动题，我推荐你放弃思考并且看题解的时间如下：</p><table><thead><tr><th>AtCoder点值</th><th>CF难度</th><th>思考时间</th></tr></thead><tbody><tr><td>600</td><td>R2000</td><td>40分钟</td></tr><tr><td>700</td><td>R2200</td><td>50分钟</td></tr><tr><td>800</td><td>R2400</td><td>60分钟</td></tr><tr><td>900</td><td>R2600</td><td>70分钟</td></tr><tr><td>1000</td><td>R2800</td><td>80分钟</td></tr></tbody></table><p>如果你切了AtCoder上的教育题，你编程比赛的技能将会有所提高。但还有另一个问题，没有付诸实践，你没办法上分。</p><p>所以，你应该至少在CF上打50场虚拟赛（尤其是Div1）。在虚拟赛中，你可以学到，紫名、橙名应该如何打比赛（比如比赛策略），以及如何在CF比赛中利用在AtCoder学到的技巧。<strong>我强烈推荐在虚拟赛后看看所有题的题解，除了太难的题</strong>（比如在比赛中AC人数少于30的题）。我还建议，在打完比赛看完题解后在笔记本上写一些对于比赛策略、教训和可以改进的地方的反思。</p><p>此外，我建议你每周一次，花点时间思考一些难题（比如CF上R2800的题）。如果你想了很久也想不出来，我建议你去读题解，因为那样你可以学到很多。解决难题可能会给你一场上分100+的机会，也会给你更快解决简单题的机会。</p><p>最后，我猜这个方法对于超过30%的人奏效，因为我用这个方法在CF上粉，我的孪生兄弟square1001用这个方法在TopCoder上红。希望我的方法可以产生新的粉名:)</p><h2 id="4-训练心理">4.训练心理</h2><p>心理问题是选手中最常见的问题之一。即使对我，直到最近两个月前，出于对一场掉分100+的恐惧，我超过9个月没打过CF上rated的比赛。另外，还有几场比赛我甚至都做不到看下一个题，因为我做不出来更简单的题，心态崩了。</p><p>我最近发现一种锻炼心态的办法。</p><ul><li>制定一个比赛前的常规程序。这能让我们在比赛期间集中注意力。<ul><li>事实上，就我而言，我的常规程序是在比赛快开始时看着倒计时减少到0。黑红大佬yutaka1999实际上在IOI开始前就在修禅。</li></ul></li><li>如果你比赛中没发挥好（比如20分钟内切不掉B题），不去看榜也是个好主意。</li><li>还有一件重要的事：“比赛过程中不要管rating”。<ul><li>我觉得，即使这场要掉分，下一场上分的可能性也提高了。这就是为什么我在比赛过程中不管rating。</li></ul></li><li>不要过于在意之前犯过的错误。错误也是一次好的学习机会，每个人都会犯错。即使是tourist也曾经在AtCoder World Tour Finals上翻车。<ul><li>我觉得吧，“rating”和“你犯过多少错、做过多少<strong>反思</strong>”之间存在关联。</li></ul></li></ul><p>以上这些方法不仅在正式比赛中适用，还在虚拟赛中适用。注意：比赛中不要有太大的压力，开心就好！</p><h2 id="5-虚拟赛推荐">5. 虚拟赛推荐</h2><p>在写关于虚拟赛的建议之前，我认为虚拟赛有以下两种类型：</p><ul><li>虚拟参与：选择一场比赛，就像真实参赛那样做题。和CF的虚拟赛系统一样。</li><li>虚拟比赛：使用VJ或者其他的评测系统。从CF上挑几题难度在自己rating附近的题，并在2到3小时内解决它们。</li></ul><p>首先，以上这两种方式我都推荐。</p><p>对于虚拟参与，我觉得你可以学到比赛策略、心态和其他一些比赛技巧。对于虚拟比赛，我觉得你可以集中精力卡一道题，因此解题、复习效率会得到提高。</p><p>这就是为什么当我在刷CF上的难题时，总是用VJ进行虚拟比赛。</p><p>如果你想在AtCoder打虚拟赛，用<a href="https://not-522.appspot.com/%EF%BC%88%E9%81%97%E6%86%BE%E7%9A%84%E6%98%AF%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E6%98%AF%E6%97%A5%E6%96%87%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E6%98%AF%E6%97%A5%E6%9C%AC%E4%BA%BA%EF%BC%8C%E5%8F%AA%E5%A5%BD%E5%A7%94%E5%B1%88%E4%BD%A0%E7%94%A8%E4%B8%80%E4%B8%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91%E4%BA%86%E3%80%82%E3%80%82%E3%80%82%EF%BC%89%E3%80%82%EF%BC%88%E7%8E%B0%E5%9C%A8%E5%B7%B2%E7%BB%8F%E4%B8%8D%E7%94%A8%E4%BA%86%EF%BC%8C%E5%AE%98%E6%96%B9%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BE%9B%E4%BA%86vp%EF%BC%89">https://not-522.appspot.com/（遗憾的是这个网站是日文的，如果你不是日本人，只好委屈你用一下谷歌翻译了。。。）。（现在已经不用了，官方已经提供了vp）</a></p><h2 id="6-未来愿景">6. 未来愿景</h2><p>幸运的是，在2019年4月29日，我CF的rating达到了2585，非常接近红名了。我很高兴，也真的很感激CF管理员和CF社区。</p><p>我实际上已经定下了未来的目标：黑红！</p><p>实际上，我最近在CF打了很多比赛或者虚拟赛。我在CF上最近10场比赛的表现是： 2865, 2661, 3029, 2890, 2858, 2875, 2318, 2717, 2506, 2891（平均2761.0）。</p><p>所以，我大概还差250分到达黑红。我为了实现梦想正在做的努力如下：</p><p><strong>[[如何训练]]</strong></p><ul><li>几乎每天都打2到3小时虚拟赛。赛后看题解、看黑红大佬的代码，写一个小时反思。</li><li>有时候（大约一周一次）从CF上选大概5题左右（难度从R2200到R2800），在2到4小时内解决。</li><li>即使打比赛三年了，我还是觉得有很多黑科技（实际上和算法板子不同）是我不知道的。所以比赛中如果有超过20人做出来的题目我没做出来，我就会去看题解。<ul><li>我觉得，如果我能在比赛中把几乎所有20个AC以上的题目做出来，早就是黑红了。</li></ul></li></ul><h2 id="7-总结">7. 总结</h2><p>这就是我要给CF社区说的所有训练方法。真心感谢你的阅读。</p><p>我使用CF很久了，也在社区中得到了成长。所以，我想我应该给CF社区做点什么贡献。做贡献有很多方式，我选择讲述在CF上分的实用技巧。我认为这是给CF做有实际意义贡献的最好方式之一。</p><p>最后，我建议一步步用一定的训练方法提高你打比赛的能力。但是训练方法因人而异，我不觉得我的方法总是最高效的，同样，我也不认为你必须按照的我方法训练。</p><p>但我觉得，这对某些人来说是最高效的方法。希望这篇博客有用，即使只有一小点儿。</p><p>因为我只是日本的一个高二学生，文中可能有很多语法错误，我英语也确实不好。我必须表示歉意，但相反，我必须感谢读者。谢谢你的阅读。</p><p>最后，祝你好运，祝你在CF上分，祝你在程序设计竞赛玩得开心。这就是我这篇博客的总结。再次感谢。</p><p>​                                                                                                                                                                                                                        永田正彦</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plan</title>
      <link href="/2024/04/02/Plan/"/>
      <url>/2024/04/02/Plan/</url>
      
        <content type="html"><![CDATA[<h1 id="学习计划">学习计划</h1><p>上了大学，发现怎么比高三过得还<s>出生</s>。</p><hr><p>感觉得列个计划，不然越学状态越糟糕。</p><h2 id="学业">学业</h2><h3 id="1、工分">1、工分</h3><p>2023-04-02</p><p>目前来说没什么问题，领先进度。希望能一直保持</p><h3 id="2、概率论">2、概率论</h3><p>2024-04-02</p><p>也没啥问题，希望4月底能学完。</p><h3 id="3、学术英语">3、学术英语</h3><p>不能像上学期那样开摆了，不然绩点就蹭蹭往下掉了。</p><p>两次PBL要认真搞，而且上课的小作文也要认真写，争取回答两三问题吧（一直懒又社恐，不敢上去)。</p><p>期末的英语考试至少要提前一周背答案咯，注意笔试和听力都得背。（听力具体是哪一部分？）</p><p>还有六级考试，不然大二就更没时间了。</p><h3 id="4、大物实验">4、大物实验</h3><p>一学分，但是还要认真准备，老师要求有点高。</p><h3 id="5、军事理论">5、军事理论</h3><p>记得一直挂网课，不知道有没有线下期末考试。</p><h3 id="6、大学物理">6、大学物理</h3><p>目前落后两章，赶紧补。（4学分的重点课）</p><p>期末考试重点看往年试卷（神中神）。</p><h3 id="7、中国文学与文化">7、中国文学与文化</h3><p>还差期末考试（但是没有答案！！！）</p><h3 id="8、思想道德与法制">8、思想道德与法制</h3><p>还是要重视，毕竟是2.5学分。</p><h3 id="9、数字逻辑">9、数字逻辑</h3><p>不知道到底有没有算入绩点，目前赶上进度，难度还行，感觉重点还是放在期末复习月。</p><h3 id="10、C">10、C++</h3><p>大Boss压轴登场。</p><p>接下来还有两个实验，一个实训。</p><p>实验三已经基本完成了，实验四还没动，感觉实验四慢慢写得花一周。</p><p>实训才是最难熬的，感觉自己的设计思路还是很混乱，打算看看相关的书籍。</p><p>打算搞可视化，接下来还得学习Qt，任务艰巨。</p><h2 id="课外">课外</h2><p>其实要是不打ACM，时间也许绰绰有余？</p><p>可惜没有如果。</p><p>从去年10月份正式开始学算法，到现在已经过去半年多了，虽然有进步，但是缓慢。。。</p><p>感觉自己也走了很多弯路，虽然学习了很多算法，但是都没有好好消化吸收，不知道怎么用（情况现在有些改观）。</p><p>还是得多多答题，多多思考，少看题解，下面附上几篇学习思路：</p><p>[A Way to Practice Competitive Programming | Heavenhold](<a href="https://www.heavenhold.cn/2024/04/03/A">https://www.heavenhold.cn/2024/04/03/A</a> Way to Practice Competitive Programming/)</p><p>以后在慢慢补充训练题单，先睡觉了。</p><hr><p>校赛告一段落，打得很糟糕，第一次打这种三人合作的比赛。</p><p>接下来先集中精力专注课内吧，这周的PBL，还有C++实训，大学物理，概率论等等。</p><p>感觉不能说按照之前的专注于某一方向了，必须都得会，CF得早日上绿了（好久没打实时赛了，应该问题不大）。</p><p>实训只是在黑框框中实现了原理，当前的重要任务还是得先学好图形化，不然就没办法继续进展。</p>]]></content>
      
      
      <categories>
          
          <category> Plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诸子百家</title>
      <link href="/2024/04/02/%E8%AF%B8%E5%AD%90%E7%99%BE%E5%AE%B6/"/>
      <url>/2024/04/02/%E8%AF%B8%E5%AD%90%E7%99%BE%E5%AE%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="诸子百家">诸子百家</h1><p>受某位大佬启发，打算整理一份算法的<s>百科全书</s>。</p><p>来源千奇百怪：包括个人博客，知乎文章，CSDN等等。</p><h2 id="杂项">杂项</h2><p>洛谷日报：<a href="https://www.luogu.com.cn/discuss/755848">2024 年洛谷日报索引创建</a></p><h2 id="大佬的博客">大佬的博客</h2><p>DPCC：<a href="https://www.totorocatcat.top/2024/03/31/WhatToDo/">What To Do | Totoro の旅 (totorocatcat.top)</a></p><p>秋钧：<a href="https://www.zhihu.com/column/c_1668286831920697344">算法学习笔记 - 知乎 (zhihu.com)</a></p><p>Pecco：<a href="https://www.zhihu.com/column/c_1182444932760125440">算法学习笔记 - 知乎 (zhihu.com)</a></p><p>严格鸽：<a href="https://www.zhihu.com/column/c_1548406061400498176">数据结构学习笔记 - 知乎 (zhihu.com)</a></p><p>hzwer：<a href="http://hzwer.com/">hzwer-blog</a></p><p>天才少女 珈百璃：<a href="https://www.zhihu.com/column/c_1447314601347649536">珈百璃的算法学习笔记</a></p><p>Matrix67: The Aha Moments：<a href="http://www.matrix67.com/blog/">某位大佬前辈的博客</a>;</p><p>K8he：<a href="https://www.cnblogs.com/K8He">K8he-blog</a></p><p>朝夕：<a href="https://zhuanlan.zhihu.com/p/112564411">【朝夕的ACM笔记】目录与索引</a></p><p>bhbjzyh：<a href="https://www.zhihu.com/column/c_1695477369492799488">算法</a></p><p>凉笙：<a href="https://www.cnblogs.com/Liang-sheng">东风夜放花千树，更吹落，星如雨</a></p><p>菠萝头：<a href="https://www.zhihu.com/column/c_1191379407951208448">算法竞赛</a></p><p>子谦：<a href="https://www.cnblogs.com/hanruyun">子谦。愿得忘忧水千觞，尽饮却愁再轻狂</a></p><p>_Lancy：<a href="https://www.cnblogs.com/ifmyt">nonxiaobai</a></p><p>xishanmeigao：<a href="https://www.cnblogs.com/xishanmeigao">xishanmeigao：每个问题里都藏着一个机会。Inside of every problem lies an opportunity.</a></p><p>hqztrue：<a href="https://www.zhihu.com/column/interestingalgorithms">算法随笔</a></p><p>北纬：<a href="https://www.zhihu.com/column/c_1550926641895014400">算法板子：收录一些常用的板子</a></p><h2 id="数据结构">数据结构</h2><p><a href="https://zhuanlan.zhihu.com/p/656702623">HelenXYZ：线段树，从入门到入坑</a></p><p><a href="https://zhuanlan.zhihu.com/p/246255556">Pecco：算法学习笔记(49): 线段树的拓展</a></p><p><a href="https://zhuanlan.zhihu.com/p/250565583">Pecco：算法学习笔记(50): 可持久化线段树</a></p><p><a href="https://zhuanlan.zhihu.com/p/575513452">Pecco：算法学习笔记(88): 线段树合并</a></p><p><a href="https://zhuanlan.zhihu.com/p/650874844">秋钧：笛卡尔树</a></p><p><a href="https://zhuanlan.zhihu.com/p/664621324">江南西路转运使：算法杂记 | 珂朵莉树</a></p><p><a href="https://zhuanlan.zhihu.com/p/657693348">HelenXYZ：FHQtreap，从入门到入坑</a></p><p><a href="https://zhuanlan.zhihu.com/p/556896902">严格鸽：数据结构学习笔记(1) Splay树 （splay实现区间操作</a></p><p><a href="https://zhuanlan.zhihu.com/p/558263140">严格鸽：数据结构学习笔记(1.1) splay树实现区间移动</a></p><p><a href="https://www.luogu.com/article/xrx28e6s">Sweetlemon：朝花中学OI队的奋斗历程——浅谈单调队列</a></p><p><a href="https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/52825227">*ACoder*：单调队列优化的多重背包</a></p><p><a href="https://www.cnblogs.com/OIerShawnZhou">退役的Shawn Zhou的博客</a></p><h2 id="动态规划">动态规划</h2><p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/article/63y3zs3d">_Watcher：数位DP模板</a></p><p><a href="https://zhuanlan.zhihu.com/p/659651268">秋钧：斜率优化动态规划</a></p><p><a href="https://zhuanlan.zhihu.com/p/663944537">bhbjzyh：动态规划的各种常见优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/665082087">bhbjzyh：动态 DP 详讲</a></p><p><a href="https://web.archive.org/web/20111007185146/http://www.notonlysuccess.com/?p=931">NotOnlySuccess：【完全版】插头DP</a></p><p><a href="https://zhuanlan.zhihu.com/p/125145772">utobe：ACM动态规划总结</a></p><p><a href="https://www.luogu.com/article/vx7a76on">command_block：DP的决策单调性优化总结</a></p><h2 id="字符串">字符串</h2><p><a href="https://zhuanlan.zhihu.com/p/105629613">Pecco：算法学习笔记(13): KMP算法</a></p><p><a href="https://zhuanlan.zhihu.com/p/669489914">bhbjzyh：exKMP/Z 函数 学习笔记</a></p><p><a href="https://zhuanlan.zhihu.com/p/672592136">江南西路转运使：算法杂记 | AC自动机</a></p><p><a href="https://zhuanlan.zhihu.com/p/649662771">秋钧：后缀数组（SA）</a></p><p><a href="https://zhuanlan.zhihu.com/p/665086302">bhbjzyh：SAM 后缀自动机详讲</a></p><h2 id="图论">图论</h2><p><a href="https://zhuanlan.zhihu.com/p/651688492">秋钧：单源（全源）最短路及其应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/349530425">Pecco：算法学习笔记(69): 强连通分量</a></p><p><a href="https://zhuanlan.zhihu.com/p/660554775">秋钧：Tarjan 算法相关（超详细！！！）</a></p><p><a href="https://zhuanlan.zhihu.com/p/567569277">严格鸽：ACM教程之 Kruskal重构树</a></p><p><a href="https://zhuanlan.zhihu.com/p/96229700">Pecco：算法学习笔记(5)：匈牙利算法</a></p><p><a href="https://zhuanlan.zhihu.com/p/648735863">秋钧：网络最大流</a></p><p><a href="https://zhuanlan.zhihu.com/p/671008388">bhbjzyh：最小费用最大流</a></p><p><a href="https://zhuanlan.zhihu.com/p/42102528">Dispwnl：【洛谷日报#23】点分治略解</a></p><p><a href="https://zhuanlan.zhihu.com/p/50211772">后缀自动机·张：2-SAT</a></p><p><a href="https://www.zhihu.com/question/292283275/answer/484871888">如何看待SPFA已死这种说法？</a></p><p><a href="https://www.zhihu.com/question/268382638/answer/337778164">如何卡spfa？</a></p><h2 id="数学">数学</h2><p><a href="https://zhuanlan.zhihu.com/p/646535621">秋钧：整体二分</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581142.html">素数筛 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581101.html">乘法逆元 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581035.html">拓展欧几里得 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581137.html">龟速乘（防止爆long long）</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581097.html">拓展中国剩余定理 - Horb7 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/108422764">Pecco：算法学习笔记(18): 欧拉函数</a></p><p><a href="https://zhuanlan.zhihu.com/p/645333706">秋钧：数论入门</a></p><p><a href="https://zhuanlan.zhihu.com/p/682429893">秋钧：线性代数在OI中的基础应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/330669300">ShineEternal：数论小白都能看懂的数学期望讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/671870244">bhbjzyh：快速傅里叶变化（FFT）入门</a></p><p><a href="https://www.luogu.com.cn/article/dz62cu5t">ShineEternal：数论小白都能看懂的线性方程组及其解法</a></p><p><a href="https://www.luogu.com.cn/article/td3ah746">ShineEternal：数论小白都能看懂的平面凸包详解</a></p><h2 id="计算几何">计算几何</h2><p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com/article/a9lmcppw">辰星凌：计算几何全家桶</a></p><h2 id="技巧">技巧</h2><p><a href="https://zhuanlan.zhihu.com/p/33080292">CFhM-R：ACM比赛常用技巧</a><br>以后还会再添加，不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC062</title>
      <link href="/2024/03/27/ABC062/"/>
      <url>/2024/03/27/ABC062/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC062">ABC062</h1><blockquote><h1 id="ABC062A-Grouping">[ABC062A] Grouping</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题目描述"><strong>题目描述</strong></h3><h4 id="现在有两个序（如下图）">现在有两个序（如下图）</h4><p><img src="https://img2.imgtp.com/2024/03/27/YuR2EpRL.png" alt=""></p><h4 id="给你两个数，问你这两个数是不是在同一个序列里面的。">给你两个数，问你这两个数是不是在同一个序列里面的。</h4><h3 id="输入格式"><strong>输入格式</strong></h3><h4 id="一行，两个整数x-y-1≤x-y≤12-。">一行，两个整数x,y(1≤x,y≤12)。</h4><h3 id="输出格式"><strong>输出格式</strong></h3><p>一行如果x和y在同一个序列里，就输出Yes，否则输出No。</p><h3 id="输入样例1"><strong>输入样例1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><strong>输出样例1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2"><strong>输入样例2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><strong>输出样例2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题目描述-2">题目描述</h2><p>すぬけ君は、$ 1 $ から $ 12 $ までの整数を下図のようにグループ分けしました。 整数 $ x $, $ y $ ($ 1\ &lt;\ =\ x\ &lt;\ y\ &lt;\ =\ 12 $) が与えられるので、$ x $, $ y $ が同一のグループに属しているか判定してください。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc062_a/b9e356d3a5d032bf49839a35a0ca16b703d349f5.png" alt="b4ab979900ed647703389d4349eb84ee.png"></p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ x $ $ y $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ x $, $ y $ が同一のグループに属しているならば <code>Yes</code> を、そうでなければ <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ x $, $ y $ は整数である。</li><li>$ 1\ &lt;\ =\ x\ &lt;\ y\ &lt;\ =\ 12 $</li></ul></blockquote><h2 id="思路">思路</h2><p>有趣的事情，这些数对应的恰好是对应月份的天数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> b,c;</span><br><span class="line">    cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a[b<span class="number">-1</span>]==a[c<span class="number">-1</span>]) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;<span class="comment">//判断</span></span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//比赛时不可少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062B-Picture-Frame">[ABC062B] Picture Frame</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>给出一个长H，宽W的图像，用小写字母表示。第i行第j个字母是a(i,j)。</p><p>输出该图像最外层用一个’#'包围后的图像</p><h2 id="输入格式-3">输入格式</h2><p>输入将会按照以下格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H W</span><br><span class="line">a(1,1) ... a(1,W)</span><br><span class="line">...</span><br><span class="line">a(H,1) ... a(H,W)</span><br></pre></td></tr></table></figure><h2 id="输出格式-3">输出格式</h2><p>输出该图像最外层用一个’#'包围后的图像</p><h2 id="说明-提示">说明/提示</h2><p>1 $\le$ H,W $\le$ 100</p><p>a(i,j)是一个小写字母</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ ピクセル、横 $ W $ ピクセルの画像があります。 各ピクセルは英小文字で表されます。 上から $ i $ 番目、左から $ j $ 番目のピクセルは $ a_{ij} $ です。</p><p>この画像の周囲 $ 1 $ ピクセルを <code>#</code> で囲んだものを出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ a_{11} $ $ … $ $ a_{1W} $ $ : $ $ a_{H1} $ $ … $ $ a_{HW} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>画像の周囲 $ 1 $ ピクセルを <code>#</code> で囲んだものを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">abc</span><br><span class="line">arc</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####</span><br><span class="line">#abc#</span><br><span class="line">#arc#</span><br><span class="line">#####</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">z</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###</span><br><span class="line">#z#</span><br><span class="line">###</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ &lt;\ =\ H,\ W\ &lt;\ =\ 100 $</li><li>$ a_{ij} $ は英小文字である。</li></ul></blockquote><h2 id="思路-2">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> h,w;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062C-Chocolate-Bar">[ABC062C] Chocolate Bar</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个大小为 $H \times W$ 的矩形，由 $H \times W$ 个小矩形组成。</p><p>你需要将这个大矩形切成三个部分，要求只能沿着小矩形的边切且且出来的三个部分必须均为矩形。</p><p>请最小化切出来的三个矩形中最大矩形与最小矩形的差，并输出这个差值。</p><h2 id="题目描述-5">题目描述</h2><p>縦 $ H $ ブロック、横 $ W $ ブロックの板チョコがあります。 すぬけ君は、この板チョコをちょうど $ 3 $ つのピースに分割しようとしています。 ただし、各ピースはブロックの境目に沿った長方形でなければなりません。</p><p>すぬけ君は、$ 3 $ つのピースの面積 (ブロック数) をできるだけ均等にしようとしています。 具体的には、$ 3 $ つのピースの面積の最大値を $ S_{max} $、最小値を $ S_{min} $ としたとき、$ S_{max}\ -\ S_{min} $ を最小化しようとしています。 $ S_{max}\ -\ S_{min} $ の最小値を求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>$ S_{max}\ -\ S_{min} $ の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ &lt;\ =\ H,\ W\ &lt;\ =\ 10^5 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 5\ -\ 5\ =\ 0 $ となります。 ![2a9b2ef47b750c0b7ba3e865d4fb4203.png](<a href="https://atcoder.jp/img/arc074/2a9b2ef47b750c0b7ba3e865d4fb4203.png">https://atcoder.jp/img/arc074/2a9b2ef47b750c0b7ba3e865d4fb4203.png</a>)</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 8\ -\ 6\ =\ 2 $ となります。 ![a42aae7aaaadc4640ac5cdf88684d913.png](<a href="https://atcoder.jp/img/arc074/a42aae7aaaadc4640ac5cdf88684d913.png">https://atcoder.jp/img/arc074/a42aae7aaaadc4640ac5cdf88684d913.png</a>)</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 10\ -\ 6\ =\ 4 $ となります。 ![eb0ad0cb3185b7ae418e21c472ff7f26.png](<a href="https://atcoder.jp/img/arc074/eb0ad0cb3185b7ae418e21c472ff7f26.png">https://atcoder.jp/img/arc074/eb0ad0cb3185b7ae418e21c472ff7f26.png</a>)</p></blockquote><h2 id="思路-3">思路</h2><p>其实很好想：暴力枚举。先横切一刀，再竖切一刀。</p><p>可以先枚举横切的一块，再将剩下的一块一分为二，尽可能均分。</p><p>注意有两个横切的方向，并且要比较横切块与竖切块的大小关系。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll h,w;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特判，如果为三的倍数，直接为0</span></span><br><span class="line">    <span class="keyword">if</span>(h%<span class="number">3</span>==<span class="number">0</span>||w%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">1e15</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举横切，这是其中一个方向</span></span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">            cnt+=w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切能均分</span></span><br><span class="line">            <span class="keyword">if</span>((h*w-cnt)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>((h*w-cnt)/<span class="number">2</span>-cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切不能均分，需要选出最大最小</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll MAX=<span class="built_in">max</span>(cnt,(h*w-cnt+h-i)/<span class="number">2</span>);</span><br><span class="line">                ll MIN=<span class="built_in">min</span>(cnt,(h*w-cnt-h+i)/<span class="number">2</span>);</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,MAX-MIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        ll ans2=<span class="number">1e15</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//另外一个方向</span></span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=w;i++)&#123;</span><br><span class="line">            cnt+=h;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切能均分</span></span><br><span class="line">            <span class="keyword">if</span>((h*w-cnt)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans2=<span class="built_in">min</span>(ans2,<span class="built_in">abs</span>((h*w-cnt)/<span class="number">2</span>-cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切不能均分</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll MAX=<span class="built_in">max</span>(cnt,(h*w-cnt+w-i)/<span class="number">2</span>);</span><br><span class="line">                ll MIN=<span class="built_in">min</span>(cnt,(h*w-cnt-w+i)/<span class="number">2</span>);</span><br><span class="line">                ans2=<span class="built_in">min</span>(ans2,MAX-MIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(ans,ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062D-3N-Numbers">[ABC062D] 3N Numbers</h1><h2 id="题面翻译-4">题面翻译</h2><p>给一个长度为 $3N$ 的数组 $a=(a_1,a_2,…,a_n)$，要求删去其中 $N$ 个数使得剩余的 $2N$ 个数中前 $N$ 个数之和与后 $N$ 个数之和的差最大。</p><h2 id="题目描述-6">题目描述</h2><p>$ N $ を $ 1 $ 以上の整数とします。</p><p>長さ $ 3N $ の数列 $ a\ =\ (a_1,\ a_2,\ …,\ a_{3N}) $ があります。 すぬけ君は、$ a $ からちょうど $ N $ 個の要素を取り除き、残った $ 2N $ 個の要素を元の順序で並べ、長さ $ 2N $ の数列 $ a’ $ を作ろうとしています。 このとき、$ a’ $ のスコアを $ (a’\ の前半\ N\ 要素の総和)\ -\ (a’\ の後半\ N\ 要素の総和) $ と定義します。</p><p>$ a’ $ のスコアの最大値を求めてください。</p><h2 id="输入格式-6">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_{3N} $</p></blockquote><h2 id="输出格式-6">输出格式</h2><p>$ a’ $ のスコアの最大値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 4 1 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8 2 2 7 4 6 5 3 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ a_i $ は整数である。</li><li>$ 1\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 300 $ 点分のテストケースでは、$ N\ &lt;\ =\ 1,000 $ が成り立つ。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ a_2 $, $ a_6 $ を取り除くと、$ a’\ =\ (3,\ 4,\ 1,\ 5) $ となり、スコアは $ (3\ +\ 4)\ -\ (1\ +\ 5)\ =\ 1 $ となります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>例えば、$ a_1 $ を取り除くと、$ a’\ =\ (2,\ 3) $ となり、スコアは $ 2\ -\ 3\ =\ -1 $ となります。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>例えば、$ a_2 $, $ a_3 $, $ a_9 $ を取り除くと、$ a’\ =\ (8,\ 7,\ 4,\ 6,\ 5,\ 3) $ となり、スコアは $ (8\ +\ 7\ +\ 4)\ -\ (6\ +\ 5\ +\ 3)\ =\ 5 $ となります。</p></blockquote><h2 id="思路-4">思路</h2><p>一开始想的是单调队列？结果发现是优先队列</p><p>思路来自：[<a href="https://www.luogu.com.cn/article/zhsnt0hm">ABC062D] 3N Numbers - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>本体我们可以把整个数列划分成两部分，取第一部分（前一段）前$n$大的值，第二部分（后一段）前$n$小的值。这样对两段分别加和，然后将两端的和作差即可。</p><p>很容易想到枚举分界线，对分界线两边的数字分别取最大值，时间复杂度$O(n^2log\ n)$，不可取。</p><p>枚举分界线的操作没有二分的性质，二分也不可取。</p><p>那么如果我们能够与处理好每个分界线所对应的前后两短的最大最小值，那么问题就迎刃而解了。</p><p>很显而易见，我们可以维护一个优先队列，最大值即为整个优先队列里前$n$大的值，维护最小值亦然，便于处理完成了。</p><p>代码整体时间复杂度：$O(nlog\ n)$。</p><p>注意：<strong>不开 long long 见祖宗！</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],q[MAXN],p[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt;&gt;pq;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;n)sum-=pq.<span class="built_in">top</span>(),pq.<span class="built_in">pop</span>();</span><br><span class="line">        q[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ll&gt;qp;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">3</span>*n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        qp.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">while</span>(qp.<span class="built_in">size</span>()&gt;n)sum-=qp.<span class="built_in">top</span>(),qp.<span class="built_in">pop</span>();</span><br><span class="line">        p[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i&lt;=<span class="number">2</span>*n;i++)ans=<span class="built_in">max</span>(ans,q[i]-p[i+<span class="number">1</span>]);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC061</title>
      <link href="/2024/03/26/ABC061/"/>
      <url>/2024/03/26/ABC061/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC061">ABC061</h1><blockquote><h1 id="ABC061B-Counting-Roads">[ABC061B] Counting Roads</h1><h2 id="题面翻译">题面翻译</h2><p>题意简述：</p><p>有N个城市和M条道路。</p><p>第i条道路（1 &lt;= i &lt;= M）双向连接两个城市ai和bi（1 &lt;= ai，bi &lt;= N），</p><p>可能有多条道路连接同一对的两个城市。</p><p>对于每个城市，有多少条道路连接到它？</p><p>输入：N，M，每条道路的情况；</p><p>输出：连接到每个城市的道路条数。</p><p>样例输入：</p><p>4 3</p><p>1 2</p><p>2 3</p><p>1 4</p><p>样例输出：</p><p>2</p><p>2</p><p>1</p><p>1</p><p>样例解释：</p><p>共有4个城市，3条道路</p><p>1号——2号</p><p>2号——3号</p><p>1号——4号</p><p>有2条道路连接到1号，2条连接到2号，1条连接到3号，1条连接到4号。</p><p>注意：</p><p>所有道路都是双向的。</p><h2 id="题目描述">题目描述</h2><p>$ N $ 個の都市があり、$ M $ 本の道路があります。<br>$ i(1≦i≦M) $ 番目の道路は、都市 $ a_i $ と 都市 $ b_i $ $ (1≦a_i,b_i≦N) $ を双方向に結んでいます。<br>同じ $ 2 $ つの都市を結ぶ道路は、$ 1 $ 本とは限りません。<br>各都市から他の都市に向けて、何本の道路が伸びているか求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ : $ $ a_M $ $ b_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを $ N $ 行に出力せよ。<br>$ i(1≦i≦N) $ 行目には、都市 $ i $ から他の都市に向けて、何本の道路が伸びているかを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 8</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br><span class="line">2 8</span><br><span class="line">3 7</span><br><span class="line">5 2</span><br><span class="line">4 1</span><br><span class="line">6 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2≦N,M≦50 $</li><li>$ 1≦a_i,b_i≦N $</li><li>$ a_i\ ≠\ b_i $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>- 都市 $ 1 $ からは $ 1 $ 番目と $ 3 $ 番目の道路が伸びています。 - 都市 $ 2 $ からは $ 1 $ 番目と $ 2 $ 番目の道路が伸びています。 - 都市 $ 3 $ からは $ 2 $ 番目の道路が伸びています。 - 都市 $ 4 $ からは $ 3 $ 番目の道路が伸びています。</p></blockquote><h2 id="思路">思路</h2><p>直接用邻接表模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> edge[<span class="number">55</span>][<span class="number">55</span>],ans[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a][b]++;</span><br><span class="line">        edge[b][a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ans[i]+=edge[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC061C-Big-Array">[ABC061C] Big Array</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目翻译">题目翻译</h2><h3 id="题目描述-2">题目描述</h3><p>有一个数组S，一开始是空的。接下来对这个数组进行N次插入操作.<br>第ii次操作会向数组中加入$b_i$<br>个整数$a_i$<br>，然后将整个数组从小到大排一次序。<br>求N次操作后, 数组中的第K个数。<br>例如S={1,2,2,3,3,3}时, 从小到大排序后第4个数是3。</p><h3 id="输入格式-2">输入格式</h3><p>第1行, 包含两个整数N,K用空格分隔.</p><p>第2行到第N+1行, 每行包含两个整数<br>$a_i$,$b_i$</p><h3 id="输出格式-2">输出格式</h3><p>输出N次操作后集合中第K小的数.</p><h3 id="说明-提示">说明/提示</h3><h4 id="数据范围">数据范围</h4><ul><li><pre><code>1≦N≦$10^5$ </code></pre></li><li><pre><code>1≦$a_i$ ,$b_i$ ≦$10^5$ </code></pre></li><li><pre><code>1≦K≦$b_1$+...+$b_n$</code></pre></li><li><pre><code>所有输入值都是整数。</code></pre></li></ul><hr><p>题目翻译者UID：370640</p><h2 id="题目描述-3">题目描述</h2><p>空の配列が $ 1 $ つあります。<br>この配列に、整数を配列に挿入する操作を $ N $ 回行います。<br>$ i(1≦i≦N) $ 回目の操作では、配列に整数 $ a_i $ を $ b_i $ 個挿入します。<br>$ N $ 回の挿入操作後の配列の中で、$ K $ 番目に小さい数を求めてください。<br>例えば、配列が $ {1,2,2,3,3,3} $ の時、$ 4 $ 番目に小さい数は $ 3 $ となります。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ a_1 $ $ b_1 $ $ : $ $ a_N $ $ b_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ N $ 回の挿入操作後の配列の中で、$ K $ 番目に小さい数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 500000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ 1≦a_i,b_i≦10^5 $</li><li>$ 1≦K≦b_1…+…b_n $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>操作後の配列は、問題文に書かれている例と同じです。</p></blockquote><h2 id="思路-2">思路</h2><p>不开long long见祖宗。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;x[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i].a&gt;&gt;x[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+n,cmp);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cnt+=x[i].b;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">            cout&lt;&lt;x[i].a;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC061D-Score-Attack">[ABC061D] Score Attack</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个有 $n$ 个点和 $m$ 条边的简单有向图。其中第 $i$ 条边从点 $a_i$ 连向点 $b_i$ ，且具有权值 $c_i$。</p><p>我们在图上进行以下游戏。一开始，一个棋子被放置在点 $1$ 。玩家可以进行如下操作：</p><ul><li>当棋子位于点 $a_i$ 时，可以通过边 $i$ 将棋子移动到点 $b_i$ ，且让分数增加 $c_i$。</li></ul><p>当棋子位于点 $n$ 时，玩家可以选择让游戏结束。假设玩家一直按最优策略操作，求出游戏结束后可以增加分数的最大值。如果分数可以无限增加，输出 <code>inf</code> 。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 頂点 $ M $ 辺の重み付き有向グラフがあります。<br>$ i(1≦i≦M) $ 番目の辺は 頂点 $ a_i $ から 頂点 $ b_i $ を重み $ c_i $ で結びます。<br>このグラフと駒を利用して、次の1人ゲームを行います。</p><p>最初、駒を頂点 $ 1 $ に置いて、プレイヤーのスコアを $ 0 $ とします。<br>プレイヤーは、次の条件で駒を繰り返し移動させることができます。</p><ul><li>頂点 $ a_i $ に駒があるとき、$ i $ 番目の辺を利用して頂点 $ b_i $ に移動する。移動後にプレイヤーのスコアが $ c_i $ 加算される。</li></ul><p>頂点 $ N $ に駒があるときのみ、ゲームを終了できます。<br>なお、与えられる有向グラフの上で頂点 $ 1 $ から頂点 $ N $ に移動できることは保障されています。</p><p>プレイヤーがゲーム終了時のスコアを出来るだけ大きくするような行動を取ったとき、ゲーム終了時のスコアはいくつになるでしょうか?<br>ゲーム終了時のスコアをいくらでも大きくできる場合は <code>inf</code> と出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_M $ $ b_M $ $ c_M $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>もし、ゲーム終了時のスコアをいくらでも大きくできる場合は <code>inf</code>、そうでない場合はゲーム終了時のスコアの最大値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 1</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inf</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">1 2 -1000000000</span><br><span class="line">2 3 -1000000000</span><br><span class="line">3 4 -1000000000</span><br><span class="line">4 5 -1000000000</span><br><span class="line">5 6 -1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-5000000000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦N≦1000 $</li><li>$ 1≦M≦min(N(N-1),2000) $</li><li>$ 1≦a_i,b_i≦N\ (1≦i≦M) $</li><li>$ a_i≠b_i\ (1≦i≦M) $</li><li>$ a_i≠a_j $ または $ b_i≠b_j\ (1≦i\ &lt;\ j≦M) $</li><li>$ -10^9≦c_i≦10^9\ (1≦i≦M) $</li><li>$ c_i $ は整数である。</li><li>与えられるグラフには、頂点 $ 1 $ から頂点 $ N $ への経路が存在する。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>駒を頂点 $ N=3 $ に移動できる経路は以下の $ 2 $ 通りです。 - 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 3 $ : スコア $ 4+3=7 $ - 頂点 $ 1 $ → 頂点 $ 3 $ : スコア $ 5 $ したがって、ゲーム終了時のスコアの最大値は $ 7 $ となります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ … と移動することで、ゲーム終了時のスコアをいくらでも増やせます。</p></blockquote><h2 id="思路-3">思路</h2><p>思路参考自：<a href="https://www.luogu.com.cn/article/3u32mbew">题解 ABC 061 D - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>很显然，题目让我们找最长路或者找正环</p><p>可以边权转负，所以就变成了找最短路+找负环。用SPFA即可。</p><p>然后你会发现 WA 了，我们的思路好像并没有问题，再读一遍题：</p><blockquote><p>If it is possible to increase the score indefinitely, print <code>inf</code>.</p><p>如果分数可以无限增加，输出 <code>inf</code> 。</p></blockquote><p>分数无限增加一定是有正环，但有正环分数就一定会无限增加么？</p><p>如果有一个正环，但从$1$到$n$的路径上并不会经过，那么他对答案是没有影响的，</p><p>所以开始时说的“找正环”是不对的，应该是 <strong>找最长路径上是否经过正环</strong>，</p><p>这样我们只需要判断$n$是否在正环上就可以了。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//思路：找最长路径、判断是否成环</span></span><br><span class="line"><span class="comment">//然后边权转负就成了最短路+找负环，用SPFA跑一遍即可</span></span><br><span class="line"><span class="comment">//分数无限增加一定是有正环，但有正环分数就一定会无限增加么？</span></span><br><span class="line"><span class="comment">//如果有一个正环，但从1到n的路径上并不会经过，那么他对答案是没有影响的</span></span><br><span class="line">ll dis[MAXN],vis[MAXN],inq[MAXN],cnt[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to,val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to,val&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)dis[i]=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge[u])&#123;</span><br><span class="line">            <span class="type">int</span> to=e.to;</span><br><span class="line">            <span class="keyword">if</span>(inq[to])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[u]+e.val)&#123;</span><br><span class="line">                dis[to]=dis[u]+e.val;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//这个我已经忘了</span></span><br><span class="line">                    <span class="keyword">if</span>(++cnt[to]&gt;=n)&#123;</span><br><span class="line">                        inq[to]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inq[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;inf\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;-dis[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC060</title>
      <link href="/2024/03/26/ABC060/"/>
      <url>/2024/03/26/ABC060/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC060">ABC060</h1><blockquote><h1 id="ABC060B-Choose-Integers">[ABC060B] Choose Integers</h1><h2 id="题面翻译">题面翻译</h2><p>问在A的倍数里有没有除B余C的，如果有输出&quot;YES&quot;(双引号不输出)，否则输出&quot;NO&quot;(双引号不输出)</p><h2 id="题目描述">题目描述</h2><p>あなたは、正の整数をいくつか選び、それらの総和を求めます。</p><p>選ぶ数の上限や、選ぶ整数の個数に制限はありません。 どんなに大きな整数を選んでもよいですし、整数を $ 5000 $ 兆個選んでもよいです。 ただし、選ぶ数はすべて $ A $ の倍数でなくてはいけません。 また、少なくとも $ 1 $ つは整数を選ばなくてはいけません。</p><p>そして総和を $ B $ で割ったあまりが $ C $ となるようにしたいです。 こうなるように整数を選ぶことが出来るか判定してください。</p><p>出来るならば <code>YES</code>、そうでないならば <code>NO</code> を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $</p></blockquote><h2 id="输出格式">输出格式</h2><p><code>YES</code> か <code>NO</code> を出力する。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 100 97</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40 98 58</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">77 42 36</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ A\ ≦\ 100 $</li><li>$ 1\ ≦\ B\ ≦\ 100 $</li><li>$ 0\ ≦\ C $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>たとえば $ 7,\ 14 $ を選ぶと総和は $ 21 $ となり、これを $ 5 $ で割ったあまりは $ 1 $ となります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>偶数をいくつ足したとしても、けっして奇数になることはありません。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>$ 1 $ の倍数、つまりすべての整数が選べるので、$ 97 $ を選べば良いです。</p></blockquote><h2 id="思路">思路</h2><p>比较常见的解法就是从1开始枚举，直到b。因为$a*(b+k)\ mod\ b=0$一定成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//万能头文件可好 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//主函数 </span></span><br><span class="line"><span class="type">int</span> a,b,c;<span class="comment">//定义 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//输入 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;<span class="comment">//开始循环判断，前文有解释 </span></span><br><span class="line"><span class="keyword">if</span>((a*i)%b==c)&#123;<span class="comment">//若符合题意 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);<span class="comment">//输出，换行是个好习惯 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//提前结束程序 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="comment">//如果一直没有符合题意的倍速，则输出NO </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//over~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种比较有趣的解法（来自：<a href="https://www.luogu.com.cn/article/t62zzh3p">题解 AT2554 【Choose Integers】 - 洛谷专栏 (luogu.com.cn)</a>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int x , int y)&#123;//最大公约数函数</span><br><span class="line">while(x % y)&#123;//更相减损法进阶：辗转相除法</span><br><span class="line">int r = x % y;//取余</span><br><span class="line">x = y;</span><br><span class="line">y = r;//迭代</span><br><span class="line">&#125;</span><br><span class="line">return y;//最大公约数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">int a , b , c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;//被除数，除数，余数</span><br><span class="line"></span><br><span class="line">if(c % gcd(a , b) == 0)&#123;//这条式子下面会给出证明</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="证明">证明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//证明：</span></span><br><span class="line"><span class="comment">//原题可表示为 </span></span><br><span class="line"><span class="comment">//k * a - p * b = c</span></span><br><span class="line"><span class="comment">//原式 = gcd(a , b) * [k * a / gcd(a , b) - p * b / gcd(a , b)]</span></span><br><span class="line"><span class="comment">//因为 k , p为任意整数</span></span><br><span class="line"><span class="comment">//所以 [k * a / gcd(a , b) - p * b / gcd(a , b)] 可以取任意整数值</span></span><br><span class="line"><span class="comment">//所以当 c 能整除 gcd(a , b)时 , 可以满足题目条件</span></span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC060C-Sentou">[ABC060C] Sentou</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>在一个公共澡堂里，有一个淋浴器。在按下开关时，淋浴器将会开始运作，在 $T$ 秒内一直流出热水。</p><p>如果你在淋浴器运作的情况下时按下开关，水就会从当前时间开始继续运作 $T$ 秒，而不是让淋浴器多运作 $T$ 秒。</p><p>在这个淋浴间前，有 $N$ 个人按下开关。第 $i$ 个人在第 $1$ 个人按下开关后的第 $t_i$ 个秒按下开关。请求出淋浴器运作的总时间。</p><h2 id="输入格式-2">输入格式</h2><p>第一行两个整数 $N$ 和 $T$，分别表示人数和淋浴器连续工作时间。</p><p>第二行共 $N$ 个整数，第 $i$ 个整数代表 $t_i$，含义见题目描述。</p><h2 id="输出格式-2">输出格式</h2><p>一行一个整数，淋浴器运作的总时间。</p><h2 id="数据范围">数据范围</h2><ul><li>$ 1\ \leq\ N\ \leq\ 200,000 $</li><li>$ 1\ \leq\ T\ \leq\ 10^9 $</li><li>$ 0\ =\ t_1\ &lt;\ t_2\ &lt;\ t_3\ &lt;\ ,\ …,\ &lt;\ t_{N-1}\ &lt;\ t_N\ \leq\ 10^9 $</li><li>$ T $ 和 $ t_i $ 都是整数。</li></ul><h2 id="题目描述-3">题目描述</h2><p>とある銭湯には、スイッチを押すと $ T $ 秒間お湯が出るシャワーがあります。</p><p>なお、お湯が出ているときにスイッチを押すと、そのタイミングから $ T $ 秒間お湯が出つづけます。 お湯の出る時間が $ T $ 秒間延長されるわけではないことに注意してください。</p><p>このシャワーの前を、$ N $ 人の人がスイッチを押して通り過ぎていきます。 $ i $ 人目の人は、$ 1 $ 人目の人がスイッチを押した $ t_i $ 秒後にスイッチを押します。</p><p>お湯が出る時間の総和は何秒かを求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T $ $ t_1 $ $ t_2 $ … $ t_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>お湯が出る時間の総和を $ X $ 秒として、$ X $ を出力する。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">0 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1000000000</span><br><span class="line">0 1000 1000000 1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000000000</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-5-2">样例 #5</h2><h3 id="样例输入-5-2">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 10</span><br><span class="line">0 3 5 7 100 110 200 300 311</span><br></pre></td></tr></table></figure><h3 id="样例输出-5-2">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">67</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 200,000 $</li><li>$ 1\ ≦\ T\ ≦\ 10^9 $</li><li>$ 0\ =\ t_1\ &lt;\ t_2\ &lt;\ t_3\ &lt;\ ,\ …,\ &lt;\ t_{N-1}\ &lt;\ t_N\ ≦\ 10^9 $</li><li>$ T,\ t_i $ はすべて整数である</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1 $ 人目の人がスイッチを押し、お湯が $ 3 $ 秒出た後にもう一度スイッチが押され、$ 4 $ 秒間お湯が出続けます。 よって合計で $ 7 $ 秒間お湯が出ます。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>$ 1 $ 人目の人がスイッチを押して、お湯が出終わった $ 1 $ 秒後にもう一度スイッチが押されます。</p></blockquote><h2 id="思路-2">思路</h2><p>只要判断这段时间段内是否重合即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,t;cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    ll ans=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//重合了，更新加上差值</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]+t&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">            ans+=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有重合，加上t</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC060D-Simple-Knapsack">[ABC060D] Simple Knapsack</h1><h2 id="题面翻译-3">题面翻译</h2><p>你有 $N$ 个物品和容量为 $W$ 的背包，每个物品要么选要么不选,它们的体积为 $w_i$，价值为 $v_i$，求总体积至多为 $W$ 情况下能拿走物品价值的最大值。</p><p><strong>【数据范围】</strong></p><p>$1\le N \le 100$，$1\le W \le 10^9$，$1 \le w_i \le 10^9$<br>$w_1 \le w_i \le w_1+3 (i=2,3,\cdots N)$<br>$1 \le v_i \le 10^7$<br>$W,w_i,v_i$ 都是整数</p><p>翻译：<a href="https://www.luogu.org/space/show?uid=68706">So_what</a></p><h2 id="题目描述-4">题目描述</h2><p>あなたは $ N $ 個の物と、強度 $ W $ のバッグを持っています。 $ i $ 個目の物は、重さが $ w_i $ で価値が $ v_i $ です。</p><p>あなたは、物のうちいくつかを選び、バッグに入れます。 ただし、選んだ物の重さの和は $ W $ 以下でなくてはいけません。</p><p>あなたは、バッグに入れた物の価値の総和を最大化したいです。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ W $ $ w_1 $ $ v_1 $ $ w_2 $ $ v_2 $ : $ w_N $ $ v_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>価値の総和の最大値を出力する。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">2 1</span><br><span class="line">3 4</span><br><span class="line">4 10</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">2 1</span><br><span class="line">3 7</span><br><span class="line">4 10</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 10</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure><h2 id="样例-4-3">样例 #4</h2><h3 id="样例输入-4-3">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-3">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 100 $</li><li>$ 1\ ≦\ W\ ≦\ 10^9 $</li><li>$ 1\ ≦\ w_i\ ≦\ 10^9 $</li><li>すべての $ i\ =\ 2,3,…,N $ について、$ w_1\ ≦\ w_i\ ≦\ w_1\ +\ 3 $</li><li>$ 1\ ≦\ v_i\ ≦\ 10^7 $</li><li>$ W,\ w_i,\ v_i $ はすべて整数である</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ 1,\ 3 $ 個目の物を選ぶと良いです。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>$ 2,\ 4 $ 個目の物を選ぶと良いです。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>すべての物が選べます。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>$ 1 $ 個も物が選べません。</p></blockquote><h2 id="思路-3">思路</h2><p>一开始，一眼01背包，交上去RE了qwq。</p><p>仔细一看，才发现范围竟然是$10^9$,然后自己又眼瞎，没看到$w_1\leq w_i \leq w_1+3$~~~~。</p><p>所以看题解喽。</p><blockquote><h3 id="前言">前言</h3><p>为什么我现在才发现这道题洛谷里面有……</p><p><a href="https://www.luogu.com.cn/problem/AT2556">题目链接</a></p><p><strong>正解：01 背包</strong></p><p>一道比较简单的创新 01 背包。</p><hr><h3 id="正解">正解</h3><p>如果按照背包的板子做，那么一定会 TLE 和 MLE。那如何优化呢？</p><p>我们注意到数据范围里有一句十分特殊的话：</p><blockquote><p>对于每个$i=2,3,···n$，满足$W_1\leq W_i\leq W_1+3$</p></blockquote><p>那么我们完全可以把每个物品的重量以$W_1$为基准，转化为一个不超过3的数。这么可以极大地优化空间复杂度。</p><p>用$h$代表$W_1$的真实数字。</p><p>但是这样的话，我们就无法得知我们现在装的东西到底有没有超过背包的容量，因为我们并不知道我们选了多少个东西。所以$dp$数组还需要开一维代表选择物品的个数。</p><p>所以$dp_{i,j,k}$代表在前$i$个物品中选择$k$个物品，背包容量为$j$时的最大价值。</p><p>还需要注意一下循环的范围：</p><ul><li>$i：1-n$</li></ul><p>（这个不需要解释了吧……）</p><ul><li>$j:0-3*i$</li></ul><p>（因为物品的重量被处理过，当原来的$W_i=W_1$时这个物品的重量为0。所以最小的背包容量有可能是 00。物品最大的重量不超过3，有$i$个物品，所以最大可能容量为$3*i$。）</p><ul><li>$k:1-i$</li></ul><p>（选择的物品数量不能超过总数。因为后面求答案$ans$的初始值就为0已经包括了一个都不选的情况，所以不需要考虑不选物品的情况。）</p><p>最后求答案的时候需要枚举$dp_{n,i,j}$，注意只有$i+j*h\leq m$时背包才不超限，可以更新答案。</p><p>具体见代码。</p><h3 id="Code">Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b) <span class="comment">//卡常小技巧：用这个比库函数要快一些</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll n,m,ans,h,w[<span class="number">105</span>],v[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">305</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;h,&amp;v[<span class="number">1</span>]); <span class="comment">//h 代表 W1 的的重量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">w[i]-=h; <span class="comment">//以 W1 为基准转化每一件物品的重量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i;k++)&#123; <span class="comment">//选择的物品数量不能大于总数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>*i;j++)&#123; <span class="comment">//3*i 为被允许的最大容量</span></span><br><span class="line"><span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">dp[i][j][k]=dp[i<span class="number">-1</span>][j][k];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j][k]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k],dp[i<span class="number">-1</span>][j-w[i]][k<span class="number">-1</span>]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在合法的范围内寻找最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>*n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i+j*h&lt;=m)</span><br><span class="line">ans=<span class="built_in">max</span>(ans,dp[n][i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>再贴上另外一篇文章：<a href="https://www.luogu.com.cn/article/9a3g900f">题解AT_arc073_b - 洛谷专栏 (luogu.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC059</title>
      <link href="/2024/03/26/ABC059/"/>
      <url>/2024/03/26/ABC059/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC059">ABC059</h1><blockquote><h1 id="ABC059A-Three-letter-acronym">[ABC059A] Three-letter acronym</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个由小写英文字母组成的字符串，以大写字母的方式输出它们的首字母。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる $ 3 $ つの単語 $ s_1 $, $ s_2 $, $ s_3 $ が空白区切りで与えられるので、単語の先頭の文字をつなげ、大文字にした略語を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s_1 $ $ s_2 $ $ s_3 $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoder beginner contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resident register number</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RRN</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k nearest neighbor</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KNN</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async layered coding</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALC</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ s_1 $, $ s_2 $, $ s_3 $ は英小文字からなる。</li><li>$ 1\ ≦|s_i|≦\ 10\ (1≦i≦3) $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>atcoder</code> <code>beginner</code> <code>contest</code> の先頭の文字はそれぞれ<code>a</code> <code>b</code> <code>c</code>なので、<code>ABC</code>が答えになります。</p></blockquote><h2 id="思路">思路</h2><p>为什么会写这道题解？因为经常忘了ASCII码大小写字母转换差<strong>32</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[i][<span class="number">0</span>]&amp;&amp;s[i][<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)cout&lt;&lt;<span class="built_in">char</span>(s[i][<span class="number">0</span>]<span class="number">-32</span>);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;s[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059B-Comparison">[ABC059B] Comparison</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题目描述-2">题目描述</h3><p>给定两个正整数 $a, b$，比较他们的大小。</p><h3 id="输入格式-2">输入格式</h3><p>输入有两行，第一行为数 $a$，第二行为数 $b$。</p><h3 id="输出格式-2">输出格式</h3><p>如果 $a &gt; b$，输出 “GREATER”；如果 $a = b$，输出 “EQUAL”，如果 $a &lt; b$，输出 “LESS”。</p><h3 id="数据范围">数据范围</h3><p>$1 \le a, b \le 10^{100}$，保证 $a, b$ 均无前导零。</p><h2 id="题目描述-3">题目描述</h2><p>$ 2 $ つの正整数 $ A,\ B $ が与えられるので、その大小を比較してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ A\ &gt;\ B $ のとき<code>GREATER</code>、$ A\ &lt;\ B $ のとき<code>LESS</code>、$ A=B $ のとき<code>EQUAL</code>と出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">36</span><br><span class="line">24</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GREATER</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">850</span><br><span class="line">3777</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9720246</span><br><span class="line">22516266</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456789012345678901234567890</span><br><span class="line">234567890123456789012345678901</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦A,\ B\ ≦\ 10^{100} $</li><li>入力の $ A,\ B $ の先頭は<code>0</code>でない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 36\ &gt;\ 24 $ なので、答えは<code>GREATER</code>です。</p></blockquote><h2 id="思路-2">思路</h2><p>这题还WA了两次。</p><p>注意字符串比较的是字典序，所以得看长度是否相等。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//长度相等，比较字典序。</span></span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">length</span>()==b.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;b[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;GREATER&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b[i]&gt;a[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;LESS&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;EQUAL&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则直接比较字典序即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">length</span>()&gt;b.<span class="built_in">length</span>())cout&lt;&lt;<span class="string">&quot;GREATER&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;LESS&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059C-Sequence">[ABC059C] Sequence</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个长度为 $N$ 的序列 $A$，每次操作可以选择一个 $i$ 使得 $A_i$ 大小减 $1$ 或加 $1$。</p><p>记 $S_i = \sum\limits_{j = 1} ^ i A_j$，求最少的操作次数使得：</p><ul><li><p>$\forall i \in [1, n], S_i \ne 0$</p></li><li><p>$\forall i \in [1, n - 1], S_i \times S_{i + 1} &lt; 0$</p></li></ul><h2 id="题目描述-4">题目描述</h2><p>長さ $ N $ の数列があり、$ i $ 番目の数は $ a_i $ です。 あなたは $ 1 $ 回の操作でどれか $ 1 $ つの項の値を $ 1 $ だけ増やすか減らすことができます。</p><p>以下の条件を満たすために必要な操作回数の最小値を求めてください。</p><ul><li>すべての$ i\ (1≦i≦n) $ に対し、第 $ 1 $ 項から第 $ i $ 項までの和は $ 0 $ でない</li><li>すべての$ i\ (1≦i≦n-1) $ に対し、$ i $ 項までの和と $ i+1 $ 項までの和の符号が異なる</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ $ … $ $ a_n $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>必要な操作回数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 -3 1 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 -6 4 -5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-1 4 3 2 -5 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦\ n\ ≦\ 10^5 $</li><li>$ |a_i|\ ≦\ 10^9 $</li><li>$ a_i $ は整数</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>例えば、数列を $ 1,\ -2,\ 2,\ -2 $ に $ 4 $ 回の操作で変更することができます。この数列は $ 1,\ 2,\ 3,\ 4 $ 項までの和がそれぞれ $ 1,\ -1,\ 1,\ -1 $ であるため、条件を満たしています。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>はじめから条件を満たしています。</p></blockquote><h2 id="思路-3">思路</h2><p>不难想到，有两种情况：</p><p>1、$±±±······$</p><p>2、$-±±+······$</p><p>我们可以分别计算这两种情况，这里注意$±$号代表的分别是$+1、-1$。如果是其他数字，那么代价只会更大，这个不难想到（其实就是贪心）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN],sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先讨论+-+-的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接用sum即可，没必要开前缀和数组，否则还得维护，更麻烦</span></span><br><span class="line">        <span class="comment">//sum这里其实只维护了a_i与a_i-1之间的关系，下面也一样</span></span><br><span class="line">        sum+=a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//奇数位应该为+，但这里却是-</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>)&#123;</span><br><span class="line">            ans1-=sum<span class="number">-1</span>;</span><br><span class="line">            sum=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数位应该为-，这里却为+</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;sum&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            ans1+=sum+<span class="number">1</span>;</span><br><span class="line">            sum=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再讨论-+-+的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数位应该为+，这里却为-</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans2-=sum<span class="number">-1</span>;</span><br><span class="line">            sum=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//奇数位应该位-，这里却为+</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>)&#123;</span><br><span class="line">            ans2+=sum+<span class="number">1</span>;</span><br><span class="line">            sum=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选出两种方案中的最小情况</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059D-Alice-Brown">[ABC059D] Alice&amp;Brown</h1><h2 id="题面翻译-4">题面翻译</h2><p>大意：</p><p>现有两堆石子，Alice和Brown以此进行游戏，规则如下：</p><ul><li><p><code>Alice先手</code>，两方分别按照<code>回合制</code>取石子</p></li><li><p>每个人每回合可以任意从任一堆中取出<code>2的倍数个</code>石子（前提是该堆里有这么多石子），扔掉其中的一半，将另一半放入另一堆中。</p></li><li><p>当一方<code>无法进行取石子操作</code>时视作此方失败。</p></li></ul><p>现给出石子数量n,m$(0≤n,m≤10^{18})$，请你输出胜方名称(Alice|Brown)。</p><h2 id="题目描述-5">题目描述</h2><p>AliceとBrownはゲームをするのが好きです。今日は以下のゲームを思いつきました。</p><p>$ 2 $つの山があり、はじめに$ X,\ Y $個の石が置かれています。 AliceとBrownは毎ターン以下の操作を交互に行い、操作を行えなくなったプレイヤーは負けとなります。</p><ul><li>片方の山から $ 2i $ 個の石を取り、そのうち $ i $ 個の石を捨て、残りの $ i $ 個の石をもう片方の山に置く。ここで、整数 $ i\ (1≦i) $ の値は山に十分な個数の石がある範囲で自由に選ぶことができる。</li></ul><p>Aliceが先手で、二人とも最適にプレイすると仮定したとき、与えられた $ X,\ Y $ に対しどちらのプレイヤーが勝つか求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $ $ Y $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>Aliceが勝つとき<code>Alice</code>と、Brownが勝つとき<code>Brown</code>と出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brown</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brown</span><br></pre></td></tr></table></figure><h2 id="样例-4-3">样例 #4</h2><h3 id="样例输入-4-3">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-3">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 0≦\ X,\ Y\ ≦\ 10^{18} $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>Aliceは $ 2 $ 個石のある山から $ 2 $ 個取るしかありません。その結果、山の石の数はそれぞれ $ 0,\ 2 $ 個となり、Brownは $ 2 $ 個の石を取り、山の石の数はそれぞれ $ 1,\ 0 $ 個となります。 Aliceはこれ以上操作を行うことができないので、Brownの勝ちです。</p></blockquote><h2 id="思路-4">思路</h2><p>博弈论。</p><p>不难发现，当$n=0,m=0$或$n=1,m=0$或$n=0,m=1$或$n=1,m=1$时，也就是$abs(n-m)&lt;=1$时，先手必输，<s>于是这题就结束了</s>。</p><p>分析一下$why$。我们假设$abs(n-m)\leq 1$时，先手先从第一堆中取出$2x$个石子。</p><p>于是$n’=n-2x,m’=m+x$，接下来轮到后手。</p><p>后手执行相同的操作，那么$n’‘=n’+x=n-x,m’‘=m’-2x=m-x$。发现还是$abs(m’‘-n’')\leq 1$.</p><p>这样一直持续下去，直到最基础的四种情况，所以先手必输。</p><p>那么$abs(n-m)&gt; 1$呢？先手可以反客为主！先手可以很简单地将$abs(n-m)&gt;1$转换为$abs(n-m)\leq1$.</p><p>所以原来的先手变成了后手，原来的后手变成了先手</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN],sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b)&lt;<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;Brown&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希与字典树</title>
      <link href="/2024/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/"/>
      <url>/2024/03/26/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E4%B8%8E%E5%AD%97%E5%85%B8%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串哈希">字符串哈希</h1><p>文章转载自：<a href="https://www.luogu.com.cn/article/lxwwcykj">字符串学习笔记·哈希（HASH）与字典树（Trie） - 洛谷专栏 (luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr><p>** <em>这篇博客我打算皮一下qwq，适合初学者阅读（因为讲的是在太细了）</em> **</p><h1 id="一、首先理解字符串操作的意义：">一、首先理解字符串操作的意义：</h1><h2 id="没意义"><s>没意义</s></h2><p>其实字符串操作的意义是很浅显的，比如百度的推荐搜索啊，比如查找比对一篇题解里有多少个相同或者不同的脏字然后$kkksc03$再根据其数量、恶劣程度决定用多大的刀将博主$kill$掉。。。所以字符串操作很重要啊喂$qwq$。</p><p>再来考虑时间：如果百度对于一个人的一次“常搜”推荐需要$10s$，那么对于全国网友来说，同时上网的人群基数很高，那么如果服务器性能不好的话，怕不是要三星$note\ 7\ qwq???$</p><p>所以啊，打造高效的字符串算法是很有必要滴！</p><h1 id="二、言归正传，浅析字符串哈希">二、言归正传，浅析字符串哈希</h1><p>哈希其实是所有字符串操作中，笔者认为最简单的操作了（except输入输出qwq）。哈希的过程，其实可以看作<strong>对一个串的单向加密过程</strong>，并且需要保证所加的密<strong>不能高概率重复</strong>（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样qwq），通过这种方式来替代一些很费时间的操作。</p><p>比如，最常见的，当然就是通过哈希数组来判断几个串是否相同（洛谷P3370）。此处的操作呢，很简单，就是对于每个串，<strong>我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串 *尽量* 不同。</strong></p><p>此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如ab和ba，并不是同一个串，但是如是做却会让其认为是qwq）。这种情况就叫做**$hash$冲突**，并且在如此的单向加密哈希中，$hash$冲突的情况在所难免（bzoj就有这种让你给出一组样例，使得一段哈希代码冲突的题，读者可以尝试尝试）。</p><p>而我们此处介绍的，即是最常见的一种哈希：<strong>进制哈希</strong>。进制哈希的核心便是<strong>给出一个固定进制$base$，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个$base$进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同</strong></p><p>奉上$P3370AC$代码（单哈希）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull a[<span class="number">10010</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prime=<span class="number">233317</span>; </span><br><span class="line">ull mod=<span class="number">212370440130137957ll</span>;</span><br><span class="line"><span class="function">ull <span class="title">hashe</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"> ull ans=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"> ans=(ans*base+(ull)s[i])%mod+prime;</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"> a[i]=<span class="built_in">hashe</span>(s);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(a[i]!=a[i+<span class="number">1</span>])</span><br><span class="line"> ans++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性</p><h2 id="1、无错哈希">1、无错哈希</h2><p>其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突（比如somebody’s birthday qwq）。</p><p>先贴代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//m个串</span></span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;str;<span class="comment">//下一行的check为bool型 </span></span><br><span class="line"><span class="keyword">while</span>(check[<span class="built_in">hash</span>(str)])hash[i]+=<span class="number">19260817</span>;</span><br><span class="line">hash[i]+= <span class="built_in">hash</span>(str) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如下图（亲手做的<s>英文高逼格</s>）：</p><p><img src="https://img2.imgtp.com/2024/03/26/MMacPCbS.png" alt=""></p><p>但是，这种方法类似桶查找，但是桶查找的弊端2就会很恶心——数据过大，$check$数组无能为力来支持上亿个空间（弊端1是由于数据具有跳跃性，浪费最后的统计次数，但在此不是特别明显，就当我皮了一下qwq）</p><h2 id="2、多重哈希">2、多重哈希</h2><p>这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。</p><p><img src="https://img2.imgtp.com/2024/03/26/Rih5RpxS.png" alt=""></p><p>下面皮一个哈希自动机qwq（不用百度了，名字自己起的）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希自动机,需要二维hash数组 </span></span><br><span class="line"><span class="keyword">for</span>伪代码排序，用来使哈希值单调（更好判断相/不同的数量） </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">check=<span class="number">1</span>； </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=qwq;j++)<span class="comment">//皮一下</span></span><br><span class="line"><span class="keyword">if</span>(hash[j][i]==hash[j][i+<span class="number">1</span>])&#123;check=<span class="number">0</span>;<span class="keyword">break</span>;&#125; </span><br><span class="line"><span class="keyword">if</span>(check)ans++;<span class="comment">//此为判断相同个数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、字典树浅析">三、字典树浅析</h1><h2 id="1、简要介绍">1、简要介绍</h2><p>首先要知道，字典树是一种假想数据结构（数据结构不都是 假想的吗qwq），那么问题来了——为什么是要用字典树呢？为什么不用类似字典链表之类的东西呢？很简单，所有树形结构 都有一个基本特点，就是</p><p><strong>元素与元素间的关系为继承的一对多关系</strong>。</p><p>拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；<strong>而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行</strong></p><p>比如下图就是一棵$Trie$，这里用颜色区分单词路径上的点，</p><p><img src="https://img2.imgtp.com/2024/03/26/d33Z3qzO.png" alt=""></p><h2 id="2、字典树基础与如何建树（插入操作）">2、字典树基础与如何建树（插入操作）</h2><p>首先，关于字典树，我们一般不是用点来存储字符的，而是用边——为什么呢？之后再说（十分皮地卖个关子qwq）。</p><p>重新首先，一般来说，字典树是不会使用根节点的，原因很浅显，<strong>因为根节点的个数决定究竟有几棵字典树</strong>，而通常字典树是只有一棵的，否则产生森林会很麻烦（qwq你皮你就splay，并且如果有森林的话应该叫做“字典森林”啊喂）。</p><p>但是我们要知道，并不是一个题中所有的串都有公共前缀（肯定不会的吧qwq），<strong>可如果根节点唯一，就代表他们一定有公共前缀，并且公共前缀的长度必定大于等于1</strong>。</p><p>其次，<strong>字典树中每个节点的子节点数量都肯定会小于某个数。</strong></p><p>如果字典树里都是小写字母，那么“某个数”就是26；如果大小写都有，“某个数”就应该是52（证明过程：显然）；</p><p>并且<strong>每个节点的所有的边都不同</strong>，这条性质可以便于我们判断在某一棵字典树到底有没有某条链：<strong>只要前缀不符合，就不需要再判断，因为必然没有（同一深度、同一父亲，边与边必定互异）</strong></p><p>在这里，我选择用结构体来存树，具体解释见注释：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建树（其实就是存点啦）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nodes</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">26</span>];</span><br><span class="line"><span class="comment">//此处只考虑小写字母字典树</span></span><br><span class="line">    <span class="type">bool</span> mark;</span><br><span class="line"><span class="comment">// 此为标记，作用下面说 </span></span><br><span class="line">&#125;trie[<span class="number">10001</span>]; </span><br><span class="line"><span class="type">int</span> root=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//根节点永久为0 qwq </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_check</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> position=root;<span class="comment">//初始化位置,跟深度没有直接关系 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> symbol=(<span class="type">int</span>)str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">/*此处实际是因为我们的trie都是存int的,如果贸然存char会</span></span><br><span class="line"><span class="comment">很别扭qwq，并且此处由于都是小写字母，所以 -‘a’ ,如果</span></span><br><span class="line"><span class="comment">存了别的类型的字符，需要特判，保证字符容易确定 */</span></span><br><span class="line">    <span class="keyword">if</span>(!trie[position].son[symbol]) <span class="comment">//还没有被编号</span></span><br><span class="line">    trie[position].son[symbol]=++num;<span class="comment">//编一个号</span></span><br><span class="line"></span><br><span class="line">position=trie[position].son[symbol] ;</span><br><span class="line"><span class="comment">//更新迭代位置，直到字符链的最末端 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> temp=trie[position].mark;</span><br><span class="line">trie[position].mark =<span class="number">1</span>;</span><br><span class="line"><span class="comment">//将这条链的最末端置为1，如果还有重复的串，那么一定会出现</span></span><br><span class="line"><span class="comment">//最末端相同 ;反之，最末端节点的mark相同也可以推出链相同，</span></span><br><span class="line"><span class="comment">//借此来判断串是否相同 </span></span><br><span class="line"><span class="keyword">return</span> temp!=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*最后说一下为什么要编号：我们根据程序可以看出，字符串是</span></span><br><span class="line"><span class="comment">按秩插入树，所以一条链上的编号肯定满足单调，便于我们查找</span></span><br><span class="line"><span class="comment">和比对*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是便可以通过这种方式比对字符串，期望时间复杂度$O(n)$大多用于比对。</p><h2 id="3、关于字典树的查找">3、关于字典树的查找</h2><p>查找前缀比较好写，只需要一边判断是否符合要求，一边判断是否继续迭代即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> pos=root;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> x=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span>(trie[pos].son[x]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//如果在建完树之后这个点还没有被编号，</span></span><br><span class="line"> <span class="comment">//那么就肯定不存在这条链。（互异性） </span></span><br><span class="line"> pos=trie[pos].son[x] ;<span class="comment">//继续迭代 </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实查询单词和查询前缀差别不大，只是我们<strong>每次都需要维护一个$check<a href="bool">i</a>$</strong>，存在单词链的<strong>末尾</strong>。</p><p>每当一个新字符已经被标记时（即所<strong>查询单词的这个字母及其前缀都在树的某条链上</strong>），我们<strong>使这个字符$check$异于它祖先们的$check$</strong>，最后判断**该条匹配链结尾字符的$check$是否异于链上其他字符的$check$**即可判断是否有这个单词（如果没有的话，末尾的$check$肯定与链上其他的相同啊qwq）</p><p>至于前缀出现次数，很简单，只要将每一个前缀的出现次数存到它相连的子节点，最后输出前缀最后一个字符所带的次数即可（可以用数组维护，也可以直接写在结构体里）</p><p>好啦，就是这样，希望对大家有所帮助</p><h2 id="日拱一卒，功不唐捐！">日拱一卒，功不唐捐！</h2>]]></content>
      
      
      <categories>
          
          <category> 想成为串串大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序、拷贝、替换算法</title>
      <link href="/2024/03/26/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/26/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E3%80%81%E6%8B%B7%E8%B4%9D%E3%80%81%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-3-常用排序算法">5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort">5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle">5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge">5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line"><span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse">5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法">5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy">5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace">5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if">5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap">5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap</span>(v1, v2);</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算术生成和集合算法</title>
      <link href="/2024/03/26/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E5%92%8C%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/26/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%9C%AF%E7%94%9F%E6%88%90%E5%92%8C%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-5-常用算术生成算法">5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate">5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill">5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法">5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection">5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union">5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference">5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用遍历与查找算法</title>
      <link href="/2024/03/26/%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2024/03/26/%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-1-常用遍历算法">5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each">5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform">5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法">5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find">5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if">5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find">5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search">5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count">5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if">5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**按值统计用count，按条件统计用count_if</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-函数对象</title>
      <link href="/2024/03/26/STL-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/03/26/STL-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-1-函数对象">4.1 函数对象</h3><h4 id="4-1-1-函数对象概念">4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用">4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyPrint</span>()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词">4.2  谓词</h3><h4 id="4-2-1-谓词概念">4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词">4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词">4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象">4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义">4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数">4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数">4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数">4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map容器</title>
      <link href="/2024/03/26/map%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/map%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-9-map-multimap容器">3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念">3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值">3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数:</li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换">3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除">3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计">3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序">3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组">3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述">3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤">3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line"><span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line">vector&lt;Worker&gt;vWorker;</span><br><span class="line"><span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line">multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line"><span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line"><span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set容器</title>
      <link href="/2024/03/26/set%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/set%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-8-set-multiset-容器">3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念">3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值">3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line"><span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换">3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">swap</span>(s2);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除">3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计">3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别">3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建">3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序">3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line">set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(p1);</span><br><span class="line">s.<span class="built_in">insert</span>(p2);</span><br><span class="line">s.<span class="built_in">insert</span>(p3);</span><br><span class="line">s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list容器</title>
      <link href="/2024/03/26/list%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/list%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-7-list容器">3.7 list容器</h3><h4 id="3-7-1-list基本概念">3.7.1 list基本概念</h4><p>**功能：**将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://img2.imgtp.com/2024/03/26/1PdMd8EA.jpg" alt=""></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数">3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换">3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作">3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​    //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>//如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除">3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">erase</span>(++it);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取">3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序">3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例">3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li><li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue容器</title>
      <link href="/2024/03/26/queue%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/queue%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-6-queue-容器">3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念">3.6.1 queue 基本概念</h4><p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://img2.imgtp.com/2024/03/26/nYjeUhcY.jpg" alt=""></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><h4 id="3-6-2-queue-常用接口">3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.<span class="built_in">push</span>(p1);</span><br><span class="line">q.<span class="built_in">push</span>(p2);</span><br><span class="line">q.<span class="built_in">push</span>(p3);</span><br><span class="line">q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack容器</title>
      <link href="/2024/03/26/stack%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/stack%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-5-stack容器">3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念">3.5.1 stack 基本概念</h4><p><strong>概念：<strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="https://img2.imgtp.com/2024/03/26/FGuiFdJQ.jpg" alt=""></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><h4 id="3-5-2-stack-常用接口">3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque容器</title>
      <link href="/2024/03/26/deque%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/deque%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-3-deque容器">3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念">3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/RUhva8I6.jpg" alt=""></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://img2.imgtp.com/2024/03/26/rnkkrVHb.jpg" alt=""></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数">3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作">3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</p></li><li><p><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作">3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                             //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除">3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取">3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序">3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector容器</title>
      <link href="/2024/03/26/vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-2-vector容器">3.2 vector容器</h3><h4 id="3-2-1-vector基本概念">3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/A35F09qp.jpg" alt=""></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数">3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                    //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作">3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p></li><li><p><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小">3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​      //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除">3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear</li></ul><h4 id="3-2-6-vector数据存取">3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器">3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间">3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string容器</title>
      <link href="/2024/03/26/string%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/03/26/string%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-1-string容器">3.1 string容器</h3><h4 id="3-1-1-string基本概念">3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数">3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>          //创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code>        //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作">3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str7;</span><br><span class="line">str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接">3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换">3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较">3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1</p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取">3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除">3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串">3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL初识</title>
      <link href="/2024/03/26/STL%E5%88%9D%E8%AF%86/"/>
      <url>/2024/03/26/STL%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h2 id="2-STL初识">2 STL初识</h2><h3 id="2-1-STL的诞生">2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念">2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件">2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器">2.4  STL中容器、算法、迭代器</h3><p>**容器：**置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>**算法：**问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p>**迭代器：**容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识">2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型">2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型">2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string mName;</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类模板</title>
      <link href="/2024/03/26/%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/03/26/%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="1-3-类模板">1.3 类模板</h3><h4 id="1-3-1-类模板语法">1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别">1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机">1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数">1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承">1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现">1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写">1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元">1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例">1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="type">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数模板</title>
      <link href="/2024/03/26/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/03/26/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="1-2-函数模板">1.2 函数模板</h3><ul><li><p>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li></ul><h4 id="1-2-1-函数模板语法">1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板实现交换</span></span><br><span class="line"><span class="comment">//1、自动类型推导</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//声明一个模板，告诉编译器后面的代码中紧跟的T不要报错，T是一个通用的数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"><span class="comment">//利用函数模板</span></span><br><span class="line"><span class="comment">//1、自动类型推导：由编译器自动推导，根据传入的数据</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">1.1</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">2.2</span>;</span><br><span class="line"><span class="comment">//swapDouble(c, d);</span></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="built_in">mySwap</span>&lt;<span class="type">double</span>&gt;(c, d);<span class="comment">//这里尖括号的数据类型对应T</span></span><br><span class="line">cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项">1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p></li><li><p>模板必须要确定出T的数据类型，才可以使用</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"><span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、自动类型推导，必须推导出一致的数据类型T才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mySwap(a, c);//错误，推导出不一致的的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//func();//没有确定T的数据类型，无法调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例">1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试char数组</span></span><br><span class="line"><span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line"><span class="built_in">mySort</span>(charArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试int数组</span></span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">mySort</span>(intArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别">1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则">1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性">1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"><span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2024/03/26/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/03/26/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h2 id="5-文件操作">5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件">5.1文本文件</h3><h4 id="5-1-1写文件">5.1.1写文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件">5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><hr><p>自己的实现，有些奇怪</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream a;</span><br><span class="line">    a.<span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>,ios::out);</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;123456&quot;</span>&lt;&lt;endl;</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;kkksc3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;scutwin&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream b;</span><br><span class="line">    b.<span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!b.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种</span></span><br><span class="line">    <span class="comment">//char buf[1024]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//while(b&gt;&gt;buf)&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;buf&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="comment">//char buf1[1024]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//while(b.getline(buf1,sizeof(buf1)))&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;buf1&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    <span class="comment">//char c;</span></span><br><span class="line">    <span class="comment">//while(b.get(c))&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种</span></span><br><span class="line">    <span class="comment">//char d;</span></span><br><span class="line">    <span class="comment">//while((d=b.get())!=EOF)&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;d;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五种</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(b,s))&#123;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    b.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-二进制文件">5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件">5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件">5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/2024/03/26/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2024/03/26/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-5-运算符重载">4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载">4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1、成员函数重载+号</span></span><br><span class="line"></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = <span class="keyword">this</span>-&gt;m_a + p.m_a;</span><br><span class="line">temp.m_b = <span class="keyword">this</span>-&gt;m_b + p.m_b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2、全局函数重载符号</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;<span class="comment">//注意这个函数需要放在test01前面，否则会报错</span></span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数重载版本</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,<span class="type">int</span> num) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = p1.m_a + num;</span><br><span class="line">temp.m_b = p1.m_b + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p1.m_a = <span class="number">10</span>;</span><br><span class="line">p1.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_a = <span class="number">10</span>;</span><br><span class="line">p2.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数重载本质：</span></span><br><span class="line"><span class="comment">//Person p3 = p1.operator+(p2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载本质：</span></span><br><span class="line">Person p3 = <span class="keyword">operator</span>+(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两者都可以简化为以下版本</span></span><br><span class="line"><span class="comment">//Person p3 = p1 + p2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 也可以发生函数重载</span></span><br><span class="line">Person p4 = p1 + <span class="number">100</span>;<span class="comment">//Person +int;</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、成员函数重载+号</span></span><br><span class="line"><span class="comment">//2、全局函数重载+号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载">4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//利用成员函数重载 左移运算符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person &amp;p) &#123; //等价于p.operator&lt;&lt;(p) 实际上需要传进两个对象，但我们只需要一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外的一种尝试</span></span><br><span class="line"><span class="comment">/*void operator&lt;&lt;(cout) &#123;//等价于p.operator&lt;&lt;(cout) 简化版本 p &lt;&lt; cout,输出结果为cout在右侧，与预期效果相反</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：不会利用成员函数重载&lt;&lt;运算符，因为无法实现 cout在左侧</span></span><br><span class="line"><span class="comment">//int m_a;</span></span><br><span class="line"><span class="comment">//int m_b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般来说,数据成员设置权限为私有，可以利用友元的技术解决函数调用的问题 但是注意类外无法访问数据成员</span></span><br><span class="line"><span class="comment">//所以应该先给他们赋初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能利用全局函数重载左移运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点击cout，可以查看cout的数据类型</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(ostream &amp;cout, Person &amp;p) &#123;//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; p.m_a &lt;&lt; &quot; &quot; &lt;&lt; &quot;m_b=&quot; &lt;&lt; p.m_b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">//ostream &amp;operator&lt;&lt;(ostream&amp; cout, Person&amp; p) &#123;//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; p.m_a &lt;&lt; &quot; &quot; &lt;&lt; &quot;m_b=&quot; &lt;&lt; p.m_b;</span></span><br><span class="line"><span class="comment">//return cout;//直接返回，后面就不会再重载endl</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一种写法：给out起别名，其实就是引用，指向同一块内存空间</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<span class="comment">//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line">out &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;m_b=&quot;</span> &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> out;<span class="comment">//直接返回，后面就不会再重载endl</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*Person p;</span></span><br><span class="line"><span class="comment">p.m_a = 10;</span></span><br><span class="line"><span class="comment">p.m_b = 10;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*Person p1;</span></span><br><span class="line"><span class="comment">p1.m_a = 10;</span></span><br><span class="line"><span class="comment">p1.m_b = 10*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1;<span class="comment">//系统提示没有与这些操作数匹配的&quot;&lt;&lt;&quot;的运算符,重载后可以运行</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;<span class="comment">//会报错，因为后面添加了endl，解决方案在上</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;<span class="comment">//没输出一次就返回cout,可以往后无限叠加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载">4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义整形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"><span class="keyword">friend</span>  ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载前置++运算符</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//注意这里要返回的是引用，如果删去&amp;</span></span><br><span class="line"><span class="comment">//返回引用是为了一直对一个数据进行递增操作</span></span><br><span class="line"><span class="comment">//先进行++运算</span></span><br><span class="line">m_Num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再进行自身返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//注意这里返回我们写的myint,this是指向自身，*是解引用的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载后置++运算符</span></span><br><span class="line"><span class="comment">//void operator++() &#123;//z这里会报错，因为发生重定义现象</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置返回的是值，注意不能返回引用，如果返回引用，返回的是一个局部的对象，局部对象在当前函数执行完后就被释放了，再返回它就是非法操作了</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;<span class="comment">//int 代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="comment">//先 记录当时结果</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后递增</span></span><br><span class="line">m_Num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后将记录结果做返回</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint) &#123;</span><br><span class="line">cout &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;<span class="comment">//没有与之匹配的操作运算符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回引用的输出效果</span></span><br><span class="line"><span class="comment">//这种都是对同一个数据类型进行递增，也就是myint1</span></span><br><span class="line">cout &lt;&lt; ++myint1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ++(++myint1) &lt;&lt; endl;<span class="comment">//提示没有与之匹配的操作运算符,解决方案在上 </span></span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; myint1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////不返回引用的输出效果</span></span><br><span class="line"><span class="comment">// 返回的是一个新的对象，再对该新对象++</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; ++myint1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">////输出为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; ++(++myint1) &lt;&lt; endl;//提示没有与之匹配的操作运算符,解决方案在上 </span></span><br><span class="line"><span class="comment">////输出为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; myint1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">////输出为2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint2;</span><br><span class="line">cout &lt;&lt; myint2++ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; myint2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载">4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);<span class="comment">//new开辟出来的东西需要使用指针接受，堆区数据由程序员手动开辟，手动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>() &#123;<span class="comment">//把堆区数据释放干净</span></span><br><span class="line"><span class="comment">//这是一个浅拷贝</span></span><br><span class="line"><span class="comment">//调用时能正常输出，但系统崩溃，因为p1与p2指向同一块内存，内存被重复释放，导致系统崩溃</span></span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要使用深拷贝解决</span></span><br><span class="line"><span class="comment">//重载 赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line"><span class="comment">//编译器提供浅拷贝</span></span><br><span class="line"><span class="comment">//m_age=p.m_age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝</span></span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝操作</span></span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *m_age;<span class="comment">//需要开辟到堆区,所以使用指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p1.m_age &lt;&lt; endl;<span class="comment">//输出的是指针指向的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p1.m_age &lt;&lt; endl;<span class="comment">//解引用，输出p1年龄</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p2.m_age &lt;&lt; endl;<span class="comment">//输出p2年龄</span></span><br><span class="line"></span><br><span class="line">p2 = p1;<span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p2.m_age &lt;&lt; endl;<span class="comment">//输出年龄也是18</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">c = b = a;</span><br><span class="line">    <span class="comment">//连续赋值操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; c &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载">4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载==号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载!=号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_age != p.m_age || <span class="keyword">this</span>-&gt;m_name != p.m_name) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Sam&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Sam&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;<span class="comment">//没有与之匹配的运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1==p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1!=p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;<span class="comment">//没有与之匹配的运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1!=p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1==p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载">4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印输出类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重载函数调用运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint2</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//()小括号重载 让对象使用重载后的小括号 由于使用起来非常类似于函数调用，因此称为仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MyPrint2</span>(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//函数的调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数非常的灵活，没有固定的写法</span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyAdd myadd;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">myadd</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;<span class="comment">//通过一个类名和一个()创建一个匿名对象，用完就被释放</span></span><br><span class="line"><span class="comment">//输出为200</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="/2024/03/26/%E5%8F%8B%E5%85%83/"/>
      <url>/2024/03/26/%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-4-友元">4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//goodGay全局函数是Building的友元，可以访问Builing中的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span>  <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building* building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()&#123;</span><br><span class="line">m_livingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingroom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedroom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_livingroom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;全局函数正在访问：&quot; &lt;&lt; building-&gt;m_bedroom &lt;&lt; endl;//报错，类外不可以访问</span></span><br><span class="line"><span class="comment">//解决方法：在类内的最上面添加函数的声明</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;<span class="comment">//公共属性，类外可以访问</span></span><br><span class="line">Building building;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元">4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数 访问类中的属性</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//GoodGay类是该类的友元，可以访问本类中的私有成员</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;<span class="comment">//加上::,说明作用域</span></span><br><span class="line">m_livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line"><span class="comment">//创建建筑物对象</span></span><br><span class="line">building = <span class="keyword">new</span> Building;<span class="comment">//在堆区开创建一个新的对象，并让Building* building;指向这个新的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;<span class="comment">//GoodGay::说明作用域</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;<span class="comment">//先调用GoodGay的构造函数，创建一个Building,同时会调用Building的构造函数</span></span><br><span class="line">ss.<span class="built_in">visit</span>();<span class="comment">//调用visit函数，访问builing中的livingRoom</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数可以访问Builing中的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//让visit2函数不可以访问Builing中的私有成员</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//告诉编译器 GoodGay类下的visit成员函数作为本类的友元，可以访问私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;<span class="comment">//注意需要添加GoodGay::来说明作用域</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">m_livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;visit函数正在访问&quot; &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;不可以访问类内的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;</span><br><span class="line">ss.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;</span><br><span class="line">ss.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象模型和this指针</title>
      <link href="/2024/03/26/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/"/>
      <url>/2024/03/26/C++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E5%92%8Cthis%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-3-C-对象模型和this指针">4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储">4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，<strong>类内的成员变量和成员函数分开存储</strong></p><p><strong>只有非静态成员变量才属于类的对象上</strong></p><p>（静态成员变量和静态成员函数不属于某个对象，<strong>非静态成员函数不属于类的对象（非静态成员函数只有一份）</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;<span class="comment">//静态成员变量 不属于类对象上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void func() &#123;//加了函数 字节还是4 说明非静态成员函数不属于类对象上</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void func2() &#123;//加了静态函数 字节还是4 说明静态成员函数不属于类对象上</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person2::m_b = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//空对象占用的内存空间</span></span><br><span class="line"><span class="comment">//C++编译器会给每个空对象也分配一个字节空间，为了区分不同的空对象所占用的内存空间的位置</span></span><br><span class="line"><span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出为1</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person1 p1;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为4，对应int m_a的字节，</span></span><br><span class="line"></span><br><span class="line">Person2 p2;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出还是4，对应int m_a的字节</span></span><br><span class="line"><span class="comment">//说明static int m_b不属于类的对象上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01()</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念">4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li><strong>当形参和成员变量同名时，可用this指针来区分</strong></li><li>*<em>在类的非静态成员函数中返回对象本身，可使用return <em>this</em></em></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Person(int age) &#123;//点击左边的age，可以发现编译器认为该行的age与下一行的age是同一个，与最下行的age不是同一个</span></span><br><span class="line"><span class="comment">//age = age;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int age;//这个age实际上从来都没有进行过赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;<span class="comment">//this指向的是 被调用的成员函数 所属的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddAge1</span><span class="params">(Person&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//this指向p2的指针，而*this指向的是p2这个对象本体，注意这里需要用引用的方式返回本体</span></span><br><span class="line"><span class="comment">//如果是返回值的方式，输出结果是20</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">19</span>)</span></span>;<span class="comment">//this指向的是p1</span></span><br><span class="line">cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//只加上1次</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p2.<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出结果20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上多次</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);这样写会报错，因为前面的函数返回值是void</span></span><br><span class="line"><span class="comment">//如果可以使得p2.PersonAddAge(p1)返回的还是p2，依此类推，可以持续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式编程思想</span></span><br><span class="line">p2.<span class="built_in">PersonAddAge1</span>(p1).<span class="built_in">PersonAddAge1</span>(p1).<span class="built_in">PersonAddAge1</span>(p1);</span><br><span class="line"><span class="comment">//如果是返回值的方式，输出结果是20，返回的不是本体了，而是用本体创建一个新的数据p2&#x27;，调用了拷贝构造函数，依此类推p2&#x27;&#x27;,p2&#x27;&#x27;&#x27;等等</span></span><br><span class="line">cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是<strong>也要注意有没有用到this指针</strong></p><p><strong>如果用到this指针，需要加以判断保证代码的健壮性</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person Class&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原因是传入的指针是NULL</span></span><br><span class="line">cout &lt;&lt; m_age &lt;&lt; endl;<span class="comment">//实际上在属性前面默认加上了this-&gt;,说明是当前对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原因是传入的指针是NULL</span></span><br><span class="line">cout &lt;&lt; m_age &lt;&lt; endl;<span class="comment">//实际上在属性前面默认加上了this-&gt;,说明是当前对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//老版本的结果是系统崩了，现在是没有输出</span></span><br><span class="line">Person* p=<span class="literal">NULL</span>;<span class="comment">//指针指向的Person是一个空指针，相当于this-&gt;是一个空的东西，没有实体，没有创建一个确定的对象，this根本就没有指向一个确定的数据</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();<span class="comment">//没有输出/崩了</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge1</span>();<span class="comment">//没有输出/没崩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数">4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li><strong>常函数内不可以修改成员属性</strong></li><li><strong>成员属性声明时加关键字mutable后，在常函数中依然可以修改</strong></li></ul><p><strong>常对象：</strong></p><ul><li><strong>声明对象前加const称该对象为常对象</strong></li><li><strong>常对象只能调用常函数</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量 指针的指向是不可以修改的</span></span><br><span class="line"><span class="comment">//this实际上就是Person * const this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson0</span><span class="params">()</span> </span>&#123;<span class="comment">//不可以修改成员属性的值</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">100</span>; <span class="comment">//实际上是this-&gt;m_a = 100;正常运行</span></span><br><span class="line"><span class="comment">//this=NULL;this指针不可以修改指针的指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量 </span></span><br><span class="line"><span class="comment">//下面加上了const 这里就是const Person * const this 此时this也不可以修改指针的值了</span></span><br><span class="line"><span class="comment">//在成员函数后面加上const,修饰的是this指向，让指针的指向的值也不可以修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//不可以修改成员属性的值</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = <span class="number">100</span>;<span class="comment">//正常，没有保错</span></span><br><span class="line"><span class="comment">//m_a = 100; 实际上是this-&gt;m_a = 100;执行时报错</span></span><br><span class="line"><span class="comment">//this=NULL;this指针不可以修改指针的指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_b;<span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，加上mutable关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">showPerson0</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Person p;<span class="comment">//在对象前面加上const,变为常对象</span></span><br><span class="line"><span class="comment">//p.m_a = 100;会报错，不可以修改</span></span><br><span class="line">p.m_b;<span class="comment">//正常运行，m_b在常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象只能调用常函数</span></span><br><span class="line">p.<span class="built_in">showPerson1</span>();<span class="comment">//正常运行，没有报错</span></span><br><span class="line"><span class="comment">//p.showPerson0();//不可以调用，因为普通成员函数可以修改属性 否则的话说明常对象里面的数据也可以修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的初始化和清理</title>
      <link href="/2024/03/26/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/"/>
      <url>/2024/03/26/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E6%B8%85%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-2-对象的初始化和清理">4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​<strong>一个对象或者变量没有初始状态，对其使用后果是未知</strong></p><p>​<strong>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</strong></p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，<strong>这两个函数将会被编译器自动调用，完成对象初始化和清理工作</strong>。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现（函数体内一行代码都没有）。</strong></p><ul><li>构造函数：主要作用在于<strong>创建对象时为对象的成员属性赋值</strong>，<strong>构造函数由编译器自动调用，无须手动调用</strong>。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，<strong>没有返回，值也不写void</strong></li><li><strong>函数名称与类名相同</strong></li><li><strong>构造函数可以有参数，因此可以发生重载</strong></li><li>程序在<strong>调用对象时候会自动调用构造</strong>，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，<strong>没有返回值也不写void</strong></li><li><strong>函数名称与类名相同,在名称前加上符号  ~</strong></li><li><strong>析构函数不可以有参数，因此不可以发生重载</strong></li><li>程序在<strong>对象销毁前会自动调用析构</strong>，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意写清楚作用域    </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数：进行初始化操作</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数：进行清理的操作</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**编译器提供的构造函数和析构函数是空实现（函数体内一行代码都没有）。**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;<span class="comment">//在栈上的数据，test01执行完毕后，就会释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();<span class="comment">//输出结果为构造和析构都有调用</span></span><br><span class="line">    </span><br><span class="line">    Person p;<span class="comment">//输出结果为只有构造函数的调用。因为还有下面的system(&quot;pause&quot;),此时程序还没有执行完毕，只有当按下任意键后，在return 0之前（也就是在整个main函数执行完毕后，才会出现析构函数的调用）</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​<strong>按参数分为： 有参构造和无参构造</strong></p><p>​<strong>按类型分为： 普通构造和拷贝构造</strong></p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数：克隆复制另外一份，注意不能改变本身的属性（添加const）,用引用的方式调进来</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        <span class="comment">//将传入的人身上的所有属性，拷贝到我身上。</span></span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line">    Person p;<span class="comment">//默认构造函数调用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span><span class="comment">//拷贝构造函数调用</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意1：调用无参（默认）构造函数不能加括号，如果加了编译器认为这是一个函数声明，不会认为是在创建对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//Person p2();没有任何的输出结果</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//2.2 显式法</span></span></span><br><span class="line"><span class="function">Person p3 </span>= <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//有参构造</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(p1); <span class="comment">//拷贝构造调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person(10)</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;111&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//单独写就是匿名对象  当前行执行结束之后，系统会立即回收匿名对象（马上析构）（也就是在test02()执行完毕之前就析构），后面无法使用该对象。</span></span><br><span class="line">    <span class="comment">//输出结果为</span></span><br><span class="line">    <span class="comment">//有参构造函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); 有参构造</span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); 拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">//编译器会认为Person(p4)==Person p4,导致重定义</span></span><br><span class="line"><span class="comment">//Person (p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li><strong>使用一个已经创建完毕的对象来初始化一个新对象</strong></li><li><strong>值传递的方式给函数参数传值</strong></li><li><strong>以值方式返回局部对象</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; newman.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数！</span></span><br><span class="line">    <span class="comment">//拷贝构造函数!</span></span><br><span class="line">    <span class="comment">//100</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    </span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，而是赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;<span class="comment">//实参传给形参，会按照传进来的p1拷贝一份新的数据，把形参数据改变，不会影响实参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);<span class="comment">//拷贝构造函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;<span class="comment">//根据返回的这个p1创建一个新的对象，返回给test03,因为这是局部对象，执行后会被释放掉。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//默认构造函数！</span></span><br><span class="line">    <span class="comment">//输出原本的p1的地址</span></span><br><span class="line">    <span class="comment">//拷贝构造函数！</span></span><br><span class="line">    <span class="comment">//析构函数！（原本的p1）</span></span><br><span class="line">    <span class="comment">//输出拷贝后p1的地址</span></span><br><span class="line">    <span class="comment">//析构函数！（拷贝的p1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个的地址是不同的</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p><strong>1．默认构造函数(无参，函数体为空)</strong></p><p><strong>2．默认析构函数(无参，函数体为空)</strong></p><p><strong>3．默认拷贝构造函数，对属性进行值拷贝</strong></p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义<strong>有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</strong></p></li><li><p>如果用户定义<strong>拷贝构造函数，c++不会再提供其他构造函数</strong></p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数!</span></span><br><span class="line">    <span class="comment">//拷贝构造函数!</span></span><br><span class="line">    <span class="comment">//p2的年龄为18</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果将拷贝函数注释，输出结果少了一行“拷贝构造函数!”，其他相同</span></span><br><span class="line">    <span class="comment">//编译器会自动提供一个拷贝构造函数，对属性进行简单的拷贝操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="comment">//不调用默认构造函数的话正常输出</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; </span><br><span class="line">    cout&lt;&lt;p3.age&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供，此时的输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数！</span></span><br><span class="line">    <span class="comment">//10</span></span><br><span class="line">    <span class="comment">//析构函数！</span></span><br><span class="line">    <span class="comment">//析构函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p><strong>浅拷贝：简单的赋值拷贝操作，编译器提供的简单赋值操作</strong></p><p><strong>深拷贝：在堆区重新申请空间，进行拷贝操作</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p></blockquote><p>自己的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age,<span class="type">int</span> height) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);<span class="comment">//手动开辟，手动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现拷贝函数，解决浅拷贝函数带来的问题</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line"><span class="comment">//m_height=p.m_height;编译器默认的赋值</span></span><br><span class="line"><span class="comment">//深拷贝操作</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"><span class="comment">//正常运行，可以看到地址不同</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="comment">//析构代码，将堆区开辟的数据释放</span></span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">m_height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统崩了，指向的是同一块地址，p2先析构（析构了一块堆区的地址），p1再析构（没有堆区的地址），此时系统崩溃</span></span><br><span class="line"><span class="comment">//自己实现拷贝函数，解决浅拷贝函数带来的问题</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">180</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄为&quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot;身高为&quot;</span>&lt;&lt;*p1.m_height&lt;&lt;endl;<span class="comment">//两个的输出结果一样</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄为&quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot;身高为&quot;</span>&lt;&lt;*p2.m_height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-6-初始化列表">4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己的实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传统初始化</span></span><br><span class="line"><span class="comment">/*Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">m_a = a;</span></span><br><span class="line"><span class="comment">m_b = b;</span></span><br><span class="line"><span class="comment">m_c = c;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表属性</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c) :<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b), <span class="built_in">m_c</span>(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Person p(10, 20, 30);</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员">4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string pName) &#123;</span><br><span class="line">m_Pname = pName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手机品牌</span></span><br><span class="line">string m_Pname;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Phone m_Phone=pName 隐式转化法初始化，上面也恰好有一个string的数据类型，因此可以实现</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其他类对象作为本类的成员时，构造时先构造类对象，再构造自身，析构则相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_Pname &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员">4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li><strong>所有对象共享同一份数据</strong></li><li><strong>在编译阶段分配内存，即程序还没有运行之前就分配内存了。分配在全局区</strong></li><li><strong>类内声明，类外初始化</strong></li></ul></li><li>静态成员函数<ul><li><strong>所有对象共享同一个函数</strong></li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li></ul><p>**示例1 ：**静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己写的：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;<span class="comment">//必须在类外初始化，否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量也是有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_a = <span class="number">100</span>;<span class="comment">//不再需要加上static关键字，但是需要加类名和::</span></span><br><span class="line"><span class="type">int</span> Person::m_b = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p.m_a = <span class="number">200</span>;<span class="comment">//修改数据为200</span></span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象，所有对象都够共享同一份数据</span></span><br><span class="line"><span class="comment">//因此静态成员有两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象进行访问</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名进行访问</span></span><br><span class="line">cout &lt;&lt; Person::m_a &lt;&lt; endl;<span class="comment">//类的名称加上::</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::m_b &lt;&lt; endl;在私有作用域内，类外不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**示例2：**静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己写的：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_a = <span class="number">200</span>;<span class="comment">//静态成员函数可以访问静态成员变量</span></span><br><span class="line"><span class="comment">//m_b = 200;//静态成员函数不可以访问 非静态成员变量，无法区分到底是哪个对象的m_b的属性</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;<span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_b;<span class="comment">//非静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func2函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//两种访问方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、通过对象进行访问</span></span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名访问</span></span><br><span class="line">cout &lt;&lt; Person::func &lt;&lt; endl;<span class="comment">//输出该静态函数的地址</span></span><br><span class="line">Person::<span class="built_in">func</span>();<span class="comment">//输出的是&quot;static void func函数&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2();//类外是不可以访问的</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::func2 &lt;&lt; endl;//该静态函数的地址也不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装</title>
      <link href="/2024/03/26/%E5%B0%81%E8%A3%85/"/>
      <url>/2024/03/26/%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-1-封装">4.1 封装</h3><h4 id="4-1-1-封装的意义">4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p>**示例1：**设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为：常常使用函数来实现</span></span><br><span class="line"><span class="comment">//获取到圆的周长：这是一个函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建一个具体的圆（就是对象）</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">    <span class="comment">//实例化：通过一个类 创建一个对象的过程</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限</li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 儿子可以访问父亲中的保护内容</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 儿子不可以访问父亲的私有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//改成private,类外不可以访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个具体对象</span></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限的内容类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限的内容类外访问不到</span></span><br><span class="line">    </span><br><span class="line">    p.<span class="built_in">func</span>()<span class="comment">//public可以访问，private不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别">4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li><strong>struct 默认权限为公共</strong></li><li><strong>class 默认权限为私有</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限，不可以访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限，可以访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有">4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，<strong>可以自己控制读写权限</strong></p><p><strong>优点2：<strong>对于写权限，我们</strong>可以检测数据的有效性</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//创建一个接口，利用函数访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 可读可写 如果想修改（范围是0-150）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;<span class="comment">//对数据进行有效性地验证</span></span><br><span class="line">m_Age = <span class="number">0</span>;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2024/03/26/%E5%A4%9A%E6%80%81/"/>
      <url>/2024/03/26/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-7-多态">4.7  多态</h3><h4 id="4-7-1-多态的基本概念">4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="https://img2.imgtp.com/2024/03/26/rlTPWghq.png" alt=""></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2024/03/26/%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/03/26/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-6-继承">4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="https://img2.imgtp.com/2024/03/26/45FfiE86.png" alt=""></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/h2EaLshZ.png" alt=""></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型">4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="https://img2.imgtp.com/2024/03/26/WB7DLB75.png" alt=""></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="https://img2.imgtp.com/2024/03/26/SPiG6Y3o.png" alt=""></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="https://img2.imgtp.com/2024/03/26/VmrX5axh.jpg" alt=""></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC058</title>
      <link href="/2024/03/24/ABC058/"/>
      <url>/2024/03/24/ABC058/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC058">ABC058</h1><blockquote><h1 id="ABC058D-井井井">[ABC058D] 井井井</h1><h2 id="题面翻译">题面翻译</h2><p>给定 $n$ 条平行于 $y$ 轴的直线 $x_{1…n}$，和 $m$ 条平行于 $x$ 轴的直线 $y_{1…n}$，</p><p>计算 $x_i,x_j$ 和 $y_k,y_l$ 组成的矩形面积之和，$1\le x&lt;y\le n$，$1\le k&lt;l\le m$。</p><h2 id="题目描述">题目描述</h2><p>$ 2 $ 次元平面上に $ x $ 軸と平行な直線が $ m $ 本と $ y $ 軸と平行な直線が $ n $ 本引いてあります。 $ x $ 軸と平行な直線のうち下から $ i $ 番目は $ y\ =\ y_i $ で表せます。 $ y $ 軸と平行な直線のうち左から $ i $ 番目は $ x\ =\ x_i $ で表せます。</p><p>この中に存在しているすべての長方形についてその面積を求め、 合計を $ 10^9+7 $ で割ったあまりを出力してください。</p><p>つまり、$ 1\leq\ i\ &lt;\ j\leq\ n $ と $ 1\leq\ k\ &lt;\ l\leq\ m $ を満たすすべての組 $ (i,j,k,l) $ について、  直線 $ x=x_i $, $ x=x_j $, $ y=y_k $, $ y=y_l $ で囲まれる 長方形の面積を求め、合計を $ 10^9+7 $ で割ったあまりを出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ m $ $ x_1 $ $ x_2 $ $ … $ $ x_n $ $ y_1 $ $ y_2 $ $ … $ $ y_m $</p></blockquote><h2 id="输出格式">输出格式</h2><p>長方形の面積の合計を $ 10^9+7 $ で割ったあまりを $ 1 $ 行に出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 3 4</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">-790013317 -192321079 95834122 418379342 586260100 802780784</span><br><span class="line">-253230108 193944314 363756450 712662868 735867677</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">835067060</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ \leq\ n,m\ \leq\ 10^5 $</li><li>$ -10^9\ \leq\ x_1\ &lt;\ …\ &lt;\ x_n\ \leq\ 10^9 $</li><li>$ -10^9\ \leq\ y_1\ &lt;\ …\ &lt;\ y_m\ \leq\ 10^9 $</li><li>$ x_i,\ y_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>この入力を図にすると、以下のようになります。 ![sample1-1](<a href="https://atcoder.jp/img/arc071/aec4d5cc2e5c73dbee455be237a649a5.png">https://atcoder.jp/img/arc071/aec4d5cc2e5c73dbee455be237a649a5.png</a>) 長方形 A,B,…,I それぞれの面積を合計すると $ 60 $ になります。 ![sample1-2](<a href="https://atcoder.jp/img/arc071/f0771c0f7e68af2b00e7513186f585ff.png">https://atcoder.jp/img/arc071/f0771c0f7e68af2b00e7513186f585ff.png</a>)</p></blockquote><h2 id="思路">思路</h2><p>一开始想的是枚举可能有多少种排列方式（构成整个大矩形），然后统计输出即可，但是好像不合题意？</p><p>思路参考自：[【题解】AT2394 <a href="https://www.luogu.com.cn/article/wlvi5bx0">ARC071B] 井井井 / ### - 洛谷专栏 (luogu.com.cn)</a></p><p>可以将线段分解成相邻两直线之间的距离，如$x_i-x_{i-1}$，那么只需要枚举左右端点：$(i-1)*(n-i+1)$。</p><p>就可以得到所有的情况$(x_i-x_{i-1})<em>(i-1)</em>(n-i+1)$。同理$y$也是如此。最后$sumx*sumy$即为答案，注意不要忘记取模。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll x[MAXN],y[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sumx=<span class="number">0</span>,sumy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)sumx=(sumx+(x[i]-x[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(n-i+<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)sumy=(sumy+(y[i]-y[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(m-i+<span class="number">1</span>))%mod;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(sumx*sumy)%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC057</title>
      <link href="/2024/03/24/ABC057/"/>
      <url>/2024/03/24/ABC057/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC057">ABC057</h1><blockquote><h1 id="ABC057C-Digits-in-Multiplication">[ABC057C] Digits in Multiplication</h1><h2 id="题面翻译">题面翻译</h2><p>对于两个正整数A和B，将F ( A，B )定义为以下两者中较大的一个: max（A的位数，B的位数） 例如，F ( 3，11 ) = 2，因为3有一位，11有两位。</p><p>给你一个整数n 求F ( A，B )的最小值为 使得 N = A×B</p><p>输入 n</p><p>输出 min f(a,b)</p><p>感谢@chengni 提供的翻译</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。<br>ここで、$ 2 $ つの正の整数 $ A,B $ に対して、$ F(A,B) $ を「$ 10 $ 進表記における、$ A $ の桁数と $ B $ の桁数のうち大きい方」と定義します。<br>例えば、$ F(3,11) $ の値は、$ 3 $ は $ 1 $ 桁、$ 11 $ は $ 2 $ 桁であるため、$ F(3,11)=2 $ となります。<br>$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くとき、$ F(A,B) $ の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くときの $ F(A,B) $ の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000003</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9876543210</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^{10} $</li><li>$ N $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ (A,B)=(100,100) $ のときに $ F(A,B) $ は最小値をとるため、$ F(100,100)=3 $ を出力します。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>条件を満たす $ (A,B) $ の組は $ (1,1000003) $ と $ (1000003,1) $ の $ 2 $ 通りで、$ F(1,1000003)=F(1000003,1)=7 $ です。</p></blockquote><h2 id="思路">思路</h2><p>不难想到，最小值与平方根有关，所以我们可以求出平方根，然后选出较大的数。分解位数并统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll d=(ll)<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    ll num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//选出较大的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            num=n/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分解数位并统计</span></span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC057D-Maximum-Average-Sets">[ABC057D] Maximum Average Sets</h1><h2 id="题面翻译-2">题面翻译</h2><p>有n个数，可以选取最少A个最多B个，使得所选的数的平均值最大。求可能的最大平均值 和 在平均值最大的情况下的方案数</p><h2 id="题目描述-2">题目描述</h2><p>$ N $ 個の品物が与えられます。<br>$ i $ 番目の品物の価値は $ v_i\ (1≦i≦N) $ です。<br>これらの品物から、$ A $ 個以上、$ B $ 個以下を選ばなければなりません。<br>この制約下において、選んだ品物の価値の平均の最大値を求めてください。<br>また、選んだ品物の平均が最大となるような品物の選び方が何通りあるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ v_1 $ $ v_2 $ $ … $ $ v_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>解答を $ 2 $ 行に出力せよ。<br>$ 1 $ 行目には、選んだ品物の価値の平均の最大値を出力せよ。絶対誤差または相対誤差が $ 10^{−6} $ 以下ならば正解となる。<br>$ 2 $ 行目には、選んだ品物の平均が最大となるような品物の選び方の数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2 2</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.500000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 3</span><br><span class="line">10 20 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15.000000</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">1000000000000000 999999999999999 999999999999998 999999999999997 999999999999996</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000.000000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50 1 50</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.000000</span><br><span class="line">1125899906842623</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦50 $</li><li>$ 1≦A≦B≦N $</li><li>$ 1≦v_i≦10^{15} $</li><li>$ v_i $ は全て整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 4 $ 番目の品物と $ 5 $ 番目の品物を選ぶと価値の平均が最大となるため、出力の $ 1 $ 行目は $ 4.5 $ です。 また、それ以外の品物の選び方で価値の平均が $ 4.5 $ になるものはないため、出力の $ 2 $ 行目は $ 1 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>価値の平均が最大となる品物の選び方は複数存在することがあります。</p></blockquote><h2 id="思路-2">思路</h2><p>显然，选取最大的A个数，再往下选均值只会越来越小。</p><p>方案数只与临界值有关，其他更大的肯定被选了。</p><p>注意考虑临界情况，可能在最大的A个数后面还存在若干个数与临界值相等，所以利用排列组合计算方案。</p><p>但是还有一种特殊情况，就是最大值与临界值相等，所以不一定只选A个，还可能选A+1、A+2个等等。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll n,a,b,num;</span><br><span class="line">ll v[MAXN];</span><br><span class="line">ll C[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="comment">//组合数预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选出最大的A个数</span></span><br><span class="line">    <span class="built_in">sort</span>(v+<span class="number">1</span>,v+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;(<span class="type">double</span>)ans/a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计n个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计a个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最大值与临界值相等，那么最多可以选择b个</span></span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">1</span>]==v[a])&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=a;i&lt;=b;i++)&#123;</span><br><span class="line">            num+=C[cnt1][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        num=C[cnt1][cnt2];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC056</title>
      <link href="/2024/03/24/ABC056/"/>
      <url>/2024/03/24/ABC056/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC056">ABC056</h1><blockquote><h1 id="ABC056C-Go-Home">[ABC056C] Go Home</h1><h2 id="题面翻译">题面翻译</h2><p>在0秒的时候有一只袋鼠在左右无限长的数轴上的原点上。在i-1到i的时间内，袋鼠可以选择不动，也可以向任意方向跳i个单位长度。也就是说，如果袋鼠在坐标x，时间i-1到i的时候，可以存在x-i,x,x+i三点之中。袋鼠的家在坐标X。袋鼠想尽快移动到它家。求袋鼠到达家的时间的最小值。</p><p>输入格式：</p><p>输入由标准输入以下列格式给出：$ X $</p><p>输出：</p><p>袋鼠到达坐标的最早时间</p><h2 id="题目描述">题目描述</h2><p>無限に左右に伸びている数直線上の $ 0 $ の地点に時刻 $ 0 $ にカンガルーがいます。 カンガルーは時刻 $ i-1 $ から $ i $ にかけて、なにもしないか、もしくは長さがちょうど $ i $ のジャンプを、左右どちらかの方向を選んで行えます。 つまり、時刻 $ i-1 $ に座標 $ x $ にいたとすると、時刻 $ i $ には $ x-i $, $ x $, $ x+i $ のどれかに存在することが出来ます。 カンガルーの家は座標 $ X $ にあります。カンガルーはできるだけ早く座標 $ X $ まで移動しようとしています。 カンガルーが座標 $ X $ に到着する時刻の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $</p></blockquote><h2 id="输出格式">输出格式</h2><p>カンガルーが座標 $ X $ に到着する時刻の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ X $ は整数</li><li>$ 1≦X≦10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 3 $ 回右にジャンプすると時刻 $ 3 $ に家にたどり着けて、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>時刻 $ 0 $ にはなにもせず、時刻 $ 1 $ に右にジャンプすることで時刻 $ 2 $ に家にたどり着けます。</p></blockquote><h2 id="思路">思路</h2><p>可以发现，一直往前跳，肯定跳得是最多的，所以我们采取贪心想法，一直跳，直到超过范围即可结束。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//ans记录的是时间</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i记录的是跳过的路程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        i+=ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC056D-No-Need">[ABC056D] No Need</h1><h2 id="题面翻译-2">题面翻译</h2><p>给出一个由 $N$ 个整数构成的集合和一个整数 $K$，若该集合中的的非空子集和大于等于 $K$，则称该子集为优秀的集合</p><p>若所有包含这个数的优秀子集去掉该数后仍然是优秀集合，则称该数字为“可有可无的数字”。</p><p>请求出在 $N$ 个数中“可有可无的数字”个数。</p><h2 id="题目描述-2">题目描述</h2><p>シカのAtCoDeerくんは正整数が書かれたカードを $ N $ 枚持っています。$ i(1≦i≦N) $ 枚目に書かれている数は $ a_i $ です。 AtCoDeerくんは大きい数が好きなので、カードに書かれた数の総和が $ K $ 以上になるようなカードの部分集合を<em>よい集合</em>と呼びます。</p><p>そして、各カード $ i $ に対して、そのカードが<em>不必要</em>かどうかを次のように判定します。</p><ul><li>「カード $ i $ を含む任意の<em>よい集合</em>に対して、その集合からカード $ i $ を除いたものも<em>よい集合</em>」 ならカード $ i $ は<em>不必要</em></li><li>それ以外の場合は、<em>不必要</em>でない</li></ul><p>不必要なカードの枚数を求めてください。ただし、それぞれの判定は独立に行われ、不必要だからと言ってカードが途中で捨てられたりすることはありません。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>不必要なカードの枚数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1 4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 400</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 20</span><br><span class="line">10 4 3 10 25 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力は全て整数</li><li>$ 1≦N≦5000 $</li><li>$ 1≦K≦5000 $</li><li>$ 1≦a_i≦10^9\ (1≦i≦N) $</li></ul><h3 id="部分点">部分点</h3><ul><li>$ N,K≦400 $ を満たすデータセットに正解した場合は、部分点として $ 300 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>よい集合は {$ 2,3 $} と {$ 1,2,3 $} の二つです。 カード $ 1 $ を含むよい集合は {$ 1,2,3 $} しかなく、これから $ 1 $ を取り除いた {$ 2,3 $} もよい集合なので、カード $ 1 $ は不必要です。 また、よい集合である {$ 2,3 $} から $ 2 $ を取り除いた集合 {$ 3 $} はよい集合ではないため、カード $ 2 $ は不必要ではありません。 カード $ 3 $ も同様に不必要ではないため、答えは $ 1 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>この場合よい集合は存在しないため、全てのカードは不必要となります。</p></blockquote><h2 id="思路-2">思路</h2><p>直接算可有可无的，似乎有点困难，所以算那些是必须的。不难想到，只要一个数本身大于$k$，那么他就是必须的，所以可以先排个序，那些大于$k$的数肯定不是可有可无的。</p><p>接下来就是进行判断了：怎么判断一个数是不是必须的呢？我们不妨假设$x$是必须的，那么设原有的和为$sum$，则$sum&lt;k$且$sum+x\geq k$必成立。</p><p>那么我们不妨枚举一下$sum$，然后进行判断（可以用$DP$解决）。</p><p>设$dp[i]$表示的是当总和为$i$时，是否符合大于$k$，$0$表示不合法，$1$表示合法。并对此进行状态转移，具体看看代码。</p><p>思路参考自：[题解 AT2346【<a href="https://www.luogu.com.cn/article/qo9lzcig">ARC070B] No Need】 - 洛谷专栏 (luogu.com.cn)</a></p><p>​                       [题解 <a href="https://www.luogu.com.cn/article/g80jpt1t">ABC056D] No Need - 洛谷专栏 (luogu.com.cn)</a></p><p>题解区还有一些有趣的写法：[AT_arc070_b <a href="https://www.luogu.com.cn/problem/solution/AT_arc070_b">ABC056D] No Need - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">bool</span> dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意初始化</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//a[i]&gt;=k，更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=k)cnt=i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举不合法的总和，并枚举对应可能的a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//如果dp[j]合法且j+a[i]&gt;=k,说明i不是必须的</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;j+a[i]&gt;=k)cnt=i;</span><br><span class="line">            <span class="comment">//如果dp[j]是合法的，则dp[j+a[i]]也是合法的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[j])dp[j+a[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC055</title>
      <link href="/2024/03/24/ABC055/"/>
      <url>/2024/03/24/ABC055/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC055">ABC055</h1><blockquote><h1 id="ABC055D-Menagerie">[ABC055D] Menagerie</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>Snuke，一个喜欢动物的人，建立了一个动物园。</p><p>一共有n个动物在动物园中，编号 $1-n$ ，被按顺序围成一个圈。</p><p>有两种动物：诚实的羊只说真话，不诚实的狼只说假话。</p><p>Snuke无法区别这两种动物，他问每只动物以下问题：“你旁边的两只动物是同一种吗？”第i只动物的答案为 $Si$ 。如果 $Si$ 为“o”，则表示相同，“x”则相反。</p><p>此外，若羊回答“o”，相邻的生物则都是羊或都是狼，而“x”则相反。若狼回答“x”，相邻的生物则都是羊或狼，而“o”则相反。</p><p>Snuke想知道是否有一种可行的排列方式。如果有，输出这种排列。如果没有，则输出“-1”。</p><p>注：“S”表示羊，“W”表示狼。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんは動物が好きなので動物園を作りました。</p><p>この動物園では $ 1,2,3,\ …,\ N $ の番号を割り振られた $ N $ 匹の動物が円環状に並べられています。 $ i\ (2≦i≦N-1) $ 番の動物は $ i-1 $ 番の動物と $ i+1 $ 番の動物と隣り合っています。また、$ 1 $ 番の動物は $ N $ 番の動物と $ 2 $ 番の動物と隣り合っており、$ N $ 番の動物は $ N-1 $ 番の動物と $ 1 $ 番の動物と隣り合っています。</p><p>動物園には本当のことしか言わない正直者の羊と、嘘しか言わない嘘つきの狼の 2 種類の動物がいます。</p><p>すぬけくんには羊と狼の区別がつかないので、それぞれの動物に両隣の動物が同じ種類かどうかを訪ねたところ、$ i $ 番目の動物は $ s_i $ と答えました。$ s_i $ が <code>o</code> ならば両隣の動物が同じ種類であると、<code>x</code> ならば異なる種類であると $ i $ 番の動物が言ったことを示します。</p><p>より形式的には、羊は両隣の動物がどちらも羊あるいはどちらも狼のとき <code>o</code> と答え、そうでないとき <code>x</code> と答えます。 狼は両隣の動物がどちらも羊あるいはどちらも狼のとき <code>x</code> と答え、そうでないとき <code>o</code> と答えます。</p><p>これらの回答結果と矛盾しないような各動物の種別の割り当てが存在するか、すぬけくんは気になっています。存在するならば一例を示し、存在しないならば <code>-1</code> を出力しなさい。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ s $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ s $ と矛盾しないような各動物の種類の割当てが存在しないならば <code>-1</code> を出力してください。 存在するならば以下の形式で文字列 $ t $ を出力してください。 $ t $ で示される割り当てが $ s $ と矛盾しないならば正解となります。</p><ul><li>$ t $ は長さ $ N $ で <code>S</code> と <code>W</code> のみからなる文字列</li><li>$ t_i $ が <code>S</code> ならば $ i $ 番の動物が羊であることを、<code>W</code> ならば狼であることを示す</li></ul><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">ooxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSSWWS</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">oox</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">oxooxoxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSWWSSSWWS</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 3\ ≦\ N\ ≦\ 10^{5} $</li><li>$ s $ は <code>o</code> と <code>x</code> のみからなる長さ $ N $ の文字列</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>例えば $ 1,2,3,4,5,6 $ 番の動物がそれぞれ羊、羊、羊、狼、狼、羊であるとき発言と矛盾しません。その他、狼、羊、狼、羊、狼、狼であるようなときも矛盾しません。 両隣が同じ種類の動物のとき羊は <code>o</code> と発言し、狼は <code>x</code> と発言すること、 両隣が異なる種類の動物のとき羊は <code>x</code> と発言し、狼は <code>o</code> と発言することに注意してください。 ![b34c052fc21c42d2def9b98d6dccd05c.png](<a href="https://atcoder.jp/img/arc069/b34c052fc21c42d2def9b98d6dccd05c.png">https://atcoder.jp/img/arc069/b34c052fc21c42d2def9b98d6dccd05c.png</a>)</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>存在しない場合は <code>-1</code> を出力してください。</p></blockquote><h2 id="思路">思路</h2><p>思路转载自：[AT_arc069_b <a href="https://www.luogu.com.cn/article/6yhy8dr1">ABC055D] Menagerie 题解 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>我们只要知道了前两个动物的种类，就可以推出所有动物的种类。那么思路就是，枚举前两个动物的种类即可。</p><p>但如果每种情况都讨论的话未免太复杂，所以我们考虑一种简化方法。</p><table><thead><tr><th>前两个动物的种类</th><th>第 22 个动物的回答</th><th>第 33 个动物的种类</th></tr></thead><tbody><tr><td>SS</td><td>o</td><td>S</td></tr><tr><td>SS</td><td>x</td><td>W</td></tr><tr><td>SW</td><td>o</td><td>W</td></tr><tr><td>SW</td><td>x</td><td>S</td></tr><tr><td>WS</td><td>o</td><td>W</td></tr><tr><td>WS</td><td>x</td><td>S</td></tr><tr><td>WW</td><td>o</td><td>S</td></tr><tr><td>WW</td><td>x</td><td>W</td></tr></tbody></table><p>找规律得：如果设$S=1,W=0,o=1，x=0$，则第三个动物种类为$(a_2+b_1+b_2)mod\ 2$，可以得到递推式：<br>$$<br>b_i=(b_{i-1}+b_{i-2}+a_{i-1})mod\ 2<br>$$<br>推出所有动物的种类之后，还要进行验证，第一、二个动物再往前两个在环的情况下是否一样，需要特判。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">bool</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="comment">//b数组代表的是动物种类，a数组代表的是第i个动物说的话是真是假</span></span><br><span class="line"><span class="comment">//判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>]=x,b[<span class="number">2</span>]=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=(a[i<span class="number">-1</span>]+b[i<span class="number">-1</span>]+b[i<span class="number">-2</span>])%<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里需要特判推导出来的1、2是否与实际一致</span></span><br><span class="line">    <span class="keyword">if</span>((b[<span class="number">1</span>]==(a[n]+b[n]+b[n<span class="number">-1</span>])%<span class="number">2</span>)&amp;&amp;(b[<span class="number">2</span>]==(a[<span class="number">1</span>]+b[<span class="number">1</span>]+b[n])%<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i])cout&lt;&lt;<span class="string">&quot;S&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;W&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="comment">//进行初始化，如果为o，初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=(s[i]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举1、2号动物所有可能情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC054</title>
      <link href="/2024/03/24/ABC054/"/>
      <url>/2024/03/24/ABC054/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC054">ABC054</h1><blockquote><h1 id="ABC054B-Template-Matching">[ABC054B] Template Matching</h1><h2 id="题面翻译">题面翻译</h2><p>给与纵N行，横N N列像素排列了的图像A，纵M行，横M M列像素排列了的模板图像B。</p><p>像素是构成图像的最小单位，其中1×1×1的正方形。</p><p>另外，给定的图像全部是二值图像，各像素的颜色用白和黑两种表示。</p><p>在输入中，全部的像素用文字表示，.白色的像素，#与黑色的像素对应。图像A由N N个字符串A_1、…、A_N A 1、…、A_N A N表示。字符串A_i Ai</p><p>的j j字符目对应于图像A上第i i、从左边第j j j个像素。(1≤i，j≤N) (1≤i，j≤N)同样，模板图像B由M M个字符串B_1，…，B_M B 1，…，B M M M表示。字符串B_i B i的j j j字符目对应于模板图像B上第i i、从左边第j j j的像素。(1≤i,j≤M) (1≤i,j≤M)</p><p>当仅允许图像平行移动时，请确定模板图像B是否包含在图像A中。</p><h2 id="题目描述">题目描述</h2><p>縦 $ N $ 行、横 $ N $ 列に画素が並んだ画像Aと、縦 $ M $ 行、横 $ M $ 列に画素が並んだテンプレート画像Bが与えられます。<br>画素は画像を構成する最小単位であり、ここでは $ 1×1 $ の正方形とします。<br>また、与えられる画像は全て2値画像であり、各画素の色は白と黒の2種類で表されます。</p><p>入力において、全ての画素は文字で表されており、<code>.</code>は白色の画素、 <code>#</code> は黒色の画素に対応します。<br>画像Aは $ N $ 個の文字列 $ A_1,…,A_N $ で表されます。<br>文字列 $ A_i $ の $ j $ 文字目は、画像Aの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦N) $<br>同様に、テンプレート画像Bは $ M $ 個の文字列 $ B_1,…,B_M $ で表されます。<br>文字列 $ B_i $ の $ j $ 文字目は、テンプレート画像Bの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦M) $</p><p>画像の平行移動のみ許されるとき、テンプレート画像Bが画像Aの中に含まれているかを判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ A_1 $ $ A_2 $ $ : $ $ A_N $ $ B_1 $ $ B_2 $ $ : $ $ B_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>画像Aの中にテンプレート画像Bを含む場合は <code>Yes</code>、含まない場合は <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">#.</span><br><span class="line">.#</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦M≦N≦50 $</li><li>$ A_i $ は <code>#</code> と <code>.</code> からなる長さ $ N $ の文字列</li><li>$ B_i $ は <code>#</code> と <code>.</code> からなる長さ $ M $ の文字列</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>テンプレート画像Bが、画像A中の左上の $ 2\ ×\ 2 $ の部分画像と右下の $ 2\ ×\ 2 $ の部分画像に一致するため、<code>Yes</code> と出力します。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>画像Aは白色の画素、テンプレート画像Bは黒色の画素で構成されるため、含まれることはありません。</p></blockquote><h2 id="思路">思路</h2><p>直接从矩形的左上角开始暴力匹配即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a[<span class="number">55</span>],b[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//思路，从左上角开始暴力匹配即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+x<span class="number">-1</span>][j+y<span class="number">-1</span>]!=b[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]=<span class="string">&quot; &quot;</span>+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;b[i],b[i]=<span class="string">&quot; &quot;</span>+b[i];</span><br><span class="line">    <span class="comment">//从左上角开始暴力匹配，注意范围</span></span><br><span class="line">    <span class="comment">//如果合法，cout&lt;&lt;&quot;YES&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-m+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC054C-One-stroke-Path">[ABC054C] One-stroke Path</h1><h2 id="题面翻译-2">题面翻译</h2><h4 id="题目描述-2">题目描述</h4><p>给定一个没有重边和自环的 $N$ 个点 $M$ 条边的无权无向图，第 $i$ 条边连接顶点 $a _ i$ 和 $b _ i$。</p><p>求以顶点 $1$ 为起点，只访问 $1$ 次所有顶点的路径有多少条？特别地，起点和终点也视为被访问。</p><h4 id="输入格式-2">输入格式</h4><p>第一行两个整数 $N, M$。</p><p>接下来 $m$ 行，其中第 $i$ 行两个整数 $a _ i, b _ i$。</p><p>$<br>N M \<br>a _ 1 b _ 1 \<br>a _ 2 b _ 2 \<br>\kern {0.667 em} \vdots \<br>a _ M b _ M<br>$</p><h4 id="输出格式-2">输出格式</h4><p>输出满足条件的路径有多少。</p><h4 id="数据范围">数据范围</h4><p>$<br>2 \le N \le 8 \<br>0 \le M \le N(N - 1) \<br>1 \le a _ i &lt; b _ i \le N<br>$</p><p>给定的无向图中不包含重边和自环。</p><h2 id="题目描述-3">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $ 辺の重み無し無向グラフが与えられます。<br>$ i\ (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。<br>ここで、自己ループは $ a_i\ =\ b_i\ (1≦i≦M) $ となる辺のことを表します。<br>また、二重辺は $ a_i=a_j $ かつ $ b_i=b_j\ (1≦i\ &lt;\ j≦M) $ となる辺のことを表します。<br>頂点 $ 1 $ を始点として、全ての頂点を1度だけ訪れるパスは何通りありますか。<br>ただし、パスの始点と終点の頂点も訪れたものとみなします。</p><p>例として、図1のような無向グラフが与えられたとします。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/5764771c0b3041c3346efe47c98edb49c94a9b3d.png" alt="">図1：無向グラフの例</p><p>このとき、図2で表されるパスは条件を満たします。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/7f5174784cef5e6da48aed9eeb9756a6de9199db.png" alt="">図2：条件を満たすパスの例</p><p>しかし、図3で表されるパスは条件を満たしません。全ての頂点を訪れていないからです。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad6e861039122f07481a4ef820a2461de4e5e54c.png" alt="">図3：条件を満たさないパスの例1</p><p>また、図4で表されるパスも条件を満たしません。始点が頂点 $ 1 $ ではないからです。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad37aa02ed59054ab7ef974821bffd978f95285d.png" alt="">図4：条件を満たさないパスの例2</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ : $ $ a_M $ $ b_M $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>問題文の条件を満たすパスが何通りあるか出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">2 7</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2≦N≦8 $</li><li>$ 0≦M≦N(N-1)/2 $</li><li>$ 1≦a_i\ &lt;\ b_i≦N $</li><li>与えられるグラフは自己ループと二重辺を含まない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>与えられるグラフは以下の図で表されます。 ![43c0ac53de20d989d100bf60b3cd05fa.png](<a href="https://atcoder.jp/img/5013/43c0ac53de20d989d100bf60b3cd05fa.png">https://atcoder.jp/img/5013/43c0ac53de20d989d100bf60b3cd05fa.png</a>) 条件を満たすパスは以下の $ 2 $ 通りです。 ![c4a27b591d364fa479314e3261b85071.png](<a href="https://atcoder.jp/img/5013/c4a27b591d364fa479314e3261b85071.png">https://atcoder.jp/img/5013/c4a27b591d364fa479314e3261b85071.png</a>)</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>このテストケースは問題文の例と同じです。</p></blockquote><h2 id="思路-2">思路</h2><p>范围很小，直接DFS即可，记录从1开始能否访问所有顶点的路径数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">bool</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x是当前所在的点，cnt是当前统计的经过点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意标记</span></span><br><span class="line">    b[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])&#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(b[to])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//这里写cnt+1，不要写cnt++</span></span><br><span class="line">        <span class="built_in">dfs</span>(to,cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    b[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC054D-Mixing-Experiment">[ABC054D] Mixing Experiment</h1><h2 id="题面翻译-3">题面翻译</h2><hr><h2 id="题目描述：">题目描述：</h2><p>有 $N$ 个物体，第 $i$ 个物体含有 $a_i$ 质量的 A 元素 和 $b_i$ 质量的 B 元素，代价为 $c_i$ 。</p><p>问能否取若干个物体，使 A 元素与 B 元素质量之比为 $M_a : M_b$ ，并使代价最小。</p><hr><h2 id="输入格式-4">输入格式:</h2><p>第一行3个整数 $N ,M_a ,M_b$</p><p>下面 $N$ 行，每行3个整数 $a_i ,b_i ,c_i$</p><p>$ N $   $ M_a $   $ M_b $<br>$ a_1 $   $ b_1 $   $ c_1 $<br>$ a_2 $   $ b_2 $   $ c_2 $</p><p>$ : $<br>$ a_N $   $ b_N $   $ c_N $</p><hr><h2 id="输出格式：">输出格式：</h2><p>若能满足条件则输出 <strong>最小代价</strong>。</p><p>否则输出 -1</p><hr><h2 id="数据范围：">数据范围：</h2><ul><li><p>$1\le N\le 40$</p></li><li><p>$1\le a_i,b_i\le 10$</p></li><li><p>$1\le c_i\le 100$</p></li><li><p>$1\le M_a,M_b\le 10$</p></li><li><p>$gcd(M_a,M_b)=1$</p></li><li><p>输入都为整数。</p></li></ul><hr><p>translated by @君のNOIP。</p><h2 id="题目描述-4">题目描述</h2><p>イルカは、微量の物質Cを生成したいと考えています。<br>物質Cを生成するためには、タイプAの物質とタイプBの物質の混合比が $ M_a:M_b $ となる溶液を用意する必要があります。<br>しかし、イルカは薬品を1つも持っていないため、薬局へ薬品を買いに行くことにしました。<br>薬局では、$ N $ 種類の薬品を取り扱っており、各薬品 $ i $ の在庫はちょうど1つです。<br>各薬品 $ i $ は、タイプAの物質 $ a_i $ グラム、タイプBの物質 $ b_i $ グラム含んでおり、価格 $ c_i $ 円で売られています。<br>イルカは、いくつかの薬品を薬局で買います。買った薬品は全て使わなければなりません。<br>物質Cを生成するために、必要な最小予算を求めてください。<br>薬局で売られている薬品の組み合わせで、物質Cを生成できない場合はそれを報告してください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M_a $ $ M_b $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_N $ $ b_N $ $ c_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>物質Cを生成するために必要な最小予算を出力せよ。物質Cを生成できない場合には <code>-1</code> を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 1</span><br><span class="line">1 2 1</span><br><span class="line">2 1 2</span><br><span class="line">3 3 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 10</span><br><span class="line">10 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦40 $</li><li>$ 1≦a_i,b_i≦10 $</li><li>$ 1≦c_i≦100 $</li><li>$ 1≦M_a,M_b≦10 $</li><li>$ gcd(M_a,M_b)=1 $</li><li>$ a_i $、$ b_i $、$ c_i $、$ M_a $、$ M_b $は整数である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>最小予算となる組み合わせは、薬品 $ 1 $ と薬品 $ 2 $ を混合する場合です。 この場合、混合した溶液中に物質Aは $ 3 $ グラム、物質Bは $ 3 $ グラム含まれており、混合比は $ 3:3=1:1 $ となって条件を満たします。 このときの合計価格は $ 3 $ 円となります。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>物質Aと物質Bの混合比が $ 1:10 $ となる薬品の組み合わせはないので、<code>-1</code>を出力します。</p></blockquote><h2 id="思路-3">思路</h2><p>很容易看出来这是一个01背包问题。</p><p>注意有两个维度：$dp[i][j]$表示$A$总质量为$i$，$B$总质量为$j$。由此可得状态转移方程，注意要倒序枚举。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m_a,m_b,suma,sumb;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m_a&gt;&gt;m_b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        suma+=a[i];</span><br><span class="line">        sumb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=suma;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sumb;j++)&#123;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ans存储答案</span></span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒序枚举，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=suma;i&gt;=a[k];i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sumb;j&gt;=b[k];j--)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i-a[k]][j-b[k]]+c[k]);</span><br><span class="line">                <span class="comment">//如果有满足合法比的情况，则更新答案</span></span><br><span class="line">                <span class="keyword">if</span>(i*m_b==j*m_a)ans=<span class="built_in">min</span>(ans,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC053</title>
      <link href="/2024/03/24/ABC053/"/>
      <url>/2024/03/24/ABC053/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC053">ABC053</h1><blockquote><h1 id="ABC053C-X-Yet-Another-Die-Game">[ABC053C] X: Yet Another Die Game</h1><h2 id="题面翻译">题面翻译</h2><p>一个骰子，初始的时候任意的一个面朝上，接下来每一轮可以翻转骰子到相邻的一面，并获得此面的得分（那一面的数值即是得分）。问至少要几轮才可以获得够 $x$ 分。</p><p><strong>注</strong>：所有数均在$longlong$范围内。</p><h3 id="输入格式">输入格式</h3><p>一个数 $x$ 。</p><h3 id="输出格式">输出格式</h3><p>输出也是一个数，即最少的轮数。</p><h2 id="题目描述">题目描述</h2><p>すぬけくんは $ 6 $ 面サイコロで遊ぶことにしました。 サイコロは $ 1 $ から $ 6 $ までの整数がそれぞれの面に書かれており、向かい合う面に書かれた数の和はどれも $ 7 $ です。</p><p>すぬけくんはサイコロの好きな面が上向きになるように置いたのち何回か以下の操作を行います。</p><ul><li>操作：サイコロを手前、奥、左、右のどれかの方向に $ 90° $ だけ回転させる。その後、上を向いている面に書かれた数を $ y $ として $ y $ 点得る。</li></ul><p>例えば、図のように $ 1 $ と書かれた面が上を向いており、手前側の面に $ 5 $ が、右側の面に $ 4 $ が書かれている状況を考えます。<br>図に示されるように右方向に回転させることで $ 3 $ と書かれた面が上を向くようにすることが可能です。 その他、左方向に回転させた場合は $ 4 $ と書かれた面が、手前方向に回転させた場合は $ 2 $ と書かれた面が、奥方向に回転させた場合は $ 5 $ と書かれた面が上を向くようにすることが可能です。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc068_a/853455ad24539a0166e2da8cad62831372eeae9b.png" alt="864abc2e4a08c26015ffd007a30aab03.png"></p><p>すぬけくんが合計で $ x $ 点以上得るために必要な最小の操作回数を求めなさい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ x $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">149696127901</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27217477801</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ x\ ≦\ 10^{15} $</li><li>$ x $ は整数</li></ul></blockquote><h2 id="思路">思路</h2><p>被题意误导了，其实大于$x$也是可以的</p><p>如果要步骤最少，我们可以6-5-6-5······，这样一路下来，就能得到最小的操作次数。</p><p>注意下面的一轮是按6-5算的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll x;cin&gt;&gt;x;</span><br><span class="line">    <span class="comment">//注意这里要乘上2</span></span><br><span class="line">    ll ans=(x/<span class="number">11</span>)*<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果恰好完成，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">11</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有，判断是否在0-6之间，如果是则加1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>&lt;=x%<span class="number">11</span>&amp;&amp;x%<span class="number">11</span>&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则加2</span></span><br><span class="line">    cout&lt;&lt;ans+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC053D-Card-Eater">[ABC053D] Card Eater</h1><h2 id="题面翻译-2">题面翻译</h2><p>有一堆牌，每张牌上有一个数字。 每次可以取出其中3张，丢掉数字最大的和数字最小的牌，把中间那张再放回牌堆。 要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんはカードゲームで遊ぶことにしました。 $ N $ 枚からなるカードの山があり、上から $ i $ 枚目のカードには整数 $ A_i $ が書かれています。</p><p>すぬけくんはこのカードの山に対し $ 0 $ 回以上、以下の操作を行い、残ったカードに書かれた値が互いに異なるようにしたいです。最大で何枚のカードを残すことが可能か求めなさい。なお、$ N $ は奇数であり、少なくとも $ 1 $ 枚のカードを残すことが可能であることが保証されます。</p><p>操作：カードの山から任意の $ 3 $ 枚のカードを抜き出す。抜き出したカードのうち書かれた値が最大であるようなカード $ 1 $ 枚と最小であるようなカード $ 1 $ 枚の合計 $ 2 $ 枚を選んで食べる。その後残った $ 1 $ 枚をカードの山に戻す。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ A_3 $ … $ A_{N} $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 3 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">1 3 5 2 1 3 2 8 8 6 2 6 11 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 3\ ≦\ N\ ≦\ 10^{5} $</li><li>$ N $ は奇数</li><li>$ 1\ ≦\ A_i\ ≦\ 10^{5} $</li><li>$ A_i $ は整数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>操作を $ 1 $ 回行って $ 1,1,2 $ を取り出すというのが最適な操作手順の $ 1 $ つです。最大値である $ 2 $ と書かれたカードで最小値である $ 1 $ と書かれたカードがそれぞれ $ 1 $ 枚ずつ食べられ、残った $ 1 $ と書かれたカードがカードの山に戻されます。カードの山に残っているカードは $ 1,3,7 $ となり、これらは互いに異なります。</p></blockquote><h2 id="思路-2">思路</h2><p>一个很好想的思路，可以统计一下有多少种牌的数量是大于1的（记作$cnt$），这样的话，他们之间就可以两两配对，这样可以避免减少卡牌的种类。</p><p>但是有特殊情况，如果$cnt$是奇数，说明会剩下一张重复的卡牌，所以我们不得不重新选出一张牌来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,a=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//记录重复的卡牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(m[a])cnt++;</span><br><span class="line">        <span class="keyword">else</span> m[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否可能无法配对</span></span><br><span class="line">    cnt+=cnt%<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC052</title>
      <link href="/2024/03/24/ABC052/"/>
      <url>/2024/03/24/ABC052/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC052">ABC052</h1><blockquote><h1 id="ABC052C-Factors-of-Factorial">[ABC052C] Factors of Factorial</h1><h2 id="题面翻译">题面翻译</h2><p>给定正整数 $N \left( 1\leq N \leq 10 ^3 \right)$ 求 $N!$ 的约数个数。结果对 $10^9 + 7$ 取模</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。 $ N! $ の正の約数の個数を $ 10^9+7 $ で割った余りを求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ N! $ の正の約数の個数を $ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">972926972</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^3 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 3! $ $ =6 $ です。$ 6 $ の正の約数は $ 1,2,3,6 $ の $ 4 $ 個なので、$ 4 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>需要一点点数论知识（可惜我没有）。</p><p>思路转载自：[<a href="https://www.luogu.com.cn/article/5yq3f4lw">题解] AT2286 [ARC067A] Factors of Factorial - 洛谷专栏 (luogu.com.cn)</a></p><p>若一个正整数$n&gt;1$，且可分解为一系列质因数的乘积：<br>$$<br>n=\prod \limits_{i=1}^k {p}^{a_i}<em>i<br>$$<br>则$n$约数的个数$f(n)$为：<br>$$<br>f(n)=\prod \limits</em>{i=1}^k(a_i+1)<br>$$<br>由于观察到数据并不大，$n\leq1000$，我们可以考虑从$1$到$n$，每乘到一个数时，都分解一次质因数，用一个$map$数组统计可分解的质因数个数。中间的每个数可以分解的质因数指数都加 1，到最后就统计出了$n!$的质因数分解形式。时间复杂度$O(n^2)$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="comment">//分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            n/=i;</span><br><span class="line">            <span class="comment">//进行统计</span></span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(p=m.<span class="built_in">begin</span>();p!=m.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">        ans=ans*(p-&gt;second+<span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC052D-Walk-and-Teleport">[ABC052D] Walk and Teleport</h1><h2 id="题面翻译-2">题面翻译</h2><p>在东西方向延伸的直线上，有N个城市。城市坐标按从西到东递增。</p><p>你现在在某个城市里，想去其他所有的城市。移动的方法有以下两种。</p><p>一，在直线上按东西方向平移，每移动一个单位距离疲劳值加A</p><p>二，直接瞬移到某个坐标，并且疲劳值加B</p><p>请使用以上两种方式直到去完其他所有的城市，并求出最小的疲劳值。</p><p><strong>输入输出格式</strong></p><p>输入格式：</p><p>第一行三个数,即N,A,B,</p><p>第二行N个数，即X[1],X[2]…,X[N]。</p><p>输出格式：</p><p>输出最小的疲劳值。</p><p><strong>说明</strong></p><p>2&lt;=N&lt;=1e5</p><p>1&lt;=Xi,A,B&lt;=1e9且X(i)&lt;X(i+1)</p><h2 id="题目描述-2">题目描述</h2><p>東西方向にのびる直線上に、$ N $ 個の町があります。 町には、西から順に $ 1 $ から $ N $ までの番号がついています。 直線上には座標が設定されていて、東に行くほど座標が大きくなります。 町 $ i $ の座標は $ X_i $ です。</p><p>あなたは今、町 $ 1 $ にいて、これからほかの全ての町を訪れたいです。 移動する手段は次の $ 2 $ 種類あります。</p><ul><li>直線上を歩いて移動する。 東西どちらに歩いても、$ 1 $ 移動する度に疲労度が $ A $ 上がります。</li><li>好きな場所へテレポートする。 テレポートをすると、移動した距離によらず疲労度が $ B $ 上がります。</li></ul><p>この $ 2 $ 種類の移動を繰り返して全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるか求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ X_1 $ $ X_2 $ $ … $ $ X_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるかを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 5</span><br><span class="line">1 2 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 100</span><br><span class="line">40 43 45 105 108 115 124</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">84</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 2</span><br><span class="line">24 35 40 68 72 99 103</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力は全て整数である</li><li>$ 2≦N≦10^5 $</li><li>$ 1≦X_i≦10^9 $</li><li>全ての $ i(1≦i≦N-1) $ について、$ X_i\ &lt;\ X_{i+1} $ が成り立つ</li><li>$ 1≦A≦10^9 $</li><li>$ 1≦B≦10^9 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>町 $ 1 $ から町 $ 2 $ まで $ 1 $ の距離歩いて移動したあと、町 $ 3 $ にテレポートし、そこから町 $ 4 $ まで $ 2 $ の距離歩いて移動すると、 疲労度の上昇値の合計が $ 2×1+5+2×2=11 $ になり、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>町 $ 1 $ から町 $ 7 $ まで歩き続けると、疲労度の上昇値の合計が $ 84 $ になり、これが最小です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>どのような順番でもよいので、$ 6 $ 回のテレポートで全ての町を訪れると、疲労度の上昇値の合計が $ 12 $ になり、これが最小です。</p></blockquote><h2 id="思路-2">思路</h2><p>一眼的贪心</p><p>题解区发现一篇奇怪的题解：[题解 AT2287 【<a href="https://www.luogu.com.cn/article/gs4bm7sp">ARC067B] Walk and Teleport】 - 洛谷专栏 (luogu.com.cn)</a>，可以看看。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> x[MAXN];</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a*(x[i]-x[i<span class="number">-1</span>])&lt;b)ans+=a*(x[i]-x[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">else</span> ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC051</title>
      <link href="/2024/03/24/ABC051/"/>
      <url>/2024/03/24/ABC051/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC051">ABC051</h1><blockquote><h1 id="ABC051B-Sum-of-Three-Integers">[ABC051B] Sum of Three Integers</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目描述">题目描述</h1><p>有两个整数 $K$ , $S$</p><p>求有几种方案使得三个非负整数 $X$ , $Y$ , $Z$ 之和= $S$ 并且均 $\leq K$</p><h1 id="输入格式">输入格式</h1><p>两个正整数 $K$ , $S$ , 见题目描述。</p><h1 id="输出格式">输出格式</h1><p>一个整数，表示方案数</p><h2 id="题目描述-2">题目描述</h2><p>$ 2 $ つの整数 $ K,S $ が与えられます。<br>$ 3 $ つの変数 $ X,Y,Z $ があり、$ 0≦X,Y,Z≦K $ を満たす整数の値を取ります。<br>$ X\ +\ Y\ +\ Z\ =\ S $ を満たす $ X,Y,Z $ への値の割り当ては何通りありますか。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ K $ $ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>問題文の条件を満たす $ X,Y,Z $ の組が何通りあるか出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2≦K≦2500 $</li><li>$ 0≦S≦3K $</li><li>$ K,S $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>問題文の条件を満たす $ X,Y,Z $ の組は以下の $ 6 $ 通りです。 - $ X\ =\ 0,\ Y\ =\ 0,\ Z\ =\ 2 $ - $ X\ =\ 0,\ Y\ =\ 2,\ Z\ =\ 0 $ - $ X\ =\ 2,\ Y\ =\ 0,\ Z\ =\ 0 $ - $ X\ =\ 0,\ Y\ =\ 1,\ Z\ =\ 1 $ - $ X\ =\ 1,\ Y\ =\ 0,\ Z\ =\ 1 $ - $ X\ =\ 1,\ Y\ =\ 1,\ Z\ =\ 0 $</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>$ X\ +\ Y\ +\ Z $ の最大値は $ 15 $ であり、それを満たす組は $ 1 $ 通りです。</p></blockquote><h2 id="思路">思路</h2><p>直接枚举不行，所以我们可以只要枚举X，Y，然后判断是否存在符合要求的Z即可，注意X,Y,Z的范围</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> k,s;cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j&lt;=s&amp;&amp;s-j-i&lt;=k)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC051C-Back-and-Forth">[ABC051C] Back and Forth</h1><h2 id="题面翻译-2">题面翻译</h2><p>在平面直角坐标系中，有点 $A（sx,sy）$ 和 点 $B（tx,ty）$ 保证 $sx&lt;tx$，$sy&lt;ty$ 并且 $sx,sy,tx,ty$ 都为整数。</p><p>在 $A$ 点有一只海豚，它每次可以向上下左右其中一个方向移动一个单位长度。这只海豚想从 $A$ 点到 $B$ 点再回到 $A$ 点再到 $B$ 点再回到 $A$ 点。</p><p>要求：除了 $A,B$ 点以外，所有格点都不能走第二遍。海豚不能斜着走。</p><p>输出一个字符串 <code>S</code> 表示海豚的最短路径，<br><code>S</code> 中只包括 $U,R,D,L$。</p><ul><li>$U$：向上走一个单位长度。</li><li>$R$：向右走一个单位长度。</li><li>$D$：向下走一个单位长度。</li><li>$L$：向左走一个单位长度。</li></ul><h1 id="输入格式：">输入格式：</h1><p>一行，$sx,sy,tx,ty$。</p><h1 id="输出格式：">输出格式：</h1><p>一行，字符串 <code>S</code>。</p><p>如果有多个最短路径，输出其中任意一个。</p><p>Translate by @sqh_let_it_be</p><h2 id="题目描述-3">题目描述</h2><p>イルカは $ x $ 軸正方向を右、$ y $ 軸正方向を上とする 2 次元座標平面にいます。<br>イルカは現在点 $ (sx,sy) $ にいて、$ 1 $ 秒あたり上下左右に距離 $ 1 $ だけ進むことができます。<br>このとき、移動前と移動後の $ x $ 座標、$ y $ 座標はともに整数でなければなりません。<br>イルカはここから $ sx\ と\ sy\ を満たす点\ (tx,ty) $ に行き、その後点 $ (sx,sy) $ に戻り、また点 $ (tx,ty) $ に行き、その後点 $ (sx,sy) $ に戻ります。<br>このとき、イルカは点 $ (sx,sy) $ と点 $ (tx,ty) $ を除いて、途中で同じ座標を複数回通らないように移動しなければなりません。<br>このような条件を満たすイルカの最短経路を $ 1 $ つ求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ sx $ $ sy $ $ tx $ $ ty $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>イルカの最短経路を表す文字列 $ S $ を出力せよ。<br>$ S $ の $ i $ 番目の文字はイルカの $ i $ 番目の移動を表す。<br>イルカの各方向への移動を表す文字の対応関係は以下のとおりである。</p><ul><li><code>U</code>: 上方向</li><li><code>D</code>: 下方向</li><li><code>L</code>: 左方向</li><li><code>R</code>: 右方向</li></ul><p>条件を満たすような最短経路が複数ある場合、そのうちどれか $ 1 $ つを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURDDLLUUURRDRDDDLLU</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2 -2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURRURRDDDLLDLLULUUURRURRDDDLLDL</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ -1000≦\ sx $</li><li>$ -1000≦\ sy $</li><li>$ sx,sy,tx,ty $ は整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>以下に示す移動経路が最短経路の $ 1 $ つです。 - $ 1 $ 回目の $ (sx,sy) $ から $ (tx,ty) $ への移動: $ (0,0) $ → $ (0,1) $ → $ (0,2) $ → $ (1,2) $ - $ 1 $ 回目の $ (tx,ty) $ から $ (sx,sy) $ への移動: $ (1,2) $ → $ (1,1) $ → $ (1,0) $ → $ (0,0) $ - $ 2 $ 回目の $ (sx,sy) $ から $ (tx,ty) $ への移動: $ (0,0) $ → $ (-1,0) $ → $ (-1,1) $ → $ (-1,2) $ → $ (-1,3) $ → $ (0,3) $ → $ (1,3) $ → $ (1,2) $ - $ 2 $ 回目の $ (tx,ty) $ から $ (sx,sy) $ への移動: $ (1,2) $ → $ (2,2) $ → $ (2,1) $ → $ (2,0) $ → $ (2,-1) $ → $ (1,-1) $ → $ (0,-1) $ → $ (0,0) $</p></blockquote><h2 id="思路-2">思路</h2><p>直接暴力模拟过程即可。</p><p>具体看大佬的图示：</p><p><img src="https://img2.imgtp.com/2024/03/24/t2daHxyP.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> sx,sy,tx,ty;cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;</span><br><span class="line">    <span class="type">int</span> x=tx-sx,y=ty-sy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DR&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC051D-Candidates-of-No-Shortest-Paths">[ABC051D] Candidates of No Shortest Paths</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个 $n$ 个点，$m$ 条边的无重边无自环的加权无向连通图，问全源最短路有几条边没被用到。</p><h2 id="题目描述-4">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $ 辺の重み付き無向連結グラフが与えられます。<br>$ i\ (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を距離 $ c_i $ で結びます。<br>ここで、自己ループは $ a_i\ =\ b_i\ (1≦i≦M) $ となる辺のことを表します。<br>また、二重辺は $ (a_i,b_i)=(a_j,b_j) $ または $ (a_i,b_i)=(b_j,a_j)\ (1≦i\ &lt;\ j≦M) $ となる辺のことを表します。<br>連結グラフは、どの異なる $ 2 $ 頂点間にも経路が存在するグラフのことを表します。<br>どの異なる $ 2 $ 頂点間の、どの最短経路にも含まれない辺の数を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_M $ $ b_M $ $ c_M $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>グラフ上の、どの異なる $ 2 $ 頂点間の、どの最短経路にも含まれない辺の数を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦N≦100 $</li><li>$ N-1≦M≦min(N(N-1)/2,1000) $</li><li>$ 1≦a_i,b_i≦N $</li><li>$ 1≦c_i≦1000 $</li><li>$ c_i $ は整数である。</li><li>与えられるグラフは自己ループと二重辺を含まない。</li><li>与えられるグラフは連結である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>この入力例で与えられるグラフにおける、全ての異なる $ 2 $ 頂点間の最短経路は以下の通りです。 - 頂点 $ 1 $ から頂点 $ 2 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 1 $ - 頂点 $ 1 $ から頂点 $ 3 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 1 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 3 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 2 $ - 頂点 $ 3 $ から頂点 $ 1 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 3 $ から頂点 $ 2 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 2 $ したがって、一度も最短経路として使用されていない辺は、頂点 $ 2 $ と頂点 $ 3 $ を結ぶ長さ $ 3 $ の辺のみであるため、$ 1 $ を出力します。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>全ての辺が異なる $ 2 $ 頂点間のある最短経路で使用されます。</p></blockquote><h2 id="思路-3">思路</h2><p>$n$只有100，所以直接用$Floyd$即可，再每次记录当前边有没有被松弛掉，如果是第一次松弛就$ans++$。</p><p>注意到是无向图，所以$ans$要除以二。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],ans;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">g[x][y]=g[y][x]=z,vis[x][y]=vis[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//记录边，并且给边打上标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]&gt;g[i][k]+g[k][j])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i][j])ans++,vis[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果是第一次松弛，ans++</span></span><br><span class="line">g[i][j]=g[i][k]+g[k][j];</span><br><span class="line">&#125;<span class="comment">//Floyd模板</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC050</title>
      <link href="/2024/03/22/ABC050/"/>
      <url>/2024/03/22/ABC050/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC050">ABC050</h1><blockquote><h1 id="ABC050B-Contest-with-Drinks-Easy">[ABC050B] Contest with Drinks Easy</h1><h2 id="题面翻译">题面翻译</h2><p>joisino 小姐姐即将参加某个编程比赛的决赛。在这个比赛中，准备了 $N$ 个问题，其中从 $1$ 到 $N$ 号码。我知道 joisino 小姐姐要解决问题 $i$（$1≤i≤N$）需要的时间是 $T_i$ 秒。</p><p>另外，在这个比赛中，提供M种不同的饮料，有 $1$~$M$ 的号码。如果喝了饮料 $i$（$1≤i≤M$） 的话，参赛者的大脑会被给予强烈的刺激，解决问题 $P_i$ 的时间是 $X_i$ 秒。问题之间的时间互不<br>影响。</p><p>每名参赛者在比赛开始前可以喝一瓶饮料。小姐姐joisino对于各自的饮料，想知道要解答所有的问题需要多少秒。解决所有问题的时间是解决各个问题的时间的总和。你的工作是为了帮助(取悦)小姐姐写一个程序。</p><h2 id="题目描述">题目描述</h2><p>joisinoお姉ちゃんは、あるプログラミングコンテストの決勝を控えています。 このコンテストでは、$ N $ 問の問題が用意されており、それらには $ 1～N $ の番号がついています。 joisinoお姉ちゃんは、問題 $ i(1≦i≦N) $ を解くのにかかる時間が $ T_i $ 秒であることを知っています。</p><p>また、このコンテストでは、$ M $ 種類のドリンクが提供されており、$ 1～M $ の番号がついています。 そして、ドリンク $ i(1≦i≦M) $ を飲むと、脳が刺激され、問題 $ P_i $ を解くのにかかる時間が $ X_i $ 秒になります。 他の問題を解くのにかかる時間に変化はありません。</p><p>コンテスタントは、コンテスト開始前にいずれかのドリンクを $ 1 $ 本だけ飲むことができます。 joisinoお姉ちゃんは、それぞれのドリンクについて、それを飲んだ際に、全ての問題を解くのに何秒必要なのかを知りたくなりました。 全ての問題を解くのに必要な時間とは、それぞれの問題を解くのにかかる時間の合計です。 あなたの仕事は、joisinoお姉ちゃんの代わりにこれを求めるプログラムを作成することです。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ T_2 $ $ … $ $ T_N $ $ M $ $ P_1 $ $ X_1 $ $ P_2 $ $ X_2 $ $ : $ $ P_M $ $ X_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>それぞれのドリンクについて、それを飲んだ際に全ての問題を解くのに必要な時間を求め、順番に $ 1 $ 行ずつ出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7 2 3 8 5</span><br><span class="line">3</span><br><span class="line">4 2</span><br><span class="line">1 7</span><br><span class="line">4 13</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br><span class="line">25</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>入力は全て整数である</li><li>$ 1≦N≦100 $</li><li>$ 1≦T_i≦10^5 $</li><li>$ 1≦M≦100 $</li><li>$ 1≦P_i≦N $</li><li>$ 1≦X_i≦10^5 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>一つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$ 1 $ 秒、$ 1 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 6 $ 秒が答えになり、$ 6 $ を出力します。 二つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$ 2 $ 秒、$ 3 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 9 $ 秒が答えになり、$ 9 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>其实求的就是喝下第$i$杯饮料后，总时间变为多少。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i],sum+=t[i];</span><br><span class="line">    <span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;sum-t[x]+y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC050C-Lining-Up">[ABC050C] Lining Up</h1><h2 id="题面翻译-2">题面翻译</h2><p>有编号为1-N号的N个人，他们都记得“自己左边排队的人数和自己右边排队的人数之差的绝对值”，根据他们的报告，给你i的「自己的左排列的人数和自己的右排列的人数的差的绝对值」Ai。<br>请根据他们的报告，求出原来的排列方法有几种。但是，因为答案有时候会变得很大，请对10^9+7取模 。另外，他们的报告可能有错误，没有可能的排列方法，此时请输出0。</p><p>范围：<br>$$<br>1≦N≦10^5;<br>0≦Ai≦N−1.<br>$$</p><h2 id="题目描述-2">题目描述</h2><p>$ 1～N $ までの番号がついた、$ N $ 人の人がいます。 彼らは昨日、ある順番で左右一列に並んでいましたが、今日になってその並び方が分からなくなってしまいました。 しかし、彼らは全員、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」を覚えています。 彼らの報告によると、人 $ i $ の、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」は $ A_i $ です。</p><p>彼らの報告を元に、元の並び方が何通りあり得るかを求めてください。 ただし、答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを出力してください。 また、彼らの報告が間違っており、ありうる並び方がないこともありえます。 その際は $ 0 $ を出力してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ … $ $ A_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>元の並び順としてありうるものが何通りあるか求め、$ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">6 4 0 2 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">7 5 1 1 7 3 5 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ 0≦A_i≦N-1 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ありうる並び方は、人の番号で書くと、 - $ 2,1,4,5,3 $ - $ 2,5,4,1,3 $ - $ 3,1,4,5,2 $ - $ 3,5,4,1,2 $ の $ 4 $ 通りです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>どのような並び方でも、報告と矛盾するので、$ 0 $ が答えになります。</p></blockquote><h2 id="思路-2">思路</h2><p>当初WA了好多发，不是忘记取模，就是WA了一个点qwq。</p><p>思路不难想，不过要注意分奇偶讨论。</p><p>注意到分布的值$A_i$应该具有对称性，所以对于每一个$A_i$值，它可能的个数就只能是0或2（除了为奇数情况时，0值只有一个，其他情况没有0值）。</p><p>所以我们只需要分奇偶讨论，然后判断即可。</p><p>注意到范围很大，所以可以用快速幂优化一下（我也不知道没有快速幂会不会喜提$TLE$）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].num;</span><br><span class="line">        b[a[i].num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="built_in">qpower</span>(<span class="number">2</span>,n/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC050D-Xor-Sum">[ABC050D] Xor Sum</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>给出正整数$N$.</p><p>求出整数对$u$和$v$ $(0≤u,v≤N)$的数目，使得存在两个非负整数$a$和$b$满足$a\ xor\  b = u$和$a\ +\ b= v$。这里，$xor$表示按位异或。 要求对答案取模$10^9 + 7$。</p><h2 id="输入输出格式">输入输出格式</h2><h3 id="输入格式-3">输入格式</h3><p>一个正整数$N$</p><h3 id="输出格式-3">输出格式</h3><p>满足条件的$u,v$的个数，对$10^9+7$取模</p><h2 id="数据范围：">数据范围：</h2><p>$N&lt;=10^{18}$</p><h2 id="题目描述-4">题目描述</h2><p>正の整数 $ N $ が与えられます。 $ 2 $ つの整数 $ u,v(0≦u,v≦N) $ であって、ある非負整数 $ a,b $ が存在して、$ a $ $ xor $ $ b=u $、$ a+b=v $ となるようなものが何通りあるかを求めてください。 ここで、$ xor $ はビットごとの排他的論理和を表します。 なお、答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>ありうる $ 2 $ 数の組が何通りあるかを求め、$ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1422</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52277</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">787014179</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦10^{18} $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ u,v $ としてありうるものは、以下の $ 5 $ 通りです。 - $ u=0,v=0 $（ $ a=0,b=0 $ とすると、$ 0 $ $ xor $ $ 0=0 $、$ 0+0=0 $ となります。） - $ u=0,v=2 $（ $ a=1,b=1 $ とすると、$ 1 $ $ xor $ $ 1=0 $、$ 1+1=2 $ となります。） - $ u=1,v=1 $（ $ a=1,b=0 $ とすると、$ 1 $ $ xor $ $ 0=1 $、$ 1+0=1 $ となります。） - $ u=2,v=2 $（ $ a=2,b=0 $ とすると、$ 2 $ $ xor $ $ 0=2 $、$ 2+0=2 $ となります。） - $ u=3,v=3 $（ $ a=3,b=0 $ とすると、$ 3 $ $ xor $ $ 0=3 $、$ 3+0=3 $ となります。）</p></blockquote><h2 id="思路-3">思路</h2><p>[题解 <a href="https://www.luogu.com.cn/article/s9kikzf6">ARC066] B - 洛谷专栏 (luogu.com.cn)</a></p><p>暂时先不写思路了，帮舍友配博客去了。可以先看看上面的文章，大佬讲得很好。</p><hr><p>补思路</p><p>一开始的想法是$v$可能与$u$相同，或者比$u$多出一位（这里是二进制位），所以肯定比$u$多出$2^{n+1}$（假设$u$原来有$n$位），然后想办法枚举，发现好像不行？也许以后尝试实现一下</p><p>下面的思路是大佬的：</p><blockquote><p>考虑<br>$$<br>a+b=((a\ and\ b)&lt;&lt;1)+(a\ xor\ b)<br>$$<br>$</p><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到$a+b\geq a\ xor b$这样的结论。</p><p>那么如果由于$u&lt;v$，所以如果$v$不越界那么$u$一定不越界。于是考虑按$v$进行$dp$。具体的，考虑状态$f_{i,j}$表示考虑了$a$和$b$二进制下的前$i$位，当前$v=a+b=j$的方案数。</p><p>考虑如何转移。对于$a$和$b$而言，第$i$位有三种情况，$(0,0),(0,1),(1,1)$。那么也就是假设原来的和为$j’$，和当前的和$j$可能有以下关系：</p><p>1、$2*(j’+1)=j$对应着都补一位1。</p><p>2、$2*j’=j$对应着都补一位0 。</p><p>3、$j’+(j’+1)=j$对应着一个补1一个补0 。</p><p>那么也就是<br>$$<br>f_{i,j}=f_{i-1,\lfloor \frac{j}{2}\rfloor}+f_{i-1,\lfloor \frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor{\frac{(j-2)}{2}\rfloor}}<br>$$</p><p>考虑把第一维压掉之后，就是另一篇题解的那种做法了。</p><p>（下面的代码就是优化的）</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//注意范围为10^18，所以用map</span></span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    m[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    ll ans=<span class="built_in">solve</span>(n);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC049</title>
      <link href="/2024/03/22/ABC049/"/>
      <url>/2024/03/22/ABC049/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC049">ABC049</h1><blockquote><h1 id="ABC049C-白昼夢">[ABC049C] 白昼夢</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目大意">题目大意</h1><p>输入一个以英文小写字母组成的字符串S，规定一个空的字符串T，现在你可对字符串T进行你喜欢的操作，问是否能让字符串T变为字符串S？</p><p><strong>喜欢的操作如下 ：</strong></p><p>在字符串T的末尾加入<br>“dream”或“dreamer”或“erase”或“eraser”。</p><hr><h2 id="输入格式">输入格式</h2><p>一个字符串S</p><h2 id="输出格式">输出格式</h2><p>若可以输出<strong>YES</strong>,否则输出<strong>NO</strong>。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる文字列 $ S $ が与えられます。 $ T $が空文字列である状態から始め、以下の操作を好きな回数繰り返すことで $ S\ =\ T $ とすることができるか判定してください。</p><ul><li>$ T $ の末尾に <code>dream</code> <code>dreamer</code> <code>erase</code> <code>eraser</code> のいずれかを追加する。</li></ul><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ S\ =\ T $ とすることができる場合 <code>YES</code> を、そうでない場合 <code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erasedream</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreameraser</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreamerer</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦|S|≦10^5 $</li><li>$ S $ は英小文字からなる。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>erase</code> <code>dream</code> の順で $ T $ の末尾に追加することで $ S\ =\ T $ とすることができます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p><code>dream</code> <code>eraser</code> の順で $ T $ の末尾に追加することで $ S\ =\ T $ とすることができます。</p></blockquote><h2 id="思路">思路</h2><p>其实是一道模拟题（doge），只要判断读到$d$或$e$时，判断是不是$dream、dreamer、erase、eraser$中的一个即可，注意$dreamer$与$erase、eraser$会首尾重叠，所以还需进一步分类。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//读到e，判断是不是eraser或erase</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;s&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">5</span>]==<span class="string">&#x27;r&#x27;</span>)&#123;</span><br><span class="line">                    i+=<span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到d，判断是不是dream、dreamer、dreamerase、dreameraser即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;e&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;m&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp; s[i + <span class="number">7</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i + <span class="number">8</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; s[i + <span class="number">9</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                    i += <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        i += <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        i += <span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC049D-連結">[ABC049D] 連結</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>有$N$个城市，$K$条道路（指地面上的道路）和$L$条地铁。道路和地铁都是无向的。对于每个点，请你求出它只通过道路<strong>和</strong>只通过地铁都能到达的点的个数。道路和地铁之间不能换乘，你只能<strong>完全</strong>通过地铁到达某个点，或者<strong>完全</strong>通过道路到达某个点。</p><h2 id="输入格式-3">输入格式</h2><p>第一行三个正整数$N,K,L$<br>($N\le2\times 10^5,K,L\le10^5$)<br>然后$K$行，每行两个数$p,q$，表示城市$p$和城市$q$通过道路连接。<br>然后$L$行，每行两个数$r,s$，表示城市$r$和城市$s$通过地铁连接。</p><h2 id="输出格式-3">输出格式</h2><p>一行$N$个正整数，表示每个点只通过道路和只通过地铁都能到达的点的个数。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の都市があり、$ K $ 本の道路と $ L $ 本の鉄道が都市の間に伸びています。 $ i $ 番目の道路は $ p_i $ 番目と $ q_i $ 番目の都市を双方向に結び、 $ i $ 番目の鉄道は $ r_i $ 番目と $ s_i $ 番目の都市を双方向に結びます。 異なる道路が同じ $ 2 $ つの都市を結ぶことはありません。同様に、異なる鉄道が同じ $ 2 $ つの都市を結ぶことはありません。</p><p>ある都市から別の都市に何本かの道路を通って到達できるとき、それらの都市は道路で連結しているとします。また、すべての都市はそれ自身と道路で連結しているとみなします。<br>鉄道についても同様に定めます。</p><p>全ての都市について、その都市と道路・鉄道のどちらでも連結している都市の数を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ L $ $ p_1 $ $ q_1 $ : $ p_K $ $ q_K $ $ r_1 $ $ s_1 $ : $ r_L $ $ s_L $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>$ N $ 個の整数を出力せよ。$ i $ 番目の数は $ i $ 番目の都市と道路・鉄道の両方で連結している都市の数である。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 4 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">6 7</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2 2 2</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 2*10^5 $</li><li>$ 1\ ≦\ K,\ L≦\ 10^5 $</li><li>$ 1\ ≦\ p_i,\ q_i,\ r_i,\ s_i\ ≦\ N $</li><li>$ p_i\ &lt;\ q_i $</li><li>$ r_i\ &lt;\ s_i $</li><li>$ i\ ≠\ j $ のとき、$ (p_i,\ q_i)\ ≠\ (p_j,\ q_j) $</li><li>$ i\ ≠\ j $ のとき、$ (r_i,\ s_i)\ ≠\ (r_j,\ s_j) $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1,\ 2,\ 3,\ 4 $ 番目の都市は全て互いに道路で連結しています。 鉄道で連結している都市は $ 2,\ 3 $ のみなので、答えは順に $ 1,\ 2,\ 2,\ 1 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>并查集+map，具体也不知道怎么解释，太累了，不想写了qwq</p><p>直接看题解吧：<a href="https://www.luogu.com.cn/article/j3jx0o1z">题解 AT2159 【連結 / Connectivity】 - 洛谷专栏 (luogu.com.cn)</a></p><hr><p>补思路补思路~~~</p><p>可以发现这是一个连通性问题，<s>所以我们不难想到用并查集</s>。</p><p>但是答案求的是这两个图的交集的元素个数，所以我们可以开一个数组$Fa[i][j]$，表示有多少个点满足在$fa1$中的祖先是$i$，有多少个点在$fa2$中的祖先是$j$。那么，对于一个点$u$，它走两条线路都能到的点数量就是<code>Fa[fa1.find(i)][fa2.find(i)]</code>（其中$find$是查找祖先的函数）。记录这个数组的方法也很简单，就是对于每个点，<code>Fa[fa1.find(i)][fa2.find(i)]++</code>。</p><p>但是这样会喜提$MLE$，所以我们可以拿出神器：$map+pair$</p><p>用$map&lt;pair&lt;int,int&gt;,int&gt;$就可以省下很多空间，而我们其实只需要遍历这$n$个点即可，所以绰绰有余，我们只需要遍历每个点时加一即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa1[MAXN],fa2[MAXN];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//思路：并查集+stl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x],fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x,fa),fy=<span class="built_in">find</span>(y,fa);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,k,l;cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa1[i]=i,fa2[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC048</title>
      <link href="/2024/03/22/ABC048/"/>
      <url>/2024/03/22/ABC048/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC048">ABC048</h1><blockquote><h1 id="ABC048A-AtCoder-Contest">[ABC048A] AtCoder *** Contest</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个字符串，求这三个字符串的首字母并输出。</p><p>翻译提供者：一条小鱼</p><h2 id="题目描述">题目描述</h2><p>すぬけ君は、AtCoder $ s $ Contest という名前のコンテストを開こうとしています。 ここで、$ s $ は長さ $ 1 $ 以上の文字列であり、$ 1 $ 文字目は英大文字、$ 2 $ 文字目以降は英小文字です。</p><p>すぬけ君は、このコンテストの略称を A$ x $C に決めました。 ここで、$ x $ は $ s $ の先頭の英大文字です。</p><p>コンテストの名前が与えられるので、コンテストの略称を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>AtCoder $ s $ Contest</p></blockquote><h2 id="输出格式">输出格式</h2><p>コンテストの略称を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Beginner Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Snuke Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder X Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AXC</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ s $ の長さは $ 1 $ 以上 $ 100 $ 以下である。</li><li>$ s $ の $ 1 $ 文字目は英大文字である。</li><li>$ s $ の $ 2 $ 文字目以降は英小文字である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>今あなたが参加しているコンテストです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>このコンテストは存在しません。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s1,s2,s;cin&gt;&gt;s1&gt;&gt;s&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[<span class="number">0</span>]&amp;&amp;s[<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">        s[<span class="number">0</span>]=s[<span class="number">0</span>]<span class="number">-32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;s[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048B-Between-a-and-b-…">[ABC048B] Between a and b …</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>给出两个非负整数a，b（a≤b）和一个正整数x。请在 a 以上 b 以下（包含a，b）的整数中， 找出可被 x 整除的数数量。</p><h2 id="输入输出格式">输入输出格式</h2><h4 id="输入格式：">输入格式：</h4><p>三个数，a b x</p><h4 id="输出格式：">输出格式：</h4><p>一行，一个整数，在 a 以上 b 以下（包含a，b）的整数中可被 x 整除的数数量。</p><h2 id="输入输出样例">输入输出样例</h2><ol><li>输入样例#1:<br>4 8 2<br>输出样例#1:<br>3</li><li>输入样例#2:<br>0 5 1<br>输出样例#2:<br>6</li><li>输入样例#3:<br>9 9 2<br>输出样例#3:<br>(无)</li><li>输入样例#4:<br>1 1000000000000000000 3<br>输出样例#4:<br>333333333333333333</li></ol><h3 id="数据范围：">数据范围：</h3><p>0 ≤ a ≤ b ≤ 10^18<br>1 ≤ x ≤ 10^18</p><h4 id="样例说明1">样例说明1:</h4><p>4 6 8 可以</p><h4 id="样例说明2">样例说明2:</h4><p>0 1 2 3 4 5 可以</p><h4 id="样例说明3">样例说明3:</h4><p>没有能被2整除的</p><h4 id="样例说明4">样例说明4:</h4><p>请注意溢出</p><p>感谢@2x6_81和 @曾熠辰 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>非負の整数 $ a $, $ b $ ($ a\ &lt;\ =\ b $) と、正の整数 $ x $ が与えられます。 $ a $ 以上 $ b $ 以下の整数のうち、$ x $ で割り切れるものの個数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ x $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ a $ 以上 $ b $ 以下の整数のうち、$ x $ で割り切れるものの個数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 9 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1000000000000000000 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">333333333333333333</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 0\ &lt;\ =\ a\ &lt;\ =\ b\ &lt;\ =\ 10^{18} $</li><li>$ 1\ &lt;\ =\ x\ &lt;\ =\ 10^{18} $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 4 $ 以上 $ 8 $ 以下の整数のうち $ 2 $ で割り切れるものは、$ 4 $, $ 6 $, $ 8 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>$ 0 $ 以上 $ 5 $ 以下の整数のうち $ 1 $ で割り切れるものは、$ 0 $, $ 1 $, $ 2 $, $ 3 $, $ 4 $, $ 5 $ です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>$ 9 $ 以上 $ 9 $ 以下の整数のうち $ 2 $ で割り切れるものはありません。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>オーバーフローに注意してください。</p></blockquote><h2 id="思路-2">思路</h2><p>数据范围很大，所以肯定不能暴力枚举。</p><p>我们只需要找到最小的大于$a$的数，同时也是$x$的倍数，最大的小于$b$的数，同时也是$x$的倍数。</p><p>然后简单算一下即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll a,b,x;cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;</span><br><span class="line">    ll ans1=(a/x+(a%x==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>))*x;</span><br><span class="line">    ll ans2=(b/x)*x;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(ans2-ans1)/x;</span><br><span class="line">    cout&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048C-Boxes-and-Candies">[ABC048C] Boxes and Candies</h1><h2 id="题面翻译-3">题面翻译</h2><p>$N$个箱子横排成一列，左边第$i$个箱子里装着$a_i$个糖果。</p><p>Snuke可以多次执行以下操作：</p><p>选一个里面不少于$1$个糖果的箱子，从那个箱子里吃一个糖果。</p><p>他的目标：</p><p>任何$2$个相邻的箱子都不多于$x$个糖果。</p><p>请确定实现他的目标所需的最小操作次数。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 個の箱が横一列に並んでいます。 最初、左から $ i $ 番目の箱には $ a_i $ 個のキャンディが入っています。</p><p>すぬけ君は次の操作を好きな回数だけ行うことができます。</p><ul><li>キャンディが $ 1 $ 個以上入っている箱をひとつ選び、その箱のキャンディを $ 1 $ 個食べる。</li></ul><p>すぬけ君の目標は次の通りです。</p><ul><li>どの隣り合う $ 2 $ つの箱を見ても、それらの箱に入っているキャンディの個数の総和が $ x $ 以下である。</li></ul><p>目標を達成するために必要な操作回数の最小値を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ x $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>目標を達成するために必要な操作回数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1</span><br><span class="line">1 6 1 2 0 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ 0\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li><li>$ 0\ &lt;\ =\ x\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ 2 $ 番目の箱のキャンディを $ 1 $ 個食べればよいです。 すると、各箱のキャンディの個数は $ (2,\ 1,\ 2) $ となります。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>たとえば、$ 2 $ 番目の箱のキャンディを $ 6 $ 個食べ、$ 4 $ 番目の箱のキャンディを $ 2 $ 個食べ、$ 6 $ 番目の箱のキャンディを $ 3 $ 個食べればよいです。 すると、各箱キャンディの個数は $ (1,\ 0,\ 1,\ 0,\ 0,\ 1) $ となります。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>最初から目標が達成されているので、操作を行う必要はありません。</p><h3 id="Sample-Explanation-4-2">Sample Explanation 4</h3><p>すべてのキャンディを食べなければなりません。</p></blockquote><h2 id="思路-3">思路</h2><p>贪心题，和前一个盒子进行判断是否大于$x$，简单的模拟即可，注意一下当前盒子数目情况的判断。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,x;cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]+a[i]&gt;x)&#123;</span><br><span class="line">            ans+=(a[i<span class="number">-1</span>]+a[i]-x);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=a[i<span class="number">-1</span>]+a[i]-x)&#123;</span><br><span class="line">                a[i]-=a[i<span class="number">-1</span>]+a[i]-x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048D-An-Ordinary-Game">[ABC048D] An Ordinary Game</h1><h2 id="题面翻译-4">题面翻译</h2><p>给定一个长度大于等于3的字符串$S$,$S$中没有相邻的两个字符相等。</p><p><strong>玩法</strong>:</p><p>玩家$1$和玩家$2$交替进行操作——从$S$中删除一个字符,但删除后$S$不能有相邻的两个字符相等,否则另一位玩家获胜(两人都很聪明)</p><p>现在玩家$1$先操作,请问谁可以获得胜利?</p><p>输入一个字符串$S$</p><p>若玩家$1$胜利,输出<code>first</code>;玩家$2$获胜,输出<code>Second</code></p><h2 id="题目描述-5">题目描述</h2><p>長さ $ 3 $ 以上の文字列 $ s $ があります。 $ s $ の中に同一の文字が隣り合う箇所はありません。</p><p>高橋君と青木君がゲームで勝負します。 二人は交互に次の操作を行います。 高橋君が先手です。</p><ul><li>$ s $ から両端以外の文字をひとつ取り除く。 ただし、その文字を取り除くことで、$ s $ の中に同一の文字が隣り合う箇所ができる場合、その文字を取り除くことはできない。</li></ul><p>先に操作を行えなくなった人が負けです。 二人が最適に行動したとき、どちらが勝つかを判定してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>先手の高橋君が勝つならば <code>First</code> を、後手の青木君が勝つならば <code>Second</code> を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Second</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcab</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 3\ &lt;\ =\ |s|\ &lt;\ =\ 10^5 $</li><li>$ s $ は英小文字のみからなる。</li><li>$ s $ の中に同一の文字が隣り合う箇所はない。</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>先手の高橋君は操作を行うことができません。 なぜならば、$ s $ から両端以外の文字の <code>b</code> を取り除くと、$ s $ は <code>aa</code> となって <code>a</code> が隣り合うからです。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>先手の高橋君が $ s $ から <code>b</code> を取り除くと、$ s $ は <code>ac</code> となります。 すると、後手の青木君は操作を行うことができません。 なぜならば、$ s $ には両端以外の文字が存在しないからです。</p></blockquote><h2 id="思路-4">思路</h2><p>应该是博弈论。</p><p>推导过程看这里：[题解 AT2153 【<a href="https://www.luogu.com.cn/article/lwt0riem">ARC064B] An Ordinary Game】 - 洛谷专栏 (luogu.com.cn)</a></p><p>我就直接贴代码了qwq</p><hr><p>好的，我来补思路了uwu</p><p>其实从样例中可以比较明显地发现，结果与字符串的长度、首尾是否相同有关。</p><p>引用$DPair$大佬思路：</p><blockquote><p>首先我们发现一个及其显然的结论：删除到无法删除时，字符串情况只可能是这样的：</p><p>$$ababababa···ababab$$</p><p>即字符串中出现且只出现<strong>两种不同</strong>的字符，并<strong>交替出现</strong>（或只剩两个，但也可以看作这种情况）。</p><p>字符不可能只有一个，否则就违背题意了，而且由于首尾不能被删除，因此最后至少剩下两个字符，即不可能出现只有一个字符的情况。</p><p>排除这种可能性后，只出现两种不同字符的原因在于，由于相邻字符保证不同，且我要保证我现在的状态是一个死局，那么字符串$s$中$s_{i-1}=s_{i+1}$，即所有奇数下标位置的字符相同，所有偶数下标位置的字符相同，且这两种字符不同。故只有两种字符，且<strong>奇偶交替出现</strong>。</p><p>然后我们发现，若字符串长度为奇数，则首尾下标都为奇数，故要使该状态成为死局必须保证<strong>首尾相同</strong>，反之，即<strong>首尾不同</strong>，则绝对安全，不可能死局，也就是必胜，那么对手也就必败（这一步好像是博弈论的一个<strong>经典思考环节</strong>）。所以当<strong>字符串长度为偶数且首尾不同</strong>时，我的下一步操作一定会使对手进入必胜态，那么我就必败（因为本游戏没有平局）。</p><p><strong>首尾相同</strong>的情况也类似，只不过此时字符串长度为偶数时是安全的必胜态，奇数才为必败态。</p><p>因此当<strong>首尾相同且长度偶数</strong>或<strong>首尾不同且长度奇数</strong>时，先手必胜，反之后手必胜。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//ababababa</span></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[len<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC047</title>
      <link href="/2024/03/22/ABC047/"/>
      <url>/2024/03/22/ABC047/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC047">ABC047</h1><blockquote><h1 id="ABC047A-キャンディーと2人の子供">[ABC047A] キャンディーと2人の子供</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个数，如果存在其中两个数的和等于第三个数，输出Yes，不存在，输出No，强调一下，岛国的题最后输出要记得换行，否则听取WA声一片</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園に通う $ 2 $ 人の子供がキャンディーの取り合いをしています。</p><p>$ 3 $ 個のキャンディーパックがあり、それぞれのパックにはキャンディーが $ a $, $ b $, $ c $ 個入っています。</p><p>えび先生はこの $ 3 $ 個のパックを、キャンディーの個数が等しくなるように $ 2 $ 人に分けようとしています。そのような分け方が可能かどうかを判定してください。</p><p>ただし、キャンディーをパックから取り出すことはできず、それぞれのパックをそのままどちらかの子供にあげる必要があります。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>キャンディーを同じ個数に分けられるなら <code>Yes</code> を、そうでなければ <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 30 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 30 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">56 25 31</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ a,\ b,\ c\ ≦\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>ひとりめの子供に $ 30 $ 個のキャンディーの入ったパックを、もう一方の子供に $ 10 $ 個と $ 20 $ 個のキャンディーの入ったパックをあげると、$ 2 $ 人のもらうキャンディーの個数を等しくすることができます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>この場合、$ 100 $ 個のキャンディーの入ったパックを貰った子供は必ずもう一方の子供より多くのキャンディーを貰うことになってしまいます。 $ 3 $ つすべてのパックをどちらかの子供にあげるように分けなければならないことに注意してください。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(a+b==c||a+c==b||b+c==a)cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC047B-すぬけ君の塗り絵-2-イージー">[ABC047B] すぬけ君の塗り絵 2 イージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>平面上有一个左下角坐标$(0,0)$，右上角坐标$(W,H)$ 的矩形，起初长方形内部被涂白。</p><p>现在给出$N$个操作，每个操作都给定一个点$(x_i,y_i)$和一个参数$a_i$，代表：</p><ul><li>$a_i=1$时，$x&lt;x_i$的区域将被涂黑</li><li>$a_i=2$时，$x&gt;x_i$的区域将被涂黑</li><li>$a_i=3$时，$y&lt;y_i$的区域将被涂黑</li><li>$a_i=4$时，$y&gt;y_i$的区域将被涂黑</li></ul><p>现在问当所有操作均结束后剩下的白色区域的面积</p><h2 id="题目描述-2">题目描述</h2><p>$ xy $ 平面上に、左下の座標が $ (0,\ 0) $、右上の座標が $ (W,\ H) $ で、各辺が $ x $ 軸か $ y $ 軸に平行な長方形があります。最初、長方形の内部は白く塗られています。</p><p>すぬけ君はこの長方形の中に $ N $ 個の点を打ちました。$ i $ 個目 ($ 1\ ≦\ i\ ≦\ N $) 点の座標は $ (x_i,\ y_i) $ でした。</p><p>また、すぬけ君は長さ $ N $ の数列 $ a $ を決めて、各 $ 1\ ≦\ i\ ≦\ N $ に対し、</p><ul><li>$ a_i\ =\ 1 $ のときは長方形の $ x\ &lt;\ x_i $ をみたす領域</li><li>$ a_i\ =\ 2 $ のときは長方形の $ x\ &gt;\ x_i $ をみたす領域</li><li>$ a_i\ =\ 3 $ のときは長方形の $ y\ &lt;\ y_i $ をみたす領域</li><li>$ a_i\ =\ 4 $ のときは長方形の $ y\ &gt;\ y_i $ をみたす領域</li></ul><p>を黒く塗りました。</p><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ W $ $ H $ $ N $ $ x_1 $ $ y_1 $ $ a_1 $ $ x_2 $ $ y_2 $ $ a_2 $ $ : $ $ x_N $ $ y_N $ $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 2</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 5</span><br><span class="line">1 6 1</span><br><span class="line">4 1 3</span><br><span class="line">6 9 4</span><br><span class="line">9 4 2</span><br><span class="line">3 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ W,\ H\ ≦\ 100 $</li><li>$ 1\ ≦\ N\ ≦\ 100 $</li><li>$ 0\ ≦\ x_i\ ≦\ W $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ 0\ ≦\ y_i\ ≦\ H $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ W $, $ H $ (21:32 追記), $ x_i $, $ y_i $ は整数である</li><li>$ a_i $ ($ 1\ ≦\ i\ ≦\ N $) は $ 1,\ 2,\ 3,\ 4 $ のいずれかである</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>すぬけ君が塗りつぶしを始める前の長方形は以下の図のようになっています。 ![e19e673abcd0882783f635cce9d2f94d.png](<a href="https://atcoder.jp/img/abc047/e19e673abcd0882783f635cce9d2f94d.png">https://atcoder.jp/img/abc047/e19e673abcd0882783f635cce9d2f94d.png</a>) $ (x_1,\ y_1)\ =\ (2,\ 1) $、$ a_1\ =\ 1 $ なので、まずすぬけ君は $ x $ 座標が $ 2 $ より小さい領域を塗りつぶし、長方形は以下のようになります。 ![f25cd04bbac23c4e5426d70511a9762f.png](<a href="https://atcoder.jp/img/abc047/f25cd04bbac23c4e5426d70511a9762f.png">https://atcoder.jp/img/abc047/f25cd04bbac23c4e5426d70511a9762f.png</a>) $ (x_2,\ y_2)\ =\ (3,\ 3) $、$ a_2\ =\ 4 $ なので、次にすぬけ君は $ y $ 座標が $ 3 $ より大きい領域を塗りつぶし、長方形は最終的に以下のようになります。 ![46b0c06fd9eee4f148e1f441f7abca53.png](<a href="https://atcoder.jp/img/abc047/46b0c06fd9eee4f148e1f441f7abca53.png">https://atcoder.jp/img/abc047/46b0c06fd9eee4f148e1f441f7abca53.png</a>) この最終的な状態における白い部分の面積は $ 9 $ なので、出力は $ 9 $ となります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>塗りつぶした結果、白い部分が残らないこともありえます。</p></blockquote><h2 id="思路-2">思路</h2><p>其实直接暴力就可以，但是我们想想优化方法</p><p>以$a=1$为例，可以发现：对结果有影响的只有当$a=1$时，所有$x$的可能取值中最大的，其他的只是重复填涂而已，对结果没影响。同理可得$a=2,a=3,a=4$的情况。</p><p>注意可能是否不存在的情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> w,h,n;cin&gt;&gt;w&gt;&gt;h&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">0</span>,a2=w,a3=<span class="number">0</span>,a4=h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,a;cin&gt;&gt;x&gt;&gt;y&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">            a1=<span class="built_in">max</span>(a1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">            a2=<span class="built_in">min</span>(a2,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">3</span>)&#123;</span><br><span class="line">            a3=<span class="built_in">max</span>(a3,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">4</span>)&#123;</span><br><span class="line">            a4=<span class="built_in">min</span>(a4,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边界小于左边界，或者上边界小于下边界</span></span><br><span class="line">    <span class="keyword">if</span>(a4&lt;a3||a2&lt;a1)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;(a2-a1)*(a4-a3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC047C-一次元リバーシ">[ABC047C] 一次元リバーシ</h1><h2 id="题面翻译-3">题面翻译</h2><p>输入一个长度不多于$10^5$的字符串，只包含B或W。若前后两个字符不一样，答案累加，输出答案。</p><p>感谢@da32s1da 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>きつねの次郎と三郎が一次元リバーシで遊んでいます。一次元リバーシでは、盤面には白か黒の石が一列に並んだ状態となっており、列の右端か左端に新たに石を打っていきます。通常のリバーシと同じように、たとえば白の石を打つことで黒の石を挟むと、挟まれた黒の石は白い石に変わります。</p><p>ゲームの途中で三郎に急用ができて帰ってしまうことになりました。このとき、盤面の状態は文字列 $ S $ で表されます。石は $ |S| $ (文字列の長さ) 個並んでおり、左から $ i $ ($ 1\ ≦\ i\ ≦\ |S| $) 個目の石の色は、$ S $ の $ i $ 文字目が <code>B</code> のとき黒、<code>W</code> のとき白です。</p><p>次郎は現在の盤面に対して、できるだけ少ない個数の石を新たに打つことで全ての石を同じ色にしようと考えました。最小で何個の石を打てばよいかを求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>全ての石を同じ色にするために打つ必要のある石の個数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BBBWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WWWWWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WBWBWBWBWB</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ |S|\ ≦\ 10^5 $</li><li>$ S $ に含まれる文字は <code>B</code> または <code>W</code> のいずれかである</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>たとえば右端に黒い石を打つとすべての白い石を黒い石にすることができます。他にも、左端に白い石を打つことでもすべての石の色を同じにできます。 いずれの場合も $ 1 $ 個の石ですべての石を同じ色にすることができるので、$ 1 $ を出力します。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>最初から全ての石が同じ色の場合、新たに石を打つ必要はありません。</p></blockquote><h2 id="思路-3">思路</h2><p>开个$flag$记录一下即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">char</span> flag=s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag!=s[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>发现自己$SB$了，直接统计有多少个相邻的字符不同即可</p><blockquote><h1 id="ABC047D-高橋君と見えざる手">[ABC047D] 高橋君と見えざる手</h1><h2 id="题面翻译-4">题面翻译</h2><h1 id="高桥君和不可见之手">高桥君和不可见之手</h1><h2 id="问题描述">问题描述</h2><p>有 $N$ 个小镇排在一条直线上。旅行商人高桥君从小镇 $1$ 出发，一边买卖苹果一边朝小镇 $N$ 前行。</p><p>开始时高桥君处在小镇 $1$ ，身上一个苹果也没有。高桥君不断进行以下行动。</p><ul><li>移动：从小镇 $i(i &lt; N)$ 开始，移动到小镇 $i+1$ 。</li><li>买卖苹果：买进或卖出任意个苹果。在小镇 $i(1 \leq i \leq N)$ 买进或卖出苹果单价都为 $A_i$ 円。 $A_i$ 为相异的整数。</li></ul><p>在每个小镇进行交易的苹果数量没有限制，但是旅行中所买进和卖出的苹果总数(买进苹果数加上卖出苹果数)必须在 $T$ 以内。高桥君会使自己在旅程中所获利益(卖苹果所得钱数减去买苹果所花钱数)最大。</p><p>在高桥君进行旅行之前，青木君可以对于任意 $i$ ，使 $A_i$ 变为非负整数 $A_i’$ 。这个操作的代价为 $|A_i-A_i’|$ 。操作后即使出现相异小镇苹果单价相同的情况也没关系。</p><p>青木君的目的是：花费尽量少的代价，使高桥君所得的最大利益至少下降 $1$ 円。请求出最小代价。</p><p>数据保证初始状态下高桥君至少能获得 $1$ 円的利益。</p><h2 id="数据范围">数据范围</h2><ul><li>$1 \leq N \leq 10^5$</li><li>$1 \leq A_i \leq 10^9$</li><li>$A_i$ 相异</li><li>$2 \leq T \leq 10^9$</li><li>保证初始状态下高桥君至少能获得 $1$ 円的利益。</li></ul><h2 id="输入">输入</h2><p>输入按以下标准：<br>$$ N \space T $$<br>$$ A_1 \space A_2 \space \dots \space A_N $$</p><h2 id="输出">输出</h2><p>输出使高桥君最大收益至少下降 $1$ 円的最小代价和。</p><h2 id="样例1解释">样例1解释</h2><p>在初始状态下，高桥君能够进行以下的行动来获得最大收益( $150$ 円)：</p><ol><li>从小镇 $1$ 移动到小镇 $2$ 。</li><li>在小镇 $2$ 处花 $50$ 円买一个苹果。</li><li>从小镇 $2$ 移动到小镇 $3$ 。</li><li>在小镇 $3$ 处卖掉一个苹果获得 $200$ 円。</li></ol><p>举例来说，如果青木君把小镇 $2$ 的苹果单价从 $50$ 円上调至 $51$ 円，高桥君就无法获得 $150$ 円的收益。也就是说，此操作能够使高桥君的最大收益至少下降 $1$ 円，所以答案为 $1$ 。</p><p>另外，将小镇 $3$ 的苹果单价从 $200$ 円降至 $199$ 円也能够达到目的。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 個の町が一直線上に並んでいます。行商人の高橋君は町 $ 1 $ から出発し、リンゴの売買をしながら町 $ N $ へと向かいます。</p><p>はじめ高橋君は町 $ 1 $ におり、リンゴを $ 1 $ つも持っていません。高橋君は次のいずれかの行動を繰り返し行います。</p><ul><li>移動: 町 $ i $ ($ i\ &lt;\ N $) にいるとき、町 $ i\ +\ 1 $ へ移動する。</li><li>リンゴの売買: リンゴを好きな個数だけ売買する。ここで、町 $ i $ ($ 1\ ≦\ i\ ≦\ N $) ではリンゴの買値も売値もともに $ A_i $ 円とする。ここで $ A_i $ は相異なる整数です。</li></ul><p>$ 1 $ つの町で売買するリンゴの個数に制限はありませんが、旅の中で売買するリンゴの個数は合計で (買う個数と売る個数を合わせて) $ T $ 個以下にしなくてはなりません。</p><p>高橋君は旅の利益、すなわちリンゴを売った代金から買った代金を引いた値を最大にするように旅をするとします。旅が終わったときに持っていたリンゴの価値は考えず、旅の中で売買した金額だけを考えます。</p><p>この旅に先立って、青木君は任意の町 $ i $ に対して $ A_i $ を好きな非負整数 $ A_i’ $ に変えるという操作を好きなだけ行うことができます。ただし、この操作は行うごとに $ |A_i\ -\ A_i’| $ のコストがかかります。操作後には異なる町の間でリンゴの値段が同じになっていても構いません。</p><p>青木君の目的はできるだけ少ない合計コストの操作で高橋君の利益を少なくとも $ 1 $ 円下げることです。合計コストの最小値を求めてください。</p><p>ただし、元の状態で高橋君が $ 1 $ 円以上の利益を上げられることは仮定して構いません。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T $ $ A_1 $ $ A_2 $ $ … $ $ A_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>高橋君の収益を少なくとも $ 1 $ 円下げるために必要な合計コストの最小値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">100 50 200</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">50 30 40 10 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">7 10 4 5 9 3 6 8 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 10^5 $</li><li>$ 1\ ≦\ A_i\ ≦\ 10^9 $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ A_i $ は相異なる</li><li>$ 2\ ≦\ T\ ≦\ 10^9 $</li><li>入力の状態では高橋君は $ 1 $ 円以上の利益を上げられることが保証される</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>この入力の状態では、高橋君は次のようにして最大の利益である $ 150 $ 円を達成することができます。 1. 町 $ 1 $ から町 $ 2 $ へ移動する。 2. 町 $ 2 $ で $ 50 $ 円を支払い、リンゴを $ 1 $ 個買う。 3. 町 $ 2 $ から町 $ 3 $ へ移動する。 4. 町 $ 3 $ で $ 200 $ 円でリンゴを $ 1 $ 個売る。 たとえば、青木君が町 $ 2 $ のリンゴの値段を $ 50 $ 円から $ 51 $ 円に変えると、高橋君はどのようにしても $ 150 $ 円の利益を上げることができなくなります。すなわち、コスト $ 1 $ で高橋君の利益を少なくとも $ 1 $ 円下げることが可能であり、答えは $ 1 $ となります。 他にも、町 $ 3 $ のリンゴの値段を $ 200 $ 円から $ 199 $ 円に変えることでもコスト $ 1 $ で高橋君の利益を下げることが可能です。</p></blockquote><h2 id="思路-4">思路</h2><p>高木的理想情况就是最高售价-最低买价（记作$MAX$），那么我们只需要找到所有的满足情况即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,t;cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    ll MAX=LONG_LONG_MIN,MIN=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll a;cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//b记录的是该方案对应的利润</span></span><br><span class="line">        b[i]=a-MIN;</span><br><span class="line">        <span class="comment">//MIN：最低购入价格</span></span><br><span class="line">        MIN=<span class="built_in">min</span>(MIN,a);</span><br><span class="line">        <span class="comment">//MAX最大利润</span></span><br><span class="line">        MAX=<span class="built_in">max</span>(MAX,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==MAX)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC046</title>
      <link href="/2024/03/22/ABC046/"/>
      <url>/2024/03/22/ABC046/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC046">ABC046</h1><blockquote><h1 id="ABC046A-AtCoDeerくんとペンキ">[ABC046A] AtCoDeerくんとペンキ</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>AtCoDeer先生最近买了三个油漆罐。两天前他买的那一种颜色是A，他昨天买的颜色是B，他今天买的颜色是C。每个颜料的颜色可以用1到100之间的正整数来表示。</p><p>由于AtCoDeer先生出生健忘村，AtCoDeer先生可能买了一个以上的油漆罐颜色相同。计算这些油漆罐的不同颜色的数量并告诉AtCoDeer先生。</p><p>范围：</p><p>1&lt;=(a,b,c)&lt;=100</p><p>输入格式： 三个正整数a,b,c</p><p>输出格式： 一个正整数，表示不同颜色数量</p><h2 id="题目描述">题目描述</h2><p>シカのAtCoDeerくんはペンキをこれまでに$ 3 $つ買いました。おととい買ったペンキの色は $ a $ , 昨日買ったペンキの色は $ b $ , 今日買ったペンキの色は $ c $ です。各ペンキの色は$ 1 $以上$ 100 $以下の整数で表されます。 AtCoDeerくんはわすれんぼうなため、同じ色のペンキを買ってしまっていることがあります。AtCoDeerくんが買ったペンキの色の種類の個数を教えてあげてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>AtCoDeerくんが買ったペンキの色の種類の個数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 33</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦a,b,c≦100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>色 $ 1 $,$ 3 $,$ 4 $ の $ 3 $ 種類です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>色 $ 3 $,$ 33 $ の $ 2 $ 種類です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可，可以用map</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(m[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046B-AtCoDeerくんとボール色塗り">[ABC046B] AtCoDeerくんとボール色塗り</h1><h2 id="题面翻译-2">题面翻译</h2><p>你有N个球，K种颜料</p><p>你要把N个球涂上颜料，但是为了美观相邻的两个球不能是一样颜色的。</p><p>问有多少种涂色方法？</p><p>样例1：输入 2 2 输出 2 样例解释：只有01和10这两种涂色方法</p><p>样例2:输入 1 10 输出 10 样例解释：有0,1,2,3,4,5,6,7,8和9这些方法</p><p>感谢@RioBlu 提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>シカのAtCoDeerくんは一列に並んだ $ N $ 個のボールをそれぞれ $ K $ 色のペンキの色のうちのどれかで塗ろうとしています。見栄えが悪くならないように、隣り合ったボールは別の色で塗ることにします。ボールの塗り方としてあり得るものの個数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>ボールの塗り方としてあり得るものの個数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">322828856</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 2≦K≦1000 $</li><li>答えは $ 2^{31}-1 $ 以下</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>色を$ 0 $,$ 1 $で表すと、左のボールを$ 0 $で塗り、右のボールを$ 1 $で塗る という方法と、 左のボールを$ 1 $で塗り、右のボールを$ 0 $で塗る という方法の$ 2 $通りがあります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>ボールは一つしか無いため,$ 10 $色のうちどれを使っても良いので答えは$ 10 $通りです。</p></blockquote><h2 id="思路-2">思路</h2><p>简单的组合数学</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ll ans=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=(k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046C-AtCoDeerくんと選挙速報">[ABC046C] AtCoDeerくんと選挙速報</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定 $n$ 和 $n$ 对正整数 $T_i,A_i$，已知正整数数列 $t_i,a_i$ 满足以下条件：</p><ul><li>$t_i\le t_{i+1}$，$a_i\le a_{i+1}$</li><li>$t_i/a_i=T_i/A_i$</li></ul><p>求 $t_n+a_n$ 的最小值，保证答案不超过 $10^{18}$。</p><h2 id="题目描述-3">题目描述</h2><p>シカのAtCoDeerくんは選挙速報を見ています。選挙には二人の候補高橋くんと青木くんが出ています。速報では、現在の二人の得票数の比が表示されていますが、得票数そのものは表示されていません。AtCoDeerくんは $ N $ 回画面を見て、 $ i(1≦i≦N) $ 回目に見たときに表示されている比は $ T_i:A_i $ でした。ここで、AtCoDeerくんが選挙速報の画面を$ 1 $回目に見た段階で既にどちらの候補にも少なくとも一票は入っていたことがわかっています。 $ N $ 回目に画面を見たときの投票数(二人の得票数の和)として考えられるもののうち最小となるものを求めてください。ただし、得票数が途中で減ることはありません。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ A_1 $ $ T_2 $ $ A_2 $ $ : $ $ T_N $ $ A_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ N $ 回目に画面を見たときの投票数として考えられる最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">1 1</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">1 5</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 10</span><br><span class="line">48 17</span><br><span class="line">31 199</span><br><span class="line">231 23</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6930</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 1≦T_i,A_i≦1000\ (1≦i≦N) $</li><li>$ T_i $ と $ A_i $ は互いに素 $ (1≦i≦N) $</li><li>答えが $ 10^{18} $ 以下になることは保証されている</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>二人の得票数が $ 2,3 $ -&gt; $ 3,3 $ -&gt; $ 6,4 $ と動くと投票数は $ 10 $ になって、これが最小値です。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>一度画面を見てからもう一度画面を見るまでに一票も入ってないことがありえます。</p></blockquote><h2 id="思路-3">思路</h2><p>有意思的一道题。</p><p>思路参考自<a href="https://www.luogu.com.cn/article/5qxzbt31">AT2140题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>设$u,v$为目前两个人的得票数，需要保证在以后的每一步中都有$u:v=T_i:A_i$</p><p>先设$u,v$分别为$T_i,A_i$的倍数。注意到总票数不会减少，所以$u,v$应该变为大于他们的最小的$T_i$或者$A_i$的倍数。</p><p>所以接下来这一步：$u=T_i*\lceil\frac{u}{T_i}\rceil，u=A_i*\lceil\frac{v}{A_i}\rceil$。</p><p>因为要一直保证$u:v=T_i:A_i$，所以接下来需要比较$\frac{u}{T_i}$和$\frac{v}{A_i}$的大小：</p><p>$\frac{u}{T_i}$小，根据比例的基本性质，$u=\frac {vT_i}{A_i}$。同理可得其他情况。</p><p>答案即$u+v$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i]&gt;&gt;a[i];</span><br><span class="line">    ll u=t[<span class="number">1</span>],v=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        u=((u<span class="number">-1</span>)/t[i]+<span class="number">1</span>)*t[i],v=((v<span class="number">-1</span>)/a[i]+<span class="number">1</span>)*a[i];</span><br><span class="line">        <span class="keyword">if</span>(u/t[i]&lt;v/a[i])u=(v/a[i])*t[i];</span><br><span class="line">        <span class="keyword">else</span> v=(u/t[i])*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;u+v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046D-AtCoDeerくんと変なじゃんけん">[ABC046D] AtCoDeerくんと変なじゃんけん</h1><h2 id="题面翻译-4">题面翻译</h2><p>你和对手都只有两种出拳方式：石头（$g$）和布（$p$），规则一样，赢了得一分，平局不得分，输了减一分。<br>现给你对手的出拳方式，设你到 $i$ 位置共出了 $x_i$ 次石头，$y_i$ 次布，在对于任意位置 $i$ 满足 $x_i \geq y_i$ 的条件下，输出你能得到的最大分数。</p><h2 id="题目描述-4">题目描述</h2><p>シカのAtCoDeerくんは友達のTopCoDeerくんとあるゲームをして対戦しています。 このゲームは $ N $ ターンからなります。各ターンではそれぞれのプレイヤーはじゃんけんのグーかパーを出します。ただし、各プレイヤーは次の条件を満たす必要があります。</p><p>(※) 各ターンの後で、(今までにパーを出した回数)$ ≦ $(今までにグーを出した回数) を満たす</p><p>このゲームでの各プレイヤーの得点は、(勝ったターンの数) $ - $ (負けたターンの数) です。 AtCoDeerくんは特殊能力を持っているので、ゲームが始まる前にTopCoDeerくんの出す $ N $ ターンの手を全て知ることが出来ました。 AtCoDeerくんの各ターンでの手を決めて、AtCoDeerくんの得点を最大化してください。 TopCoDeerくんの出す手の情報は文字列 $ s $ で与えられます。 $ s $ の $ i(1≦i≦N) $ 文字目が <code>g</code>のときは $ i $ ターン目でTopCoDeerくんがグーを出すことを、 <code>p</code>のときはパーを出すことを表します。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>AtCoDeerくんの得点の最大値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ggppgggpgg</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ N=|s| $</li><li>$ s $ の各文字は<code>g</code>か<code>p</code></li><li>$ s $ で表される手は、条件(※)を満たしている</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>常に相手とあいこになるように手を出すことで、$ 0 $点を取ることができて、これが最大値です。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>例えばグー,パー,グー,パー,グー,グー,パー,パー,グー,パー と出すことで、 $ 3 $回勝って$ 1 $回負けているので得点は$ 2 $点になり、これが最大値です。</p></blockquote><h2 id="思路-4">思路</h2><p>直接模拟，判断$p$是否大于$max_p$。再处理即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll p=<span class="number">0</span>,g=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>)p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll lose=<span class="number">0</span>,win=<span class="number">0</span>;</span><br><span class="line">    ll max_p=s.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;=max_p)lose+=(p-max_p);</span><br><span class="line">    <span class="keyword">else</span> win+=(max_p-p);</span><br><span class="line">    cout&lt;&lt;win-lose;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC044</title>
      <link href="/2024/03/21/ABC044/"/>
      <url>/2024/03/21/ABC044/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC044">ABC044</h1><p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC044A-高橋君とホテルイージー">[ABC044A] 高橋君とホテルイージー</h1><h2 id="题面翻译">题面翻译</h2><p>有一家酒店，这家酒店住宿费的收取规则如下</p><ul><li>前K晚每晚X元</li><li>从K+1晚开始每晚Y元</li></ul><p>高橋老弟要在这里连续住N晚，问他的住宿费合计为多少元</p><h4 id="输入格式">输入格式</h4><p>第一行，N</p><p>第二行，K</p><p>第三行，X</p><p>第四行，Y</p><h4 id="输出格式">输出格式</h4><p>一行，住宿总费用</p><h2 id="题目描述">题目描述</h2><p>$ 1 $ 軒のホテルがあります。 このホテルの宿泊費は、次のようになっています。</p><ul><li>最初の $ K $ 泊までは、$ 1 $ 泊あたり $ X $ 円</li><li>$ K+1 $ 泊目以降は、$ 1 $ 泊あたり $ Y $ 円</li></ul><p>高橋君は、このホテルに $ N $ 泊連続で宿泊することにしました。 高橋君の宿泊費は合計で何円になるか求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ X $ $ Y $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>高橋君の宿泊費の合計金額を表す整数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48000</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20000</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ N,\ K\ \leq\ 10000 $</li><li>$ 1\ \leq\ Y $</li><li>$ N,,K,,X,,Y $ はいずれも整数である</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>宿泊費は次のようになります。 - $ 1 $ 泊目は $ 10000 $ 円 - $ 2 $ 泊目は $ 10000 $ 円 - $ 3 $ 泊目は $ 10000 $ 円 - $ 4 $ 泊目は $ 9000 $ 円 - $ 5 $ 泊目は $ 9000 $ 円 したがって、合計は $ 48000 $ 円です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k,x,y;cin&gt;&gt;n&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;n*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        ans+=k*x+(n-k)*y;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044B-美しい文字列">[ABC044B] 美しい文字列</h1><h2 id="题面翻译-2">题面翻译</h2><p>输入一个字符串，判断每个字母出现的次数是否都为偶数</p><p>如果是，输出“Yes”，否则输出“No”</p><h2 id="题目描述-2">题目描述</h2><p>$ w $ を、英小文字のみからなる文字列とします。 $ w $ が以下の条件を満たすならば、$ w $ を<em>美しい文字列</em>と呼ぶことにします。</p><ul><li>どの英小文字も、$ w $ 中に偶数回出現する。</li></ul><p>文字列 $ w $ が与えられます。$ w $ が美しい文字列かどうか判定してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ w $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ w $ が美しい文字列ならば <code>Yes</code> を、それ以外の場合は <code>No</code> を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abaccaba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hthth</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ |w|\ \leq\ 100 $</li><li>$ w $ は英小文字 (<code>a</code>-<code>z</code>) のみからなる文字列である</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p><code>a</code> が $ 4 $ 回、<code>b</code> が $ 2 $ 回、<code>c</code> が $ 2 $ 回、それ以外の英小文字が $ 0 $ 回出現します。</p></blockquote><h2 id="思路-2">思路</h2><p>开个桶，直接统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        m[s[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i]%<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044C-高橋君とカード">[ABC044C] 高橋君とカード</h1><h2 id="题面翻译-3">题面翻译</h2><p>高桥有n张卡。在i(1≤i≤n)的第一个磁卡上，卡上面写着整数x_i。</p><p>高桥从这些卡片中挑选1张以上，想把选择的卡片上写的整数的平均数变成等于A的数。问有几种方案。</p><p>读入： 第一行读入N,A； 接下来一行读入N个数</p><p>输出： 一个数，记得加回车</p><p>感谢@STEPHEN_ 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>高橋君は、$ N $ 枚のカードを持っています。 $ i\ ,\ (1\ \leq\ i\ \leq\ N) $ 番目のカードには、整数 $ x_i $ が書かれています。 高橋君は、これらのカードの中から $ 1 $ 枚以上を選び、 選んだカードに書かれた整数の平均をちょうど $ A $ にしたいと考えています。 そのようなカードの選び方が何通りあるか求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ x_1 $ $ x_2 $ $ … $ $ x_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>書かれた整数の平均がちょうど $ A $ となるようなカードの選び方の総数を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 9 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 8</span><br><span class="line">6 6 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5</span><br><span class="line">3 6 2 8 7 6 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33 3</span><br><span class="line">3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8589934591</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ \leq\ N\ \leq\ 50 $</li><li>$ 1\ \leq\ A\ \leq\ 50 $</li><li>$ 1\ \leq\ x_i\ \leq\ 50 $</li><li>$ N,,A,,x_i $ はいずれも整数である</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 1\ \leq\ N\ \leq\ 16 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>- 平均が $ 8 $ となるカードの選び方は、以下の $ 5 $ 通りです。 - $ 3 $ 枚目のカードのみを選ぶ。 - $ 1 $ 枚目と $ 2 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目と $ 4 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 2 $ 枚目および $ 3 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 3 $ 枚目および $ 4 $ 枚目のカードを選ぶ。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>- 答えは $ 32 $ ビット整数型に収まらない場合があります。</p></blockquote><h2 id="思路-3">思路</h2><p>转载自<a href="https://www.luogu.com.cn/article/z25wx5t7">AT2037 题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>计数型01背包。</p><p>一开始想的是只写$f_{j}$，表示的是和为$j$的方法数。</p><p>但是最后发现不行，因为有可能最后可能不同的组合组成的数为$j$，所以得多加一个维度$i$，表示的是取了$i$个数</p><p>所以状态中存了两个值：$f_{i,j}$表示取了$i$个数，和为$j$的方法数。</p><p>这样转移方程为：$f_{i,j}=f_{i,j}+f_{i-1,j-a_k}$，$i-1$是这个数还没取，也就是少取了一个，$j-a_k$表示当前这个和减去现在的这个值，也就是之前的和。</p><p>注意就是枚举$i$和$j$时要反着枚举，初始化$f[0][0]=1$，开$long\ long$。</p><p>注意平均值不一定是整数哦。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">55</span>][<span class="number">2505</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//设初值。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">  <span class="comment">//注意这两重循环是反着的，否则会从已经改过的值转移来。</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)</span><br><span class="line">            sum+=(j*<span class="number">1.0</span>/i==<span class="built_in">double</span>(m))*f[i][j];</span><br><span class="line">  <span class="comment">//如果平均值等于 m 就将 sum 加上 f[i][j]。</span></span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;<span class="comment">//AT 加换行。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,A;cin&gt;&gt;n&gt;&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j*<span class="number">1.0</span>/i)==(<span class="type">double</span>)A)sum+=f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044D-桁和">[ABC044D] 桁和</h1><h2 id="题面翻译-4">题面翻译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line"></span><br><span class="line">对于2以上的整数b和一个1以上的整数n，函数f(b,n)的定义如下：</span><br><span class="line"></span><br><span class="line">1.若n&lt;b,f(b，n)=n;</span><br><span class="line"></span><br><span class="line">2.若n&gt;=b,f(b,n)=f(b,floor(n/b))+(n%b).</span><br><span class="line"></span><br><span class="line">说白了就是即n在b进制下各位数的和 举个例子：</span><br><span class="line"></span><br><span class="line">f(10,87654)=8+7+6+5+4=30</span><br><span class="line"></span><br><span class="line">f(100,87654)=8+76+54=138</span><br><span class="line"></span><br><span class="line">设函数f(b,n)的值为s；</span><br><span class="line"></span><br><span class="line">输入输出格式</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line"></span><br><span class="line">输入包含两个数，代表n,s的值</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line"></span><br><span class="line">输出包含1个数，是b的值，如果找不到符合要求的b值，则输出-1</span><br></pre></td></tr></table></figure><p>注：此为<a href="https://www.luogu.org/space/show?uid=118196">Over_The_Best</a>翻译，但他被禁言了，由我代发</p><h2 id="题目描述-4">题目描述</h2><p>$ 2 $ 以上の整数 $ b $ および $ 1 $ 以上の整数 $ n $ に対し、関数 $ f(b,n) $ を次のように定義します。</p><ul><li>$ n\ &lt;\ b $ のとき $ f(b,n)\ =\ n $</li><li>$ n\ \geq\ b $ のとき $ f(b,n)\ =\ f(b,,{\rm\ floor}(n\ /\ b))\ +\ (n\ {\rm\ mod}\ b) $</li></ul><p>ここで、$ {\rm\ floor}(n\ /\ b) $ は $ n\ /\ b $ を超えない最大の整数を、 $ n\ {\rm\ mod}\ b $ は $ n $ を $ b $ で割った余りを表します。</p><p>直感的に言えば、$ f(b,n) $ は、$ n $ を $ b $ 進表記したときの各桁の和となります。 例えば、</p><ul><li>$ f(10,,87654)=8+7+6+5+4=30 $</li><li>$ f(100,,87654)=8+76+54=138 $</li></ul><p>などとなります。</p><p>整数 $ n $ と $ s $ が与えられます。 $ f(b,n)=s $ を満たすような $ 2 $ 以上の整数 $ b $ が存在するか判定してください。 さらに、そのような $ b $ が存在するならば、その最小値を求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ s $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>$ f(b,n)=s $ を満たす $ 2 $ 以上の整数 $ b $ が存在するならば、そのような $ b $ の最小値を出力せよ。 そのような $ b $ が存在しないならば、代わりに <code>-1</code> を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">138</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">45678</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">31415926535</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 10^{11} $</li><li>$ 1\ \leq\ s\ \leq\ 10^{11} $</li><li>$ n,,s $ はいずれも整数である</li></ul></blockquote><h2 id="思路-4">思路</h2><p>题解区都是一堆奇怪的显然，莫名其妙的就是$O(\sqrt{n})$的时间复杂度。幸好在下面翻到一篇好文章，这里是原文链接：<a href="https://www.luogu.com.cn/article/qkzeokn7">AT2038 - 洛谷专栏 (luogu.com.cn)</a></p><p>其实是一道数学题</p><p>不妨设$n=a_0+a_1b+a_2b^2+······$，则$s=a_0+a_1+a_2+······$。</p><p>先考虑特殊情况 :</p><p>1、$n=s$，则$b=n+1$</p><p>2、$n&lt;s$，则无解。</p><p>我们用$n$减去$s$：</p><p>$n-s=a_1(b-1)+a_2(b^2-1)+a_3(b^3-1)+······$。</p><p>容易知道，$b^n-1=(b-1)(b^{n-1}+b^{n-2}+b^{n-3}+······+1)$，所以说 , 右式可以提出$b-1$。</p><p>显然：$(b-1)|n-s$，那么$b$可能的取值范围就缩成了$\sqrt{n}$数量级，接下来直接调用函数，暴力枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n,s;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll b,ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(b,n/b)+n%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,n)==s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;s)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==s)&#123;</span><br><span class="line">        cout&lt;&lt;n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tot=n-s,ans=<span class="number">1e15</span>;</span><br><span class="line">    <span class="comment">//可以结合最基础的素数筛，理解为什么枚举到根号n即可</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=(ll)<span class="built_in">sqrt</span>(tot)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//注意是判断两个哦</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(tot/i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,tot/i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e15</span>)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC045</title>
      <link href="/2024/03/21/ABC045/"/>
      <url>/2024/03/21/ABC045/</url>
      
        <content type="html"><![CDATA[<h1 id="ABC045">ABC045</h1><blockquote><h1 id="ABC045A-台形">[ABC045A] 台形</h1><h2 id="题面翻译">题面翻译</h2><p>一个梯形，给出上底a，下底b，高h的长度，求它的面积~~~</p><h2 id="题目描述">题目描述</h2><p>上底の長さが $ a $、下底の長さが $ b $、高さが $ h $ の台形があります。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc045_a/695fd302082c8c27a3f1814f7489c8be1c4f74c9.png" alt="">台形の例</p><p>この台形の面積を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ h $</p></blockquote><h2 id="输出格式">输出格式</h2><p>台形の面積を整数で出力せよ。面積が整数になることは保障されている。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ a\ \leq\ 100 $</li><li>$ 1\ \leq\ b\ \leq\ 100 $</li><li>$ 1\ \leq\ h\ \leq\ 100 $</li><li>入力で与えられる値はすべて整数</li><li>$ h $ は偶数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>上底の長さ $ 3 $、下底の長さ $ 4 $、高さ $ 2 $ の台形の面積は、 $ (3+4)×2/2\ =\ 7 $ です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>この例で与えられるのは平行四辺形ですが、平行四辺形も台形です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    ll a,b,h;cin&gt;&gt;a&gt;&gt;b&gt;&gt;h;</span><br><span class="line">    cout&lt;&lt;(a+b)*h/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC045B-3人でカードゲームイージー">[ABC045B] 3人でカードゲームイージー</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题面描述">题面描述</h3><p>Alice、Bob 和 Charlie 在玩 <em>Card Game for Three</em>。</p><ul><li>开始时，每名玩家有一叠由卡牌组成的牌堆。每张牌上有一个字母 $\texttt a, \texttt b$ 或 $\texttt c$。 卡牌的顺序不能被改变。</li><li>Alice 先开始游戏。</li><li>玩家的牌堆中至少有一张牌，当前玩家从牌堆顶抽出一张牌，这张牌代表的玩家进行下一回合（$\texttt a$ 代表 Alice，$\texttt c$ 代表 Bob，$\texttt c$ 代表 Charlie）。</li><li><strong>从左往右抽牌</strong>（牌堆顶在左边）。</li><li>如果当前玩家的牌堆空了，游戏结束，这名玩家胜利。</li></ul><p>你得到了每名玩家最初的牌堆 $S_a, S_b, S_c$，求出胜者。</p><h3 id="数据范围">数据范围</h3><p>对于 $100 %$ 的数据，保证 $1 \leq |S_a|, |S_b|, |S_c| \leq 100$ 且 $S_a, S_b, S_c$ 仅由 $\texttt{abc}$ 三个小写拉丁字母组成。</p><h2 id="题目描述-2">题目描述</h2><p>A さん、B さん、C さんの $ 3 $ 人が以下のようなカードゲームをプレイしています。</p><ul><li>最初、$ 3 $ 人はそれぞれ <code>a</code>、<code>b</code>、<code>c</code> いずれかの文字が書かれたカードを、何枚か持っている。これらは入力で与えられた順番に持っており、途中で並べ替えたりしない。</li><li>$ A $ さんのターンから始まる。</li><li>現在自分のターンである人がカードを $ 1 $ 枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人 (例えば、カードに <code>a</code> と書かれていたならば A さん) のターンとなる。</li><li>現在自分のターンである人がカードを $ 1 $ 枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。</li></ul><p>$ 3 $ 人が最初に持っているカードがそれぞれ先頭から順に与えられます。 具体的には、文字列 $ S_A $、$ S_B $、$ S_C $ が与えられます。文字列 $ S_A $ の $ i $ 文字目 ( $ 1\ \leq\ i\ \leq\ |S_A| $ ) に書かれている文字が、A さんの持っている中で先頭から $ i $ 番目のカードに 書かれている文字です。文字列 $ S_B $、 $ S_C $ についても同様です。</p><p>最終的に誰がこのゲームの勝者となるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S_A $ $ S_B $ $ S_C $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>A さんが勝つなら <code>A</code>、B さんが勝つなら <code>B</code>、C さんが勝つなら <code>C</code> と出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aca</span><br><span class="line">accc</span><br><span class="line">ca</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcb</span><br><span class="line">aacb</span><br><span class="line">bccc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ S_A\ \leq\ 100 $</li><li>$ 1\ \leq\ S_B\ \leq\ 100 $</li><li>$ 1\ \leq\ S_C\ \leq\ 100 $</li><li>$ S_A $、$ S_B $、$ S_C $ に含まれる文字はそれぞれ <code>a</code>、<code>b</code>、<code>c</code> のいずれか</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ゲームは以下のように進行します。 - A さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんが、持っている中で最初のカード <code>c</code> を捨てる。次は C さんの番となる。 - C さんが、持っている中で最初のカード <code>c</code> を捨てる。次は C さんの番となる。 - C さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんはもう持っているカードがない。よって A さんの勝利となり、ゲームは終了する。</p></blockquote><h2 id="思路-2">思路</h2><p>其实是到模拟题，感觉有点像链表。</p><p>用$p$代表每个字符串对应的指针，不断按照题意进行移动操作，直到当前牌堆空为止。</p><p>思路参考自[题解 AT2066 <a href="https://www.luogu.com.cn/article/ssxcmj7y">ABC045B] 3人でカードゲームイージー / Card Game for Three (ABC Edit) - 洛谷专栏 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">3</span>];</span><br><span class="line">ll len[<span class="number">3</span>],p[<span class="number">4</span>],k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)cin&gt;&gt;s[i],len[i]=s[i].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(p[k]&lt;len[k])&#123;</span><br><span class="line">        k=s[k][p[k]++]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span>)(k+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC045C-たくさんの数式">[ABC045C] たくさんの数式</h1><h2 id="题面翻译-3">题面翻译</h2><p><strong>Translated by <a href="https://www.luogu.org/space/show?uid=77834">aoweiyin</a></strong></p><h2 id="题意翻译">题意翻译</h2><p>有一个仅由字符<code>1</code>到<code>9</code>构成的字符串$S(1\leq |S|\leq 10)$，让你在中间添加<code>+</code>，使其变成一个加式。求所有方案的和值（详见样例解释）。</p><h4 id="样例解释1：">样例解释1：</h4><p>输入<code>125</code>,输出<code>176</code>.</p><p>有4种：</p><ul><li>125</li><li>1+25=26</li><li>12+5=17</li><li>1+2+5=8</li></ul><h2 id="题目描述-3">题目描述</h2><p><code>1</code> 以上 <code>9</code> 以下の数字のみからなる文字列 $ S $ が与えられます。 この文字列の中で、あなたはこれら文字と文字の間のうち、いくつかの場所に <code>+</code> を入れることができます。 一つも入れなくてもかまいません。 ただし、<code>+</code> が連続してはいけません。</p><p>このようにして出来る全ての文字列を数式とみなし、和を計算することができます。</p><p>ありうる全ての数式の値を計算し、その合計を出力してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>ありうる全ての数式の値の総和を $ 1 $ 行に出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">125</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">176</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999999999</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12656242944</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\leq \left|S\right|\leq 10 $</li><li>$ S $ に含まれる文字は全て <code>1</code> 〜 <code>9</code> の数字</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>考えられる数式としては、 <code>125</code>、<code>1+25</code>、<code>12+5</code>、<code>1+2+5</code> の $ 4 $ 通りがあります。それぞれの数式を計算すると、 - $ 125 $ - $ 1+25=26 $ - $ 12+5=17 $ - $ 1+2+5=8 $ となり、これらの総和は $ 125+26+17+8=176 $ となります。</p></blockquote><h2 id="思路-3">思路</h2><p>用DFS就可以解决了，将每一位进行拆分，用数组记录下来。</p><p>$+$的插入有两种情况：</p><p>DFS数字的每一位，可以将这一位与上一个数进行结合，也可以在中间加上一个$+$，具体看代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">15</span>],ans,n;</span><br><span class="line"><span class="comment">//k表示当前是第几位数字，sum表示的是当前的总和，num表示的是当前新开的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll k,ll sum,ll num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果大于n位，则结束</span></span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">        <span class="comment">//加上答案和当前数字</span></span><br><span class="line">        ans+=sum+num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num=num*<span class="number">10</span>+a[k];</span><br><span class="line">    <span class="comment">//对应+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum+num,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//对应没有+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="comment">//分离每一位数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        a[i+<span class="number">1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//开始DFS</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//注意答案要除以2</span></span><br><span class="line">    cout&lt;&lt;ans/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有更好的方法：看看这篇文章</p><p>[题解 AT2067 【<a href="https://www.luogu.com.cn/article/eevodhvs">ARC061A] たくさんの数式 / Many Formulas】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="ABC045D-すぬけ君の塗り絵">[ABC045D] すぬけ君の塗り絵</h1><h2 id="题面翻译-4">题面翻译</h2><p>给定一个 $H$ 行 $W$ 列的矩形，再给定矩形上 $N$ 个黑格子的坐标。对于每个 $0\le j\le9$ ，求出有多少个 $3\times3$ 的子矩阵包含有<strong>恰好</strong> $j$ 个黑格子。</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ 行、横 $ W $ 列のマス目からなる盤があります。最初、どのマス目も白く塗られています。</p><p>すぬけ君が、このうち $ N $ マスを黒く塗りつぶしました。$ i $ 回目 ( $ 1\ \leq\ i\ \leq\ N $ ) に塗りつぶしたのは、 上から $ a_i $ 行目で左から $ b_i $ 列目のマスでした。</p><p>すぬけ君がマス目を塗りつぶした後の盤の状態について、以下のものの個数を計算してください。</p><ul><li>各整数 $ j $ ( $ 0\ \leq\ j\ \leq\ 9 $ ) について、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $ 列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるもの。</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ N $ $ a_1 $ $ b_1 $ : $ a_N $ $ b_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>出力は $ 10 $ 行からなる。 $ j+1 $ 行目 ( $ 0\ \leq\ j\ \leq\ 9 $ ) には、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $ 列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるものの 総数を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 8</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 20</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">2 5</span><br><span class="line">3 10</span><br><span class="line">4 2</span><br><span class="line">4 7</span><br><span class="line">5 9</span><br><span class="line">6 4</span><br><span class="line">6 6</span><br><span class="line">6 7</span><br><span class="line">7 1</span><br><span class="line">7 3</span><br><span class="line">7 7</span><br><span class="line">8 1</span><br><span class="line">8 5</span><br><span class="line">8 10</span><br><span class="line">9 2</span><br><span class="line">10 4</span><br><span class="line">10 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">26</span><br><span class="line">22</span><br><span class="line">10</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000 1000000000 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">999999996000000004</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 3\ \leq\ H\ \leq\ 10^9 $</li><li>$ 3\ \leq\ W\ \leq\ 10^9 $</li><li>$ 0\ \leq\ N\ \leq\ min(10^5,H×W) $</li><li>$ 1\ \leq\ a_i\ \leq\ H $ $ (1\ \leq\ i\ \leq\ N) $</li><li>$ 1\ \leq\ b_i\ \leq\ W $ $ (1\ \leq\ i\ \leq\ N) $</li><li>$ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ $ (i\ \neq\ j) $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>![](<a href="https://atcoder.jp/img/arc061/30326702be007759dce81231012a8353.png">https://atcoder.jp/img/arc061/30326702be007759dce81231012a8353.png</a>) この盤に含まれる $ 3×3 $ の正方形は全部で $ 6 $ 個ありますが、これらのうち $ 2 $ 個の内部には黒いマスが $ 3 $ 個、残りの $ 4 $ 個の内部には黒いマスが $ 4 $ 個含まれています。</p></blockquote><h2 id="思路-4">思路</h2><p>思路参考自<a href="https://www.luogu.com.cn/article/9kz3t00a">AT2068题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>直接开数组模拟肯定<s>喜提</s>TLE,MLE。</p><p>这时候就要想到贡献法，就是每输入一个格子，计算它对包含它的九宫格的贡献（记得判边界）</p><p>所以我们只需维护一个答案数组，每次计算新格子对它的影响就行了</p><p>但是，又有个新问题：如何记录新加进来的格子所在的九宫格原来黑格子的个数呢？</p><p><s>显然</s>我们可以用 map 来解决，用它来维护以$x,y$为中心的九宫格黑格子个数</p><p>完结撒花！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;<span class="comment">//用pair来维护二元组 </span></span><br><span class="line">map&lt;pii,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h,w;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">ans[<span class="number">0</span>]=(h<span class="number">-2</span>)*(w<span class="number">-2</span>);<span class="comment">//初始化，一开始一个黑格子都没有 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">-1</span>;k&lt;=<span class="number">1</span>;k++)<span class="comment">//遍历计算影响 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=a+j,y=b+k;<span class="comment">//九宫格的中心 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;<span class="number">1</span>&amp;&amp;y&lt;w)<span class="comment">//判断边界 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> now;<span class="comment">//now表示现在这个九宫格的黑格子的数量 </span></span><br><span class="line">now=++mp[&#123;x,y&#125;];</span><br><span class="line">                    <span class="comment">//now++,那么now-1肯定就是要--啦</span></span><br><span class="line">ans[now]++,ans[now<span class="number">-1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC043</title>
      <link href="/2024/03/20/ABC043/"/>
      <url>/2024/03/20/ABC043/</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC043A-キャンディーとN人の子供イージー">[ABC043A] キャンディーとN人の子供イージー</h1><h2 id="题面翻译">题面翻译</h2><p>幼儿园有N个孩子。教授决定给孩子们糖果，第一个人要一个糖果，第二个人要两个糖果…… ，第N个人要N个糖果。总共需要多少糖果？</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園には$ N $人の子供がいます。えび先生は、子供たちを一列に並べ、一人目にはキャンディーを$ 1 $個,二人目には$ 2 $個,…,$ N $人目には$ N $個あげることにしました。必要なキャンディーの個数の合計は何個でしょう?</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>必要なキャンディーの個数の合計を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 1+2+3=6 $が答えになります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>$ 1 $から$ 10 $までの和は$ 55 $です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>子供は一人しかいません。この時答えは$ 1 $になります。</p></blockquote><h2 id="思路">思路</h2><p>等差数列计算即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;(n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC043B-バイナリハックイージー">[ABC043B] バイナリハックイージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>$Sig$已经打造了他自己的键盘。为了设计最简单，在这个键盘上面只有$3$个按键：$0$号键，$1$号键和退格键。</p><p>首先，他正在用他的键盘使用纯文本编辑器。这个编辑器总是显示一个字符串（可能为空）。就在编辑开始的时候，这个字符串是空的。当键盘上的任意按键被按下时，字符串将发生以下变化：</p><ul><li><p>$0$号键：一个文字$0$将被插入到字符串的右边。</p></li><li><p>$1$号键：一个文字$1$将被插入到字符串的右边。</p></li><li><p>退格键：如果字符串是空的，什么都不会发生。否则字符串最右边的文字将被删除。</p></li></ul><p>$Sig$已经开始了编辑，并且按下了这些按键几次。你将被给予一个他敲击键盘的顺序字符串s。在这个字符串中，文字$0$代表$0$号键，文字$1$代表$1$号键，而字母$B$则代表退格键。请问现在编辑器上会显示什么字符串呢？</p><h2 id="题目描述-2">题目描述</h2><p>しぐはキーボードを製作しました。シンプルさを極限まで追求したこのキーボードには、<code>0</code> キー、<code>1</code> キー、バックスペースキーの $ 3 $ つしかキーがありません。</p><p>手始めに、しぐはこのキーボードで簡単なテキストエディタを操作してみることにしました。このエディタには常に一つの文字列が表示されます（文字列が空のこともあります）。エディタを起動した直後では、文字列は空です。キーボードの各キーを押すと、文字列が次のように変化します。</p><ul><li><code>0</code> キー: 文字列の右端に文字 <code>0</code> が挿入される。</li><li><code>1</code> キー: 文字列の右端に文字 <code>1</code> が挿入される。</li><li>バックスペースキー: 文字列が空なら、何も起こらない。そうでなければ、文字列の右端の $ 1 $ 文字が削除される。</li></ul><p>しぐはエディタを起動し、これらのキーを何回か押しました。しぐが押したキーを順番に記録した文字列 $ s $ が与えられます。$ s $ の中の文字 <code>0</code> は <code>0</code> キー、文字 <code>1</code> は <code>1</code> キー、文字 <code>B</code> はバックスペースキーを表します。いま、エディタの画面にはどのような文字列が表示されているでしょうか？</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>最終的にエディタに表示されている文字列を出力せよ。（「制約」セクションで述べたように、この文字列が空になるような入力は与えられない）</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01B0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0BB1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ |s|\ ≦\ 10 $ ($ |s| $ は $ s $ の長さを表す)</li><li>$ s $ は文字 <code>0</code>, <code>1</code>, <code>B</code> のみからなる。</li><li>正解は空文字列ではない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>, <code>01</code>, <code>0</code>, <code>00</code> と変化します。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>, <code>(空文字列)</code>, <code>(空文字列)</code>, <code>1</code> と変化します。</p></blockquote><h2 id="思路-2">思路</h2><p>使用deque模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;q.<span class="built_in">size</span>())q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>||s[i]==<span class="string">&#x27;1&#x27;</span>)q.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ARC059C-いっしょ">[ARC059C] いっしょ</h1><h2 id="题面翻译-3">题面翻译</h2><p>Evi有$n$个整数，分别为$a_1$，$a_2$，直到$a_n$。</p><p>他的目标是通过改变其中的一些数来使所有数相等。</p><p>对于每个整数，他最多可以变换一次。</p><p>将一个整数$x$转换为一个整数$y$会花费他$\left(x-y\right)^2$美元。</p><p>即使第$i$个数$a_i$与第$j$个数$a_j$ $\left(i!=j\right)$相等，他仍需为了改变它们中的每个数分别花费代价(请见样例2)。</p><p>请找到能够实现他目标的最小花费。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の整数 $ a_1,a_2,…,a_N $ が与えられます。えび君はこれらを書き換えて全て同じ<strong>整数</strong>にしようとしています。各$ a_i\ (1≦i≦N) $は高々一回しか書き換えられません(書き換えなくても良い)。整数$ x $を整数$ y $に書き換えるとき、コストが$ (x-y)^2 $かかります。仮に$ a_i=a_j\ (i≠j) $だとしても、ひとつ分のコストで同時に書き換えることは出来ません(入出力例$ 2 $ を参照)。えび君が目的を達成するのに必要なコストの総和の最小値を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>えび君が全てを同じ整数に書き換えるのに必要なコストの総和の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-100 -100 -100 -100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦100 $</li><li>$ -100≦a_i≦100 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>全てを$ 6 $に書き換えると、コストの総和は$ (4-6)^2+(8-6)^2=8 $となり、これが最小です。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>全てを$ 2 $に書き換えると$ (1-2)^2+(1-2)^2+(3-2)^2=3 $となります。各$ a_i $ごとに書き換えるので、二つの$ 1 $を一度にコスト$ (1-2)^2 $で書き換えられるわけではないことに注意してください。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>$ 4 $は書き換えずに、$ 2 $と$ 5 $を共に$ 4 $に書き換えることで$ (2-4)^2+(5-4)^2=5 $が達成できて、これが最小です。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>何も書き換えなくともえび君は目的を達成しています。よってこの場合コストは$ 0 $です。</p></blockquote><h2 id="思路-3">思路</h2><p>因为范围实在是太小了，所以直接暴力枚举即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> MIN=<span class="number">200</span>,MAX=<span class="number">-200</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        MIN=<span class="built_in">min</span>(a[i],MIN);</span><br><span class="line">        MAX=<span class="built_in">max</span>(a[i],MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=MIN;i&lt;=MAX;i++)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            tmp+=(a[j]-i)*(a[j]-i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(tmp,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里是有规律的，答案只可能是平均值，或者离平均值最近的两个数（也就是是这三者中的其中一个），原理大概是利用均值不等式吧。</p><blockquote><h1 id="ARC059D-アンバランス">[ARC059D] アンバランス</h1><h2 id="题面翻译-4">题面翻译</h2><p>给出字符串$s$,求区间$[l,r]$,使得该子串中有一种字母出现的次数严格大于该子串长度的一半.<br>如果没有符合条件的子串,输出两个-1.</p><p>由 @Fuko_Ibuki 提供翻译</p><h2 id="题目描述-4">题目描述</h2><p>文字列 $ t $ について、$ t $ の長さが $ 2 $ 以上であり、かつ $ t $ の中の文字のうち過半数が同じ文字であるとき、$ t $ を<em>アンバランス</em>であると呼ぶことにします。例えば、<code>voodoo</code> や <code>melee</code> はアンバランスであり、<code>noon</code> や <code>a</code> はアンバランスではありません。</p><p>小文字のアルファベットからなる文字列 $ s $ が与えられます。$ s $ にアンバランスな (連続する) 部分文字列が存在するか判定してください。存在する場合は、$ s $ の中でそのような部分文字列が存在する位置を一つ示してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>$ s $ にアンバランスな部分文字列が存在しない場合は、<code>-1 -1</code> と出力せよ。</p><p>$ s $ にアンバランスな部分文字列が存在する場合は、そのような部分文字列の一つを $ s_a\ s_{a+1}\ …\ s_{b} $ $ (1\ ≦\ a\ &lt;\ b\ ≦\ |s|) $ として、<code>$ a $ $ b $</code> と出力せよ。そのような部分文字列が複数存在する場合は、いずれも正解とみなされる。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">needed</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoder</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 2\ ≦\ |s|\ ≦\ 10^5 $</li><li>$ s $ は小文字のアルファベットのみからなる。</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 2\ ≦\ |s|\ ≦\ 100 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>文字列 $ s_2\ s_3\ s_4\ s_5 $ $ = $ <code>eede</code> はアンバランスな文字列です。他にもアンバランスな部分文字列は存在し、例えば <code>2 6</code> と出力しても正解となります。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>文字列 <code>atcoder</code> はアンバランスな部分文字列を持ちません。</p></blockquote><h2 id="思路-4">思路</h2><p>思维题吧，反正我是没什么思维qwq。</p><p>引用这位大佬的文章：[题解 AT2020 【<a href="https://www.luogu.com.cn/article/55sca778">ARC059B] アンバランス / Unbalanced】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>思路大致如下，与其它题解的差不多：</p><blockquote><p>从字符串的开头搜索到结尾，如果该字符串与后面一个或者后面第二个是相同的，那么该字符与跟它相同的就是一个符合题目要求的子序列。</p></blockquote><blockquote><p>例如$IIIAM$，虽然$IIIAM$是一个符合要求的子序列，但是$II$也符合，所以直接输出$II$就可以了。</p></blockquote><blockquote><p>再举一个例子：$IOIII$，它本身就是一个符合要求的子序列，但是，最前面的是$IOI$ ，所以可以得出结论，答案不是两个长度的子序列就是三个长度的子序列。</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i项与第i+1项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断第i项与第i+2项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">2</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC042</title>
      <link href="/2024/03/20/ABC042/"/>
      <url>/2024/03/20/ABC042/</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC042A-和風いろはちゃんイージー">[ABC042A] 和風いろはちゃんイージー</h1><h2 id="题面翻译">题面翻译</h2><p>给出三个数$A,B,C$，$1≤A,B,C≤10$，判断$A,B,C$是否能重新排列为$575$。</p><p>翻译由<a href="https://www.luogu.com.cn/user/793625">$@PCT2506$</a>提供</p><h2 id="题目描述">题目描述</h2><p>日本の誇る美しいリズムとして、五七五というものがあります。いろはちゃんは五七五が大好きです。</p><p>$ 3 $ つの文節の並びの長さがそれぞれ $ 5,7,5 $ となるようにこの順番で並んでいるとき、その $ 3 $ つの文節の並びは五七五であると言います。</p><p>並び替えたい $ 3 $ つの文節の長さを表す整数 $ A,B,C $ が与えられるので、それらの文節を並び替えて五七五にできるか判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $</p></blockquote><h2 id="输出格式">输出格式</h2><p>文節の並びを五七五にすることができるなら <code>YES</code> 、そうでないなら <code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦A,B,C≦10 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>与えられる文節の長さはそれぞれ $ 5,5,7 $ であり、$ 5,7,5 $ となるように文節を並び替えることができます。したがって、文節の並びを五七五にすることは可能といえます。</p></blockquote><h2 id="思路">思路</h2><p>直接统计5和7的个数判断即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cnt5=<span class="number">0</span>,cnt7=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">5</span>)cnt5++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">7</span>)cnt7++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt5==<span class="number">2</span>&amp;&amp;cnt7==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC042B-文字列大好きいろはちゃんイージー">[ABC042B] 文字列大好きいろはちゃんイージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>题目描述：<br>有n个长为L的字符串</p><p>要求把他们按照字典序进行排序并在一行内输出</p><p>输入格式：<br>第一行两个正整数n，L<br>以下n行每行一个字符串</p><p>输出格式：<br>仅一行：排序过后的字符串</p><p>（注 ： 这次岛国的题末尾可以不换行）</p><p><s>输入输出不敲了</s></p><p>说明：约定：</p><p>1，1 &lt;= n,L &lt;= 100且n，L 都是正整数</p><p>2，对于第i(1 &lt;= i &lt;= n)个字符串，保证长度为L</p><p>3，所有字符串都由小写字母构成</p><p>感谢@lsy263  提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>いろはちゃんは 長さ $ L $ の文字列を $ N $ 個持っており、それぞれ $ S_1,\ S_2,\ …,\ S_N $ です。</p><p>それらの文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを求めてください。</p><p>なお、ある文字列 $ s=s_1s_2s_3 $…$ s_n $ と $ t=t_1t_2t_3 $…$ t_m $ について、以下のどちらかを満たすとき、辞書順比較で $ s\ &lt;\ t $ であるといいます。</p><ul><li>ある整数 $ i(1≦i≦min(n,m)) $ に関して、 $ 1≦j\ &lt;\ i $ を満たす任意の整数 $ j $ において $ s_j\ =\ t_j $ が成立し、かつ $ s_i\ &lt;\ t_i $ が成立する。</li><li>任意の整数 $ i(1≦i≦min(n,m)) $ に関して $ s_i\ =\ t_i $ が成立し、かつ $ n\ &lt;\ m $ が成立する。</li></ul><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ L $ $ S_1 $ $ S_2 $ : $ S_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>与えられる文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">dxx</span><br><span class="line">axx</span><br><span class="line">cxx</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axxcxxdxx</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ N,\ L\ ≦\ 100 $</li><li>全ての $ i\ (1≦i≦N) $ に対し、$ S_i $ の長さは $ L $ に等しい。</li><li>各 $ i $ について, $ S_i $ は全て半角英小文字のみから成る文字列である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>与えられた文字列を <code>axx</code>,<code>cxx</code>,<code>dxx</code> という順番に並び替えてから結合することで、辞書順最小を達成できます。</p></blockquote><h2 id="思路-2">思路</h2><p>直接排序即可，其实cmp函数可以不用写的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,l=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到题解区有大佬用了优先队列，可以看看qwq</p><p>[题解 AT1978 【<a href="https://www.luogu.com.cn/article/8um5juk5">ABC042B] 文字列大好きいろはちゃんイージー / Iroha Loves Strings (ABC Edition)】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="ARC058C-こだわり者いろはちゃん">[ARC058C] こだわり者いろはちゃん</h1><h2 id="题面翻译-3">题面翻译</h2><p>买家想买一个价格为N的物品，但他又讨厌k个数字，分别为D_1，D_2，……，D_K。问他最少出多少钱，才能在保证买下这个物品的同时使自己出的钱不包括自己讨厌的数字。</p><h2 id="题目描述-3">题目描述</h2><p>いろはちゃんはこだわりもので、嫌いな数字が $ K $ 個あり、それぞれ $ D_1,\ D_2,\ …,\ D_K $ です。</p><p>いろはちゃんはお店でお買い物をしていて、 $ N $ 円の品物を買おうとしています。 もちろん、この品物は $ N $ 円以上のお金を支払えば買うことができます。 しかし、先ほど述べたようにいろはちゃんは強いこだわりがあるので、自分がお店に支払う金額の $ 10 $ 進表記にいろはちゃんの嫌いな数字が出現しないような最も少ない金額を支払おうとします。</p><p>いろはちゃんが支払う金額を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ D_1 $ $ D_2 $ … $ D_K $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>いろはちゃんが支払う金額を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 8</span><br><span class="line">1 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N\ &lt;\ 10000 $</li><li>$ 1\ ≦\ K\ &lt;\ 10 $</li><li>$ 0\ ≦\ D_1\ &lt;\ D_2\ &lt;\ …\ &lt;\ D_K≦9 $</li><li>$ {D_1,D_2,…,D_K}\ ≠\ {1,2,3,4,5,6,7,8,9} $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>嫌いでない数字は $ 0 $ と $ 2 $ のみです。 $ N=1000 $ 以上の整数で、桁に $ 0 $ と $ 2 $ のみが含まれる最小の整数は $ 2000 $ なのでそれを出力してください。</p></blockquote><h2 id="思路-3">思路</h2><p>这题想复杂了，其实直接枚举即可，从$n$开始向上枚举，并将其进行逐位拆分，判断其中是否出现讨厌的数字即可。注意如果出现0的话，直接退出循环，输出$num$即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//开个桶记录一下讨厌的数字</span></span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num=n;</span><br><span class="line">        <span class="comment">//进行逐位拆分，判断是否出现讨厌的数字</span></span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[num%<span class="number">10</span>])<span class="keyword">break</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为0，说明拆分完毕，满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，说明存在讨厌的数字，继续向上枚举</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ARC058D-いろはちゃんとマス目">[ARC058D] いろはちゃんとマス目</h1><h2 id="题面翻译-4">题面翻译</h2><h3 id="题意">题意</h3><p>有一个 $H\times W$ 的矩阵, 现在你正位于左上角的格子, 并且你只能向右移动或向下移动, 不幸的是, 矩阵的左下角 $A\times B$ 的地方被划为了禁区, 即你不能在此行走, 那么现在你有多少种方法从左上角走到右下角的格子呢?</p><h3 id="输入">输入</h3><p>一行四个整数 $H,W,A,B$.</p><h3 id="输出">输出</h3><p>方案数. 由于方案数很大, 请对 $10^9+7$ 取模.</p><p>感谢@凌幽 提供的翻译</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ マス、横 $ W $ マスのマス目があります。 いろはちゃんは、今一番左上のマス目にいます。 そして、右か下に1マス移動することを繰り返し、一番右下のマス目へと移動します。 ただし、下から $ A $ 個以内、かつ左から $ B $ 個以内のマス目へは移動することは出来ません。</p><p>移動する方法は何通りあるか求めてください。</p><p>なお、答えは非常に大きくなることがあるので、答えは $ 10^9+7 $ で割ったあまりを出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ A $ $ B $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>移動する方法の数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 7 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3570</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 99999 99999</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 44444 55555</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">738162020</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ ≦\ H,\ W\ ≦\ 100,000 $</li><li>$ 1\ ≦\ A\ &lt;\ H $</li><li>$ 1\ ≦\ B\ &lt;\ W $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>$ 2×3 $ マスありますが、左下の $ 1 $ マスには移動することができません。「右右下」、「右下右」という $ 2 $ つの移動の仕方があります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>移動できないマスが $ 12 $ マスあります。</p></blockquote><h2 id="思路-4">思路</h2><p>其实是一道数学题，思路不难想，大致有两种：</p><p>1、从$(1,1)$到$(a-1,b)$，再从$(a-1,b+1)$到$(h,w)$走，具体怎么算？其实就是高中的组合数学。</p><p>2、先考虑从$(1,1)$到$(h,w)$的所有路径数，记作$ans1$，不考虑任何要求。然后我们再考虑可能经过禁区的路径数：这时，问题相当于在前$a+b-2$步中，向下走的步数大于或等于$b-2$步，那我们只需要计算对应的每种情况：当走完向下走完$i$步时，且走完前$a+b-2$步时的所有路径数，并从当前位置开始，重新计算到$(h,w)$的所有路径数，注意两者需要一一对应相乘，然后把所有不合法的情况统计起来，记作$ans2$。那么答案就是$ans1-ans2$。</p><p>这里先贴上大佬的代码，自己写的没过qwq，而且大佬们的板子也挺漂亮的，可以整理作为自己的板子。</p><h3 id="思路1">思路1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[MAXN],inv[MAXN];</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==m||m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((fac[n]*inv[m])%mod*inv[n-m]%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x2+y2-x1-y1,x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> h,w,a,b;cin&gt;&gt;h&gt;&gt;w&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//注意记得初始化哦</span></span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算阶乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">        fac[i]=(i*fac[i<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[<span class="number">200000</span>]= <span class="built_in">qpower</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">199999</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        inv[i]=(inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h-a;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,i,b)*<span class="built_in">get</span>(i,b+<span class="number">1</span>,h,w)%mod;</span><br><span class="line">        <span class="comment">//注意这里还需要取模哦</span></span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2">思路2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = b; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * a % mod;</span><br><span class="line">a = (<span class="type">long</span> <span class="type">long</span>)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)jc[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>() - <span class="number">1</span>; m = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">a = n - <span class="built_in">read</span>() + <span class="number">1</span>; b = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">jc[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>; k = n + m + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求阶乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">jc[i] = (<span class="type">long</span> <span class="type">long</span>)jc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[k] = <span class="built_in">qpow</span>(jc[k], mod - <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = k - <span class="number">1</span>; i; --i)</span><br><span class="line">inv[i] = (<span class="type">long</span> <span class="type">long</span>)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有的情况</span></span><br><span class="line">    ans = <span class="built_in">c</span>(n + m, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减去走入禁区的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt;= b; ++i)</span><br><span class="line">ans = (ans - (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">c</span>(a + b, i) * <span class="built_in">c</span>(n + m - a - b, m - i) % mod * now + mod) % mod;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">write</span>(ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧拉定理</title>
      <link href="/2024/03/19/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/19/%E6%8B%93%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧拉定理">拓展欧拉定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33): 拓展欧拉定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p>先介绍一下<strong>欧拉定理</strong>：</p><blockquote><p>若正整数$a$与$m$互质，则$a^{\varphi(m)}\equiv 1(mod\ m)$。</p></blockquote><p>这里的$\varphi (m)$指的是欧拉函数，即小于或等于$m$且与$m$互质的正整数个数。当$m$是质数 $p$时，欧拉定理退化成费马小定理$a^{p-1}\equiv1(mod\ p)$ 。</p><p>在算法竞赛中，我们常常会用到它的一个重要的推论：若正整数$a$与$m$互质，则</p><p>$a^b\equiv a^{b\ mod\ \varphi(m)}(mod\ m)$。</p><p>（这是因为$a^b=a^{\varphi(m)\lfloor b/\varphi(m)\rfloor+b\ mod\  \varphi (m)}\equiv 1·a^{b\ mod\ \varphi(m)}(mod\ m)$）</p><p>利用这个推论，即使$b$比较大，我们也可以轻松地算出$a^b\ mod\ m$的值，但需要满足$a$与$m$互质的前提。</p><hr><p>为了解决$a$与$m$不互质时的问题，我们引入了<strong>拓展欧拉定理</strong>：若$b\geq\varphi(m)$，则：$a^b\equiv a^{b\ mod\ \varphi(m)+varphi(m)}\ (mod\ m)\ (*)$</p><p>这里仍有前提条件，但影响不大，因为$b\leq\varphi (m)$时直接用快速幂计算即可。</p><p>当$a$与$m$<strong>互质</strong>时，由于$a^b\equiv a^{b\ mod\ \varphi(m)}·1\equiv a^{b\ mod\ \varphi(m)}·a^{\varphi(m)}\ (mod\ m)\ (*)$式显然成立。</p><p>当$a$与$m$<strong>不互质</strong>时，我们考虑吧$m$<strong>质因数分解</strong>成${p_1}^{q_1}{p_2}^{q_2}······{p_n}^{q_n}$，我们只需要证明的每个${p_i}^{q_i}$，都有$a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}(mod\ {p_i}^{q_i})$即可。因为如果设$m_1、m_2$互质，且$x\equiv y\ (mod\ m_1)$同时$x\equiv y\ (mod\ m_2)$，则$x\equiv y(mod\ m_1m_2)$必成立（$x-y$既是$m_1$的倍数又是$m_2$的倍数），所以这里可以进行合并。</p><p>现在分类讨论${p_i}^{q_i}$：</p><p>若$gcd(a,{p_i}^{q_i})=1$，则：</p><p>$a^b\equiv a^{\lfloor b/\varphi(m)\rfloor\varphi(m)+b\ mod\ \varphi(m)}\equiv a^{b\ mod\ \varphi(m)}(mod\ {p_i}^{q_i})$</p><p>（注意到$\lfloor b/\varphi(m)\rfloor\varphi(m)$必然是$\varphi ({p_i}^{q_i})$的倍数，因为欧拉函数是<strong>积性函数</strong>）</p><p>若$gcd(a,{p_i}^{q_i})\ne1$，则$a$必然是$p$的倍数。设$a=np$，注意到$\varphi({p_i}^{q_i})={p_i}^{q_i-1}(p_i-1)$，则可以证明$\varphi ({p_i}^{q_i}\geq q_i)$。则：</p><p>$b\geq \varphi(m) \geq \varphi({p_i}^{q_i})\geq q_i$</p><p>所以${p_i}^{q_i}$是$a^{b\ mod\ \varphi (m)+\varphi(m)}$的因数，也是$a^b$的因数，即：</p><p>$a\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}\equiv 0(mod\ {p_i}^{q_i})$</p><p>综上，$a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)(mod\ m)}(b\geq\varphi(m))$</p><p>代码实现时可以边读入边取模，另外一定要注意这个式子仅在$b\geq \varphi(m)$时成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> large_enough = <span class="literal">false</span>; <span class="comment">// 判断是否有b &gt;= phi(m)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">(<span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>)</span> <span class="comment">// 快速读入稍加修改即可以边读入边取模，不取模时直接模一个大于数据范围的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= MOD)</span><br><span class="line">        &#123;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">            large_enough = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 求欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> MOD)</span> <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = <span class="number">1LL</span> * ans * a % MOD; <span class="comment">// 注意防止溢出</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">1LL</span> * a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), phiM = <span class="built_in">phi</span>(m), b = <span class="built_in">read</span>(phiM);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qpow</span>(a, b + (large_enough ? phiM : <span class="number">0</span>), m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>关于欧拉定理的证明我就不放上来了，实在是太难了┭┮﹏┭┮，如果感兴趣的话可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33): 拓展欧拉定理 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢卡斯定理</title>
      <link href="/2024/03/18/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/18/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="卢卡斯定理">卢卡斯定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr><p><strong>卢卡斯定理</strong>是一个与组合数有关的数论定理，在算法竞赛中用于求组合数对某质数的模。</p><p>这里接下来直接介绍卢卡斯定理，原文章的引入和证明不会涉及qwq。如果想看的话可以看看原作者的文章：<a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)</a></p><hr><p>直接根据定义$\binom{m}{n}=\frac{m!}{n!(m-n)!}$计算，很容易溢出，当然我们可以边乘边除，但有点麻烦。于是我们有另外一种思路，利用递推式：$\binom{m}{n}=\binom{m-1}{n-1}+\binom{m-1}{n}$（这个递推式可以从杨辉三角中得到），这种方法相对不容易溢出，时间复杂度为$O(n^2)$。</p><p>但是，然而，实际上，组合数的增长速度是非常快的，如$\binom{300}{150}$则有89位数字，比宇宙中的原子数还多。所谓递推不容易溢出，那如果结果本身就溢出了，你又怎么办呢？</p><p>所幸算法竞赛中的题目常常会要求将结果对某个质数$p$取模，这样一来，溢出的问题就不用太担心了。我们干脆直接回到最原始的方法：$\binom{m}{n}=\frac{m!}{n!(m-n)!}$。只不过，现在我们要把除法变成求<a href="https://zhuanlan.zhihu.com/p/100587745">逆元</a>，也即：$\binom{m}{n}=m!·inv(n!)·inv[(m-n)!](mod\ p)$。</p><p>模$p$ 意义下阶乘和逆元都可以$O(n)$预处理出来，然后直接$O(1)$查询即可（实际上不预处理逆元直接$O(log\ n)$求也绰绰有余）。这基本上是<strong>最常用</strong>的求组合数方法。</p><p>绕了一圈，怎么还没提到卢卡斯定理呢？嗯……一般来说，这个方法够用了。偏偏，有时候，$p$可能比$m$小……</p><p>这下麻烦了。如果$p$比$m$小，就不能保证$n$和$m-n$的逆元存在了（它们可能是$p$的倍数）。当然还是可以用杨辉三角递推，但$O(n^2)$还是太不理想。于是，本文的主角——卢卡斯定理终于要出场了。</p><hr><h2 id="卢卡斯定理-2">卢卡斯定理</h2><blockquote><p>对于非负整数$m,n$和质数$p$ ，$\binom{m}{n}\equiv \prod_{i=0}^k \binom{m_i}{n_i}(mod\ p)$ ，其中$m=m_kp^k+······+m_1p+m_0、n=n_kp^k+······+n_1p+n_0$是$m$和$n$的 $p$进制展开。</p></blockquote><p>但其实，我们一般使用的是这个可以与之互推的式子：</p><blockquote><p>$\binom{m}{n}=\binom{m\ mod\ p}{n\ mod\ p}·\binom{\lfloor m/p \rfloor}{\lfloor n/p \rfloor}(mod\ p)$</p></blockquote><p>当$m&lt;n$时，规定$\binom{m}{n}=0$（待会讲这个定义的含义）。</p><p>就像辗转相除法那样，可以利用这个式子递归求解，递归出口是 $n=0$。其实这篇文章只需要这个好记的公式就够了，你甚至可以马上写出卢卡斯定理的板子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要先预处理出fact[]，即阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m &lt; n ? <span class="number">0</span> : fact[m] * <span class="built_in">inv</span>(fact[n], p) % p * <span class="built_in">inv</span>(fact[m - n], p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lucas</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> % p : <span class="built_in">lucas</span>(m / p, n / p, p) * <span class="built_in">C</span>(m % p, n % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(p+log_p\ m)$，前提是：</p><p>阶乘和逆元都采取递推的方式预处理出来，（只需要预处理$p$以内的即可），每次调用$C$函数都是$O(1)$，一共要调用$log_p\ m$次，总的时间复杂度即为$O(p+log_p\ m)$。</p><hr><p>没想到吧o(*≧▽≦)ツ，全文只需要这个代码模板即可（ε=ε=ε=┏(゜ロ゜;)┛逃）。</p><p>定理的证明maybe以后会补充？？？因为都是数学符号，看得有点烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/2024/03/18/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
      <url>/2024/03/18/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数">欧拉函数</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><h2 id="欧拉函数的引入及性质">欧拉函数的引入及性质</h2><p>**欧拉函数$\varphi(x)$**是一个非常重要的函数，它定义为小于（或不大于，这里是一样的）$x$但与$x$互质的正整数的数量，例如$\varphi (12)=4$，有1、5、7、11与之互质。特别地，规定$\varphi (1)=1$。</p><p>主要性质如下：</p><blockquote><p>若$p$是质数，则$\varphi (p^n)=p^{n-1}(p-1)$</p><p>若$a|x$，则$\varphi (ax)=a\varphi (x)$</p><p>若$a、b$互质，则$\varphi(a)\varphi(b)=\varphi(ab)$</p><p>（这里跳过证明，想要看证明的可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数 - 知乎 (zhihu.com)</a>）（也许我自己以后会补充？）</p></blockquote><p>注意：符合第三个性质的函数称为积性函数。</p><hr><p>我们把正整数<strong>质因数分解</strong>：</p><p>$x={p_1}^{k_1}{p_2}^{k_2}······{p_n}^{k_n}$。</p><p>所有${p_i}^{k_i}$两两互质，由欧拉函数的性质得：</p><p>$\varphi (x)={p_1}^{k_1-1}(p_1-1){p_2}^{k_2-1}(p_2-1)······{p_n}^{k_n-1}(p_n-1)$.</p><p>即：</p><p>$\varphi (x)=x·\frac{p_1-1}{p_1}·\frac{p_2-1}{p_2}······\frac{p_n-1}{p_n}$</p><p>我们可以利用这个方法以最坏的时间复杂度$O(\sqrt{n})$内求出指定正整数的欧拉函数值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除再乘防止溢出</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) <span class="comment">// 每个质因数只处理一次，可以把已经找到的质因数除干净</span></span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>); <span class="comment">// 最后剩下的部分也是原来的n的质因数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们还可以把求欧拉函数与<strong>筛法</strong>结合起来，例如用类似埃氏筛的方法，求1~n的欧拉函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> phi[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        phi[i] = i; <span class="comment">// 除1外没有数的欧拉函数是本身，所以如果phi[i] = i则说明未被筛到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == i) <span class="comment">// 未被筛到</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 所有含有该因子的数都进行一次操作</span></span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以保证范围内每个数都能被它的所有质因数筛且只筛一次。注意一个正整数$x$是质数的充要条件是</p><p>$\varphi (x)=x-1$，所以我们其实顺便求出了所有的素数。这个方法的时间复杂度是$O(nloglog\ n)$，比一个一个求的$O(n\sqrt{n})$更好。</p><p>当然也可以在欧拉筛途中顺便求出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i), phi[i] = i - <span class="number">1</span>; <span class="comment">// 性质一，指数为1的情形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[p * i] = phi[i] * p; <span class="comment">// 性质二</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                phi[p * i] = phi[p] * phi[i]; <span class="comment">// 这时肯定互质，用性质三</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有进行质因数分解，综合运用了开头提到的三种性质，时间复杂度为$O(n)$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/"/>
      <url>/2024/03/18/%E4%BA%8C%E6%AC%A1%E5%89%A9%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<p>还没写好，可能这几天补好</p><hr><h1 id="二次剩余">二次剩余</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/166123245">算法学习笔记(41): 二次剩余 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p><strong>二次剩余</strong>，常被称为模意义开根，是求满足$n\equiv x^2(mod\ m)$的$x$的值。</p><p>首先需要注意，并不是对每个$n$而言上面的方程都有解。如果上面的方程有非零解，我们称$n$是模$m$的<strong>二次剩余</strong>。如果方程无解，则称$n$是模$m$的<strong>二次非剩余</strong>。</p><p>为了方便讨论，我们引入<strong>勒让德符号</strong>：</p><p>$ (\frac{a}{b})=\left{<br>\begin{aligned}<br>1     &amp;  , 如果a是p的二次剩余\<br>0     &amp;  , 如果a\ mod\ p=0\<br>{-1}  &amp;  , 如果a是p的二次非剩余<br>\end{aligned}<br>\right.<br>$</p><p>接下来讨论如何求解二次剩余，一般只考虑奇素数的情况。</p><hr><h2 id="欧拉准则">欧拉准则</h2><p>当模数是奇素数$p$且与$a$互质时，由费马小定理，$a^{p-1}\equiv1\ (mod\ p)$，设$p=2q+1$，</p><p>则有$a^{2q}\equiv 1\ (mod\ p)$，于是$(a^q-1)(a^q+1)\equiv 0\ (mod\ p)$，故$a^q\equiv \pm1 (mod\ p)$，即$a^{\frac{p-1}{2}}\equiv\pm1\ (mod\ p)$。</p><p>所以只要$a、p$互质，$a^{\frac{p-1}{2}}$在模$p$意义下就只可能等于$1$或${-1}$。到底是$1$还是${-1}$，这与二次剩余紧密相关，实际上，有以下公式：</p><blockquote><p>$(\frac{a}{p})\equiv a^{\frac{p-1}{2}}(mod\ p)$</p></blockquote><p>以上公式被称为<strong>欧拉准则</strong>，我们只需要计算$a^{\frac{p-1}{2}}$即可判断$a$是否为$p$的二次剩余。</p><hr><p>这里实际上有一个<strong>证明</strong>：“$a$是模$p$的二次剩余”是&quot;$a^{\frac{p-1}{2}}\equiv 1(mod\ p)$&quot;的充要条件。</p><p>但是目前没时间写，可能过两天再写。咕咕咕</p><hr><p>由此可以有一个推论：当$\frac{p-1}{2}$是奇数时，如果$a$是模$p$的二次剩余，则${-a}$是mo$p$的二次非剩余。相反，当$\frac{p-1}{2}$是偶数时，如果$a$是模$p$的二次剩余，则${-a}$也是模$p$的二次剩余。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
      <url>/2024/03/18/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉筛">欧拉筛</h1><p>文章部分内容转载自<a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 - 知乎 (zhihu.com)</a>、<a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏 (luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr><p>不想再写一遍原理了qwq（如果忘记原理就去看看大佬们的详细证明吧，感觉注释也说得很清楚了@w@）。</p><p><a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏 (luogu.com.cn)</a></p><p>所以我就直接贴上欧拉筛的模板了。</p><hr><blockquote><h1 id="【模板】线性筛素数">【模板】线性筛素数</h1><h2 id="题目背景">题目背景</h2><p>本题已更新，从判断素数改为了查询第 $k$ 小的素数<br>提示：如果你使用  <code>cin</code> 来读入，建议使用 <code>std::ios::sync_with_stdio(0)</code> 来加速。</p><h2 id="题目描述">题目描述</h2><p>如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。</p><p>接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出 $q$ 行，每行一个正整数表示答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【数据范围】<br>对于 $100%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。</p><p>Data by NaCly_Fish.</p></blockquote><p><strong>学委大佬的代码</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> isPrime[N];<span class="comment">//isPrime[i]==1表示：i是质数</span></span><br><span class="line"><span class="type">int</span> Prime[N], cnt = <span class="number">0</span>;<span class="comment">//Prime存质数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="number">1</span>, <span class="built_in">sizeof</span>(isPrime));</span><br><span class="line"><span class="comment">//以“每个数都是素数”为初始状态，逐个删去</span></span><br><span class="line">isPrime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//1不是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;<span class="comment">//没被筛掉</span></span><br><span class="line">Prime[++cnt] = i;<span class="comment">//i成为下一个素数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span></span><br><span class="line"><span class="comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span></span><br><span class="line">isPrime[i * Prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="built_in">getPrime</span>(n);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; Prime[k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pecco</strong>大佬的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isnp[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 质数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>两者的写法其实很相似了，如果忘记了原理，可以先看看<strong>学委大佬</strong>的，要写题的话，推荐用<strong>pecco</strong>大佬的板子。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
      <url>/2024/03/18/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="中国剩余定理">中国剩余定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/103394468">算法学习笔记(10): 中国剩余定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p><strong>中国剩余定理</strong>，也叫<strong>孙子定理</strong>，之所以叫这个名字，是因为《孙子算经》中有这样一个问题：</p><blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><p>实际上就是求解下面的<strong>同余方程组</strong>：<br>$$<br>\left{<br>\begin{aligned}<br>x &amp; \equiv b_1 &amp; (mod\ a_1)\<br>x &amp; \equiv b_2 &amp; (mod\ a_2)\<br>x &amp; \equiv b_n &amp; (mod\ a_n)<br>\end{aligned}<br>\right.<br>$$<br>这个方程组有解的一个<strong>充分条件</strong>是：$a_1、a_2······a_n$<strong>两两互质</strong>，可以使用构造法得到下面方程的通解，一下面这道模板题为例：</p><p>（<strong>洛谷P1495 曹冲养猪</strong>）</p><blockquote><p><strong>题目描述</strong><br>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有16头母猪，如果建了3个猪圈，剩下1头猪就没有地方安家了。如果建造了5个猪圈，但是仍然有1头猪没有地方去，然后如果建造了7个猪圈，还有2头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？<br><strong>输入格式</strong><br>第一行包含一个整数$n\ (n \leq10)——$建立猪圈的次数，解下来n行，每行两个整数$a_i,b_i\ (b_i\leq a_i \leq1000)$表示建立了$a_i$个猪圈，有$b_i$头猪没有去处。你可以假定$a_i,a_j$互质.<br><strong>输出格式</strong><br>输出包含一个正整数，即为曹冲至少养母猪的数目。</p></blockquote><p>(本质上就是给“物不知数”套了个背景)。</p><hr><p>我们从“物不知数”这个具体问题出发。<strong>（接下来一大波数学公式，请做好心理再看）</strong></p><p>要想直接找到一个$n$使得方程组$\left{<br>\begin{aligned}<br>x &amp; \equiv 2 &amp;(mod\ 3)\<br>y &amp; \equiv 3 &amp;(mod\ 5)\<br>z &amp; \equiv 2 &amp;(mod\ 7)<br>\end{aligned}<br>\right.<br>$ 成立时不容易的，但是要找到</p><p>$n_1,n_2,n_3$使得$\left{<br>\begin{aligned}<br>n_1 &amp; \equiv 2&amp; (mod\ 3) \<br>n_2 &amp; \equiv 3&amp; (mod\ 5) \<br>n_3 &amp; \equiv 2&amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$是相对容易的。</p><p>直接令$x=n_1+n_2+n_3$可以吗？恐怕未必。在什么情况下$n_1\equiv 2(mod\ 3)$可以推出$n_1+n_2\equiv2(mod\ 3)$呢？显然，那只有当$n_2$是3的倍数时成立。同理，要想让$n_1+n_2+n_3$也符合前式，也需要$n_2$和$n_3$都是3的倍数。</p><p>这样推导下来，$x=n_1+n_2+n_3$符合方程组的条件是$n_1$是35的倍数，$n_2$是21的倍数，$n_3$是15的倍数。也就是说，现在我们需要求三个同余方程：</p><p>$\left{<br>\begin{aligned}<br>35m_1 &amp; \equiv 2 &amp; (mod\ 3) \<br>21m_2 &amp; \equiv 3 &amp; (mod\ 5) \<br>15m_3 &amp; \equiv 2 &amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$</p><p>注意到模数两两互质，则$gcd(35,3)=gcd(21,5)=gcd(15,7)=1$，所以我们可以用拓展欧几里得的方法解（我愿称之为最妙的一步<strong>qwq</strong>，这里用的是求逆元的方法）：</p><p>$ \left{<br>\begin{aligned}<br>35w_1 &amp; \equiv 1&amp; (mod\ 3) \<br>21w_2 &amp; \equiv 1&amp; (mod\ 5)\<br>15w_3 &amp; \equiv 1&amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$</p><p>解得$w_1=2,w_2=1,w_3=1$，然后可得：$\left{<br>\begin{aligned}<br>m_1 &amp; =2w_1=4 \<br>m_2 &amp; =3w_2=3 \<br>m_3 &amp; =2w_3=2<br>\end{aligned}<br>\right.<br>$</p><p>于是：$\left{<br>\begin{aligned}<br>n_1 &amp; = 35m_1=140 \<br>n_2 &amp; = 21m_2=63 \<br>n_3 &amp; = 15m_3=30<br>\end{aligned}<br>\right.<br>$。</p><p>三者相加，即得一<strong>特解233</strong>（这里的233不是网络意义下的233，但我算出来不禁233了）。所有与233在<strong>模</strong>105<strong>意义下同余</strong>的数都是这个方程组的解，要求<strong>最小正数解</strong>只需对105取模即可，这里得出来是<strong>23</strong>。</p><hr><p>接下来将这个过程一般化（<strong>个人感觉严重劝退qwq</strong>）。设$p=\prod_{i=1}^{n}a_i$（即所有模数的乘积），并设$r_i=\frac{p}{a_i}$（在“物不知数”中即为35、21和15）。于是$w_i={inv(r_i)|}_{a_i}$（表示$r_i$在模$a_i$意义下的逆元），$m_i=b_iw_i$，而$n_i=r_im_i$，所有$n_i$相加得到$x$。</p><p>以上这些综合起来就是：</p><p>$x\equiv \sum_{i=1}^nb_ir_i{[r_i]^{-1}|}_{a_i}\ (mod\ p)$</p><p>下面贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span>  <span class="comment">// a是模数数组，b是余数数组，n是数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;   <span class="comment">// 逆元的求法参见上篇文章，或者下面有完整代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的是符合方程组的最小正整数解，一般题目要求的就是这个。</p><p>再附上曹冲养猪的完整AC代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, a[<span class="number">10</span>], b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, a + i, b + i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">CRT</span>(a, b, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现（其实就是照抄作者的qwq）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(ll a[],ll b[],ll n)</span></span>&#123;</span><br><span class="line">    ll p=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p*=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll r=p/a[i];</span><br><span class="line">        x+=(b[i]*r*<span class="built_in">inv</span>(r,a[i]))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">CRT</span>(a,b,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元</title>
      <link href="/2024/03/18/%E9%80%86%E5%85%83/"/>
      <url>/2024/03/18/%E9%80%86%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="逆元">逆元</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/100587745">算法学习笔记(9)：逆元 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><h2 id="逆元的引入">逆元的引入</h2><p>在数论中，如果$ab\equiv1(mod\ p)$，我们就说$a$和$b$在模$p$意义下互为乘法逆元，记作$a=inv(b)$。</p><p>为什么要引入逆元？常常会遇到一些题目要求结果对一个大质数$p$取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。<strong>加减法</strong>和<strong>乘法</strong>对取模运算都是<strong>封闭</strong>的，所以你可以处处取模来避免溢出。</p><p><img src="https://img2.imgtp.com/2024/03/18/RqrxFVdZ.png" alt=""></p><p>但是遇到除法时，就麻烦了：</p><p><img src="https://img2.imgtp.com/2024/03/18/AdajgadB.png" alt=""></p><p>为了解决模意义下的除法问题，我们引入了逆元。$inv(a)$其实可以看作是模$p$意义下的$\frac{1}{a}$，那么在模$p$意义下，$\frac{a}{b}$就可以变成$a*inv(b)(mod\ p)$。</p><p>实际上，在模10意义下的$inv(3)=7$，所以上面的式子可以这样计算：</p><p><img src="https://img2.imgtp.com/2024/03/18/mah9Ky6H.png" alt=""></p><p>这里介绍三种计算逆元的方法：<strong>拓展欧几里得</strong>，<strong>费马小定理</strong>，<strong>线性递推</strong>。</p><hr><h2 id="拓展欧几里得">拓展欧几里得</h2><p>最常用的求逆元方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span><span class="comment">// 拓欧</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exgcd</span>(a, p, x, y) != <span class="number">1</span>) <span class="comment">// 无解的情形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="费马小定理">费马小定理</h2><p>费马小定理叙述如下：</p><blockquote><p>若$p$是质数，且$gcd(a,p)=1$，则有$a^{p-1}\equiv1(mod\ p)$</p></blockquote><p>从逆元的定义可以推导：$a*inv(a)\equiv a^{p-1}(mod\ p)$，于是有$inv(a)\equiv a^{p-2}(mod\ p)$。</p><p>于是对$a^{p-2}$算一下<strong>快速幂</strong>即可。注意：这个方法的前提是：$p$是质数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll p)</span><span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans % p * a % p;</span><br><span class="line">        a = a % p * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线性递推">线性递推</h2><p>以上两种方法都是常用的求逆元方法，但是，洛谷上的这道毒瘤模板题，必须要用特殊的方法：</p><p>（<strong>洛谷P3811 【模板】乘法逆元</strong>）</p><blockquote><p><strong>题目背景</strong><br>这是一道模板题<br><strong>题目描述</strong><br>给定$n$，$p$ ，求 $1 \sim n$中所有整数在模$p$意义下的乘法逆元。<br><strong>输入格式</strong><br>一行两个正整数$n,p$。<br><strong>输出格式</strong><br>输出$n$行，第$i$行表示$i$在模$p$下的乘法逆元。</p></blockquote><p>因为这道题要求一系列的乘法逆元，而且数据范围是$1\leq n\leq 3*10^{6} $ ，常规方法是行不通的。这里介绍逆元的<strong>线性递推</strong>求法（需保证$p$是质数）。</p><p>设$p=aq+r$，即$q=\lfloor p/a \rfloor，r=p\ mod\ a$。</p><p>在模$p$意义下，有$aq+r\equiv 0\ (mod\ p)$。</p><p>整理可得：$a=-r*inv(q)\ (mod\ p)$。</p><p>那么$inv(a)=-q*inv®\ (mod\ p)$。</p><p>即：$inv(a)=-\lfloor p/a \rfloor *inv(p\ mod\ a)\ (mod\ p)$。</p><p>其实和拓展欧几里得还是有不少相似之处的。我们可以用<strong>记忆化搜索</strong>的方法，减少多次查询的时间复杂度（空间换时间）。（<strong>递推</strong>亦可，其实就这题而言递推更好）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多次对不同的p使用需要清空Inv数组</span></span><br><span class="line">ll Inv[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mod</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Inv[a])</span><br><span class="line">        <span class="keyword">return</span> Inv[a];</span><br><span class="line">    Inv[a] = <span class="built_in">mod</span>(-p / a * <span class="built_in">inv</span>(p % a, p), p);</span><br><span class="line">    <span class="keyword">return</span> Inv[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;inv[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得</title>
      <link href="/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
      <url>/2024/03/17/%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧几里得">拓展欧几里得</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a></p><p>如有侵权，请联系作者删除</p><hr><h2 id="辗转相除法">辗转相除法</h2><p>在介绍拓展欧几里得算法之前，先看看<strong>欧几里得算法</strong>（又称<strong>辗转相除法</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除法，求两个数的最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理这里省略，详情请参考原作者的文章：<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a></p><hr><h2 id="拓展欧几里得-2">拓展欧几里得</h2><p>拓展欧几里得是可以在<strong>辗转相除</strong>的途中求出不定方程$ax+by=c$的一组解</p><p><img src="https://img2.imgtp.com/2024/03/17/US3JbpKq.png" alt=""></p><p>可以发现：倒数第二行的$3+6<em>3=21$，可以改写成$3=6</em>(-3)+21$，也就是说：3可以被表示为6和21的线性组合。</p><p>倒数第三行，$6+21*1=27$，说明6可以被表示为21和27的线性组合，那么3也可以被表示为21和27的线性组合。具体地：</p><p>$3=6*(-3)+21=(27-21)<em>(-3)+21=27</em>(-3)+21*4$</p><p>这样一路推导下来，可以得到3表示为75和48的线性组合。那么$75x+48y=3$就能找到解了。</p><p>由上文可以得到求解$ax+by=gcd(a,b)$的一种方法。但如果$c$是其他数呢？</p><p>实际上，$c$必须是 $gcd(a,b)$的倍数，因为我们由方程 $ax+by=c$ 两边除以 $gcd(a,b)$ 可得 $\frac{a}{gcd(a,b)}x+\frac{b}{gcd(a,b)}y=\frac{c}{gcd(a,b)}$ ，方程左边当然是整数，那么方程右边也必须是整数。所以$c$是$gcd(a,b)$的倍数。</p><p>这其实上是一个数论定理：</p><blockquote><p><strong>裴蜀定理</strong></p><p>设$a、b$为正整数，则关于$x、y$的方程$ax+by=c$有整数解当且仅当$c$是$gcd(a,b)$的倍数</p></blockquote><p><img src="https://img2.imgtp.com/2024/03/17/ohJDTt3U.png" alt=""></p><p>可以发现，通过求$bx_0+(a\ mod\ b)y_0=c$的解，可以得出$ax+by=c$的解。</p><p>前者等价于$bx_0+(a-\lfloor a/b \rfloor)y_0=c$，也就是$ay_0+b(x_0-\lfloor a/b \rfloor y_0)=c$，可以对比两者的系数，可以让：<br>$$<br>\left{<br>\begin{aligned}<br>x &amp; =  y_0 \<br>y &amp; =  x_0-\lfloor a/b \rfloor y_0 \<br>\end{aligned}<br>\right.<br>$$<br>当$b==0$时递归结束即可，简化版如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">//这里交换了x和y</span></span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（这里其实有个普通版的，但是我偷懒了，直接搬了简化版qwq，若谷想看原版的，或者进一步探究原理的可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a>）</strong></p><hr><p>这样我们求出来的$ax+by=gcd(a,b)$的一组特解，那么通解是什么？</p><p>设除了已经求出来的$x,y$之外还有一组解$x_1=x+\delta$和$y_1$，那么由$ax_1-a\delta+by==gcd(a,b)$，可以得到$ax_1+b(y-\frac{a\delta}{b})=gcd(a,b)$，可以得到：</p><p>$y_1=y-\frac{a\delta}{b}$。</p><p>注意：我们还需要保证$\delta$和$\frac{a\delta}{b}$都是整数，后者等于$\frac{a’}{b’}\delta$，其中：<br>$$<br>\left{<br>\begin{aligned}<br>a’ &amp; =  \frac{a}{gcd(a,b)} \<br>b’ &amp; =  \frac{b}{gcd(a,b)} \<br>\end{aligned}<br>\right.<br>$$<br>由于$a’、b’$互质，$\delta$应当等于$kb’$（$k$是整数），即：<br>$$<br>\left{<br>\begin{aligned}<br>x_k &amp; =  x+k*\frac{b}{gcd(a,b)} \<br>y_k &amp; =  y-k*\frac{a}{gcd(a,b)} \<br>\end{aligned}<br>\right.<br>$$<br>这就是该不定方程的解。一般题目求的符合某些条件的解。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2024/03/17/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以$O(log_2n)$的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：<strong>最朴素的想法，7 * 7=49，49 * 7=343，… 一步一步算，共进行了</strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：<strong>先算7的5次方，即7 * 7 * 7 * 7 * 7，再算它的平方，共进行了</strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：<strong>先算7 * 7得49，则7的5次方为49 * 49 * 7，再算它的平方，共进行了</strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在$O(log_2 n)$时间内计算出幂的算法，也就是快速幂。</p><hr><h2 id="递归快速幂">递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：<br>$$<br>a^n=\left{<br>\begin{aligned}<br>a^n*a                               &amp;      &amp;if\ n\ is\ odd\<br>a^{\frac{n}{2}}*a^{\frac{n}{2}}     &amp;      &amp;if\ n\ is\ even\ but\ not\ 0 \<br>1                                   &amp;      &amp;if\ n\ is\ 0<br>\end{aligned} \right.<br>$$</p><p>对应的递归形式写法如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这个temp不能省略，如果写成了qpow(a,n/2) * qpow(a,n/2)，那会计算两次$a^\frac{n}{2}$，时间复杂度会退化成$O(n)$</p><p>经常会遇到取模类的问题，这里我们的应对策略是在利用快速幂进行计算时也需要取模，此时应当注意：<strong>原则是步步取模</strong>，如果mod较大，还需开<strong>long long</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归快速幂的缺点是：产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong></p><hr><h2 id="非递归快速幂">非递归快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以$7^{10}$为例，转换为计算$7^{1010_{(2)}}$，我们可以把它拆成$7^{1000_{(2)}}$和$7^{10_{(2)}}$，由此类推，任何数都可以拆分成若干个$a^{(100···)_{(2)}}$的形式相乘，恰好对应的就是$a^1$、$a^2$、$a^4$ ······来计算，只需要<strong>不断地对底数平方即可算出它们</strong></p><p><img src="https://img2.imgtp.com/2024/03/17/HhfSbxa6.png" alt=""></p><p>可以结合代码进行理解（如果实在看不懂只能看看原作者的文章了qwq）</p><hr><h2 id="快速幂的拓展">快速幂的拓展</h2><p>快速幂算法的应用范围实际上不止于此：在计算$a^{\frac{n}{2}}$时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的非递归快速幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">qpow</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a; <span class="comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>此时的时间复杂度不再是$O(log_2\ n)$，此时还与底数的乘法的时间复杂度有关。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法（第一弹）</title>
      <link href="/2024/03/17/Latex%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/17/Latex%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Latex-语法">Latex 语法</h1><p>先简单整理下Latex的语法，以后会经常用到<br><a href="https://blog.csdn.net/ccnice99/article/details/127507471?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Latex%E8%AF%AD%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127507471.142%5Ev99%5Epc_search_result_base6&amp;spm=1018.2226.3001.4449">【自用】【持续更新】LaTeX常用基础语法大全_latex语法-CSDN博客</a></p><h2 id="基础语法">基础语法</h2><h3 id="段落">段落</h3><h4 id="居中">居中</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">要居中的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure><h4 id="排序列表">排序列表</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 原始模板</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 自定义排序列表的编号形式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(1)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a.]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 实心圆点列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="comment">% 短横杠列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span>[-] 第一小题</span><br><span class="line"><span class="keyword">\item</span>[-] 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本、变量">文本、变量</h3><h4 id="加粗">加粗</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\textbf</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;我们&#125;、<span class="keyword">\textbf</span>&#123;我们&#125;、我们</span><br><span class="line">注意：boldsymbol会变斜体（可能仅限英文）</span><br></pre></td></tr></table></figure><p>$$<br>\textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们<br>$$</p><h4 id="斜体">斜体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\textit&#123;我们&#125;、\it&#123;我们&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\textit{我们}、\it{我们}<br>$$</p><h4 id="向量（顶有向量箭头）">向量（顶有向量箭头）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\vec</span> v</span><br></pre></td></tr></table></figure><p>$$<br>\vec v<br>$$</p><h4 id="估计（顶有尖头hat）">估计（顶有尖头hat）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;y&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\hat{y}<br>$$</p><h4 id="平均（顶有横线）">平均（顶有横线）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \overline的线稍长，能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\bar</span> x ，<span class="keyword">\overline</span> x，<span class="keyword">\bar</span>&#123;AB&#125; ，<span class="keyword">\overline</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% \overline的线稍长，能覆盖所有字符<br>\bar x ，\overline x，\bar{AB} ，\overline{AB}<br>$$</p><h4 id="顶有波浪号">顶有波浪号~</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \widetilde能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\tilde</span> x ，<span class="keyword">\widetilde</span> x，<span class="keyword">\tilde</span>&#123;AB&#125; ，<span class="keyword">\widetilde</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% \widetilde能覆盖所有字符<br>\tilde x ，\widetilde x，\tilde{AB} ，\widetilde{AB}<br>$$</p><h4 id="分式">分式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\frac{分子}{分母}<br>$$</p><h4 id="24个希腊字母">24个希腊字母</h4><p><img src="https://img2.imgtp.com/2024/03/17/9AmVbzpN.png" alt=""></p><h4 id="花体、集合手写体">花体、集合手写体</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 花体</span></span><br><span class="line"><span class="keyword">\mathcal</span>&#123;X&#125; ，<span class="keyword">\mathcal</span>&#123;Y&#125; ，<span class="keyword">\mathcal</span>&#123;D&#125;</span><br><span class="line"><span class="comment">% 集合手写体</span></span><br><span class="line"><span class="keyword">\mathbb</span>&#123;N&#125; ，<span class="keyword">\mathbb</span>&#123;Z&#125; ，<span class="keyword">\mathbb</span>&#123;R&#125; ，<span class="keyword">\mathbb</span>&#123;C&#125; ，<span class="keyword">\mathbb</span>&#123;Q&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 花体<br>\mathcal{X} ，\mathcal{Y} ，\mathcal{D}<br>$$</p><p>$$<br>% 集合手写体<br>\mathbb{N} ，\mathbb{Z} ，\mathbb{R} ，\mathbb{C} ，\mathbb{Q}<br>$$</p><h3 id="大型运算">大型运算</h3><h4 id="求和">求和</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在右边</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在正上、正下</span><br><span class="line"><span class="keyword">\\</span> 换行</span><br></pre></td></tr></table></figure><p>$$<br>\sum_{i=1}^{n}x_i<br>$$</p><p>$$<br>\sum\limits_{i=1}^{n}x_i<br>$$</p><p>求和符号的上下位置也可以缺省</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>i <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">^</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>\sum\limits_i \sum\limits^n<br>$$</p><h3 id="数组矩阵">数组矩阵</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 无括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="comment">% 圆括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="comment">% 单竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="comment">% 双竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="comment">% 方括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="comment">% 花括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 无括号矩阵<br>\begin{matrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{matrix}<br>\<br>% 圆括号矩阵<br>\begin{pmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{pmatrix}<br>\<br>% 单竖线矩阵<br>\begin{vmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{vmatrix}<br>\<br>% 双竖线矩阵<br>\begin{Vmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{Vmatrix}<br>\<br>% 方括号矩阵<br>\begin{bmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{bmatrix}<br>\<br>% 花括号矩阵<br>\begin{Bmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{Bmatrix}<br>$$</p><h3 id="符号">符号</h3><h4 id="属于">属于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br></pre></td></tr></table></figure><p>$$<br>\in<br>$$</p><h4 id="集合之间的各种运算关系">集合之间的各种运算关系</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">A<span class="keyword">\subset</span> B</span><br><span class="line">A<span class="keyword">\supset</span> B</span><br><span class="line">A<span class="keyword">\subseteq</span> B</span><br><span class="line">A<span class="keyword">\supseteq</span> B</span><br><span class="line">A<span class="keyword">\cap</span> B</span><br><span class="line">A<span class="keyword">\cup</span> B</span><br><span class="line"><span class="comment">% A减B</span></span><br><span class="line">A<span class="keyword">\setminus</span> B</span><br><span class="line"><span class="keyword">\emptyset</span></span><br></pre></td></tr></table></figure><p>$A\subset B$     $A\supset B$     $A\subseteq B$      $A\supseteq B$     $A\cap B$     $A\cup B$     $A\setminus B$     $\emptyset$</p><h4 id="任意">任意</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\forall</span></span><br></pre></td></tr></table></figure><p>$$<br>\forall<br>$$</p><h4 id="存在">存在</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\exists</span></span><br></pre></td></tr></table></figure><p>$$<br>\exists<br>$$</p><h4 id="因为、所以">因为、所以</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\because</span> 和 <span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure><p>注意：如果没有编译成功，需要在导言区导入宏包amssymb</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\because 和 \therefore<br>$$</p><h4 id="无穷大">无穷大</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\infty</span>+<span class="keyword">\infty</span> -<span class="keyword">\infty</span></span><br></pre></td></tr></table></figure><p>$$<br>\infty +\infty -\infty<br>$$</p><h4 id="尖括号">尖括号</h4><p>注意与小于号&lt;，大于号&gt; 区别</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\rangle</span></span><br></pre></td></tr></table></figure><p>$$<br>\langle<br>\<br>\rangle<br>$$</p><h4 id="小于等于、大于等于、不等于、恒等于、恒不等于">小于等于、大于等于、不等于、恒等于、恒不等于</h4><p>巧记：等于equation，所以这几个符号都是从 <em>eq</em> 词根出发的</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\le</span> 或者 <span class="keyword">\leq</span></span><br><span class="line"><span class="keyword">\ge</span> 或者 <span class="keyword">\geq</span></span><br><span class="line"><span class="keyword">\ne</span> 或者 <span class="keyword">\neq</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\not</span><span class="keyword">\equiv</span>  <span class="params">#</span> 注意这里只能是拼接<span class="keyword">\not</span>和<span class="keyword">\equiv</span>，<span class="keyword">\nequiv</span>无效</span><br></pre></td></tr></table></figure><p>$\le 或者 \leq$     $\ge 或者 \geq$     $\ne 或者 \neq$     $\equiv$     $\not\equiv$</p><h4 id="远小于、远大于">远小于、远大于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ll</span>，<span class="keyword">\gg</span></span><br></pre></td></tr></table></figure><p>$$<br>\ll，\gg<br>$$</p><h4 id="约等于">约等于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\approx</span></span><br></pre></td></tr></table></figure><p>$$<br>\approx<br>$$</p><h4 id="向上取整、向下取整">向上取整、向下取整</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lceil</span> x <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> x <span class="keyword">\rfloor</span></span><br></pre></td></tr></table></figure><p>$$<br>\lceil x \rceil<br>\<br>\lfloor x \rfloor<br>$$</p><h4 id="绝对值">绝对值</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>|-2<span class="keyword">\right</span>| 或者 <span class="keyword">\vert</span> -2<span class="keyword">\vert</span> 或者  <span class="keyword">\lvert</span> -2<span class="keyword">\rvert</span> </span><br></pre></td></tr></table></figure><p>可以观察一下区别<br>$$<br>\left|-2\right| 或者 \vert -2\vert 或者  \lvert -2\rvert<br>$$</p><h4 id="双竖线">双竖线</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span> A<span class="keyword">\|</span> 或者 <span class="keyword">\left</span><span class="keyword">\|</span>A<span class="keyword">\right</span><span class="keyword">\|</span> 或者 <span class="keyword">\Vert</span> A<span class="keyword">\Vert</span></span><br></pre></td></tr></table></figure><p>$$<br>| A| 或者 \left|A\right| 或者 \Vert A\Vert<br>$$</p><h4 id="花括号">花括号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\&#123;</span> A<span class="keyword">\&#125;</span> 或者 <span class="keyword">\left</span><span class="keyword">\&#123;</span> A <span class="keyword">\right</span><span class="keyword">\&#125;</span> </span><br></pre></td></tr></table></figure><p>$$<br>{ A} 或者 \left{ A \right}<br>$$</p><h4 id="乘号">乘号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\times</span> 或者 ×</span><br></pre></td></tr></table></figure><p>$$<br>\times 或者 ×<br>$$</p><h4 id="开n次方">开n次方</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>&#123;2&#125;、<span class="keyword">\sqrt</span>[4]&#123;16&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\sqrt{2}、\sqrt[4]{16}<br>$$</p><h4 id="导数">导数</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;</span><br><span class="line"><span class="comment">% 高阶导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;<span class="built_in">^</span>&#123;n&#125; y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x<span class="built_in">^</span>&#123;n&#125;&#125;</span><br><span class="line"><span class="comment">% 求偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;Loss&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;w&#125;&#125;</span><br><span class="line"><span class="comment">% 二阶偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="built_in">^</span>&#123;2&#125;&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="keyword">\partial</span>&#123;y&#125;&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 求导<br>\frac{\mathrm{d}y}{\mathrm{d}x}<br>% 高阶导<br>\frac{\mathrm{d}^{n} y}{\mathrm{d}x^{n}}<br>% 求偏导<br>\frac{\partial{Loss}}{\partial{w}}<br>% 二阶偏导<br>\frac{\partial^{2}z}{\partial{x}^{2}}<br>\frac{\partial^{2}z}{\partial{x}\partial{y}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex多重奏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分、离散化</title>
      <link href="/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
      <url>/2024/03/14/%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%B7%AE%E5%88%86%E3%80%81%E7%A6%BB%E6%95%A3%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="【深进1-例1】求区间和"><a href="https://www.luogu.com.cn/problem/P8218">【深进1.例1】求区间和</a></h1><blockquote><h1 id="【深进1-例1】求区间和-2">【深进1.例1】求区间和</h1><h2 id="题目描述">题目描述</h2><p>给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这<br>$m$ 个区间的区间和。</p><p>对于所有测试数据，$n,m\le10^5,a_i\le 10^4$</p><h2 id="输入格式">输入格式</h2><p>第一行，为一个正整数 $n$ 。</p><p>第二行，为 $n$ 个正整数 $a_1,a_2, \cdots ,a_n$</p><p>第三行，为一个正整数 $m$ 。</p><p>接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\le l_i\le r_i\le n$</p><h2 id="输出格式">输出格式</h2><p>共 $m$ 行。</p><p>第 $i$ 行为第 $i$ 组答案的询问。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>4 4 3 2 1 2 1 4 2 3 </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>10 5 </code></p><h2 id="提示">提示</h2><p>样例解释：第 $1$ 到第 $4$ 个数加起来和为 $10$。第 $2$ 个数到第 $3$ 个数加起来和为 $5$。</p><p>对于 $50 %$ 的数据：$n,m\le 1000$；</p><p>对于 $100 %$ 的数据：$1 \le n, m\le 10^5$，$1 \le a_i\le 10^4$</p></blockquote><h2 id="思路分析">思路分析</h2><p>简单的前缀和板子，不多说。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll =<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">200000</span>];</span><br><span class="line">ll pre[<span class="number">200000</span>], sum[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">pre[i] = a[i] + pre[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">sum[i] = pre[r] - pre[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cout &lt;&lt; sum[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大加权矩形"><a href="https://www.luogu.com.cn/problem/P1719">最大加权矩形</a></h1><h2 id="题目描述-2">题目描述</h2><p>为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。</p><p>校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 –2 –7  0 </span><br><span class="line"> 9  2 –6  2</span><br><span class="line">-4  1 –4  1 </span><br><span class="line">-1  8  0 –2</span><br></pre></td></tr></table></figure><p>在左下角：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9  2</span><br><span class="line">-4  1</span><br><span class="line">-1  8</span><br></pre></td></tr></table></figure><p>和为 $15$。</p><p>几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？</p><h2 id="输入格式-2">输入格式</h2><p>第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。</p><h2 id="输出格式-2">输出格式</h2><p>最大矩形（子矩阵）的和。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line"> 9 2 -6 2</span><br><span class="line">-4 1 -4  1 </span><br><span class="line">-1 8  0 -2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><p>$1 \leq n\le 120$<br>其实是二维前缀和的板子，这里给出几份代码，看看不同的思路（大多都是细节上处理的方法不同）。</p><h2 id="AC代码-2">AC代码</h2><h3 id="CODE1">CODE1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-99999999</span>;</span><br><span class="line"><span class="type">int</span> squ[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> lin[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; squ[i][j];</span><br><span class="line"><span class="comment">//lin[i][j]表示的是第i行前j个（其实也就是第j列）数字的和</span></span><br><span class="line">lin[i][j] = lin[i][j - <span class="number">1</span>] + squ[i][j];</span><br><span class="line"><span class="comment">//sum[i][j]表示的是以第1行第1个数字为左上角，以第i行第j个数字为右下角的矩形的面积。</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + lin[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分别枚举左上角的坐标(x1,y1)和右下角(x2,y2)的坐标。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x1 = <span class="number">1</span>; x1 &lt;= n; x1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y1 = <span class="number">1</span>; y1 &lt;= n; y1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x2 = <span class="number">1</span>; x2 &lt;= n; x2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y2 = <span class="number">1</span>; y2 &lt;= n; y2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x2 &lt; x1||y2&lt;y1) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] +sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人对$sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] +sum[x1-1][y1-1]$为什么是以$(x_1,y_1)$为左上角，以$(x_2,y_2)$为右下角的矩形的面积有点疑惑。画个图解释一下：<br><img src="https://img-blog.csdnimg.cn/direct/3c6c29a63e80437eaf7b54057daf5860.png#pic_center" alt="在这里插入图片描述"><br>这下应该能看懂了吧qwq。</p><h3 id="CODE2">CODE2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//还是跟上面的操作一样</span></span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="comment">//预处理出以(i,j)为右下角的矩形的面积，画画图就懂了</span></span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="comment">//枚举左上角(i,j)，右下角(k,m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//注意k&gt;=i,m&gt;=j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=j;m&lt;=n;m++)&#123;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(i,j,k,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CODE3">CODE3</h3><p>实际上是在枚举时优化了一下，降低时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>,sum;</span><br><span class="line">    <span class="comment">//这里改成了枚举矩形的上下边i与j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//k枚举的是第几列，从左往右扫描每一列的面积，并加到sum中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(i,k,j,k);</span><br><span class="line">                <span class="comment">//如果sum&gt;ans，说明在以i行为上界，j行为下界的，并且右界限为k的构成的连续矩形面积（即sum）更大，更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;ans)ans=sum;</span><br><span class="line">                <span class="comment">//如果sum&lt;0，那么只能另开一段，置sum为0</span></span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以理解成是矩阵压缩，可以看看题解的第一篇，本质其实是一样的。<br><a href="https://www.luogu.com.cn/problem/solution/P1719">P1719 最大加权矩形</a></p><h1 id="语文成绩"><a href="https://www.luogu.com.cn/problem/P2367">语文成绩</a></h1><blockquote><h1 id="语文成绩-2">语文成绩</h1><h2 id="题目背景">题目背景</h2><p>语文考试结束了，成绩还是一如既往地有问题。</p><h2 id="题目描述-3">题目描述</h2><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><h2 id="输入格式-3">输入格式</h2><p>第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。</p><p>第二行有 $n$ 个数，$a_1 \sim a_n$，代表各个学生的初始成绩。</p><p>接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。</p><h2 id="输出格式-3">输出格式</h2><p>输出仅一行，代表更改分数后，全班的最低分。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><p><code>3 2 1 1 1 1 2 1 2 3 1 </code></p><h3 id="样例输出-1-3">样例输出 #1</h3><p><code>2 </code></p><h2 id="提示-3">提示</h2><p>对于 $40%$ 的数据，有 $n \le 10^3$。</p><p>对于 $60%$ 的数据，有 $n \le 10^4$。</p><p>对于 $80%$ 的数据，有 $n \le 10^5$。</p><p>对于 $100%$ 的数据，有 $n \le 5\times 10^6$，$p \le n$，学生初始成绩 $ \le 100$，$z<br>\le 100$。</p></blockquote><h2 id="思路分析-2">思路分析</h2><p>差分的板子题，但是我经常忘记怎么操作了，贴上证明。<br><img src="https://img-blog.csdnimg.cn/direct/7348fc92b069475784845bf92f234e14.png#pic_center" alt="在这里插入图片描述"><br>这里贴的是<a href="https://www.luogu.com.cn/blog/156353/solution-p2367">GoldenFishX大佬的博客</a>，可以看看（大佬如果觉得侵权，联系我删除即可qwq）。</p><h2 id="AC代码-3">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll p, n, a[<span class="number">5000500</span>], d[<span class="number">5000500</span>];</span><br><span class="line">ll x, y, z, ans=<span class="number">9999999999</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//求出差分数组</span></span><br><span class="line">d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="comment">//上面讲得很清楚了</span></span><br><span class="line">d[x] += z;</span><br><span class="line">d[y + <span class="number">1</span>] -= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//差分的性质：a[i]=d[i]+d[i-1]+d[i-2]+······+d[1]</span></span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + d[i];</span><br><span class="line">ans = <span class="built_in">min</span>(ans, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地毯"><a href="https://www.luogu.com.cn/problem/P3397">地毯</a></h1><h2 id="题目描述-4">题目描述</h2><p>在 $n\times n$ 的格子上有 $m$ 个地毯。</p><p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p><h2 id="输入格式-4">输入格式</h2><p>第一行，两个正整数 $n,m$。意义如题所述。</p><p>接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。</p><h2 id="输出格式-4">输出格式</h2><p>输出 $n$ 行，每行 $n$ 个正整数。</p><p>第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 2 3 3</span><br><span class="line">3 3 5 5</span><br><span class="line">1 2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 0 0</span><br><span class="line">0 1 2 1 1</span><br><span class="line">0 0 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="样例解释">样例解释</h3><p>覆盖第一个地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr></tbody></table><p>覆盖第一、二个地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$2$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr></tbody></table><p>覆盖所有地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$1$</th><th style="text-align:center">$1$</th><th style="text-align:center">$1$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$2$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr></tbody></table><hr><h3 id="数据范围">数据范围</h3><p>对于 $20%$ 的数据，有 $n\le 50$，$m\le 100$。</p><p>对于 $100%$ 的数据，有 $n,m\le 1000$。</p><h2 id="思路分析-3">思路分析</h2><p>这题其实可以暴力模拟水过去，但实际上正解是二维差分。（补学一下qwq）。<br>设数组$a$的差分数组为$b$，则：<br>$$b[[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$$.<br>（偷懒了，直接贴书上的内容qwq）</p><blockquote><p><img src="https://img-blog.csdnimg.cn/direct/268ddecc2f5c4e04bcbd0ab4d710df40.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p>可以看到(a)，(b)图中，右下角的矩形中的各点都+1了，可以试着结合一维差分的证明理解一下wsm。©，(d)图其实就是相同的操作罢了。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="comment">//上面提到的操作</span></span><br><span class="line">        mat[x1][y1]++;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y1]--;</span><br><span class="line">        mat[x1][y2+<span class="number">1</span>]--;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y2+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//求前缀和，处理出每个点的值</span></span><br><span class="line">            mat[i][j]+=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            cout&lt;&lt;mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="火烧赤壁"><a href="https://www.luogu.com.cn/problem/P1496">火烧赤壁</a></h1><h2 id="题目背景-2">题目背景</h2><p>曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p><p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p><p>隆冬的十一月，天气突然回暖，刮起了东南风。</p><p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p><p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p><h2 id="题目描述-5">题目描述</h2><p>给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。</p><h2 id="输入格式-5">输入格式</h2><p>第一行一个整数，表示起火的信息条数 $n$。<br>接下来 $n$ 行，每行两个整数 $a, b$，表示一个着火位置的起点和终点（<strong>注意：左闭右开</strong>）。</p><h2 id="输出格式-5">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-5">样例 #1</h2><h3 id="样例输入-1-5">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示-5">提示</h2><h3 id="数据规模与约定">数据规模与约定</h3><p>对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a \leq  b \lt 2^{31}$，且答案小于 $2^{31}$。</p><h2 id="思路分析-4">思路分析</h2><p>实际上这是一道离散化的题目，但是我当初做的时候还不会离散化qwq，看了题解区大佬的绝妙思路：<br><a href="https://wxwoo.blog.luogu.org/solution-p1496">大佬的题解</a><br><img src="https://img-blog.csdnimg.cn/direct/dbcb14ba5ade43389d9fc5e8b3e94590.png#pic_center" alt="在这里插入图片描述"><br>可以发现，覆盖的范围是一样的，那么我们可以这样操作：<br>1、将起点和终点排个序。<br>2、将他们按照从小到大的顺序一一匹配，计算长度。<br>3、如果有重复的覆盖范围，减去即可。（也就是当前的终点坐标比下一个的起点坐标大时）</p><h2 id="AC代码-5">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">20200</span>], b[<span class="number">20200</span>], l;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">l += b[i] - a[i];</span><br><span class="line"><span class="comment">//注意i&lt;n,因为a[n]，b[n]是最后的起点和终点</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">l -= b[i] - a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="领地选择"><a href="https://www.luogu.com.cn/problem/P2004">领地选择</a></h1><h2 id="题目描述-6">题目描述</h2><p>作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。</p><p>首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。</p><h2 id="输入格式-6">输入格式</h2><p>第一行三个整数 $N,M,C$，表示地图的宽和长以及首都的边长。</p><p>接下来 $N$ 行每行 $M$ 个整数，表示了地图上每个地块的价值。价值可能为负数。</p><h2 id="输出格式-6">输出格式</h2><p>一行两个整数 $X,Y$，表示首都左上角的坐标。</p><h2 id="样例-1-6">样例 #1</h2><h3 id="样例输入-1-6">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="提示-6">提示</h2><p>对于 $60%$ 的数据，$N,M\le 50$。</p><p>对于 $90%$ 的数据，$N,M\le 300$。</p><p>对于 $100%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。</p><h2 id="思路分析-5">思路分析</h2><p>二维前缀和的练习题，不解释了qwq。</p><h2 id="AC代码-6">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m, c;</span><br><span class="line">ll map[<span class="number">1010</span>][<span class="number">1010</span>], sum[<span class="number">1010</span>][<span class="number">1010</span>], maxn = <span class="number">-999999999</span>, nx,ny;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; map[i][j];</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + map[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= m; j++) &#123;</span><br><span class="line">    <span class="comment">//枚举以(i,j)为右下角、边长为c的正方形的面积，注意更新坐标</span></span><br><span class="line"><span class="keyword">if</span> (sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c] &gt; maxn) &#123;</span><br><span class="line">maxn = sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c];</span><br><span class="line">nx = i - c + <span class="number">1</span>;</span><br><span class="line">ny = j - c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; nx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ny;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聪明的质检员"><a href="https://www.luogu.com.cn/problem/P1314">聪明的质检员</a></h1><blockquote><h2 id="题目描述-7">题目描述</h2><p><code>小T</code> 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$<br>逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：</p><ol><li>给定$ m$ 个区间 $[l_i,r_i]$；</li><li>选出一个参数 $W$；</li><li>对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：</li></ol><p>$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times<br>\sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$</p><p>其中 $j$ 为矿石编号。</p><p>这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\sum\limits_{i=1}^m y_i$</p><p>若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。<code>小T</code> 不想费时间去检验另一批矿产，所以他想通过调整参数<br>$W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。</p><h2 id="输入格式-7">输入格式</h2><p>第一行包含三个整数 $n,m,s$，分别表示矿石的个数、区间的个数和标准值。</p><p>接下来的 $n$ 行，每行两个整数，中间用空格隔开，第 $i+1$ 行表示 $i$ 号矿石的重量 $w_i$ 和价值 $v_i$。</p><p>接下来的 $m$ 行，表示区间，每行两个整数，中间用空格隔开，第 $i+n+1$ 行表示区间 $[l_i,r_i]$ 的两个端点 $l_i$<br>和 $r_i$。注意：不同区间可能重合或相互重叠。</p><h2 id="输出格式-7">输出格式</h2><p>一个整数，表示所求的最小值。</p><h2 id="样例-1-7">样例 #1</h2><h3 id="样例输入-1-7">样例输入 #1</h3><p><code>5 3 15  1 5  2 5  3 5  4 5  5 5  1 5  2 4  3 3 </code></p><h3 id="样例输出-1-7">样例输出 #1</h3><p><code>10 </code></p><h2 id="提示-7">提示</h2><p>【输入输出样例说明】</p><p>当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$<br>相差最小为 $10$。</p><p>【数据范围】</p><p>对于 $10%$ 的数据，有 $1 ≤n ,m≤10$；</p><p>对于 $30%$的数据，有 $1 ≤n ,m≤500$ ；</p><p>对于 $50%$ 的数据，有 $1 ≤n ,m≤5,000$；   对于 $70%$ 的数据，有 $1 ≤n ,m≤10,000$ ；</p><p>对于 $100%$ 的数据，有 $1 ≤n ,m≤200,000$，$0 &lt; w_i,v_i≤10^6$，$0 &lt;<br>s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$</p></blockquote><h2 id="思路分析-6">思路分析</h2><p>直接暴力枚举求出这个点肯定不行，并且看到题目要求最小值，所以可以猜测：使用二分。<br>二分的是$W$的值，$check(mid)$的判断条件是$s-\sum\limits_{i=1}^m y_i$是否大于0，由此缩减二分的范围，分析一下单调性：当$W$减少时，$\sum\limits_{i=1}^m y_i$增大，反之，则变小，并且当$W$足够小时，$\sum\limits_{i=1}^m y_i$会大于$s$,符合单调性，可以使用二分。具体看看注释。<br>还需要先预处理出前缀和：包括个数和总价值，否则会TLE。</p><h2 id="AC代码-7">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],l[MAXN],r[MAXN],cnt_num[MAXN],cnt_val[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    ll sum,ans,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    ans=s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//w是矿石的重量，v是矿石的价值</span></span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//输入的是查询的区间</span></span><br><span class="line">        cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt_num,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt_val,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_val));</span><br><span class="line">        <span class="comment">//利用前缀和，预处理出合格品的个数和总价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;=mid)&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>]+v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>];</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计一下检测结果，也就是查询的各个区间总价值之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            sum+=(cnt_val[r[i]]-cnt_val[l[i]<span class="number">-1</span>])*(cnt_num[r[i]]-cnt_num[l[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意更新答案，得到的是最小值，注意ans初始化为无穷大</span></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-s));</span><br><span class="line">        <span class="comment">//说明这个解合法，将右端点确定下来</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=s)right=mid;</span><br><span class="line">        <span class="comment">//否则，将左端点确定下来</span></span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序自动分析"><a href="https://www.luogu.com.cn/problem/P1955">程序自动分析</a></h1><blockquote><h1 id="NOI2015-程序自动分析">[NOI2015] 程序自动分析</h1><h2 id="题目描述-8">题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如<br>$x_i=x_j$ 或 $x_i\neq x_j$<br>的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq<br>x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入格式-8">输入格式</h2><p>输入的第一行包含一个正整数 $t$，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第一行包含一个正整数 $n$，表示该问题中需要被满足的约束条件个数。接下来 $n$ 行，每行包括三个整数<br>$i,j,e$，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $e=1$，则该约束条件为<br>$x_i=x_j$。若$e=0$，则该约束条件为 $x_i\neq x_j$。</p><h2 id="输出格式-8">输出格式</h2><p>输出包括 $t$ 行。</p><p>输出文件的第 $k$ 行输出一个字符串 <code>YES</code> 或者 <code>NO</code>（字母全部大写），<code>YES</code> 表示输入中的第 $k$<br>个问题判定为可以被满足，<code>NO</code> 表示不可被满足。</p><h2 id="样例-1-8">样例 #1</h2><h3 id="样例输入-1-8">样例输入 #1</h3><p><code>2 2 1 2 1 1 2 0 2 1 2 1 2 1 1 </code></p><h3 id="样例输出-1-8">样例输出 #1</h3><p><code>NO YES </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>2 3 1 2 1 2 3 1 3 1 1 4 1 2 1 2 3 1 3 4 1 1 4 0 </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>YES NO </code></p><h2 id="提示-8">提示</h2><p>【样例解释1】</p><p>在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。</p><p>在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。</p><p>【样例说明2】</p><p>在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得<br>$x_1=x_2=x_3$，即可同时满足所有的约束条件。</p><p>在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出<br>$x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。</p><p>【数据范围】</p><p>所有测试数据的范围和特点如下表所示：</p><h3 id="勘误：测试点-8-sim-10-的-i-j-约束为-1-leq-i-j-leq-10-9-，而不是下图中的-10-10-。">勘误：测试点 $8 \sim 10$ 的 $i, j$ 约束为 $1 \leq i, j \leq 10^9$，而不是下图中的 $10^{10}$。</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/4a99dde45fc5970ecba60d38c39a3bc2.png" alt=""></p></blockquote><h2 id="思路分析-7">思路分析</h2><p>这个其实是并查集+离散化，但是离散化我还不太熟，暂时没写。当初用了$unordered-map$混过去了qwq。<br>说正题，这道题有两个特征，查询和赋值，我们分析一下，这其实跟并查集的功能很相似，并查集维护的是一些元素的分组，用的是查询和合并两个操作。这里的赋值，我们其实可以用合并来实现：<br>1、如果是赋值，合并为一组。<br>2、如果是查询，那么我们只要看两者是否在同一组内即可。<br>这里并查集写的是按秩合并，不会的可以用普通的并查集代替。</p><h2 id="AC代码-8">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;Rank;</span><br><span class="line"><span class="type">int</span> x[MAXN],y[MAXN],e[MAXN];</span><br><span class="line"><span class="comment">//并查集的查询功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=<span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的合并功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]&gt;=Rank[fy])pre[fy]=fx;</span><br><span class="line">    <span class="keyword">else</span> pre[fx]=fy;</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]==Rank[fy]&amp;&amp;fx!=fy)Rank[fx]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意清空数组，因为有多组数据输入，不然喜迎WA qwq</span></span><br><span class="line">    pre.<span class="built_in">clear</span>();</span><br><span class="line">    Rank.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//输入元素，以及对应的操作，注意在原题中指的是下标x，y</span></span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;e[i];</span><br><span class="line">        <span class="comment">//将并查集初始化</span></span><br><span class="line">        pre[x[i]]=x[i];</span><br><span class="line">        pre[y[i]]=y[i];</span><br><span class="line">        <span class="comment">//按秩合并才需要的初始化，其实这一行也可以不用写@~@</span></span><br><span class="line">        Rank[x[i]]=<span class="number">1</span>,Rank[y[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果是1，合并两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(e[i])<span class="built_in">join</span>(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果不是1，查看两者的祖先是否一样</span></span><br><span class="line">        <span class="keyword">if</span>(!e[i])&#123;</span><br><span class="line">            <span class="comment">//不一样的话，直接输出NO，return 0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x[i])==<span class="built_in">find</span>(y[i]))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经历重重困难，终于是YES了！！！</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO11MAR-Brownie-Slicing-G"><a href="https://www.luogu.com.cn/problem/P3017">[USACO11MAR] Brownie Slicing G</a></h1><h2 id="题面翻译">题面翻译</h2><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由 $R\times C(1\leq R,C\leq 500)$ 个小的巧克力蛋糕组成的。第 $i$ 行，第 $j$ 列的蛋糕有 $N_{i,j}(N_{i,j}\leq 4000)$ 块巧克力碎屑。</p><p>Bessie想把蛋糕分成 $A\times B(1\leq A\leq R,1\leq B\leq C)$ 块，:给 $A\times B$ 只奶牛。蛋糕先水平地切 $A-1$ 刀（只能切沿整数坐标切）来把蛋糕划分成 $A$ 块。然后再把剩下来的每一块独立地切 $B-1$ 刀，也只能切沿整数坐标切。其他 $A\times B-1$ 只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个$5\times4$的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>这样，Bessie至少能获得 $3$ 块巧克力碎屑</p><h2 id="题目描述-9">题目描述</h2><p>Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 &lt;= R &lt;= 500; 1 &lt;= C &lt;= 500) of little brownie squares. The square at row i, column j contains N_ij (0 &lt;= N_ij &lt;= 4,000) chocolate chips.</p><p>Bessie wants to partition the brownie up into A*B chunks (1 &lt;= A &lt;= R; 1 &lt;= B &lt;= C): one for each of the A*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer</p><p>coordinates) to divide the brownie into A strips.  Then cut each strip *independently* with B-1 vertical cuts, also on integer</p><p>boundaries. The other A*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.</p><p>Determine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.</p><p>As an example, consider a 5 row x 4 column brownie with chips</p><p>distributed like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>Thus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.</p><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由R*C(1 &lt;= R,C &lt;= 500)个小的巧克力蛋糕组成的。第i行，第j列的蛋糕有N_ij(1&lt;= N_ij &lt;= 4,000)块巧克力碎屑。</p><p>Bessie想把蛋糕分成A*B块，(1 &lt;= A&lt;= R,1 &lt;= B &lt;= C): 给A*B只奶牛。蛋糕先水平地切A-1刀（只能切沿整数坐标切）来把蛋糕划分成A块。然后再把剩下来的每一块独立地切B-1刀，也只能切沿整数坐标切。其他A*B-1只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个5*4的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><h2 id="输入格式-9">输入格式</h2><p>* Line 1: Four space-separated integers: R, C, A, and B</p><p>* Lines 2…R+1: Line i+1 contains C space-separated integers: N_i1, …, N_iC</p><h2 id="输出格式-9">输出格式</h2><p>* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie</p><h2 id="样例-1-9">样例 #1</h2><h3 id="样例输入-1-9">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 4 2 </span><br><span class="line">1 2 2 1 </span><br><span class="line">3 1 1 1 </span><br><span class="line">2 0 1 3 </span><br><span class="line">1 1 1 1 </span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路分析-8">思路分析</h2><p>当初也没想出来怎么二分，看了题解区大佬的题解恍然大悟。<br>蛋糕要分成$A * B$块，注意可以先分成$A$横块，每一块再分成$B$条，也就是切条时可以不用一刀切！！！<br>那么要统计一块蛋糕的巧克力屑，肯定就是使用前缀和了。我们也可以先预处理出前缀和，再进行二分。<br>二分的是巧克力屑的数量，$check(mid)$的是能否切出$A*B$块蛋糕，具体$check(mid)$怎么写可以看看代码+注释。</p><h2 id="AC代码-9">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cake[<span class="number">510</span>][<span class="number">510</span>],line[<span class="number">510</span>][<span class="number">510</span>],pre[<span class="number">510</span>][<span class="number">510</span>],r,c,a,b,ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//我们先切一行，再将这一行切成B列，看看最终能否满足A*B块蛋糕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,sum_cake=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i枚举的是当前行，j枚举的是当前列，last记录的是上一块（行）蛋糕的最底行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="comment">//判断当前切的蛋糕的巧克力屑的数量是否大于x，也就是二分的值</span></span><br><span class="line">            <span class="comment">//我们一列一列的补充蛋糕，判断补充后，其巧克力屑数目是否大于x，不满足，则补充。</span></span><br><span class="line">            <span class="keyword">if</span>(sum_cake+(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>])&lt;x)&#123;</span><br><span class="line">                sum_cake+=(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足，另开一列，注意统计的蛋糕数目+1，蛋糕上的巧克力屑数目重置为0</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum_cake=<span class="number">0</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断这一行蛋糕，切出来是否有B块</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=b)&#123;</span><br><span class="line">        <span class="comment">//如果有B块，我们则记录这块蛋糕的最后一行，并且记录 行的蛋糕数量++，没有只能再加上一行继续切了，直到满足为止。</span></span><br><span class="line">            last=i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看看是否能不能切除A行蛋糕，满足return true，否则，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;a)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输入R、C、A、B</span></span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//输入蛋糕的巧克力屑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=MAXN;</span><br><span class="line">    <span class="comment">//二分，不多说了，重点在check(x)</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="海底高铁"><a href="https://www.luogu.com.cn/problem/P3406">海底高铁</a></h1><h2 id="思路分析-9">思路分析</h2><p>先想想暴力怎么办？我们可以先统计每段铁路要经过几次，再贪心，看看是办卡优惠还是买票优惠。<br>但是这样肯定会TLE，想想怎么改——————前缀和吗？不对，前缀和求的是多个元素之间的关系。<br>差分吗？差分维护的是多个元素之间的逻辑关系，最终得到的是单个元素。<br>那就是差分了！我们可以利用它来得出每段铁路经过的次数，想想差分的作用，O(1)修改区间的值，O(n)查询单个元素的值。基于此，我们可以先O(1)预处理区间总共要修改的值，再O(n)得到每段铁路经过的次数，最后贪心得出最小花费。具体可以看看注释。<br>可以看看这篇<a href="https://www.luogu.com.cn/article/srpjwp5w">搞笑的故事</a>，相信会有所收获。</p><h2 id="AC代码-10">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll p[MAXN],a[MAXN],b[MAXN],c[MAXN],ans[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分，统计修改次数，注意相邻元素不一定是从小到大，所以可能得交换顺序</span></span><br><span class="line">    <span class="comment">//一般来说，是d[l]++,d[r+1]--。l指的是左端点，r指的是右端点，但是我们这里d[l]++,d[r]--即可，因为其实从r城市出发的铁路我们根本不需要经过。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans[<span class="built_in">min</span>(p[i],p[i+<span class="number">1</span>])]++;</span><br><span class="line">        ans[<span class="built_in">max</span>(p[i],p[i+<span class="number">1</span>])]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得出每段铁路需要经过的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//贪心，看看每一段铁路是买票优惠还是买卡优惠</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">min</span>(ans[i]*a[i],ans[i]*b[i]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Poetize6-IncDec-Sequence"><a href="https://www.luogu.com.cn/problem/P4552">[Poetize6] IncDec Sequence</a></h1><blockquote><h1 id="Poetize6-IncDec-Sequence-2">[Poetize6] IncDec Sequence</h1><h2 id="题目描述-10">题目描述</h2><p>给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加<br>$1$ 或者都减 $1$。     请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p><h2 id="输入格式-10">输入格式</h2><p>第一行一个正整数 $n$    接下来 $n$ 行,每行一个整数,第 $i+1 $行的整数表示 $a_i$。</p><h2 id="输出格式-10">输出格式</h2><p>第一行输出最少操作次数    第二行输出最终能得到多少种结果</p><h2 id="样例-1-10">样例 #1</h2><h3 id="样例输入-1-10">样例输入 #1</h3><p><code>4 1 1 2 2 </code></p><h3 id="样例输出-1-10">样例输出 #1</h3><p><code>1 2 </code></p><h2 id="提示-9">提示</h2><p>对于 $100%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。</p></blockquote><h2 id="思路分析-10">思路分析</h2><p>先想想元素相同？其实就是他们的差都是0，我们关注的是单个元素，并且是各元素之间的逻辑关系问题，所以我们使用差分来求解。<br>那么问题就变成了怎么让差分数组全为0（除了$diff[1]$不为0，因为$a[0]$为0），对一个区间$[l,r]$进行修改，其实就是$diff[l]++$、$dff[r+1]–$。而一个差分数组里元素肯定有正有负，最好的情况是，一次修改，可以让一个负数加1，一个正数减1，这样操作步骤就是最少的。<br>但是如果只剩下正数或者负数，就只能一次一次进行了。<br>至于有多少可能结果，其实就是最后只剩正数或者负数时，一步步修改的操作次数了。为什么？<br>前面修改的时候，我们修改的是$[l,r]$，对$diff[1]$无影响，而只剩正数或者负数时，我们可以$diff[1]++$$diff[x]–$了，也可以$diff[1]–$$diff[x]++$，也可以不动，所以可能的结果就是：剩余的正数/负数+1，因为本身不修改，也要加上。</p><h2 id="AC代码-11">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,x=<span class="number">0</span>,y=<span class="number">0</span>,d;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//求差分数组：x统计正数，y统计负数</span></span><br><span class="line">        d=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">0</span>)x+=d;</span><br><span class="line">        <span class="keyword">else</span> y-=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格的证明是:ans1=min(x,y)+abs(x-y),所以ans1=max(x,y)。</span></span><br><span class="line">    ll ans1=<span class="built_in">max</span>(x,y);</span><br><span class="line">    <span class="comment">//不解释了，看看上面</span></span><br><span class="line">    ll ans2=<span class="built_in">abs</span>(x-y)+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2012-提高组-借教室"><a href="https://www.luogu.com.cn/problem/P1083">[NOIP2012 提高组] 借教室</a></h1><h2 id="题目描述-11">题目描述</h2><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><h2 id="输入格式-11">输入格式</h2><p>第一行包含两个正整数 $n,m$，表示天数和订单的数量。</p><p>第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。</p><p>接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。</p><h2 id="输出格式-11">输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。</p><h2 id="样例-1-11">样例 #1</h2><h3 id="样例输入-1-11">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">2 5 4 3 </span><br><span class="line">2 1 3 </span><br><span class="line">3 2 4 </span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-10">提示</h2><p>【输入输出样例说明】</p><p>第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供$3$个教室，而第 $3$ 天剩余的教室数为$2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。</p><p>【数据范围】</p><p>对于10%的数据，有$1≤ n,m≤ 10$；</p><p>对于30%的数据，有$1≤ n,m≤1000$；</p><p>对于 70%的数据，有$1 ≤ n,m ≤ 10^5$；</p><p>对于 100%的数据，有$1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n$。</p><p>NOIP 2012 提高组 第二天 第二题</p><p>2022.2.20 新增一组 hack 数据</p><h2 id="思路分析-11">思路分析</h2><p>（这道当初也不会qwq，看了题解<a href="https://www.luogu.com.cn/article/sncheqxz">大佬——皎月半洒花</a>的博客）还是想想暴力，可以暴力先枚举订单数量，然后减少可以使用的教室数目，直到超过上限为止，但是这肯定会TLE。<br>想想怎么办？我们修改的是教室的数目，并且是一个区间，所以想到的是差分。<br>因为需要找到哪一个不满足，所以加上二分进行查询即可。<br>引用大佬的话：</p><blockquote><p>一般来说，二分是个很有用的优化途径，因为这样会直接导致减半运算，而对于能否二分，有一个界定标准：状态的决策过程或者序列<strong>是否满足单调性或者可以局部舍弃性</strong>。 而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p></blockquote><h2 id="AC代码-12">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">ll r[MAXN],d_j[MAXN],s_j[MAXN],t_j[MAXN],diff[MAXN],need[MAXN],ans,n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(diff,<span class="number">0</span>,<span class="built_in">sizeof</span>(diff));</span><br><span class="line">    <span class="comment">//利用差分进行区间修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        diff[s_j[i]]+=d_j[i];</span><br><span class="line">        diff[t_j[i]+<span class="number">1</span>]-=d_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得到每天需要的教室数目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        need[i]=need[i<span class="number">-1</span>]+diff[i];</span><br><span class="line">        <span class="comment">//看看每天的教室数目能否满足需求</span></span><br><span class="line">        <span class="keyword">if</span>(need[i]&gt;r[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;d_j[i]&gt;&gt;s_j[i]&gt;&gt;t_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以先判断是否能全部满足，如果能输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">1</span>,right=m;</span><br><span class="line">    <span class="comment">//二分的是订单号，check的是每天的教室数目能否满足</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4391</title>
      <link href="/2024/03/13/Luogu%20P4391/"/>
      <url>/2024/03/13/Luogu%20P4391/</url>
      
        <content type="html"><![CDATA[<h1 id="BOI2009-Radio-Transmission-无线传输">[BOI2009] Radio Transmission 无线传输</h1><blockquote><h2 id="题目描述">题目描述</h2><p>给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$<br>是不确定的，现在只想知道它的最短长度是多少。</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 $L$，表示给出字符串的长度。</p><p>第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。</p><h2 id="输出格式">输出格式</h2><p>仅一行，表示 $s_2$ 的最短长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 cabcabca </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>3 </code></p><h2 id="提示">提示</h2><h4 id="样例输入输出-1-解释-对于样例，我们可以利用-texttt-abc-不断自我连接得到-texttt-abcabcabcabc-，读入的-texttt-cabcabca-，是它的子串。">样例输入输出 1 解释 对于样例，我们可以利用 $\texttt{abc}$ 不断自我连接得到 $\texttt{abcabcabcabc}$，读入的 $\texttt{cabcabca}$，是它的子串。</h4><h4 id="规模与约定-对于全部的测试点，保证-1-L-le-10-6-。">规模与约定 对于全部的测试点，保证 $1 &lt; L \le 10^6$。</h4></blockquote><p>按照题意，我们要求的是$s_2$的最短长度，也就是$s_1$最小的循环字串。<br>这里实际上有一个结论：答案就是$n-pmt[n-1]$。(可能有的结论是$n-pmt[n]$，只是因为下标是从1开始)<br>具体证明可以看这篇博客：（写得很清楚了）<br><a href="https://lyyy.blog.luogu.org/p4391-boi2009radio-transmission-wu-xian-zhuan-shu-ti-xie">大佬的详解</a><br>下面贴上代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充证明">补充证明</h2><p><img src="https://img-blog.csdnimg.cn/direct/444dc91cd4ed450f93fd37e51a114e9d.png#pic_center" alt="在这里插入图片描述"><br>上面的前后缀是$max(border)$。不妨记上面的前缀为$s_1$，下面的后缀为$s_2$。<br>我们可以发现<img src="https://img-blog.csdnimg.cn/direct/be681483c20c45ec91851a924eecfe1b.png#pic_center" alt="在这里插入图片描述"><br>箭头联系起来的各部分是相等的，也就是$s_1[1]=s_2[2]、s_1[2]=s_2[3]、s_1[3]=s_2[4]······$，由此类推。<br>同时，又因为$s_1[1]=s_2[1]、s_1[2]=s_2[2]、s_1[3]=s_2[3]······$，将两者联系起来，我们可以得到：<br>$$s_1[i]=s_2[j]|1&lt;=i&lt;=5，1&lt;=j&lt;=5$$<br>那有没有可能：更一般的情况是：$s_1$红色部分的后面加上一小段普通的字符串$t$。<br>我们可以分析一下：实际上这是可能的。我们可以结合样例进行分析。（这里不写了，样例的解释很清楚，可以认为：最后的循环节被强行切割了一部分。）<br>所以我们总结一下上面的内容：红色部分的字符串就是我们要求的最小循环节了。<br>所以问题转化为：求$max(border)$。<br>只需要求出$pmt[n-1]$即可，那么$n-pmt[n-1]$就是答案了。</p><h2 id="AC代码：">AC代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 929(Div.3)</title>
      <link href="/2024/03/13/Codeforces%20Round%20929(Div.3)/"/>
      <url>/2024/03/13/Codeforces%20Round%20929(Div.3)/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-A"><a href="https://codeforces.com/contest/1933/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接累计各元素绝对值即可</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans+=x;</span><br><span class="line">        <span class="keyword">else</span> ans-=x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-B"><a href="https://codeforces.com/contest/1933/problem/B">Problem B</a></h1><h2 id="思路分析-2">思路分析</h2><p>两种操作：去除一个元素，或者某个元素+1。<br>其实可以发现，$sum$%$3$结果只有$0,1,2$.<br>$0：$直接输出0即可。<br>$1：$要不删去一个元素(其取模结果为1)，要不加2，所以可以用个$flag$，看看有没有这样的元素存在。<br>$2：$要不删去一个元素，要不加1，无所谓，都是两次操作。</p><h2 id="AC代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,flag=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)flag=<span class="number">1</span>;</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-C"><a href="https://codeforces.com/contest/1933/problem/C">Problem C</a></h1><h2 id="思路分析-3">思路分析</h2><p>坐牢的开始qwq，自己想得太复杂了，其实直接用快速幂枚举$x,y$即可（看了队里大佬的代码）。<br>这里去重有个小技巧，可以用$set$，这样就可以不用写判断是否重复的条件（set可以直接去重），最后输出$set.size()$即可。</p><h2 id="AC代码-3">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpower</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans*=a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,l;cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;<span class="built_in">quickpower</span>(a,x)&lt;=l;x++)&#123;</span><br><span class="line">        <span class="comment">//注意y的枚举条件是quickpower(a,x)*quickpower(b,y)&lt;=l</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; <span class="built_in">quickpower</span>(a,x)*<span class="built_in">quickpower</span>(b,y)&lt;=l;y++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">quickpower</span>(a,x)* <span class="built_in">quickpower</span>(b,y);</span><br><span class="line">            <span class="keyword">if</span>(l%num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//将l/num存入set中</span></span><br><span class="line">                s.<span class="built_in">insert</span>(l/num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-D"><a href="https://codeforces.com/contest/1933/problem/D">Problem D</a></h1><h2 id="思路分析-4">思路分析</h2><p>看看样例，可以大胆猜测一下，先从小到大排序，可以发现，$SmallElememt$%$BigElememt$肯定不为0，那么这样贪心排序下来，如果可以得到结果不为0，满足题意，直接$return$即可。<br>但是，需要特判是否有相同的情况，只需要考虑$a_0、a_1$即可，后面是否连续无影响，如果$a_0==a_1$，则不满足题意。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//元素按照从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=a[<span class="number">0</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果%!=0，输出yes</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%a[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Problem-E"><a href="https://codeforces.com/contest/1933/problem/E">Problem E</a></h1><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 928(Div.4)</title>
      <link href="/2024/03/13/Codeforces%20Round%20928(Div.4)/"/>
      <url>/2024/03/13/Codeforces%20Round%20928(Div.4)/</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-A"><a href="https://codeforces.com/contest/1926/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接模拟即可</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">5</span>-a)cout&lt;&lt;<span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-B"><a href="https://codeforces.com/contest/1926/problem/B">Problem B</a></h1><h2 id="思路分析-2">思路分析</h2><p>我的思路是：当统计每一行1的个数，当第$i$与第$i-1$行中统计到的1的个数（前提是这两行中1的个数不为0）不同时，就是三角形，否则是正方形。</p><p>一开始的时候WA了一次，就是没考虑到第$i$行与第$i+1$行中1的个数都得不为0</p><h2 id="WA代码">WA代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚写博客的时候想到可以改进一下，如果$flag==1$了，那么后面的输入其实都是没有意义的，也就不需要统计和判断了，修改如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;!flag;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i]&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-C"><a href="https://codeforces.com/contest/1926/problem/C">Problem C</a></h1><h2 id="思路分析-3">思路分析</h2><p>其实是一个见过很多次的操作了qwq，先离线处理计算（没错，就是你想的暴力计算$qwq$）出所有在数据范围内的答案，然后用一个数组将其存下即可。这样可以做到$O(1)询问$，预处理时间是$O(MAXN)$，总的时间复杂度为$O(MAXN+n)$</p><h2 id="AC代码-3">AC代码</h2><p>具体细节看看代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x的各位数字拆解，并统计各位数字总和</span></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        tot+=(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//直接输出计算好的ans[n]即可</span></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">        <span class="comment">//需要用前缀和数组存下来，因为后面有多次询问，所以需要对应记录哪个i，对应哪个ans[i]</span></span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]+<span class="built_in">cal</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-D"><a href="https://codeforces.com/contest/1926/problem/D">Problem D</a></h1><h2 id="思路分析-4">思路分析</h2><p>题目的意思：将给的数字分成若干组，同一组中的若干个数字之间，他们的二进制形式的每一位必须都是不同的，求最小组数<br>我们可以先分析同一组中的数字有什么特点：<br><img src="https://img-blog.csdnimg.cn/direct/064ba75fccfd477c99803f52409a641e.png#pic_center" alt="在这里插入图片描述"><br>那么我们可以根据这个性质，来求解这道题了，具体还得看代码。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LUOGU_RID: 148392530</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//book：输入的数字x的个数，可以理解为存放x的库</span></span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//查看存放 x对应的异或数（记作y）的库 是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x])&#123;</span><br><span class="line">            <span class="comment">//如果存在，那么book[y]的数量--</span></span><br><span class="line">            book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x]--;</span><br><span class="line">            <span class="comment">//说明可以创建出一组满组（也就是有x，y的组），ans++，统计一下</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，book[x]++，说明x库中x的数量增加了一个</span></span><br><span class="line">        <span class="keyword">else</span> book[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再遍历一下无法找到 对应的y 的x，那么他们只能单独成组了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:book)&#123;</span><br><span class="line">        ans+=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-E"><a href="https://codeforces.com/contest/1926/problem/E">Problem E</a></h1><h2 id="思路分析-5">思路分析</h2><p>可以先模拟一下题目说的流程：<br><img src="https://img-blog.csdnimg.cn/direct/c675e02c15524d56a0222edca40eef9e.png#pic_center" alt="在这里插入图片描述"></p><h2 id="AC代码-5">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意得向上取整</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;(n+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tot=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        k-=tot;</span><br><span class="line">        <span class="comment">//注意总数/2</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//轮数++</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说实话，我也没太懂为什么是2*k-1</span></span><br><span class="line">    <span class="comment">//owo 我们每一次删除的时候删的是K*(1,3,5······)，所以这里2*k-1，才是对应删的奇数（K泛指系数）</span></span><br><span class="line">    cout&lt;&lt;((<span class="number">2</span>*k<span class="number">-1</span>)&lt;&lt;cnt)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Edu 162</title>
      <link href="/2024/03/13/Codeforces%20Edu%20162/"/>
      <url>/2024/03/13/Codeforces%20Edu%20162/</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-A"><a href="https://codeforces.com/contest/1923/problem/A">Problem A</a></h2><h3 id="思路分析">思路分析</h3><p>贪心，因为$chips$只能左移到最近的空格子，所以其实只需要考虑在最长的以1开头和以1结尾的串内（记作$s$）移动即可（其他部分没用，不然只会做多余的移动）。<br>至于怎么移，可以想象把从第一个1串右端的所有1串保持成串的形式，轮流滚近第一个1串，恰好接上为止，可以证明，滚的次数恰好就是$s$内0的个数。<br>画个图比较好理解：<br><img src="https://img-blog.csdnimg.cn/direct/52b551df24b94fe297337faaa27b22d7.png#pic_center" alt="在这里插入图片描述"><br>不难发现：答案就是$s$中0的个数，可以多结合几个样例分析一下。</p><h3 id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l=MAXN,r,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//预处理出最长的$s$串的左右端点，注意l初始化为MAXN，并且统计出1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;    </span><br><span class="line">            r=i;</span><br><span class="line">            l=<span class="built_in">min</span>(l,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r-l+<span class="number">1</span>-cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//求出0的个数，也就是最少的移动次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B"><a href="https://codeforces.com/contest/1923/problem/B">Problem B</a></h2><h3 id="思路分析-2">思路分析</h3><p>贪心，很显然，肯定是需要先打举例我们最近的怪物，再打次近的怪物，依此类推，只要在其中，有一个怪物打不死，那么我们就输了。<br>所以这里可以用到前缀和，预处理出前$i$个最近的怪物们的总血量（记作$pre[i]$），如果在对应的这段时间内，（也就是$abs(a[i].pos)$），我们打出的子弹数$k*abs(a[i].pos)&lt;pre[i]$，那么我们就输出$NO$直接判掉。<br>注意得先派个序，按距离从小到大，可以用结构体+$cmp$。</p><h3 id="代码实现-2">代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll hp,pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.pos)&lt;<span class="built_in">abs</span>(b.pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,k,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].hp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].pos;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=a[i].hp;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;k*<span class="built_in">abs</span>(a[i].pos))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C"><a href="https://codeforces.com/contest/1923/problem/C">Problem C</a></h2><h3 id="思路分析-3">思路分析</h3><p>其实就是看能否根据给出的子数组，构造出一个好数组（被翻译坑了）。<br>怎么构造？？？总和相同，但是相同位置的元素不同，并且元素都大于0。<br>有一个比较容易实现的想法：就是在原有的基础上，部分元素加1，显然，有一些元素需要减少，但是又不能减太多（不然就小于0了）。<br>这其中就有一个比较特别的元素：1。1只能加，不能减，那么要加多少个1（记作$x$）就只能由其他非一元素（能够贡献的记作$y$）贡献了。</p><h3 id="代码实现-3">代码实现</h3><p>可以用前缀和，预处理出在各个区间内1的个数，以及各个区间内非一元素的最大贡献。<br>这里有用到一些小技巧：可以先在输入$a[i]$时，将$a[i]–$，这样求出来$sum[r]-sum[l-1]$就是$y$了。<br>需要注意特判一下：如果$l==r$，那么我们就无法构造出好数组（很显然）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,q,l,r,tot;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">cnt</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];       <span class="comment">//预处理出前i个元素的最大贡献</span></span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);  <span class="comment">//预处理出前i个元素中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ll x=cnt[r]-cnt[l<span class="number">-1</span>];</span><br><span class="line">        ll y=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==r||x&gt;y)cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;  <span class="comment">//无法满足或者长度为1，就NO，否则YES</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Problem-D"><a href="https://codeforces.com/contest/1923/problem/D">Problem D</a></h2><h3 id="思路分析-4">思路分析</h3><p>分析题意，很容易想到$i-nd$史莱姆只能被左边的或者右边的吃掉，先分析左边的情况。<br>假设$i$（偷懒，其实是$i-nd$史莱姆，下面也一样）被左边的史莱姆吃掉，先做一些定义：<br>$ans[i]$：被吃掉的最小操作次数。<br>$l[i]$：第$i$个数字的上一个与$a[i]$不同的位置。<br>$left$：记录一个区间的左端点。</p><p>如果存在$left$，使得：<br>1、$[left,i-1]$区间的和&gt;$ans[i]$。<br>2、$[left,i-1]$区间数字种类$&gt;=2$（因为相同不能互相吞并，那么最少需两种大小不同的史莱姆）。<br>那么操作次数就是:$i-left$。</p><p>可以发现$i-1$其实是固定的（对于每一个$i$来说）,并且$left$越小，区间和越大，反之，区间和越小，所以想到可以用二分。<br>那么我们就需要用前缀和求出区间和，再用二分求出端点位置。</p><p>但是怎么判断$[left,i-1]$区间数字种类$&gt;=2$，这时候$l[i]$就派上用场了。<br>二分的左右端点分别为$left$（这里的$left$与上面的$left$无关，是完全不同的两个），$right$。中间值为$mid$。<br>如果$mid&gt;l[i-1]$，那么第二个条件就不成立（此时区间数字种类只有1）.</p><p>基本上就分析完了，但是如果是右边怎么办，我们只需要将数组反转即可。</p><h3 id="代码实现-4">代码实现</h3><p>一些细节可以看注释</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(MAXN)</span>,<span class="title">pre</span><span class="params">(MAXN)</span>,<span class="title">l</span><span class="params">(MAXN)</span>,<span class="title">ans</span><span class="params">(MAXN)</span>,<span class="title">b</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//其实跟下面的条件2判断一样，也就是前面的一段全都是同一个数字</span></span><br><span class="line">    <span class="comment">//思路是参考RegenFallen大佬的，但我感觉这一行不用加上去，因为不可能二分到位置为0，试了一下，删去也AC了，所以加不加无所谓</span></span><br><span class="line">    <span class="comment">//if(x&lt;=0)return 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件2：区间内数字种类小于2</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;l[i<span class="number">-1</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//条件1</span></span><br><span class="line">    <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[x<span class="number">-1</span>]&gt;a[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[n-i+<span class="number">1</span>]=a[i];    <span class="comment">//先反转，存起来</span></span><br><span class="line">        ans[i]=<span class="number">1e9</span>;       <span class="comment">//ans[i]先预处理为1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];         <span class="comment">//预处理出前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];  <span class="comment">//预处理出l[i],可以举几个例子：0333332222</span></span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右端点都得判，先判右，再判左，可以保证求出来ans[i]最小，并且有可能右端点不满足（check==false），所以左端点也必须得判断。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[i]=<span class="built_in">min</span>(ans[i],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[i]=<span class="built_in">min</span>(ans[i],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来就是相同的操作，但是注意ans数组的下标要反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[n-i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans[i]==<span class="number">1e9</span>?<span class="number">-1</span>:ans[i])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-E"><a href="https://codeforces.com/contest/1923/problem/E">Problem E</a></h2><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1029A</title>
      <link href="/2024/03/13/CF1029A/"/>
      <url>/2024/03/13/CF1029A/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Many-Equal-Substrings">Many Equal Substrings</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>你有一个字符串t，它由n个字母组成。</p><p>定义一个字符串s的子串为s[l…r]，表示从位置l到r构成的一个新的串。</p><p>你的目标是构造一个字符串s，使得它的可能长度最小，要求s中存在k个位置i,可以找到k个以i为出发点的子串t。</p><p>输入： 第一行输入两个整数n和k，表示t的长度和需要k个子串</p><p>第二行输入字符串t</p><p>输出：</p><p>输出满足条件的长度最小的s。题目保证答案唯一。</p><h2 id="题目描述">题目描述</h2><p>You are given a string $ t $ consisting of $ n $ lowercase Latin<br>letters and an integer number $ k $ .</p><p>Let’s define a substring of some string $ s $ with indices from $ l $<br>to $ r $ as $ s[l \dots r] $ .</p><p>Your task is to construct such string $ s $ of minimum possible length<br>that there are exactly $ k $ positions $ i $ such that $ s[i \dots i +<br>n - 1] = t $ . In other words, your task is to construct such string $<br>s $ of minimum possible length that there are exactly $ k $ substrings<br>of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="输入格式">输入格式</h2><p>The first line of the input contains two integers $ n $ and $ k $ ( $<br>1 \le n, k \le 50 $ ) — the length of the string $ t $ and the number<br>of substrings.</p><p>The second line of the input contains the string $ t $ consisting of<br>exactly $ n $ lowercase Latin letters.</p><h2 id="输出格式">输出格式</h2><p>Print such string $ s $ of minimum possible length that there are<br>exactly $ k $ substrings of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 4 aba </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababababa </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>3 2 cat </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>catcat </code></p></blockquote><p>看到这道题要求的答案，想到了熟悉的循环节问题，就从这入手吧。<br>还是先求出来$t$的最小的循环节（记作$p$），并根据$k$进行多次构造。</p><p>但是，通过样例一可以发现，构造出来的$s$可能不是恰好由整数个$p$构成。<br>看样例一，可以发现最后恰好是由$pmt[n-1]$构成。</p><p>根据题意，可以总结出：前面输出$k-1$个循环节，后面输出$t$即可。<br>因为前面的$k-1$个循环节首尾相连，已经是构成了$k-1$个$t$结构了。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>()-pmt[s.<span class="built_in">length</span>()<span class="number">-1</span>];j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF45D</title>
      <link href="/2024/03/13/CF54D/"/>
      <url>/2024/03/13/CF54D/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Writing-a-Song">Writing a Song</h1><h2 id="题面翻译">题面翻译</h2><p><strong>题目大意</strong></p><p>求一个字符串s，满足该串长度为n，只出现字母表中前k个字母，并且在指定位置必须出现指定字符串p</p><p><strong>输入格式</strong></p><p>第一行 n，k。(n为所需字符串的长度 n&lt;=100，k为相应的字母大小 2&lt;=k&lt;=26)</p><p>第二行 p。（一个长度小于n，只包含字母表中前k个字母的字符串）</p><p>第三行 01串。（在第i个位置的数字1表示p的出现应该从s的第i个位置开始，而0表示从这里开始没有出现。）</p><p><strong>输出格式</strong></p><p>输出任意一个符合题意的字符串s</p><p>若无，输出“No solution”</p><h2 id="题目描述">题目描述</h2><p>One of the Hedgehog and his friend’s favorite entertainments is to<br>take some sentence or a song and replace half of the words (sometimes<br>even all of them) with each other’s names.</p><p>The friend’s birthday is approaching and the Hedgehog decided to make<br>a special present to his friend: a very long song, where his name will<br>be repeated many times. But try as he might, he can’t write a decent<br>song!</p><p>The problem is that the Hedgehog has already decided how long the<br>resulting sentence should be (i.e. how many letters it should contain)<br>and in which positions in the sentence the friend’s name should occur,<br>and it must not occur in any other position in the sentence. Besides,<br>the Hedgehog decided to limit himself to using only the first $ K $<br>letters of an English alphabet in this sentence (so it will be not<br>even a sentence, but one long word).</p><p>The resulting problem is indeed quite complicated, that’s why the<br>Hedgehog asks you to help him and write a program that will make the<br>desired word by the given name $ P $ , the length $ N $ of the<br>required word, the given positions of the occurrences of the name $ P<br>$ in the desired word and the alphabet’s size $ K $ . Note that the<br>occurrences of the name can overlap with each other.</p><h2 id="输入格式">输入格式</h2><p>The first line contains numbers $ N $ and $ K $ which are the length<br>of the required string and the alphabet size accordingly. The<br>limitations are: $ 1&lt;=N&lt;=100 $ , $ 2&lt;=K&lt;=26 $ .</p><p>The second line contains the name $ P $ which is a non-empty string<br>whose length does not exceed $ N $ characters. The string consists<br>only of the first $ K $ lowercase symbols of an English alphabet.</p><p>The third line contains the string of length $ N-length(P)+1 $ ,<br>consisting only of numbers zero and one. A number one in the $ i $ -th<br>position means that an occurrence of the name $ P $ should start from<br>$ i $ -th position of the desired word, while a zero means that there<br>is no occurrence starting here.</p><h2 id="输出格式">输出格式</h2><p>Print the desired word $ S $ . If there are several answers, print any<br>of them.</p><p>If there is no solution, then print “No solution”.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>5 2 aba 101 </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababa </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>5 2 a 10001 </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>abbba </code></p><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><p><code>6 2 abba 101 </code></p><h3 id="样例输出-3">样例输出 #3</h3><p><code>No solution </code></p></blockquote><p>可怕的构造题，不会qwq，只能看题解区大佬了（大佬讲得很清楚）：<br><a href="https://www.luogu.com.cn/problem/solution/CF54D">https://www.luogu.com.cn/problem/solution/CF54D</a><br>构造这方面得加强qwq，贴上AC代码：</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    string p;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> lenp=p.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> lens=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i+j]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ans[i+j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p[j]==<span class="string">&#x27;a&#x27;</span>)ans[i+j]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                        <span class="keyword">else</span> ans[i+j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])ans[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉还是得多想想特殊情况：<br>1、搜索1的时候：有没有重复占位，也就是$ans[i+j]$存在，并且$ans[i+j]!=p[j]$，如果存在，说明该位已经被占领了，直接$No$ $solution$。<br>2、搜索0的时候：看看有没有$ans[i+j]$存在，并且$ans[i+j]!=p[j]$，如果存在，则该位构造成功，直接$break$，不用做重复的判断。<br>3、如果2的情况没有发生，我们发现这里实际上只有两种情况（与上面相对应）：$ans[i+j]==0$ $or$ $ans[i+j]==p[j]$。第二种情况已经没办法改变了（因为我们在上面的构造时已经确定$ans[i+j]==p[j]$），那么我们只能改变第一种情况，看看$s[j]$是什么，那么$ans[i+j]$构造时只需要注意不等于$s[j]$即可（这里情况一存在的话，可以直接构造后$break$掉，提高一点效率，后面输出时再简单构造即可）。<br>4、如果情况一也没有发生呢？？？很不幸，那就只能$No$ $solution$了。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF126B</title>
      <link href="/2024/03/13/CF126B/"/>
      <url>/2024/03/13/CF126B/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Password">Password</h1><h2 id="题面翻译">题面翻译</h2><p>Asterix，Obelix 和他们的临时伙伴 Suffix、Prefix 已经最终找到了和谐寺。然而和谐寺大门紧闭，就连 Obelix<br>的运气也没好到能打开它。</p><p>不久他们发现了一个字符串 $S\ (1\leqslant\vert<br>S\vert\leqslant1000000)$，刻在和谐寺大门下面的岩石上。Asterix<br>猜想那一定是打开寺庙大门的密码，于是就大声将字符串朗读了出来，然而并没有什么事发生。于是 Asterix 又猜想密码一定是字符串 $S$<br>的子串 $T$。</p><p>Prefix 认为 $T$ 是 $S$ 的前缀，Suffix 认为 $T$ 是 $S$ 的后缀，Obelix 却认为 $T$ 应该是 $S$<br>中的某一部分，也就是说，$T$ 既不是 $S$ 的前缀，也不是 $S$ 的后缀。</p><p>Asterix 选择子串 $T$ 来满足所有伙伴们的想法。同时，在所有可以被接受的子串变形中，Asterix 选择了最长的一个。当<br>Asterix 大声读出子串 $T$ 时，寺庙的大门开了。（也就是说，你需要找到既是 $S$ 的前缀又是 $S$ 的后缀同时又在 $S$<br>中间出现过的最长子串）</p><p>现在给你字符串 $S$，你需要找到满足上述要求的子串 $T$。</p><h3 id="输入格式">输入格式</h3><p>一行一个只包含小写字母的字符串 $S$。</p><h3 id="输出格式">输出格式</h3><p>输出子串 $T$，如果 $T$ 不存在，输出 <code>Just a legend</code>。</p><h2 id="题目描述">题目描述</h2><p>Asterix, Obelix and their temporary buddies Suffix and Prefix has<br>finally found the Harmony temple. However, its doors were firmly<br>locked and even Obelix had no luck opening them.</p><p>A little later they found a string $ s $ , carved on a rock below the<br>temple’s gates. Asterix supposed that that’s the password that opens<br>the temple and read the string aloud. However, nothing happened. Then<br>Asterix supposed that a password is some substring $ t $ of the string<br>$ s $ .</p><p>Prefix supposed that the substring $ t $ is the beginning of the<br>string $ s $ ; Suffix supposed that the substring $ t $ should be the<br>end of the string $ s $ ; and Obelix supposed that $ t $ should be<br>located somewhere inside the string $ s $ , that is, $ t $ is neither<br>its beginning, nor its end.</p><p>Asterix chose the substring $ t $ so as to please all his companions.<br>Besides, from all acceptable variants Asterix chose the longest one<br>(as Asterix loves long strings). When Asterix read the substring $ t $<br>aloud, the temple doors opened.</p><p>You know the string $ s $ . Find the substring $ t $ or determine that<br>such substring does not exist and all that’s been written above is<br>just a nice legend.</p><h2 id="输入格式-2">输入格式</h2><p>You are given the string $ s $ whose length can vary from $ 1 $ to $<br>10^{6} $ (inclusive), consisting of small Latin letters.</p><h2 id="输出格式-2">输出格式</h2><p>Print the string $ t $ . If a suitable $ t $ string does not exist,<br>then print “Just a legend” without the quotes.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>fixprefixsuffix </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>fix </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>abcdabc </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>Just a legend </code></p></blockquote><p>看到这题的第一眼，想到的肯定是KMP（因为需要求最长公共前后缀嘛，将其记作$t$，母串记作$s$）。<br>但是，$t$还需要是$s$的中间部分，这个怎么办？？？<br>我们可以将它转化为熟悉的问题，画个图解释一下：<br><img src="https://img-blog.csdnimg.cn/direct/3fa1ee27e9eb4e6d8580999418d6f7b0.png#pic_center" alt="在这里插入图片描述">这样就一目了然了吧，$t$也是中间的橙色串的最长前后缀，这就转化成了我们熟悉的问题。</p><p>那么我们只要$2$遍历到$n-2$，只要$pmt[i]==pmt[n-1]$，那么我们就找到最长的$t$了。</p><p>但是，实际上可能是找不到的（看题意就知道了），如果$pmt[n-1]$比$max(pmt[i])$还大，所以这时$t$的长度就得缩小了（也就是不断地往回跳：$pmt[pmt[n-1]]$，$pmt[pmt[pmt[n-1]]]······$，直到小于$max(pmt[i])$，注意$i&lt;=n-2$）。</p><p>可能有点混乱，将上述的步骤总结一下：<br>1、先预处理出$max(pmt[i])，i&lt;=n-2$。<br>2、判断$pmt[n-1]$与$max(pmt[i])$的大小关系，如果$pmt[n-1]&gt;=max(pmt[i])$，就得往回跳，直到小于$max(pmt[i])$为止（记作$len$吧)，当然有可能跳到0，那么这时候就无解了。<br>3、如果有解，那么我们只需要输出$0$~$len-1$即可，毕竟$len$是字符串的长度。</p><p>我们可以在第二步开始前加上特判$pmt[n-1]==0$是否成立，如果成立，就说明前后缀不同，肯定无解。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],maxn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,pmt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len=pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;maxn)&#123;</span><br><span class="line">            len=pmt[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                cout&lt;&lt;s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA1328</title>
      <link href="/2024/03/13/UVA1328/"/>
      <url>/2024/03/13/UVA1328/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Period">Period</h1><h2 id="题面翻译">题面翻译</h2><p>对于给定字符串 $S$<br>的每个前缀，我们想知道它是否为周期串（周期串定义为由若干最小循环节拼接而成的字符串），若是，输出前缀长度和循环节数量。</p><p><strong>【输入格式】</strong></p><p>多组数据，每组数据第一行一个整数 $n$，表示字符串 $s$ 的长度，若 $n=0$ 则结束输入。</p><p>若 $n\ne0$，则第二行一个字符串 $S$，如题意。</p><p><strong>【输出格式】</strong></p><p>对于第 $i$ 组输出，第一行一个字符串 <code>Test case #i</code>。</p><p>之后若干行一行两个整数，表示如果字符串 $S$ 的一个前缀是周期串，它的长度和循环节数量（注意这里的循环节是指<strong>长度最小的</strong>循环节）。</p><p>之后再空一行。</p><p><strong>【说明】</strong></p><p>$n\leq10^6$，字符串 $S$ 均由小写字母构成。</p><h2 id="题目描述">题目描述</h2><p><a href="https://uva.onlinejudge.org/external/13/p1328.pdf">PDF</a></p><h2 id="输入格式">输入格式</h2><h2 id="输出格式">输出格式</h2><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 aaa 12 aabaabaabaab 0 </code></p><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><figcaption><span>case #1 2 2 3 3</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Test case #2 2 2 6 2 9 3 12 4 ```</span><br><span class="line"></span><br><span class="line">还是熟悉的最小循环节问题，需要注意的是，前缀长度需要大于1，所以需要从2开始判断，最大前缀长度就是$S$的长度。</span><br><span class="line"></span><br><span class="line">判断有没有循环节，看$pmt[i-1]$是否存在，计算循环节数量，看$n$%$(n-pmt[n-1])$是否等于0（因为$S$的前缀串$t$需要作为周期串）。</span><br><span class="line"></span><br><span class="line">每个测试点之间的空行特判一下即可，看$i==len$是否成立。</span><br><span class="line"></span><br><span class="line">## AC代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll=long long;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">int pmt[MAXN],n,cnt;</span><br><span class="line">string s;</span><br><span class="line">void get_pmt(const string&amp; s)&#123;</span><br><span class="line">   for(int i=1,j=0;i&lt;s.length();i++)&#123;</span><br><span class="line">       while(j&amp;&amp;s[i]!=s[j])j=pmt[j-1];</span><br><span class="line">       if(s[i]==s[j])j++;</span><br><span class="line">       pmt[i]=j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">   ios::sync_with_stdio(0),cin.tie(0);</span><br><span class="line">   while(1)&#123;</span><br><span class="line">       cin&gt;&gt;n;</span><br><span class="line">       if(n==0)break;</span><br><span class="line">       cin&gt;&gt;s;</span><br><span class="line">       int len=s.length();</span><br><span class="line">       memset(pmt,0,sizeof(pmt));</span><br><span class="line">       get_pmt(s);</span><br><span class="line">       cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;++cnt&lt;&lt;&quot;\n&quot;;</span><br><span class="line">       for(int i=2;i&lt;=len;i++)&#123;</span><br><span class="line">           if(pmt[i-1]&amp;&amp;i%(i-pmt[i-1])==0)&#123;</span><br><span class="line">               cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i/(i-pmt[i-1])&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           if(i==len)&#123;</span><br><span class="line">               cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA10298</title>
      <link href="/2024/03/13/UVA10298/"/>
      <url>/2024/03/13/UVA10298/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Power-Strings">Power Strings</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题意简述：">题意简述：</h3><p>求一个字符串由多少个重复的子串连接而成。</p><p>例如 <code>ababab</code> 由三个 <code>ab</code> 连接而成，<code>abcd</code> 由 <code>abcd</code> 由一个 <code>abcd</code> 连接而成。</p><h3 id="输入格式">输入格式</h3><p><strong>本题多组数据</strong>。</p><p>每一组数据仅有一行，这一行仅有一个字符串 $s$。</p><p>输入的结束标志为一个 <code>.</code>。</p><h3 id="输出格式">输出格式</h3><p>对于每一组数据，输出这组字符串由多少个重复的子串连接而成。</p><h3 id="说明-提示">说明/提示</h3><p>$1\le |s|\le 10^6$。</p><h2 id="题目描述">题目描述</h2><p><a href="https://uva.onlinejudge.org/external/102/p10298.pdf">PDF</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a89b1b5be26ca2d032d51c4fc5e18d2.png" alt=""></p><h2 id="输入格式-2">输入格式</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/aa5c61819fa5b54135f8b7236af00a7e.png" alt=""></p><h2 id="输出格式-2">输出格式</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/795c5ef49846eb46a838271a5812fff1.png" alt=""></p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>abcd aaaa ababab . </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 4 3 </code></p></blockquote><p>其实方法还是一样的，求出最短的循环节(记作$p$)，也就是$n-pmt[n-1]$，然后就是$n/(n-pmt[n-1])$。<br>但是，这里需要注意的是：$s$可能不是由整数个$p$构成的，可能存在最后的$p$被切割的情况。（一开始没考虑到这点，看了题解才反应过来）。<br>那么这里就需要进行特叛了：如果$n$%$(n-pmt[n-1])==0$，说明恰好整除，那么$n/(n-pmt[n-1])$就是答案了。<br>如果$n$%$(n-pmt[n-1])!=0$，那么只能以$s$自身作为循环节了，答案也就是1。<br>具体的证明可以看看评论区的大佬，写的很好：<a href="https://www.luogu.com.cn/blog/hzz/solution-uva10298">https://www.luogu.com.cn/blog/hzz/solution-uva10298</a></p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">get_pmt</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%(n-pmt[n<span class="number">-1</span>])==<span class="number">0</span>)cout&lt;&lt;n/(n-pmt[n<span class="number">-1</span>])&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>因为这道题目是有多个数据输入，且一行一个$s$，所以我们可以用$getlin(cin,s)$，只需要当$s$为&quot;$.$&quot;时结束即可。</p><h2 id="结论总结：">结论总结：</h2><p>设字符串的长度为$n$，最长相同前后缀的长度为$pmt[n-1]$。如果$n$%$(n-pmt[n-1])==0$，则答案为$n/(n-pmt[n-1])$，否则为1。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3375</title>
      <link href="/2024/03/13/Luogu%20P3375/"/>
      <url>/2024/03/13/Luogu%20P3375/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="【模板】KMP">【模板】KMP</h1><h2 id="题目描述">题目描述</h2><p>给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在<br>$s_1$ 中出现了，其出现位置为 $l$。   现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。</p><p>定义一个字符串 $s$ 的 border 为 $s$ 的一个<strong>非 $s$ 本身</strong>的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是<br>$s$ 的后缀。   对于 $s_2$，你还需要求出对于其每个前缀 $s’$ 的最长 border $t’$ 的长度。</p><h2 id="输入格式">输入格式</h2><p>第一行为一个字符串，即为 $s_1$。   第二行为一个字符串，即为 $s_2$。</p><h2 id="输出格式">输出格式</h2><p>首先输出若干行，每行一个整数，<strong>按从小到大的顺序</strong>输出 $s_2$ 在 $s_1$ 中出现的位置。   最后一行输出 $|s_2|$<br>个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>ABABABC ABA </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 3 0 0 1 </code></p><h2 id="提示">提示</h2><h3 id="样例-1-解释">样例 1 解释</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3c98caa2ee905bfada0eb2516ba7b8cc.png" alt="">。<br>对于 $s_2$ 长度为 $3$ 的前缀 <code>ABA</code>，字符串 <code>A</code> 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为<br>$1$。</p><h3 id="数据规模与约定">数据规模与约定</h3><p><strong>本题采用多测试点捆绑测试，共有 3 个子任务</strong>。</p><ul><li>Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。</li><li>Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。</li><li>Subtask 3（30 points）：无特殊约定。</li></ul><p>对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。</p></blockquote><p>这道题就是妥妥的KMP模板题，具体原理可以参考知乎Pecco大佬的文章，链接贴上：<a href="https://zhuanlan.zhihu.com/p/105629613">https://zhuanlan.zhihu.com/p/105629613</a></p><p>需要注意的一点是：Pecco大佬的KMP写法与我所看到的大部分写法有细节上的不同，所以做题的时候，如果打算用Pecco大佬的码作为模板，你需要经常琢磨到底哪一点需要修改，就当是锻炼自己是否真正理解了KMP算法吧。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> pmt[MAXN];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;  </span><br><span class="line">        pmt[i]=j;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">const</span> string &amp;p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])j++;  </span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">length</span>())&#123;  </span><br><span class="line">            cout&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">            j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    string s,p;  </span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;  </span><br><span class="line">    <span class="built_in">get_pmt</span>(p);  </span><br><span class="line">    <span class="built_in">kmp</span>(s,p);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        cout&lt;&lt;pmt[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3435</title>
      <link href="/2024/03/12/Luogu%20P3435/"/>
      <url>/2024/03/12/Luogu%20P3435/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="POI2006-OKR-Periods-of-Words">[POI2006] OKR-Periods of Words</h1><blockquote><h2 id="题面翻译">题面翻译</h2><p>对于一个仅含小写字母的字符串 $a$，$p$ 为 $a$ 的前缀且 $p\ne a$，那么我们称 $p$ 为 $a$ 的 proper<br>前缀。</p><p>规定字符串 $Q$ 表示 $a$ 的周期，当且仅当 $Q$ 是 $a$ 的 proper 前缀且 $a$ 是 $Q+Q$<br>的前缀。若这样的字符串不存在，则 $a$ 的周期为空串。</p><p>例如 <code>ab</code> 是 <code>abab</code> 的一个周期，因为 <code>ab</code> 是 <code>abab</code> 的 proper 前缀，且 <code>abab</code> 是 <code>ab+ab</code><br>的前缀。</p><p>求给定字符串所有前缀的最大周期长度之和。</p><h2 id="题目描述">题目描述</h2><p>A string is a finite sequence of lower-case (non-capital) letters of<br>the English alphabet. Particularly, it may be an empty sequence, i.e.<br>a sequence of 0 letters. By A=BC we denotes that A is a string<br>obtained by concatenation (joining by writing one immediately after<br>another, i.e. without any space, etc.) of the strings B and C (in this<br>order). A string P is a prefix of the string !, if there is a string<br>B, that A=PB. In other words, prefixes of A are the initial fragments<br>of A. In addition, if P!=A and P is not an empty string, we say, that<br>P is a proper prefix of A.</p><p>A string Q is a period of Q, if Q is a proper prefix of A and A is a<br>prefix (not necessarily a proper one) of the string QQ. For example,<br>the strings abab and ababab are both periods of the string abababa.<br>The maximum period of a string A is the longest of its periods or the<br>empty string, if A doesn’t have any period. For example, the maximum<br>period of ababab is abab. The maximum period of abc is the empty<br>string.</p><p>Task Write a programme that:</p><p>reads from the standard input the string’s length and the string<br>itself,calculates the sum of lengths of maximum periods of all its<br>prefixes,writes the result to the standard output.</p><h2 id="输入格式">输入格式</h2><p>In the first line of the standard input there is one integer $k$<br>($1\le k\le 1\ 000\ 000$) - the length of the string. In the following<br>line a sequence of exactly $k$ lower-case letters of the English<br>alphabet is written - the string.</p><h2 id="输出格式">输出格式</h2><p>In the first and only line of the standard output your programme<br>should write an integer - the sum of lengths of maximum periods of all<br>prefixes of the string given in the input.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 babababa </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>24 </code></p></blockquote><p>先理解清楚题意：proper前缀可以配合下图理解<br><img src="https://img-blog.csdnimg.cn/direct/2c12d9db942e46608af09d0f84a0255d.png#pic_center" alt="在这里插入图片描述"><br>这里我们不难看出：abcabcab的最长proper字串为abcabc，长度是6。<br>记原来的字符串为$s$，proper子串为$t$。<br>想想看，如果是要使得proper字串最长，那么恰好就是$len(s)-min(border)$。<br>我们可以大致感受一下，如果$border$越大，那么对应的$len(t)$越小，可以结合上面的例子。<br>那么我们的问题就变成了怎么求最小的$border$。<br>问题是，在KMP算法中，$pmt$求出来的是$max(border)$。<br>我们可以利用KMP算法的一个性质：$pmt[i]、pmt[pnt[i]]、pmt[pmt[pmt[i]]]······$<br>直到为0，以上这些都是$s$的$border$的长度，并且越来越小。<br>利用这个性质，我们就可以求出来$min(border)$。</p><p>因为题目是求所有前缀的最大周期长度之和，所以我们令$j=i+1$。（因为我个人的KMP写得比较奇怪，题解区的大佬是令$j=i$）。然后在$j&gt;0$的情况下不断令$j=pmt[j-1]$，直到$j$最小为止。此时$ans+=i-j+1$。<br>这里有一个技巧：当$j$求出来后，令$pmt[i]=j$，相当于记忆化，否则可能会T。</p><p>思路参考：<a href="https://www.luogu.com.cn/problem/solution/P3435">https://www.luogu.com.cn/problem/solution/P3435</a></p><p>贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pmt[j<span class="number">-1</span>])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pmt[i])pmt[i]=j;</span><br><span class="line">        ans+=i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
