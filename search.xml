<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CF959</title>
      <link href="/posts/b18046c4.html"/>
      <url>/posts/b18046c4.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF959"><a href="https://codeforces.com/contest/1994">CF959</a></h1><h2 id="A">A</h2><p>看了大佬们的做法都是比较复杂的，jiangly神写的很简洁，可以学习一下，还有换行的技巧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> N = n * m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            std::cin &gt;&gt; x;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">                x = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == N) &#123;</span><br><span class="line">                x = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; \n&quot;</span>[j == m - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>容易发现：只需要在$s_i=0,t_i=1$的情况下，判断$s_i$前面有没有1就行，可以使用一个前缀和统计一下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    string s,t; cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>)   cnt[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; t[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!cnt[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>看完jiangly神的码，总是感觉自己很蠢，看大佬的码还是大有裨益。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    std::string s, t;</span><br><span class="line">    std::cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>直接暴力肯定会TLE，不难想到：可以使用前缀和先计算各个区间的值。</p><p>考虑一个合法的区间$a_l-a_{p-1}$，那么$a_{p-1}$之后（从$a_p$开始）就是重置为0的情况。不难发现：如果是在$a_{l}-a_{p-1}$之间，答案就是$p-l-1$，那么在$a_p-1$之后呢？就是$a_p$合法的情况（类似的推导），所以这里可以使用$dp$，不难得到状态转移方程为$dp_i=dp_p+p-1-i$。（这里$dp_i$表示的就是从$i$位置以后找到的合法情况）。</p><p>至于找$p$，可以用二分查找，具体看代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wsm in queue</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;  ll m;   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)    sum[i]=sum[i<span class="number">-1</span>]+v[i];</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n+<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="built_in">upper_bound</span>(sum.<span class="built_in">begin</span>()+i,sum.<span class="built_in">end</span>(),sum[i]+m)-sum.<span class="built_in">begin</span>();</span><br><span class="line">        dp[i]=dp[p]+p-i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(),dp.<span class="built_in">end</span>(),<span class="number">0ll</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是双指针的做法，这里$dp$数组维护的是从$a_i$后，一直到$a_{n-1}$之间，不合法的区间的长度（包含本身，所以基本长度就是1，所以$dp_n=1$），先用双指针寻找合法的区间，再进行$dp$。</p><p>解释一下状态转移方程：$a_i$到$a_{j-1}$为合法的区间， 那么从$dp_j$往后开始就是非法的区间了，所以状态转移方程是$dp_i=dp_j+1$，所以不难得到此时非法的范围数值就是$dp_j$，这里用$dp_i-1$主要是因为需要讨论$j$，写成这样简单一点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a的下标是从0~n-1</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sum的下标是从1~n</span></span><br><span class="line">    <span class="function">std::vector&lt;i64&gt; <span class="title">s</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        s[i + <span class="number">1</span>] = s[i] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i64 ans = <span class="number">1LL</span> * n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>, j = n + <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (s[j - <span class="number">1</span>] - s[i] &gt; x) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = <span class="number">1</span> + (j &lt;= n ? dp[j] : <span class="number">0</span>);</span><br><span class="line">        ans -= dp[i] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>容易想到是并查集，合并的条件是$|a_u-a_v|%x=0$，不难想到$a_u=k_1x+b,a_v=k_2x+b$，我们执行$n$次操作，对应就是$x：1-n$，我们可以通过枚举$x$，再枚举$a_u$进行合并，$a_v$怎么处理？不妨让$a_v$直接为$a%x$，也就是$b$即可。通过一个数组先存起来，直到寻找到满足条件的即可。</p><p>关键的是$x$需要从$n-1$开始倒序枚举，这里是利用了抽屉原理，想一下：如果当前有$x$个点，然后所有数都取模于$x-1$，那么他们的范围一定是在$0-(x-2)$之间，说明一定会有两个点取模后存在相同的值，这样可以保证每一次操作都能连接两个不同的集合，故必定有解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">a</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: a) cin&gt;&gt;t;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">fa</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> init=[&amp;](<span class="type">int</span> n)-&gt;<span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)    fa[i]=i;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> find=[&amp;](<span class="keyword">auto</span>&amp;&amp; self,<span class="type">int</span> x)-&gt;<span class="type">int</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]==x)    <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> fa[x]=<span class="built_in">self</span>(self,fa[x]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> merge=[&amp;](<span class="type">int</span> x,<span class="type">int</span> y,<span class="keyword">auto</span>&amp;&amp; find)-&gt;<span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fx=<span class="built_in">find</span>(find,x),fy=<span class="built_in">find</span>(find,y);</span><br><span class="line">        <span class="keyword">if</span>(fx!=fy)  fa[fx]=fy;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">init</span>(n);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">u</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">//|au-av|%x==0 说明两者都是kx+b 只是k不同而已</span></span><br><span class="line">    <span class="comment">//可以通过au%x得到b 并且找到av 满足kx+b</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=n<span class="number">-1</span>;x&gt;=<span class="number">1</span>;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(x,<span class="number">-1</span>)</span></span>;<span class="comment">//用来暂时存放b的数组，可以到时候用来寻找av</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(find,i)!=i) <span class="keyword">continue</span>;   <span class="comment">//说明已经找到了，合并在一起</span></span><br><span class="line">            <span class="keyword">if</span>(tmp[a[i]%x]!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                u[x]=tmp[a[i]%x];</span><br><span class="line">                v[x]=i;</span><br><span class="line">                <span class="built_in">merge</span>(u[x],v[x],find);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>    tmp[a[i]%x]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;u[i]+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v[i]+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF964</title>
      <link href="/posts/e41c69ba.html"/>
      <url>/posts/e41c69ba.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF964"><a href="https://codeforces.com/contest/1999">CF964</a></h1><h2 id="A">A</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;n%<span class="number">10</span>+n/<span class="number">10</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>当初一直WA，忘记考虑两个回合中，一胜一平的情况了。</p><p>只需要交换一下$a$和$b$，就能枚举出所有的情况了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c,d;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;c &amp;&amp; b&gt;=d || a&gt;=c &amp;&amp; b&gt;d)  cnt+=<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;c &amp;&amp; b&gt;=d || a&gt;=c &amp;&amp; b&gt;d)  cnt+=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>只需要找每一个区间的起点和前一个区间的终点中间的这段时间即可，注意考虑起点和终点。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ll s,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">l</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">r</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)   cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    ll cnt=l[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="built_in">max</span>(cnt,l[i]-r[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=<span class="built_in">max</span>(cnt,m-r[n<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=s)  cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>直接暴力构造，使用一个指针扫描$t$串，并对此进行构造$s$即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s,t; cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;t.<span class="built_in">size</span>())  s[i]=t[j],j++;</span><br><span class="line">            <span class="keyword">else</span>    s[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&lt;t.<span class="built_in">size</span>() &amp;&amp; s[i]==t[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==t.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>&lt;&lt;s&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E">E</h2><p>思路一开始忘记了，现在想起来了。</p><p>我们不难发现先找最小的一个变为0，然后后面一直找0作为$x$进行运算即可。</p><p>这个题一看就知道适合离线处理，我们可以使用一个数组$a[i]$：表示将$i$操作为0需要的次数，最小方案数就是$2a[l]+a[l+1]+······+a[r]$，然后用前缀和进行优化即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    cout&lt;&lt;sum[r]-sum[l<span class="number">-1</span>]+a[l]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp=i;</span><br><span class="line">        <span class="keyword">while</span>(tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i]++;</span><br><span class="line">            tmp/=<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F">F</h2><p>不妨设我们抽取$x$个1，$k-x$个0，如果对答案有贡献：那么需要$\frac{k+1}{2}\leq x$。</p><p>不难想到答案的贡献就是$C_{cnt_1}^{i} \times C_{cnt_0}^{k-i}$，我们只需要枚举$i$并累计计算即可。</p><p>求组合数得用一些数学知识（费马小定理）：快速幂+乘法逆元，需要预处理出阶乘，主题特判$cnt_1&lt;i$和$cnt_0&lt;k-i$的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[MAXN],cnt[<span class="number">2</span>];</span><br><span class="line">ll fact[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod ;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll m, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m &lt; n ? <span class="number">0</span> : fact[m] * <span class="built_in">inv</span>(fact[n]) %  mod * <span class="built_in">inv</span>(fact[m - n]) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll k,n;    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    cnt[<span class="number">0</span>]=cnt[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)   </span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i])    cnt[<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">else</span>    cnt[<span class="number">0</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=(k+<span class="number">1</span>)/<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">1</span>]&lt;i)    <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[<span class="number">0</span>]&lt;k-i)  <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">C</span>(cnt[<span class="number">1</span>],i)*<span class="built_in">C</span>(cnt[<span class="number">0</span>],k-i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i]=(fact[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Edu169</title>
      <link href="/posts/2db42d85.html"/>
      <url>/posts/2db42d85.html</url>
      
        <content type="html"><![CDATA[<h1 id="Edu169">Edu169</h1><p>做得很糟糕。。。</p><h2 id="A">A</h2><p>只有$n=2$且两者之间的距离大于1时才可以插入。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: v) cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">1</span>]-v[<span class="number">0</span>]&lt;<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>直接找最小的区间即可。需要考虑左右端点不重合的情况，另外加一。</p><p>此外还需要特判不重合的情况，直接为1即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="type">int</span> L,R;    cin&gt;&gt;L&gt;&gt;R;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;L || R&lt;l)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">min</span>(R,r)-<span class="built_in">max</span>(L,l);</span><br><span class="line">    <span class="keyword">if</span>(R!=r)    ans++;</span><br><span class="line">    <span class="keyword">if</span>(l!=L)    ans++;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>博弈论，显然需要先排个序，然后依次取。</p><p>需要考虑的是，偶数位的数字是Bob可以修改的，但是要考虑前提是修改后不能大于前一位数字（也就是Alice取的），否则顺序会颠倒。</p><p>用差分计算每一个偶数位最多可以加的数，根据$k$辅助判断即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin&gt;&gt;v[i];</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),[&amp;](ll x,ll y)&#123;<span class="keyword">return</span> x&gt;y;&#125;);</span><br><span class="line">    ll a=<span class="number">0</span>,b=<span class="number">0</span>;</span><br><span class="line">    std::vector&lt;ll&gt; need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)  a+=v[i];</span><br><span class="line">        <span class="keyword">else</span>    b+=v[i];</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            need.<span class="built_in">push_back</span>(v[i<span class="number">-1</span>]-v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=a-b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: need)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&gt;=t &amp;&amp; d-t&gt;=<span class="number">0</span>)  k-=t,d-=t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d-t&gt;=<span class="number">0</span> &amp;&amp; k&lt;t)</span><br><span class="line">        &#123;</span><br><span class="line">            d-=k;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;d&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>可以学到一些$trick$的好题，这里可以使用位运算进行处理颜色。</p><p>我们要的是距离最小，可以维护每一个城市的左右边，拥有不同颜色且可以直接到达的城市（也就是一个颜色相同、一个颜色不同）。通过中间点，不断的跳跃，可以计算得到需要的距离。</p><p>需要预处理的就是$left$数组和$right$数组，可以使用类似$dp$的过程进行处理。</p><p>以$right$数组为例，如果$city_i$与$city_{i+1}$有完全相同的颜色或者没有相同的颜色，</p><p>那么$right_i=right_{i+1}$，因为如果相同，那么直接继承即可。否则，根据$right$数组的定义，肯定有一个颜色是$city_i$和$city_{right[i+1]}$都有的，$left$数组也是类似的推导。</p><p>需要注意的是：跳跃是通过中间点的，一些细节还是看代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//B1 G2 R3 Y4 </span></span><br><span class="line">    <span class="type">int</span> n,q;    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">city</span><span class="params">(n)</span></span>;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="string">&#x27;B&#x27;</span>)  city[i]|=(<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&#x27;G&#x27;</span>) city[i]|=(<span class="number">1</span>&lt;&lt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="string">&#x27;R&#x27;</span>) city[i]|=(<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span>    city[i]|=(<span class="number">1</span>&lt;&lt;<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(n,<span class="number">0</span>)</span></span>;     <span class="comment">//维护第i个城市的最左边可以直接到达的拥有不同颜色的城市</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(n,<span class="number">0</span>)</span></span>;    <span class="comment">//维护第i个城市的最右边可以直接到达的拥有不同颜色的城市</span></span><br><span class="line">    right[n<span class="number">-1</span>]=n;   <span class="comment">//后面有妙用</span></span><br><span class="line">    left[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(city[i]==city[i+<span class="number">1</span>] || (city[i] &amp; city[i+<span class="number">1</span>])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right[i]=right[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    right[i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(city[i]==city[i<span class="number">-1</span>] || (city[i] &amp; city[i<span class="number">-1</span>])==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left[i]=left[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    left[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x-=<span class="number">1</span>,y-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==y)    cout&lt;&lt;<span class="string">&quot;0\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;y) <span class="built_in">swap</span>(x,y);</span><br><span class="line">            <span class="type">int</span> ans1=<span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> tmp=x;</span><br><span class="line">            <span class="keyword">while</span>(x&lt;n &amp;&amp; (city[x] &amp; city[y])==<span class="number">0</span>)    <span class="comment">//通过中间点跳跃</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans1+=right[x]-x;</span><br><span class="line">                x=right[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;n) ans1+=<span class="built_in">abs</span>(x-y); <span class="comment">//可以直接跳</span></span><br><span class="line">            <span class="keyword">else</span>    ans1=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);   <span class="comment">//发现跳到n，说明无法到达</span></span><br><span class="line">            x=tmp;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ans2=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(y&gt;=<span class="number">0</span> &amp;&amp; (city[x] &amp; city[y])==<span class="number">0</span>)   <span class="comment">//通过中间点跳跃</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans2+=y-left[y];</span><br><span class="line">                y=left[y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;=<span class="number">0</span>)    ans2+=<span class="built_in">abs</span>(x-y); <span class="comment">//同上</span></span><br><span class="line">            <span class="keyword">else</span>    ans2=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>);</span><br><span class="line">            <span class="type">int</span> ans=<span class="built_in">min</span>(ans1,ans2); <span class="comment">//选取min即可</span></span><br><span class="line">            <span class="keyword">if</span>(ans&gt;=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>))    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF965</title>
      <link href="/posts/931b592c.html"/>
      <url>/posts/931b592c.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF965"><a href="https://codeforces.com/contest/1998/problem/A">CF965</a></h1><h2 id="A">A</h2><p>直接按照1，2，3这样下去一直构造即可。</p><p>需要考虑可能重叠的情况，所以需要特判修改一下$x_k,y_k$。</p><p>（这个地方一开是写错了，被罚惨了）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xc,yc,k; cin&gt;&gt;xc&gt;&gt;yc&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> sx=xc*k,sy=yc*k;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vx</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vy</span><span class="params">(k+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> sumx=<span class="number">0</span>,sumy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;xc&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;yc&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i==k)    vx[i]=sx-sumx,vy[i]=sy-sumy;</span><br><span class="line">        <span class="keyword">else</span>    vx[i]=i,sumx+=i,vy[i]=i,sumy+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(vx[k]==vy[k] &amp;&amp; vx[k]&lt;k &amp;&amp; vx[k]&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vx[<span class="number">1</span>]-=vx[k],vx[k]*=<span class="number">2</span>;</span><br><span class="line">        vy[<span class="number">1</span>]-=vy[k],vy[k]*=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;vx[i]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;vy[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>不难想到：对每一个数加1，然后最大的减去$n-1$即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: v) cin&gt;&gt;t,maxn=<span class="built_in">max</span>(maxn,t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t==maxn) cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>    cout&lt;&lt;t+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>可以发现，如果对中位数$midian(c_i)$进行修改，那么效果肯定是不如对$a_i$进行修改的。（因为修改$median(c_i)$的效率是<strong>小于等于</strong>1）。所以我们可以分类讨论一下：</p><ul><li>如果$a_i$可以修改，那么我们直接把全部的修改次数用到$a_i$上</li><li>否则，对$median(c_i)$进行修改，尽可能使得其更大。</li></ul><p>第一种情况：枚举每一个可以修改的$a_i$，并且进行计算，选取最大值。</p><p>第二种情况：要找一个中位数（或者百分位数），常用的一个技巧是用二分，</p><p>我们二分要找的中位数数的值，那么在整个数列中，肯定有一半及以上的数字是超过中位数，我们可以计算满足的个数，然后来判断我们目前二分的这个值是否合法。</p><p>$check$函数：可以先记录大于等于$x$的个数（记作$cnt$），然后再寻找那些可以修改的，并且小于$x$的数，计算需要的贡献$need$，如果中间$need&gt;k$，那么$x$不合法，直接退出。否则最后判断$cnt$是否大于数组的一半大小。</p><p>还需要考虑的一点就是：$a_i$的位置，会对$median(c_i)$的位置产生影响。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    ll k;   cin&gt;&gt;k;</span><br><span class="line">    std::vector&lt;pair&lt;ll,<span class="type">bool</span>&gt;&gt; <span class="built_in">a</span>(n,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: a) cin&gt;&gt;t.first;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: a) cin&gt;&gt;t.second;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),[&amp;](pair&lt;ll,<span class="type">bool</span>&gt; a, pair&lt;ll,<span class="type">bool</span>&gt; b)&#123;   <span class="keyword">return</span> a.first&lt;b.first; &#125;);</span><br><span class="line">    <span class="comment">//情况1 直接选取可以修改的a</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;n/<span class="number">2</span>)   ans=<span class="built_in">max</span>(ans,k+a[i].first+a[n/<span class="number">2</span>].first);</span><br><span class="line">            <span class="keyword">else</span>    ans=<span class="built_in">max</span>(ans,k+a[i].first+a[n/<span class="number">2</span><span class="number">-1</span>].first);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//情况2 a不可以修改，二分查找中位数</span></span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](ll x,<span class="type">int</span> p)-&gt;<span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].first&gt;=x)    cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ll need=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span> &amp;&amp; cnt&lt;n-p;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].second &amp;&amp; a[i].first&lt;x)</span><br><span class="line">            &#123;</span><br><span class="line">                need+=x-a[i].first;</span><br><span class="line">                <span class="keyword">if</span>(need&gt;k)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                cnt++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用n-p算比较方便</span></span><br><span class="line">        <span class="comment">//如果 n=5 那么cnt应该大于或等于3 对应就是5-5/2</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=n-p;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> findMid=[=](<span class="type">int</span> pos)-&gt;ll</span><br><span class="line">    &#123;</span><br><span class="line">        ll l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,pos))  l=mid;</span><br><span class="line">            <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ll maxMid_1=<span class="built_in">findMid</span>(n/<span class="number">2</span>);</span><br><span class="line">    ll maxMid_2=<span class="built_in">findMid</span>(n/<span class="number">2</span><span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i].second==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//更上面的i&lt;n/2原理一样 但是由于数组处理过，所以得这样写</span></span><br><span class="line">            <span class="keyword">if</span>(a[i].first&lt;maxMid_1) ans=<span class="built_in">max</span>(ans,a[i].first+maxMid_1);</span><br><span class="line">            <span class="keyword">if</span>(a[i].first&gt;=maxMid_2)    ans=<span class="built_in">max</span>(ans,a[i].first+maxMid_2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>可以从考虑Elsie什么时候能赢入手。</p><p>可以发现：如果Elise能赢，那么他一定是在某一次跳跃（也就是alternative bridges）后，跳到了Bessie的前面。这样他才有可能赢。</p><p>考虑详细一点：如果Elise能走到这一步，前提是什么？</p><ul><li>Elise前面走过的岛屿，Bessie都没走过（每一轮Bessie先走），不然岛屿就会坍塌，Elise直接失败。所以Bessie肯定只能在Elise的jump起点之后的岛屿出发。</li><li>在Elise到达jump的终点后，从起点出发的这段时间$t$，Bessie肯定是不能到达jump的终点（记作$y$）的，所以可以确定Bessie只能在$y-t$之前的岛屿开始出发。</li><li>由上面，我们可以确定Bessie可以出发的一个区间。我们可以利用差分来标记这个区间，最后再统计答案。</li><li>求$t$可以用$dp$，我们只需要$dp$到达最后jump的起点的最短时间即可，这个很简单，新手都会的。</li></ul><p>比较麻烦的一点是：因为数据是多组，所以如果开全局变量，每次clear会超时。所以只能开局部变量。</p><p>并且需要特判$m=0$的情况，不然会卡死。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//思路 枚举jump+差分 维护答案</span></span><br><span class="line">    std::vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; <span class="built_in">vec</span>(m,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(m)</span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">edge</span>(n+<span class="number">1</span>);        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u,v;    cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            vec[i].first=u,vec[i].second=v;</span><br><span class="line">            edge[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> t: edge[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=<span class="built_in">min</span>(dp[i],dp[t]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">d</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=t.first;</span><br><span class="line">        <span class="type">int</span> y=t.second;</span><br><span class="line">        <span class="type">int</span> need=dp[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end=y-need;</span><br><span class="line">        <span class="type">int</span> begin=x+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(begin&lt;=end)</span><br><span class="line">        &#123;</span><br><span class="line">            d[begin]+=<span class="number">1</span>;</span><br><span class="line">            d[end+<span class="number">1</span>]-=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt+=d[i];</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;<span class="number">0</span>)   cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>    cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF963</title>
      <link href="/posts/7a78fc19.html"/>
      <url>/posts/7a78fc19.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF963"><a href="https://codeforces.com/contest/1993">CF963</a></h1><h2 id="A">A</h2><p>直接统计计算即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    string s;   cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    a=b=c=d=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)a++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>)b++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;C&#x27;</span>)c++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;D&#x27;</span>)d++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="built_in">min</span>(a,n)+<span class="built_in">min</span>(b,n)+<span class="built_in">min</span>(c,n)+<span class="built_in">min</span>(d,n);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>不难发现，最后所有的数肯定都是奇数（如果是偶数，那么一定会留下一个数是奇数）。所以最基础的情况就是将所有的偶数变为奇数。</p><p>但是需要考虑，如果当前最大的奇数比当前要处理的偶数小，那么得进行额外的一次处理，可以在这个模拟的过程中动态更新最大的奇数。一开始写的很赘余，这是比赛后修改过的。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">bool</span> ok=<span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> odd=<span class="number">0</span>,even=<span class="number">0</span>;</span><br><span class="line">    ll odd_maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">        <span class="keyword">if</span>(v[i]&amp;<span class="number">1</span>)  odd++,odd_maxn=<span class="built_in">max</span>(odd_maxn,v[i]);</span><br><span class="line">        <span class="keyword">else</span>    even++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(odd &amp;&amp; even) ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(ok)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=even;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i]&amp;<span class="number">1</span>)  <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(odd_maxn&lt;v[i])</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            odd_maxn=<span class="built_in">max</span>(odd_maxn,odd_maxn+v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>要求最早的所有灯都亮的时刻。不难想到要从最后一个开始亮的灯往后找。</p><p>可以发现循环的周期$T=2k$，所以我们可以将所有的灯进行整数个周期的时间移动，保证在最后亮的灯的时间附近（尽可能地靠近，可能需要特殊的处理），这样可以尽可能让所有灯在一个时间点附近亮。</p><p>我们再将所有的时间排个序，只要最大的和最小的时间差不超过$k$即可。输出最大的时刻。否则输出$-1$（因为是所有灯都集中亮最近的时刻了）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    ll maxn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)    cin&gt;&gt;v[i],  maxn=<span class="built_in">max</span>(maxn,v[i]);</span><br><span class="line">    ll t=<span class="number">2</span>*k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]+=(maxn-v[i])/t*t;</span><br><span class="line">        <span class="keyword">if</span>(maxn-v[i]&gt;=k)    v[i]+=t;<span class="comment">//特殊处理：如果时间差&gt;k 再移动一个T</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">bool</span> ok=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(v[n<span class="number">-1</span>]-v[<span class="number">0</span>]+<span class="number">1</span>&lt;=k)  ok=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(ok)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;v[n<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>分析数据范围，只能使用$O(n)$或者$O(nlogn)$的方法。考虑如何在一个数组中找到他的中位数$x$，我们采取二分的方法。二分查找这个中位数。可以发现，到时候大于或者等于中位数的个数应该是$\frac{k+1}{2}$。我们可以进行预处理：大于$x$的数，记录其贡献为$1$，其余为$-1$，我们只需要选择其中的最多$k$个数作为一个子数组，其中大于$x$的个数大于$\frac{k+1}{2}$即可。这个可以用$dp$进行处理。（对应的贡献和就是大于0）</p><p>我们使用$dp_i$表示：到第$i+1$个数时，可以获得的贡献，具体的状态转移看代码。</p><p>比较折磨的一点就是原来的二分又出错了，使用jiangly大佬的写法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,k;    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">std::vector&lt;ll&gt; <span class="title">v</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: v) cin&gt;&gt;t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check=[&amp;](ll x)-&gt;<span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::vector&lt;ll&gt; <span class="built_in">f</span>(n,<span class="number">0</span>);</span><br><span class="line">        <span class="function">std::vector&lt;ll&gt; <span class="title">dp</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i]&gt;=x)    f[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    f[i]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>]=f[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%k==<span class="number">0</span>)  dp[i]=f[i];</span><br><span class="line">            <span class="keyword">else</span> dp[i]=dp[i<span class="number">-1</span>]+f[i];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k)    dp[i]=<span class="built_in">max</span>(dp[i],dp[i-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>]&gt;<span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        ll mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))  l=mid;</span><br><span class="line">        <span class="keyword">else</span>    r=mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)  <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF961</title>
      <link href="/posts/94769d35.html"/>
      <url>/posts/94769d35.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF961"><a href="https://codeforces.com/contest/1995">CF961</a></h1><h2 id="A">A</h2><p>先往从左下角到右上角的对角线进行填充，再不断地从两边填充。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*n+<span class="number">1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">2</span>*n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">k-=n;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k-=(i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B1">B1</h2><p>直接进行统计模拟，需要注意的是：可能存在可以补充的情况。</p><p>如果先全取$x$，再部分取$x+1$，在总和小于$m$的情况下，可以少取$x$，多取$x+1$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        mp[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]: mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ll cnt_1=<span class="built_in">min</span>(y,m/x);<span class="comment">//尽可能多去x</span></span><br><span class="line">        ll tot=cnt_1*x;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ll num=mp[x+<span class="number">1</span>];</span><br><span class="line">            ll cnt_2=<span class="built_in">min</span>(num,(m-tot)/(x+<span class="number">1</span>));<span class="comment">//尽可能多取x+1</span></span><br><span class="line">            tot+=cnt_2*(x+<span class="number">1</span>);</span><br><span class="line">            num-=cnt_2;<span class="comment">//计算剩余的x+1</span></span><br><span class="line">            ll add=<span class="built_in">min</span>(num,cnt_1);<span class="comment">//可能把x全替换，也可能只能替换一部分，最多就是剩余的x+1的数量</span></span><br><span class="line">            tot=<span class="built_in">min</span>(tot+add,m);<span class="comment">//需要小于m</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,tot);<span class="comment">//更新最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B2">B2</h2><p>思路跟上面一样。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m;    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    map&lt;ll,ll&gt; mp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  cin&gt;&gt;x;</span><br><span class="line">        mp[a[i]]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x,y]: mp)</span><br><span class="line">    &#123;</span><br><span class="line">        ll cnt_1=<span class="built_in">min</span>(y,m/x);</span><br><span class="line">        ll tot=cnt_1*x;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(x+<span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            ll num=mp[x+<span class="number">1</span>];</span><br><span class="line">            ll cnt_2=<span class="built_in">min</span>(num,(m-tot)/(x+<span class="number">1</span>));</span><br><span class="line">            tot+=cnt_2*(x+<span class="number">1</span>);</span><br><span class="line">            num-=cnt_2;</span><br><span class="line">            ll add=<span class="built_in">min</span>(num,cnt_1);</span><br><span class="line">            tot=<span class="built_in">min</span>(tot+add,m);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,tot);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>这题如果直接暴力模拟肯定会溢出，所以不行。</p><p>如果多写几个$a_{i-1}$，$a_i$可以发现：如果两者都进行$k$次平方，让$a_i&gt;a_{i-1}$的次数和原来是一样的。</p><p>使用$b_i$表示$a_i$需要的操作次数。</p><p>如果$a_i&lt;a_{i-1}$，模拟计算需要的次数$cnt$，并且$b_i=b_{i-1}+cnt$。</p><p>否则，对$a_{i-1}$进行计算（对$a_i$进行开方的操作次数$cnt$），$b_i=max(0,b_{i-1}-cnt)$。（这么搞是可以模拟计算出$a_i$需要的操作次数，如果$cnt&gt;b_{i-1}$，说明原来就比他大，根本不需要进行操作）。</p><p>麻烦的是一些细节，不好调。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">        a*=a;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">b</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span> &amp;&amp; a[i<span class="number">-1</span>]&gt;a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">                ll t1=a[i<span class="number">-1</span>],t2=a[i];</span><br><span class="line">                <span class="keyword">while</span>(t1&gt;t2)</span><br><span class="line">                &#123;   </span><br><span class="line">                    t2*=t2;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">                b[i]=b[i<span class="number">-1</span>]+cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">                ll t1=a[i<span class="number">-1</span>],t2=a[i];</span><br><span class="line">                <span class="keyword">if</span>(t1==<span class="number">1</span>)   cnt=<span class="number">0</span>;   </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>(t1&lt;=t2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        t1*=t1;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                b[i]=<span class="built_in">max</span>(<span class="number">0ll</span>,b[i<span class="number">-1</span>]-cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;t: b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;t&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        ans+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF960</title>
      <link href="/posts/e371ada3.html"/>
      <url>/posts/e371ada3.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF960"><a href="https://codeforces.com/contest/1990">CF960</a></h1><h2 id="A">A</h2><p>记录每个数出现的次数$a$，如果存在$a$为奇数，那么输出YES。否则最后输出NO。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mp[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(mp,<span class="number">0</span>,<span class="built_in">sizeof</span>(mp));</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">mp[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[a[i]]%<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>不难想到在$x$的右边所有数的总和小于0，而在$y$的左边所有数的总和小于0，所以先初始化为1，然后在$x+1，x+3······$这样交替进行构造。$y-1,y-3$也是如此。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,x,y;cin&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=y<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j-=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[j]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>对原序列求一次MAD操作得到数组$b$，不难发现：$b$数组是一个单调递增的数组，每次操作后是对$b$进行向右平移操作，前面用0补充。需要注意的是：</p><p>如果同一个数字在$b$中出现多次，那么做一次MAD运算后是右移。</p><p>如果是出现一次的话，就用前面的进行填充即可，再计算上贡献。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll mp[MAXN];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">ll maxn=<span class="number">0</span>;</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp[i]=b[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line">ll tmp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">sum+=a[i];</span><br><span class="line"><span class="keyword">if</span>(mp[a[i]])</span><br><span class="line">&#123;</span><br><span class="line">b[i]=<span class="built_in">max</span>(a[i],maxn);</span><br><span class="line">maxn=<span class="built_in">max</span>(b[i],maxn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mp[a[i]]++;</span><br><span class="line">b[i]=b[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">m[b[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m[b[i]]&gt;=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum+=b[i]*(n-i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum+=b[i]+b[i<span class="number">-1</span>]*(n-i);</span><br><span class="line">b[i]=b[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外的方法：实际上模拟两次即可（模拟完两次后，出现一次的元素就消失了，直接计算出现多次的情况即可）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jiangly</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> u32 = <span class="type">unsigned</span>;</span><br><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> u64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i64 ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; <span class="number">2</span>; t++) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : a) &#123;</span><br><span class="line">            ans += x;</span><br><span class="line">            <span class="keyword">if</span> (vis[x]) &#123;</span><br><span class="line">                mx = std::<span class="built_in">max</span>(mx, x);</span><br><span class="line">            &#125;</span><br><span class="line">            vis[x] = <span class="number">1</span>;</span><br><span class="line">            x = mx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += <span class="number">1LL</span> * (n - i) * a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D">D</h2><p>后来补的题目：应该是按照题目进行模拟吧。</p><p>关键是样例二，可以用方块进行跨行填补。代码细节比较多，不太好调。</p><p>最后需要留意的是用$a[n]$特判一下。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&gt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i+<span class="number">1</span>]&lt;=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">a[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//对应样例二</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i+<span class="number">1</span>]&lt;=<span class="number">4</span> &amp;&amp; a[i+<span class="number">2</span>]&gt;<span class="number">2</span> &amp;&amp; i+<span class="number">2</span>&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="number">2</span>;</span><br><span class="line">a[i+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">a[i+<span class="number">2</span>]-=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[n])ans++;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF958</title>
      <link href="/posts/c6877652.html"/>
      <url>/posts/c6877652.html</url>
      
        <content type="html"><![CDATA[<h1 id="CF958"><a href="https://codeforces.com/contest/1988">CF958</a></h1><p>爆0的一场，寄寄寄。</p><h2 id="A">A</h2><p>$n$一开始肯定分成$k$份，每一份最多增加$k-1$。模拟计算即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> sum=k;</span><br><span class="line"><span class="keyword">while</span>(sum&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">sum+=(k<span class="number">-1</span>);</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B">B</h2><p>考虑少了一种情况：11在串中出现两次也是合法。</p><p>方法一：分类讨论直接写。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s==<span class="string">&quot;1&quot;</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[n<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_1=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>] &amp;&amp; s[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt_1++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt_1&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">maxn=<span class="built_in">max</span>(cnt_1,maxn);</span><br><span class="line">cnt_1=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxn&gt;<span class="number">2</span> || cnt&gt;<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; s[n<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; s[n<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i+<span class="number">1</span>]==s[i] &amp;&amp; s[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; s[n<span class="number">-1</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i+<span class="number">1</span>]==s[i] &amp;&amp; s[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法二：可以想到应该尽可能地少让1和0进行操作，应该尽量让全0串化为一个0。那么最终结果就会使一个由孤立0和1（连续或者不连续）组成的串。如果0的个数小于1则有解，否则无解。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> one=<span class="built_in">count</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="type">int</span> zero=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">&#123;<span class="comment">//用连续0串的开头进行记录zero</span></span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; (i==<span class="number">0</span> || s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">zero++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(zero&lt;one)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C">C</h2><p>观察样例发现都是以$n$结尾的，我们以样例四进行研究。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>要使得单增，并且最长，且$a_{i}|a_{i-1}=n (2\leq i \leq k)$，我们进行倒推，那么第二大应该越大越好，同理推导下去。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>: <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现推导的结果如上。可以发现：从小到大，0一直在右移。我们可以统计$n$的组成，并且模拟这个过程，逐个进行计算输出。不过需要注意一些情况需要特判。</p><p>如果原来的数只有一个1（二进制），那么直接输出即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//  1 1 1 0</span></span><br><span class="line">    <span class="comment">//  1 1 0 0</span></span><br><span class="line">    <span class="comment">//  1 0 1 0</span></span><br><span class="line">    <span class="comment">//  0 1 1 0</span></span><br><span class="line">    vector&lt;ll&gt; a;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    ll m=n;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;a.size()&lt;&lt;&quot;a size:&quot;;</span></span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;m&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a.<span class="built_in">size</span>()+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cnt=a.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;a.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                ans+=(<span class="number">1ll</span>&lt;&lt;a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另外一种写法：</p><p>可以发现我们可以使用位运算进行操作，只需要获取是哪个位置的1，并且进行异或运算即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;(-x)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> one=__builtin_popcountll(n);</span><br><span class="line">    <span class="keyword">if</span>(one==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;one+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((n&gt;&gt;i) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;(n^(<span class="number">1ll</span>&lt;&lt;i))&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFB</title>
      <link href="/posts/b36c22b4.html"/>
      <url>/posts/b36c22b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="CFB">CFB</h1><h2 id="CF1882B"><a href="https://codeforces.com/contest/1882/problem/B?csrf_token=c35be50e0cb5bb19ffe9845a3d3414e8">CF1882B</a></h2><h3 id="思路">思路</h3><p>要想找出一个合法的子集，必须至少有一个元素漏选，可以通过枚举漏选的元素$q$，找到最大的符合题目要求的并集。我们可以先预处理出所有集合的并集，然后枚举$q$，如果当前集合包含$q$，那么舍去这个集合，否则就并入，这样遍历处理$q$，取最大值即可。</p><p>这里需要注意的几点：</p><ul><li>由于是多组数据，所以需要清空数组<code>a</code>和<code>s</code>。</li><li>因为集合的元素是不可重复的，所以在计算时需要考虑元素重复的情况，我们可以用一个桶来记录，当然每次处理完后也需要清空桶。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> flag[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;cin&gt;&gt;num;</span><br><span class="line">s[i][num]=<span class="number">1</span>;</span><br><span class="line">a[num]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!a[i])<span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="built_in">sizeof</span>(flag));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j][i])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">50</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!flag[k] &amp;&amp; s[j][k])</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">flag[k]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,cnt);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1879B"><a href="https://codeforces.com/contest/1879/problem/B">CF1879B</a></h2><h3 id="思路-2">思路</h3><p>我对这道题的大致理解是：一个块$(i,j)$放置一个土豆，说明填充了第$i$行，第$j$列。</p><p>我们需要的是填充满每一个块。我们可以一行一行地填充，或者一列一列地填充。以行为例，我们只需要选出所有列的最小值，然后加上行和即可。列填充也是类似的处理方法。最后只需要从这两种处理结果取最小值即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll sa[MAXN];</span><br><span class="line">ll sb[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">ll min_a=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">min_a=<span class="built_in">min</span>(a[i],min_a);</span><br><span class="line">&#125;</span><br><span class="line">ll min_b=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;b[j];</span><br><span class="line">min_b=<span class="built_in">min</span>(b[j],min_b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sa[++cnt1]=min_a+b[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans1=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt1;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans1+=sa[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sb[++cnt2]=min_b+a[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans2=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt2;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans2+=sb[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(ans1,ans2)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1867B"><a href="https://codeforces.com/contest/1867/problem/B">CF1867B</a></h2><h3 id="思路-3">思路</h3><p>题意有点抽象，结合例子，讲人话就是，我们对串$s$进行修改，使得其成为回文串，然后使用另外一个串$l$（长度为$n+1$），来表示修改了多少位，使得$s$可以成为回文串，举个例子，如果可以修改两位使得其成为回文串，那么$l_2=1$。</p><p>以上是题意，下面说一下思路。</p><p>我们可以使用双指针从两端开始扫描，可以发现，如果相同，改或不改都行。如果不同，那么必须进行一次修改。分别对必须的修改和不必须的修改进行记录。再用一个数组记录即可。这里还需要注意的是，如果长度是奇数，那么另外多进行一次修改。</p><p>细节:</p><ul><li>不要使用<code>memset</code>，否则会超时。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line">s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line"><span class="type">int</span> cnt_base=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_add=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cnt_equil=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=n;i&lt;=j;++i,--j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line">&#123;</span><br><span class="line">cnt_equil=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]!=s[j])++cnt_base;</span><br><span class="line"><span class="keyword">else</span>cnt_add+=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[cnt_base]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!cnt_equil)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt_add;i++)</span><br><span class="line">&#123;</span><br><span class="line">cnt_base+=<span class="number">2</span>;</span><br><span class="line">ans[cnt_base]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt_add*<span class="number">2</span>+<span class="number">1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[cnt_base+i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i];</span><br><span class="line">ans[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1869B"><a href="https://codeforces.com/contest/1869/problem/B">CF1869B</a></h2><h3 id="思路-4">思路</h3><p>如果可以绕主要城市，那么肯定消耗的钱是更少的（不然要走多余的城市，花更多的钱），我们可以多走主要城市。主要有两种走法：</p><ul><li>直接从起点到终点</li><li>绕过主要城市</li></ul><p>我们可以计算这两种情况的距离，起点到终点的距离直接计算即可。</p><p>绕过主要城市，那么肯定是越近越好，需要考虑起点或者终点本身就是主要城市的情况，这样就直接为0。我们分别处理起点到主要城市的距离、终点到主要城市的距离即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">ll x[MAXN],y[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(x[a]-x[b])+<span class="built_in">abs</span>(y[a]-y[b]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="type">int</span> st,ed;cin&gt;&gt;st&gt;&gt;ed;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">&#125;</span><br><span class="line">ll a_len=<span class="number">1e15</span>,b_len=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">if</span>(st&gt;k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">a_len=<span class="built_in">min</span>(a_len,<span class="built_in">dis</span>(i,st));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>a_len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ed&gt;k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">b_len=<span class="built_in">min</span>(b_len,<span class="built_in">dis</span>(i,ed));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>b_len=<span class="number">0</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(a_len+b_len,<span class="built_in">dis</span>(st,ed))&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1861B"><a href="https://codeforces.com/contest/1861/problem/B">CF1861B</a></h2><h3 id="思路-5">思路</h3><p>可以发现是以0开头，以1结尾的，我们可以这样构造：两个式子的左边都是0，右边都是1。这样的构造就符合题意。（没有注意到开头和结尾，直接写$dp$写不出来）。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> flag[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="type">int</span> n=a.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; b[i]==<span class="string">&#x27;0&#x27;</span> &amp;&amp; a[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; b[i+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1860B"><a href="https://codeforces.com/contest/1860/problem/B">CF1860B</a></h2><h3 id="思路-6">思路</h3><p>贪心的想法：肯定是多用$k$值的硬币更好。可以先计算出需要的$k$值硬币和$1$元硬币，如果拥有的1元硬币比需要的多，我们可以使用多余的来凑出$k$值硬币，这样可以消耗的更少。最后计算需要的值和拥有的数量之差即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m,k,a1,ak;cin&gt;&gt;m&gt;&gt;k&gt;&gt;a1&gt;&gt;ak;</span><br><span class="line"><span class="type">int</span> num_1=m%k;</span><br><span class="line"><span class="type">int</span> num_k=m/k;</span><br><span class="line"><span class="keyword">if</span>(a1&gt;num_1)</span><br><span class="line">&#123;</span><br><span class="line">ak+=(a1-num_1)/k;</span><br><span class="line">a1=num_1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ak&gt;num_k)ak=num_k;</span><br><span class="line">cout&lt;&lt;num_1-a1+num_k-ak&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1859B"><a href="https://codeforces.com/contest/1859/problem/B">CF1859B</a></h2><h2 id="思路-7">思路</h2><p>不难想到，我们可以先选去每个数组中最小的元素进行去除，影响结果的只有最小值和次小值。但是还得将这些选出的最小元素塞入到其他的数组中，最好的塞法就是塞到同一个数组中，（塞入到多个数组中，肯定会使得美丽值更小），并且该数组的最小值也会被更新，我们尽量让美丽值减少的少一些即可。也就是该数组原来的次小值和最小值的差最小。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">ll min_1=<span class="number">1e15</span>,min_2=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line">ans+=a[<span class="number">2</span>];</span><br><span class="line">min_1=<span class="built_in">min</span>(min_1,a[<span class="number">1</span>]);</span><br><span class="line">min_2=<span class="built_in">min</span>(min_2,a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans-min_2+min_1&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1856B"><a href="https://codeforces.com/contest/1856/problem/B">CF1856B</a></h2><h3 id="思路-8">思路</h3><p>我们可以将$a$数组全部元素减去1，再考虑将减去后为0的元素进行填补为2。进行这样的操作构造，需要注意：</p><ul><li>这里需要填充的是所有值为1的元素，进行这样操作所需要的数值就是对应的个数。</li><li>能够提供的就是所有元素的总和减去n。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ll maxn=<span class="number">0</span>;</span><br><span class="line">ll cnt_0=<span class="number">0</span>;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">a[i]-=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!a[i])</span><br><span class="line">&#123;</span><br><span class="line">cnt_0++;</span><br><span class="line">&#125;</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt_0&gt;sum)cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1855B"><a href="https://codeforces.com/contest/1855/problem/B">CF1855B</a></h2><h3 id="思路-9">思路</h3><p>区间中的每一个数都是$n$的因数，假设存在一个数$x$不是$n$的因数，那么$x$的倍数也不是$n$的因数，那么对应区间的长度的最大值也只能是$x-1$。</p><p>我们可以从1开始计算，直到找到第一个不是$n$的因数的数字即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%i)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1849B"><a href="https://codeforces.com/contest/1849/problem/B">CF1849B</a></h2><h3 id="思路-10">思路</h3><p>问题的关键是：只有最后一刀才是有效的，前面只是削弱怪物的血量。我们先进行取模运算，为0的肯定是最先被杀死的，剩下的怪物按照血量从大到小排序，即可得到全部的顺序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;;</span><br><span class="line">ll ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">ll val;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.val==b.val)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a.val&gt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i].val;</span><br><span class="line">a[i].val%=k;</span><br><span class="line">a[i].id=i;</span><br><span class="line"><span class="keyword">if</span>(!a[i].val)</span><br><span class="line">&#123;</span><br><span class="line">ans[++cnt]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].val==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans[++cnt]=a[i].id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1853B"><a href="https://codeforces.com/contest/1853/problem/B">CF1853B</a></h2><h3 id="思路-11">思路</h3><p>我们尝试找一下规律:<br>$$<br>a_3=a_2+a_1<br>$$</p><p>$$<br>a_4=a_3+a_2=2a_2+a_1<br>$$</p><p>而$a_5=a_4+a_3$，分别计算$a_1$和$a_2$的系数，这里其实也是利用斐波那契数列的递推关系。我们可以得到$a_n$是由多少个$a_1$和$a_2$组成的。我们再枚举$a_1$可能的值，从而推导出$a_2$可能的值即可。需要注意的是：</p><ul><li>$k$的范围太大，而$n$最大是2e5，所以当$30 \leq k$时，无解，直接输出0即可。不然直接处理会TLE。</li><li>$a_1 \leq a_2$这个是一个潜在的条件。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a1[MAXN],a2[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k&gt;=<span class="number">30</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">a1[<span class="number">3</span>]=<span class="number">1</span>,a2[<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">a1[<span class="number">4</span>]=<span class="number">2</span>,a2[<span class="number">4</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">5</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">a1[i]=a1[i<span class="number">-1</span>]+a1[i<span class="number">-2</span>];</span><br><span class="line">a2[i]=a2[i<span class="number">-1</span>]+a2[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num=n-a2[k]*i;</span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">0</span> &amp;&amp; num%a1[k]==<span class="number">0</span> &amp;&amp; num/a1[k]&gt;=i)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1848B"><a href="https://codeforces.com/contest/1848/problem/B">CF1848B</a></h2><h3 id="思路-12">思路</h3><p>一个大致的思路是：我们对每一种颜色单独处理。我们只能修改一块的颜色，使得需要跨越的距离变小。不难想到对最大值$p$进行处理（进行折半），得到$\lfloor \frac{p}{2} \rfloor$，然后再与次小值$q$进行比较，取两者的最大值，最后遍历所有的颜色取最小值即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll c[MAXN];</span><br><span class="line">ll nxt[MAXN];</span><br><span class="line">ll head[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">ll ans=<span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">head[i]=nxt[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;c[i];</span><br><span class="line">nxt[i]=head[c[i]];</span><br><span class="line">head[c[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">1</span>;p&lt;=k;p++)</span><br><span class="line">&#123;</span><br><span class="line">ll max_1=n-head[p],max_2=<span class="number">0</span>;</span><br><span class="line">ll num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[p];i;i=nxt[i])</span><br><span class="line">&#123;</span><br><span class="line">num=i-nxt[i]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(num&gt;max_1)</span><br><span class="line">&#123;</span><br><span class="line">max_2=max_1;</span><br><span class="line">max_1=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num&gt;max_2)</span><br><span class="line">&#123;</span><br><span class="line">max_2=num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">max</span>(max_1&gt;&gt;<span class="number">1</span>,max_2));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1847B"><a href="https://codeforces.com/contest/1847/problem/B">CF1847B</a></h2><p>思路对了，但是写挂了。</p><p>后面再补一下。</p><h3 id="思路-13">思路</h3><p>与运算的结果只会越来越小，我们可以尽量进行与运算，使得结果为0，这样就可以砍一刀，得到一个分组。需要注意的是：</p><ul><li>如果全部与运算后不为0（这是最小的结果），那么只能直接划分为1组。</li><li>如果中间部分存在结果为0，我们就砍一刀。如果最后的部分不为0，我们直接并入前面的即可。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll sum=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">sum=sum&amp;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum&amp;=a[i];</span><br><span class="line">&#125;</span><br><span class="line">sum=sum&amp;a[i];</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum=<span class="number">-1</span>;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1845B"><a href="https://codeforces.com/contest/1845/problem/B">CF1845B</a></h2><h3 id="思路-14">思路</h3><p>分成$x$和$y$分别计算，注意到$x_a(y_a)$只能是最小或者最大的情况。再与$x_b(y_b)、x_c(y_c)$中的最近点计算即可。</p><p>需要注意的是：</p><ul><li>ans初始化为1。因为从同一个起点出发。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll x[<span class="number">4</span>],y[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x[<span class="number">1</span>]&lt;=x[<span class="number">2</span>] &amp;&amp; x[<span class="number">1</span>]&lt;=x[<span class="number">3</span>])</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">min</span>(x[<span class="number">2</span>],x[<span class="number">3</span>])-x[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x[<span class="number">1</span>]&gt;x[<span class="number">2</span>] &amp;&amp; x[<span class="number">1</span>]&gt;x[<span class="number">3</span>])</span><br><span class="line">&#123;</span><br><span class="line">ans+=x[<span class="number">1</span>]-<span class="built_in">max</span>(x[<span class="number">2</span>],x[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(y[<span class="number">1</span>]&lt;=y[<span class="number">2</span>] &amp;&amp; y[<span class="number">1</span>]&lt;=y[<span class="number">3</span>])</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">min</span>(y[<span class="number">2</span>],y[<span class="number">3</span>])-y[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(y[<span class="number">1</span>]&gt;y[<span class="number">2</span>] &amp;&amp; y[<span class="number">1</span>]&gt;y[<span class="number">3</span>])</span><br><span class="line">&#123;</span><br><span class="line">ans+=y[<span class="number">1</span>]-<span class="built_in">max</span>(y[<span class="number">2</span>],y[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1834B"><a href="https://codeforces.com/contest/1834/problem/B">CF1834B</a></h2><h3 id="思路-15">思路</h3><p>发现数据范围很大，所以想到拆位处理。看样例不难发现，当$r$和$l$存在从某一位开始不同时，也就是$r_x-l_x&gt;0$时，后面的位肯定可以构造成$|0-9|$或者$|9-0|$。所以我们逐位查找计算。如果相等就跳过，如果不等就计入ans，并且从此后开始构造出$|0-9|$或者$|9-0|$的形式。</p><p>需要注意的是：</p><ul><li>两者相等的情况：直接输出0即可。</li><li>位数不同，那么$l$需要添加前导0。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string l,r;cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l.<span class="built_in">length</span>()&lt;r.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line">string tmp=l;</span><br><span class="line">l=r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r.<span class="built_in">length</span>();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&lt;r.<span class="built_in">length</span>()-tmp.<span class="built_in">length</span>())l[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span>l[i]=tmp[i-r.<span class="built_in">length</span>()+tmp.<span class="built_in">length</span>()];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">ll n=l.<span class="built_in">length</span>();</span><br><span class="line">ll flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(l[i]==r[i])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans+=r[i]-l[i];</span><br><span class="line">flag=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans+=(n-flag<span class="number">-1</span>)*<span class="number">9</span>;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1841B"><a href="https://codeforces.com/contest/1841/problem/B">CF1841B</a></h2><p>细节还是写挂了。。。</p><h3 id="思路-16">思路</h3><p>我们按照题目的描述进行构造，分为四种情况</p><ul><li>$a_i$直接接入末尾，此时还是一个单增序列。$a_{i-1}\leq a_{i}$。</li><li>$a_i&lt;a_{i-1}$，但是比$a_1$大，所以可以接入末尾，这样将前面的单增部分往后补充即可。需要使用一个$flag$作为记号。</li><li>$flag$存在，且$a_i\leq a_1$，这样才可以继续往后补充。<strong>这个需要特别注意</strong>。</li><li>否则不能补充。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">cin&gt;&gt;a[<span class="number">1</span>];</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">ll flag=<span class="number">0</span>,last=a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;=last &amp;&amp; flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">last=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;=a[<span class="number">1</span>] &amp;&amp; flag==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">last=a[i];</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i]&lt;=a[<span class="number">1</span>] &amp;&amp; flag &amp;&amp; a[i]&gt;=last)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">last=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1838B"><a href="https://codeforces.com/contest/1838/problem/B">CF1838B</a></h2><h3 id="思路-17">思路</h3><p>不难想到让1和2这两个元素的距离越远越好，这样得到的排列数目是最少的。</p><p>但是如果只是简单地放在左右两边（1左2右），可能不是最好的效果，而且题目要求只能交换一次。</p><p>可以这样构造：只要最大数$n$位于1和2中间，这样如果要得到满足题意的排列，那么必须长度大于等于$n$，比这长度小的肯定会缺少一些关键的元素，无法构成排列。</p><p>所以构造时：1左2右，$n$中间。这是三者的相对顺序。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> pos_1=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pos_2=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pos_n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos_1=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos_2=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==n)</span><br><span class="line">&#123;</span><br><span class="line">pos_n=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos_1&gt;pos_2)<span class="built_in">swap</span>(pos_1,pos_2);</span><br><span class="line"><span class="keyword">if</span>(pos_1&gt;pos_n)cout&lt;&lt;pos_1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pos_n;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pos_2&lt;pos_n)cout&lt;&lt;pos_2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pos_n;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;pos_1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pos_1;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1831B"><a href="https://codeforces.com/contest/1831/problem/B">CF1831B</a></h2><p>思路对了，脑子一抽自己全推翻了。</p><h3 id="思路-18">思路</h3><p>不难想到从$a$和$b$两个数组中，各自寻找同一个元素的最长连续段。然后把他们拼接起来，然后枚举元素值，得到的就是最长的。</p><p>证明：我们以数字2为例子，其余元素不关心。</p><ul><li>------222222------</li><li>—222-------------</li></ul><p>我们只需要把前面的无关部分先取出，然后再拼接起来即可。</p><p>需要注意的细节：</p><ul><li>计算连续最长的段时，最后的一段需要特别处理，具体看代码。</li><li>不要使用memset，会TLE。</li><li>最后枚举元素时，需要分别枚举$a$和$b$中的元素，因为元素类型可能是不同的。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll a_length[MAXN];</span><br><span class="line">ll b_length[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">ll cnt_a=<span class="number">1</span>,cnt_b=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">&#123;</span><br><span class="line">a_length[i]=b_length[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_a++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a_length[a[i<span class="number">-1</span>]]=<span class="built_in">max</span>(cnt_a,a_length[a[i<span class="number">-1</span>]]);</span><br><span class="line">cnt_a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(b[i]==b[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt_b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b_length[b[i<span class="number">-1</span>]]=<span class="built_in">max</span>(cnt_b,b_length[b[i<span class="number">-1</span>]]);</span><br><span class="line">cnt_b=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意最后一段元素的长度,统计不到，需要特别处理</span></span><br><span class="line"><span class="comment">//可能原来已经存在，和现在cnt取max</span></span><br><span class="line">a_length[a[n]]=<span class="built_in">max</span>(a_length[a[n]],cnt_a);</span><br><span class="line">b_length[b[n]]=<span class="built_in">max</span>(b_length[b[n]],cnt_b);</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(&#123;ans,a_length[a[i]]+b_length[a[i]],a_length[b[i]]+b_length[b[i]]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1837B"><a href="https://codeforces.com/contest/1837/problem/B">CF1837B</a></h2><h3 id="思路-19">思路</h3><p>构造题，不难发现可以使用连续的整数进行构造：12345······，那么关键的就是找到一段最长连续&lt;(&gt;)的子段的长度，答案就是再此基础上+1。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line">ll cnt=<span class="number">1</span>;</span><br><span class="line">ll maxn=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,cnt);</span><br><span class="line">cnt=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,cnt);</span><br><span class="line">cout&lt;&lt;maxn+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1828B"><a href="https://codeforces.com/contest/1828/problem/B">CF1828B</a></h2><h3 id="思路-20">思路</h3><p>看一下样例，首先直觉猜测跟排序和当前的位置有关，我们先对其进行一次排序。计算得出如果交换位置的差值。猜测可能是取所有需要交换差值的最小公约数（可以打个表试一下）。</p><p>需要注意的是：</p><ul><li>差值可能为0，需要特判一下。</li><li>输入的时候$a_1$先处理一下，作为$ans$。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span>  <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">ll val;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i].val;</span><br><span class="line">a[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">ll ans=<span class="built_in">abs</span>(<span class="number">1</span>-a[<span class="number">1</span>].id);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=<span class="built_in">abs</span>(i-a[i].id);</span><br><span class="line"><span class="keyword">if</span>(b[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans=__gcd(ans,b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1832B"><a href="https://codeforces.com/contest/1832/problem/B">CF1832B</a></h2><p>以为是贪心，发现不对，写了个类似dp的东西，还是不对。。。</p><h3 id="思路-21">思路</h3><p>不难想到先进行排序，如果直接贪心处理（每一次一直从两端取最大的元素或者两个最小的元素），发现有一个不符合样例（样例5）。所以贪心的方法是错误的。</p><p>再发现，我们取完$k$次后是一段连续的区间。也就是去掉两头，那么我们可以枚举去掉的两头的元素，这里使用前缀和进行处理。得到的最后结果就是$sum_{n-k+i}-sum_{2*i}$。我们只需要枚举$i$，取最大值即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(ans,sum[n-k+i]-sum[<span class="number">2</span>*i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""></h2><h2 id="CF1825B"><a href="https://codeforces.com/contest/1825/problem/B">CF1825B</a></h2><h3 id="思路-22">思路</h3><p>构造题。</p><p>一开始我的想法是：左上角放最大的元素，然后对角线放最小的元素，另外的第一行和第一列（及位置(2,1)和(1,2)）特别处理，但是发现不对。</p><p>更合理的构造方法是：把最小的元素放在(2,1)，次小的元素放在(1,2)，这样得到的结果更大。不过也可能位置反过来，因为$n$和$m$的大小关系。我们的想法是尽可能大一些，所以如果$n&gt;m$就放在(2,1)，反之同理。</p><p>还需要注意的是：</p><ul><li>可以在左上角放最小值，(2,1)和(1,2)放最大值。</li><li>最终答案取max即可。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t;cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll b[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=n*m;</span><br><span class="line">ll ans_1=<span class="number">0</span>;</span><br><span class="line">ll ans_2=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+k);</span><br><span class="line"><span class="keyword">if</span>(n&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">ans_1=(n<span class="number">-1</span>)*m*(a[k]-a[<span class="number">1</span>])+(m<span class="number">-1</span>)*(a[k]-a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(n,m);</span><br><span class="line">ans_1=(n<span class="number">-1</span>)*m*(a[k]-a[<span class="number">1</span>])+(m<span class="number">-1</span>)*(a[k]-a[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+k,cmp);</span><br><span class="line"><span class="keyword">if</span>(n&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">ans_2=(n<span class="number">-1</span>)*m*(a[<span class="number">1</span>]-a[k])+(m<span class="number">-1</span>)*(a[<span class="number">2</span>]-a[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(n,m);</span><br><span class="line">ans_2=(n<span class="number">-1</span>)*m*(a[<span class="number">1</span>]-a[k])+(m<span class="number">-1</span>)*(a[<span class="number">2</span>]-a[k]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(ans_1,ans_2)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1826B"><a href="https://codeforces.com/contest/1826/problem/B">CF1826B</a></h2><h3 id="思路-23">思路</h3><p>不难发现，对称位置的元素取模$x$后是相等的，并且他们的差值一定是$x$的倍数，要求最大的$x$，只需要逐个计算对称位置的差值，取他们的最小公约数就是答案。</p><p>需要注意的是：</p><ul><li>无限大的情况，这里只需要特判一个元素的情况即可，即输出0。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[++cnt]=<span class="built_in">abs</span>(a[n-i]-a[<span class="number">1</span>+i]);</span><br><span class="line">&#125;</span><br><span class="line">ll ans=b[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=__gcd(ans,b[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1818B"><a href="https://codeforces.com/contest/1818/problem/B">CF1818B</a></h2><h3 id="思路-24">思路</h3><p>构造题，还是不会。</p><p><a href="https://www.luogu.com.cn/article/d4gmuv2k">CF1818B 题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n&amp;<span class="number">1</span>)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;<span class="number">1</span>)cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1823B"><a href="https://codeforces.com/contest/1823/problem/B">CF1823B</a></h2><p>侥幸猜过去的。。。以后还是得找一下正确解法。</p><h3 id="思路-25">思路</h3><p>跟之前一道题类似，只不过这里可以进行一次额外的操作。要想使得交换的距离</p><p>为$k$的倍数，且额外操作的次数最多为1。</p><p>我们先排序，计算各个位置的数需要的交换距离。讨论其中不是$k$的倍数的个数的情况：</p><ul><li>大于3，肯定不行，输出-1。</li><li>等于0，不用额外操作，输出0。</li><li>等于1，感觉不行（不知道怎么证明），输出-1。</li><li>等于2，感觉可以（看样例），输出1。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> k;cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i].val;</span><br><span class="line">a[i].id=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=<span class="built_in">abs</span>(i-a[i].id);</span><br><span class="line"><span class="keyword">if</span>(b[i]%k)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;cnt&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="keyword">if</span>(cnt&gt;<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1821B"><a href="https://codeforces.com/contest/1821/problem/B">CF1821B</a></h2><h3 id="思路-26">思路</h3><p>不难想到，先找出两个数组中从左右两端开始不同的数字，这是最小的长度。还可以往两端进行扩展：</p><ul><li>往左一直找比$b_{st}$更小的，往右一直找比$b_ed$更大的。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> st=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ed=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st)</span><br><span class="line">&#123;</span><br><span class="line">st=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[n-i+<span class="number">1</span>]!=b[n-i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!ed)</span><br><span class="line">&#123;</span><br><span class="line">ed=n-i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;=b[st])st--;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=ed+<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&gt;=b[ed])ed++;</span><br><span class="line"><span class="keyword">else</span><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;st&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ed&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1820B"><a href="https://codeforces.com/contest/1820/problem/B">CF1820B</a></h2><p>思路对了，不会一些小技巧。。。</p><h3 id="思路-27">思路</h3><p>不难想到规律：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1111</span>    <span class="number">11111</span>    <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line"> <span class="number">1111</span>    <span class="number">11111</span>    <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line">  <span class="number">1111</span>    <span class="number">11111</span>    <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line">   <span class="number">1111</span>    <span class="number">11111</span>    <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line">            <span class="number">11111</span>    <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line">                      <span class="number">111111</span>      <span class="number">1111111</span></span><br><span class="line">                                   <span class="number">1111111</span></span><br></pre></td></tr></table></figure><p>要使得面积最大，且$x+y=n+$1，利用基本不等式，要使得$xy$最大，$x$和$y$应该尽可能接近。注意这里的$n$是1串的最大长度。</p><p>可以发现 $n$为偶数时，面积是$\frac{n×(n+2)}{4}$，$n$为奇数时为$\frac{(n+1)×(n+1)}{4}$。</p><p>把这两种情况合起来就是$\frac{n+2}{2}×\frac{n+1}{2}$。</p><p>需要注意的是：</p><ul><li>$s$全1时需要特判一下。</li><li>一定要按照上面的式子计算，因为是利用了计算机向下取整的性质。</li><li>注意开$long\ long $。</li><li>首尾相接的情况：可以使用拼接进行处理。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//处理首尾相接的小技巧：拼接</span></span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line">s=s+s;</span><br><span class="line">ll n=s.<span class="built_in">length</span>();</span><br><span class="line">ll maxn=<span class="number">0</span>;</span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,cnt);</span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>cnt++;</span><br><span class="line">&#125;</span><br><span class="line">maxn=<span class="built_in">max</span>(maxn,cnt);<span class="comment">//注意最后一段需要特殊处理</span></span><br><span class="line"><span class="keyword">if</span>(maxn==n)cout&lt;&lt;n/<span class="number">2</span>*n/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;(maxn+<span class="number">2</span>)/<span class="number">2</span>*((maxn+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1797B"><a href="https://codeforces.com/contest/1797/problem/B">CF1797B</a></h2><h3 id="思路-28">思路</h3><p>还是构造题，不难想到对图进行旋转，然后暴力查找不同的地方并记录。</p><p>修改一个不同的地方，对应的两幅图是有两个位置的方块是不同的。这里分类讨论一下：</p><ul><li>如果修改完不同的地方后，剩下的次数是偶数（因为修改相同的地方话，要修改两次），输出YES.</li><li>如果不是偶数，那么看$n$是不是奇数，如果是奇数，剩下的$k$是奇数就没有问题。如果不是奇数，则输出NO。</li><li>如果$k$不够，那么输出NO。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">b[i][j]=a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">reverse</span>(b[i]+<span class="number">1</span>,b[i]+<span class="number">1</span>+n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=b[n-i+<span class="number">1</span>][j])</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt/<span class="number">2</span>&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>((k-cnt/<span class="number">2</span>)%<span class="number">2</span>==<span class="number">0</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1816B"><a href="https://codeforces.com/contest/1816/problem/B">CF1816B</a></h2><h3 id="思路-29">思路</h3><p>构造题，观察几个样例，可以发现：左上角和右下角是必须经过的，而且他们对答案的贡献是只增不减的，所以把两个最大的数字放在左上角和右下角。</p><p>剩下的构造：（把左上角和右下角剔除不考虑）。可以发现：上面的奇数位置是-，偶数位置是+，下面的奇数位是-，偶数位是正的。+代表可以使得答案变大，-代表可以使得答案变小。</p><p>并且贪心的想：肯定是位置越小的格子越容易走到。</p><p>综上可以这样构造：以$n=5$为例子。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">2</span> <span class="number">8</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>上面的是: 2 8 4 6 下面的是:1 7 3 5。这样交错的构造。</p><p>即上面的是：偶数位是从大到小递减，奇数位是从小到大递增。下面的也是同理。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> m=<span class="number">2</span>*n;</span><br><span class="line">cout&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">2</span>*(i/<span class="number">2</span>+<span class="number">1</span>)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;m-i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i&amp;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;m<span class="number">-1</span>-i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1814B"><a href="https://codeforces.com/contest/1814/problem/B">CF1814B</a></h2><p>数学题，不会。。。</p><h3 id="思路-30">思路</h3><p>先贪心地想：肯定是先让$leg$长度变长越好，这样后续的操作才更少。所以我们先进行变长的操作，再进行移动。</p><p>假设长度为$m$,那么向上的操作和向右的操作是$\lceil \frac{a}{m} \rceil$和$\lceil \frac{b}{m} \rceil$，变长的操作就是$m-1$，因为最初的长度是1。那么总共的操作次数：$m-1+\lceil \frac{a}{m} \rceil + \lceil \frac{b}{m} \rceil$。</p><p>但是如果直接暴力枚举$m$肯定会TLE。这个再观察一下可以发现，类似基本不等式：$m+\frac{a+b}{m}$，所以$m$的近似值为$\sqrt{a+b}$。我们估计一下范围就是1~5e5之间。直接暴力枚举即可。</p><p>不过这个向上取整比较奇怪：我原来的写法是(a+0.5)/i，但是WA了。</p><p>$(a+i-1)/i$这种写法比较好，作为一个$trick$。</p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">const int MAXN=2e5+10;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll=long long;</span><br><span class="line">void solve();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int t=1;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">while(t--)</span><br><span class="line">&#123;</span><br><span class="line">solve();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void solve()</span><br><span class="line">&#123;</span><br><span class="line">ll ans=1e15;</span><br><span class="line">ll a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">for(int i=1;i&lt;=5e5;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans=min(ans,(a+i-1)/i+(b+i-1)/i+i-1);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1805B"><a href="https://codeforces.com/contest/1805/problem/B">CF1805B</a></h2><p>忘记清空map了，WA了一发。。。</p><h3 id="思路-31">思路</h3><p>不难想到，直接从原序列中找到最小的字母拼接在前面。</p><p>需要注意的是：如果有多个，我们选择排在后面的最小字母。</p><p>以abaca为例子：可以变为aabca（前）、aabac（后），不难发现取后面的更小。</p><p>注意：</p><ul><li>需要清空map，否则会WA。（样例没WA纯属侥幸）。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="type">int</span> pos[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">string s;cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">mp[s[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">pos[s[i]-<span class="string">&#x27;a&#x27;</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i])</span><br><span class="line">&#123;</span><br><span class="line">flag=i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span>+flag<span class="number">-0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==pos[flag])<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;s[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CF1808B"><a href="https://codeforces.com/contest/1808/problem/B">CF1808B</a></h2><p>思路大致对了，但是没写完。。。</p><p>仔细一想，这个系数求解确实不难。。。</p><h3 id="思路-32">思路</h3><p><a href="https://www.luogu.com.cn/article/qzunosis">较为入门的解决方案 - 洛谷专栏 (luogu.com.cn)</a></p><p>如果直接暴力肯定会TLE，所以改变策略，我们取一列观察，改变顺序对结果没有影响，所以不难想到排个序，列一下例子查看系数的关系，具体看上面的链接。（这个东西的求法好像也是一个<strong>套路</strong>？）。</p><p>另外的写法：<a href="https://www.luogu.com.cn/article/c4r5cgey">CF1808B Playing in a Casino 题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>需要注意的细节：</p><ul><li>这里用的是vector，不然会MLE。</li><li>需要开long long，不然WA。</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">a</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;ll&gt;(m+<span class="number">1</span>,<span class="number">0</span>)); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">b[j]=a[j][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans+=(<span class="number">2</span>*j-n<span class="number">-1</span>)*b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CodeForces </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC074</title>
      <link href="/posts/4b8c3581.html"/>
      <url>/posts/4b8c3581.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC074">ABC074</h1><blockquote><h1 id="ABC074C-Sugar-Water">[ABC074C] Sugar Water</h1><h2 id="题面翻译">题面翻译</h2><p>废柴君正在烧杯中配置糖水。最初，烧杯是空的。废柴君可以多次执行以下四种类型的操作,每种操作不是必须的。</p><ul><li>操作1：将 $100 \times A$ 克水倒入烧杯中。</li><li>操作2：将 $100 \times B$ 克水倒入烧杯中。</li><li>操作3：将 $C$ 克糖放入烧杯中。</li><li>操作4：将 $D$ 克糖放入烧杯中。</li></ul><p>在我们的实验环境中，至多 $E$ 克糖可溶解于 $100$ 克水。<br>$a$ 克水，$b$ 克糖的糖水记作百分之 $<br>\dfrac{100b}{a+b}$。<br>废柴君想用现有材料配置具有百分率最高的糖水。<br>烧杯最多可容纳 $F$ 克糖水，并且烧杯中不能有任何不溶解的糖。</p><p>输入<br>一行按顺序给出 $A \sim F$</p><p>输出<br>输出废柴君将配置的糖水的质量，以及溶解在其中的糖的质量。如果有多种答案，任意输出一个即可。</p><p>$1 \leqslant A &lt; B \leqslant 30$</p><p>$1 \leqslant C &lt; D \leqslant 30$</p><p>$1 \leqslant E \leqslant 100$</p><p>$100A \leqslant F \leqslant 3000$</p><p>输入数据均为整数。</p><p>样例 1 解释</p><p>此时，$15$ 克糖可溶解于 $100$ 克水，烧杯最多可容纳 $200$ 克糖水。</p><p>我们可以配置 $110$ 克糖水，即执行操作 $1$ 和操作 $3$。但我们无法制造更优的糖水。例如，以下操作顺序就是不可行的：</p><p>如果我们进行一次操作 $1$ 和一次操作 $4$，则烧杯中将会有未溶解的糖。<br>如果我们执行操作 $2$ 一次和操作 $3$ 三次，烧杯中的糖水质量将超过 $200$ 克。</p><p>样例2解释</p><p>$200 ~ 100$</p><p>$400 ~ 200$ 也是正确的。</p><p>$300 ~ 150$ 是错误的。<br>这是因为，为了配置 $300$ 克 $50%$ 的糖水我们得准确倒入 $150$ 克糖，这当然是不可能的。</p><p>Translated by @yyhhenry</p><h2 id="题目描述">题目描述</h2><p>すぬけ君はビーカーに砂糖水を作ろうとしています。 最初ビーカーは空です。すぬけ君は以下の $ 4 $ 種類の操作をそれぞれ何回でも行うことができます。一度も行わない操作があっても構いません。</p><ul><li>操作 1: ビーカーに水を $ 100A $ [g] 入れる。</li><li>操作 2: ビーカーに水を $ 100B $ [g] 入れる。</li><li>操作 3: ビーカーに砂糖を $ C $ [g] 入れる。</li><li>操作 4: ビーカーに砂糖を $ D $ [g] 入れる。</li></ul><p>すぬけ君の実験環境下では、水 $ 100 $ [g] あたり砂糖は $ E $ [g] 溶けます。</p><p>すぬけ君はできるだけ濃度の高い砂糖水を作りたいと考えています。</p><p>ビーカーに入れられる物質の質量 (水の質量と砂糖の質量の合計) が $ F $ [g] 以下であり、 ビーカーの中に砂糖を溶け残らせてはいけないとき、 すぬけ君が作る砂糖水の質量と、それに溶けている砂糖の質量を求めてください。 答えが複数ある場合はどれを答えても構いません。</p><p>水 $ a $ [g] と砂糖 $ b $ [g] を混ぜた砂糖水の濃度は $ \frac{100b}{a\ +\ b} $ [%]です。 また、この問題では、砂糖が全く溶けていない水も濃度 $ 0 $ [%] の砂糖水と考えることにします。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $ $ D $ $ E $ $ F $</p></blockquote><h2 id="输出格式">输出格式</h2><p>整数を空白区切りで $ 2 $ つ出力せよ。 $ 1 $ つ目は求める砂糖水の質量、$ 2 $ つ目はそれに溶けている砂糖の質量とせよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 10 20 15 200</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110 10</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 1 2 100 1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">200 100</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17 19 22 26 55 2802</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2634 934</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ A\ &lt;\ B\ ≦\ 30 $</li><li>$ 1\ ≦\ C\ &lt;\ D\ ≦\ 30 $</li><li>$ 1≦\ E\ ≦\ 100 $</li><li>$ 100A\ ≦\ F\ ≦\ 3,000 $</li><li>$ A,\ B,\ C,\ D,\ E,\ F $ はすべて整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>この入力例の状況では、水 $ 100 $ \[g\] あたり砂糖は $ 15 $ \[g\] 溶けます。 また、ビーカーに物質を $ 200 $ \[g\] まで入れることができます。 操作 1 と操作 3 を $ 1 $ 回ずつ行うことで $ 110 $ \[g\] の砂糖水を作ることができます。 また、これ以上濃度の高い砂糖水を作ることはできません。 たとえば、以下のような操作は条件を満たしません。 - 操作 1 と操作 4 を $ 1 $ 回ずつ行うと、ビーカーに砂糖が溶け残ってしまいます。 - 操作 2 を $ 1 $ 回と操作 3 を $ 3 $ 回行うと、ビーカーの中の物質の量が $ 200 $ \[g\] を超えてしまいます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>ほかに、たとえば以下の出力も正解となります。 <code>400 200</code> 一方、以下の出力は不正解となります。 <code>300 150</code> なぜなら、砂糖が $ 150 $ \[g\] 溶けた $ 300 $ \[g\] の砂糖水を作るにはビーカーに水をちょうど $ 150 $ \[g\] 入れる必要がありますが、そのようなことは不可能だからです。</p></blockquote><h2 id="思路">思路</h2><p>这道题有两种方法：循环枚举或者使用DP。</p><p>先介绍枚举法：我们可以枚举每一种可能的操作，判断是否符合题意，再取最大值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> ans1,ans2;</span><br><span class="line"><span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line">ld sum;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(ld x,ld y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x+y&gt;f)<span class="keyword">return</span>;<span class="comment">//总质量不能超过f</span></span><br><span class="line">    <span class="keyword">if</span>(x*e&lt;y*<span class="number">100</span>)<span class="keyword">return</span>;<span class="comment">//最多100克水可以溶解e克糖</span></span><br><span class="line">    <span class="keyword">if</span>(sum&lt;=<span class="number">100</span>*y/(x+y))&#123;<span class="comment">//取max</span></span><br><span class="line">        sum=<span class="number">100</span>*y/(x+y),ans1=x+y,ans2=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++)&#123;<span class="comment">//为什么枚举的范围是100？因为f最大为3000，a最大为30</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">100</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">100</span>;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=<span class="number">100</span>;l++)&#123;</span><br><span class="line">                    <span class="built_in">check</span>(<span class="number">100</span>*a*i+<span class="number">100</span>*b*j,c*k+d*l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更加有效的解法是使用DP。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a,b,c,d,e,f;</span><br><span class="line"><span class="comment">//思路：使用dp</span></span><br><span class="line"><span class="comment">//其实有点类似于背包问题：体积限制和比例限制，属于方案问题</span></span><br><span class="line"><span class="comment">//dp[i][j]表示i克水，j克糖的溶剂能否配出。</span></span><br><span class="line"><span class="comment">//可以通过枚举i和j进行dp</span></span><br><span class="line"><span class="comment">//比例限制直接在dp的过程中判断即可。</span></span><br><span class="line"><span class="type">bool</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="type">int</span> li,lj;</span><br><span class="line"><span class="type">int</span> ans1,ans2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">    li=<span class="number">100</span>,lj=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=f;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j+i&lt;=f;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-100</span>*a&gt;=<span class="number">0</span>)  dp[i][j]=dp[i<span class="number">-100</span>*a][j]|dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i<span class="number">-100</span>*b&gt;=<span class="number">0</span>)  dp[i][j]=dp[i<span class="number">-100</span>*b][j]|dp[i][j];</span><br><span class="line">            <span class="keyword">if</span>(j-c&gt;=<span class="number">0</span>)      dp[i][j]=dp[i][j]|dp[i][j-c];</span><br><span class="line">            <span class="keyword">if</span>(j-d&gt;=<span class="number">0</span>)      dp[i][j]=dp[i][j]|dp[i][j-d];</span><br><span class="line">            <span class="keyword">if</span>(e*i&gt;=j*<span class="number">100</span> &amp;&amp; dp[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j*li&gt;=i*lj)<span class="comment">//这里=不能漏了，不然会WA一个点，因为是合法的情况，后续可能一些其他的情况是从这里开始更新的，所以即使是=，也必须更新。</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans1=i+j,   ans2=j;</span><br><span class="line">                    li=i;</span><br><span class="line">                    lj=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC074D-Restoring-Road-Network">[ABC074D] Restoring Road Network</h1><h2 id="题面翻译-2">题面翻译</h2><h4 id="题面翻译-3">题面翻译</h4><p>曾经存在的高桥王国有N个城市，城市与城市之间用长度为正整数的无向道路连接。</p><p>现有一考古学家找到了一张N×N的表A，这张表代表了这N座城市两两之间的最短路。即表中的第u行第v列的值代表了从城市u到v的最短路长度。</p><p>问能否根据这张表，求出高桥王国的最小道路长度总和。</p><h4 id="输入格式-2">输入格式</h4><p>第一行：N<br>下面是大小为N×N的表A</p><h4 id="输出格式-2">输出格式</h4><p>一个整数，表示最小道路长度总和。如果无解，输出−1</p><h4 id="数据范围与约定">数据范围与约定</h4><ul><li>1 &lt;= N &lt;= 300</li><li>当 i != j 时，1 &lt;= 表A中第i行第j列的值 == 表A中第j行第i列的值 &lt;= 10^9</li><li>表A中第i行第i列的值为0</li></ul><h4 id="样例1解释">样例1解释</h4><ul><li>从城市1到城市2有长度为1的直接道路</li><li>从城市2到城市3有长度为2的直接道路</li><li>从城市1到城市3无直接道路</li></ul><h4 id="样例2解释">样例2解释</h4><p>从城市1走到城市2要走长度为1的道路，从城市2走到城市3要走长度为1的道路，所以从城市1到城市3要走的距离为2，但表中是3，所以无解。</p><h2 id="题目描述-2">题目描述</h2><p>かつて存在した高橋王国には $ N $ 個の都市があり、いくつかの都市の組は道路で双方向に結ばれていました。 道路の構造は以下のようであったことがわかっています。</p><ul><li>都市間の移動は道路を通ってのみ行われ、どの都市からどの都市へも必要なら他の都市を経由することで移動できるようになっていた。</li><li>道路の長さは道路によって異なっていたかもしれないが、全て正整数であった。</li></ul><p>考古学者のすぬけ君は、高橋王国の遺跡で整数からなる $ N\ \times\ N $ の表 $ A $ を発見しました。 すぬけ君は、この表は高橋王国における都市間の道路に沿った最短距離を表した表ではないかと考えました。</p><p>すべての $ u,\ v $ について、$ A $ の $ u $ 行目 $ v $ 列目の整数 $ A_{u,\ v} $ が都市 $ u $ から都市 $ v $ への最短経路の長さとなるような 道路の構造が存在するかどうか判定してください。 さらに、存在する場合、そのような道路の構造のうち、存在する道路の長さの和が最小となるようなものについて、その和を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_{1,\ 1} $ $ A_{1,\ 2} $ $ … $ $ A_{1,\ N} $ $ A_{2,\ 1} $ $ A_{2,\ 2} $ $ … $ $ A_{2,\ N} $ $ … $ $ A_{N,\ 1} $ $ A_{N,\ 2} $ $ … $ $ A_{N,\ N} $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>条件を満たす道路の構造が存在しない場合、<code>-1</code> と出力せよ。 存在する場合、道路の長さの和の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 3</span><br><span class="line">1 0 2</span><br><span class="line">3 2 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1 3</span><br><span class="line">1 0 1</span><br><span class="line">3 1 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0 21 18 11 28</span><br><span class="line">21 0 13 10 26</span><br><span class="line">18 13 0 23 13</span><br><span class="line">11 10 23 0 17</span><br><span class="line">28 26 13 17 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">82</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0 1000000000 1000000000</span><br><span class="line">1000000000 0 1000000000</span><br><span class="line">1000000000 1000000000 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3000000000</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦300 $</li><li>$ i\ ≠\ j $ のとき、$ 1\ ≦\ A_{i,\ j}\ =\ A_{j,\ i}\ ≦\ 10^9 $</li><li>$ A_{i,\ i}\ =\ 0 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>条件を満たす道路の構造は以下のとおりです。 - 都市 $ 1 $ と都市 $ 2 $ の間は長さ $ 1 $ の道路によって結ばれている。 - 都市 $ 2 $ と都市 $ 3 $ の間は長さ $ 2 $ の道路によって結ばれている。 - 都市 $ 3 $ と都市 $ 1 $ の間は道路で結ばれていない。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>都市 $ 1 $ から都市 $ 2 $ へ、および都市 $ 2 $ から都市 $ 3 $ へそれぞれ距離 $ 1 $ で移動できることから、 都市 $ 1 $ から都市 $ 3 $ へは都市 $ 2 $ を経由することで距離 $ 2 $ で移動できることがわかります。 一方、都市 $ 1 $ と都市 $ 3 $ の間の最短距離は $ 3 $ でなければなりません。 よって条件を満たす道路の構造は存在しないことがわかります。</p></blockquote><h2 id="思路-2">思路</h2><p>题意看上去有些复杂，实际上就是根据题目给的最短路地图，判断是否合法。</p><p>如果不合法输出-1，否则输出全部的最短路。</p><p>因为是全图的，所以不难想到<code>Floyd</code>算法。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">using</span> ld=<span class="type">long</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll d[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line">ll a[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">            d[i][j]=a[i][j];</span><br><span class="line">            ans+=a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans/=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=std::<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j]!=a[i][j]) <span class="comment">//|| a[i][j]!=a[j][i])</span></span><br><span class="line">            &#123;</span><br><span class="line">                std::cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==i)    <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(k==j)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(d[i][j]==d[i][k]+d[k][j] &amp;&amp; !vis[i][j])          <span class="comment">//这里还需要特别留意处理可能重复计算的情况，所以需要vis处理，避免多算</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ans-=d[i][j];</span><br><span class="line">                    vis[i][j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex常见符号对照表</title>
      <link href="/posts/1093ae18.html"/>
      <url>/posts/1093ae18.html</url>
      
        <content type="html"><![CDATA[<p>只有链接：<a href="https://blog.csdn.net/zgj926503/article/details/52757631">Latex常见符号对照表</a></p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC073</title>
      <link href="/posts/d5e8a022.html"/>
      <url>/posts/d5e8a022.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC073">ABC073</h1><blockquote><h1 id="ABC073C-Write-and-Erase">[ABC073C] Write and Erase</h1><h2 id="题面翻译">题面翻译</h2><p>给你一个空序列，以及$N$个询问$Ai$，如在序列中有这个数，就将序列中的数删去，如在序列中没有这个数，就将这个数加入序列中，问最后序列中的元素个数为多少。</p><h4 id="数据范围">数据范围</h4><p>$1≤N≤100000$，$1≤Ai≤1000000000(=10^9)$</p><h2 id="题目描述">题目描述</h2><p>あなたは、joisinoお姉ちゃんと以下のようなゲームをしています。</p><ul><li>最初、何も書いていない紙がある。</li><li>joisinoお姉ちゃんが一つの数字を言うので、その数字が紙に書いてあれば紙からその数字を消し、書いていなければその数字を紙に書く。これを $ N $ 回繰り返す。</li><li>その後、紙に書かれている数字がいくつあるかを答える。</li></ul><p>joisinoお姉ちゃんが言った数字が、言った順番に $ A_1,\ …\ ,A_N $ として与えられるので、ゲーム終了後に紙に書かれている数字がいくつあるか答えてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ : $ $ A_N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>ゲーム終了後に紙に書かれている数字の個数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">12</span><br><span class="line">22</span><br><span class="line">16</span><br><span class="line">22</span><br><span class="line">18</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦100000 $</li><li>$ 1≦A_i≦1000000000(=10^9) $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>以下の操作を行うこととなります。 - 紙に $ 6 $ は書かれていないので、$ 6 $ を書く。 - 紙に $ 2 $ は書かれていないので、$ 2 $ を書く。 - 紙に $ 6 $ は書かれているので、$ 6 $ を消す。 よって、最後に書いてあるのは $ 2 $ だけなので、答えは $ 1 $ です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>最後に紙に数字が一つも書かれていない場合もあります。</p></blockquote><h2 id="思路">思路</h2><p>直接开个桶，在线处理就行。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(m[a[i]])&#123;</span><br><span class="line">            ans--;</span><br><span class="line">            m[a[i]]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            m[a[i]]++;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC073D-joisino-s-travel">[ABC073D] joisino's travel</h1><h2 id="题面翻译-2">题面翻译</h2><p>一个人旅行，必须经过指定的r个城市，问最短的路程是多少。他可以从任意一个城市开始，任意一个城市结束。保证图是连通的。</p><h2 id="题目描述-2">题目描述</h2><p>Atcoder国には $ N $ 個の町があり、$ M $ 本の双方向に移動可能な道で結ばれています。</p><p>また、 $ i $ 本目の道は町 $ A_i $ と町 $ B_i $ の間を距離 $ C_i $ で結んでいます。</p><p>joisinoお姉ちゃんは、この国の $ R $ 個の町 $ r_1,r_2…r_R $ を訪れることとなりました。</p><p>最初に訪れる町までの移動と、最後に訪れる町からの移動は空路で行うが、それ以外は道を使わなければなりません。</p><p>町を訪れる順番を、道での移動距離が最小となるように決めた時の移動距離を答えてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ R $ $ r_1 $ $ … $ $ r_R $ $ A_1 $ $ B_1 $ $ C_1 $ $ : $ $ A_M $ $ B_M $ $ C_M $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>町を訪れる順番を、道での移動距離が最小となるように決めた時の移動距離を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 2</span><br><span class="line">1 3</span><br><span class="line">2 3 2</span><br><span class="line">1 3 6</span><br><span class="line">1 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6 3</span><br><span class="line">2 3 4</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">4 3 1</span><br><span class="line">1 4 1</span><br><span class="line">4 2 2</span><br><span class="line">3 1 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2≦N≦200 $</li><li>$ 1≦M≦N×(N-1)/2 $</li><li>$ 2≦R≦min(8,N) $ ( $ min(8,N) $ は $ 8 $ と $ N $ のうち小さい方)</li><li>$ r_i≠r_j\ (i≠j) $</li><li>$ 1≦A_i,B_i≦N\ ,\ A_i≠B_i $</li><li>$ (A_i,B_i)≠(A_j,B_j),(A_i,B_i)≠(B_j,A_j)\ (i≠j) $</li><li>$ 1≦C_i≦100000 $</li><li>すべての町の間は道のみで移動することができる。</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>例えば、町 $ 1 $ ,町 $ 2 $ ,町 $ 3 $ の順番で訪れると、移動距離が $ 2 $ となり、最小となります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>町 $ 1 $ を訪れたあとに町 $ 3 $ を訪れても、町 $ 3 $ を訪れたあとに町 $ 1 $ を訪れても、町 $ 1 $ と町 $ 3 $ の間の最短距離は $ 4 $ であるため、どの順番を選んだとしても答えは $ 4 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>最短路的题目，由于不确定起点，并且<code>n</code>的范围很小，所以使用<code>Floyd</code>算法可以解决。</p><blockquote><p>题意：给一张无向图，给定一些点，求走过全部给定的点的最小代价。</p><p>n&lt;=8，直接全排列然后比大小就行了，floyd n^3的复杂度在n!面前显得微不足道。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll r[<span class="number">8</span>],dis[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dis));</span><br><span class="line">    ll n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll R;</span><br><span class="line">    cin&gt;&gt;R;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;R;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ll x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        dis[x][y]=dis[y][x]=z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]+dis[k][j]&lt;dis[i][j])</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(r,r+R);</span><br><span class="line">    ll MIN=<span class="number">0</span>;</span><br><span class="line">    ll ans=INF;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        MIN=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;R<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            MIN+=dis[r[i]][r[i+<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,MIN);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(r,r+R));</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC072</title>
      <link href="/posts/a2ef90b4.html"/>
      <url>/posts/a2ef90b4.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC072">ABC072</h1><blockquote><h1 id="ABC072C-Together">[ABC072C] Together</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目">题目</h1><p>给出一个长度为N，a1，a2，…，aN的整数序列。<br>对于每个1≤i≤N，您有三个选择：1.将1添加到ai，<br>2.从ai减去1<br>3.不执行任何操作。<br>在这些操作之后，您选择一个整数X并计算i的数量，使得ai = X.<br>通过做出最佳选择来最大化这一数量。</p><h1 id="限制">限制</h1><p>1≤x≤10^5</p><p>0≤ai≤10^5</p><p>且ai是整数</p><h1 id="输出">输出</h1><p>输出最大可能的数 使ai = x</p><h1 id="样例输入">样例输入</h1><p>7<br>3 1 4 1 5 9 2</p><p>10<br>0 1 2 3 4 5 6 7 8 9</p><h1 id="样例输出">样例输出</h1><p>4</p><p>3</p><p>感谢@牧星 提供的翻译</p><h2 id="题目描述">题目描述</h2><p>長さ $ N $ の整数列 $ a_1,a_2,…,a_N $ が与えられます。</p><p>各 $ 1\ &lt;\ =i\ &lt;\ =N $ に対し、$ a_i $ に $ 1 $ 足すか、$ 1 $ 引くか、なにもしないかの三つの操作からどれか一つを選んで行います。</p><p>この操作の後、ある整数 $ X $ を選んで、$ a_i=X $ となる $ i $ の個数を数えます。</p><p>うまく操作を行い、$ X $ を選ぶことで、この個数を最大化してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>うまく操作を行い、$ X $ を選んだ時の $ a_i=X $ なる $ i $ の個数の最大値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3 1 4 1 5 9 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">99999</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ &lt;\ =N\ &lt;\ =10^5 $</li><li>$ 0\ &lt;\ =a_i\ &lt;\ 10^5\ (1\ &lt;\ =i\ &lt;\ =N) $</li><li>$ a_i $ は整数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>例えば操作後の数列を $ 2,2,3,2,6,9,2 $ とすることができて、$ X=2 $ とすると $ 4 $ を得ることができ、これが最大です。</p></blockquote><h2 id="思路">思路</h2><p>不难想到，对整个整数序列进行遍历，记当前遍历到的数字为<code>x</code>，开一个桶记录所有的可能，+1、-1、+0。这样在范围内进行遍历取最大值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        m[x+<span class="number">1</span>]++,m[x<span class="number">-1</span>]++;</span><br><span class="line">        m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1e5</span>+<span class="number">10</span>;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,m[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC072D-Derangement">[ABC072D] Derangement</h1><h2 id="题面翻译-2">题面翻译</h2><p>给你一段长为$N$的序列$p$,你每次可以进行操作交换两个相邻的元素<br>问最少要几次才能满足任意$i\in[1,N],p_i \neq i$</p><h2 id="题目描述-2">题目描述</h2><p>$ 1,2,…,N $ からなる順列 $ p_1,p_2,…,p_N $ が与えられます。 次の操作を何回か ($ 0 $回でもよい) 行うことが出来ます。</p><p>操作: 順列で<strong>隣り合う</strong>二つの数を選んでスワップする。</p><p>何回か操作を行って、任意の $ 1\ &lt;\ =i\ &lt;\ =N $ に対して $ p_i\ ≠\ i $ となるようにしたいです。 必要な操作の最小回数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ p_1 $ $ p_2 $ … $ p_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>必要な操作の最小回数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 4 3 5 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 2 4 9 5 8 7 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ &lt;\ =N\ &lt;\ =10^5 $</li><li>$ p_1,p_2,…,p_N $ は $ 1,2,…,N $ の順列である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1 $ と $ 4 $ を入れ替え、その後 $ 1 $ と $ 3 $ を入れ替えることで $ p $ は $ 4,3,1,5,2 $ となり、これは条件を満たします。 これが最小回数なので、答えは $ 2 $ となります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>$ 1 $ と $ 2 $ を入れ替えれば条件を満たします。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>初めから条件を満たしています。</p></blockquote><h2 id="思路-2">思路</h2><p>对整个序列进行遍历，只要发现$p_i=i$的情况，直接与下一个进行交换，为什么可以这样？因为交换后肯定这两个数都不满足$p_i=i$。需要注意的是，最后一个数$a_n$没有办法与下一个数进行交换，所以只能与前一个数进行交换.</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==a[i])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[i+<span class="number">1</span>]);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a[n]==n)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC071</title>
      <link href="/posts/3be6c10e.html"/>
      <url>/posts/3be6c10e.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC071">ABC071</h1><blockquote><h1 id="ABC071B-Not-Found">[ABC071B] Not Found</h1><h2 id="题面翻译">题面翻译</h2><p>给出由小写字母组成的字符串$S$。 查找未出现在$S$中且字母顺序最小的小写字母。如果所有小写字母都出现在$S$中，则输出&quot;None&quot;。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる文字列 $ S $ が与えられます． $ S $ に現れない英小文字であって，最も辞書順（アルファベット順）で小さいものを求めてください． ただし，$ S $ にすべての英小文字が現れる場合は，代わりに <code>None</code> を出力してください．</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ S $ に現れない英小文字であって，最も辞書順で小さいものを出力せよ． ただし，$ S $ にすべての英小文字が現れる場合は，代わりに <code>None</code> を出力せよ．</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoderregularcontest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcdefghijklmnopqrstuvwxyz</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">None</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fajsonlslfepbjtsaayxbymeskptcumtwrmkkinjxnnucagfrg</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ |S|\ \leq\ 10^5 $ ($ |S| $ は文字列 $ S $ の長さ)</li><li>$ S $ は英小文字のみからなる．</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>atcoderregularcontest</code> という文字列には <code>a</code> は現れますが <code>b</code> は現れません．</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>この文字列には，すべての英小文字が現れます．</p></blockquote><h2 id="思路">思路</h2><p>使用<code>map</code>处理即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        m[s[i]-<span class="string">&#x27;a&#x27;</span>]++;<span class="comment">//记录每个字母出现的次数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i]==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">char</span>(<span class="string">&#x27;a&#x27;</span>+i);<span class="comment">//从小到大遍历寻找即可</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;None&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC071C-Make-a-Rectangle">[ABC071C] Make a Rectangle</h1><h2 id="题面翻译-2">题面翻译</h2><p>有N根可以忽视粗细的棒。第i棒的长度是a_i。<br>有人想从这些棒子中选出4个不同的棒子，用这些棒子做个矩形(包括正方形)。求最大可以制作的矩形面积。</p><h2 id="题目描述-2">题目描述</h2><p>太さが無視できる棒が $ N $ 本あります． $ i $ 番目の棒の長さは $ A_i $ です．</p><p>すぬけ君は，これらの棒から $ 4 $ 本の異なる棒を選び，それらの棒を辺として長方形（正方形を含む）を作りたいです． 作ることができる最大の長方形の面積を求めてください．</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ … $ A_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>すぬけ君が作ることのできる最大の長方形の面積を出力せよ． ただし，長方形を作れない場合は，$ 0 $ を出力せよ．</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 1 2 4 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">3 3 3 3 4 4 4 5 5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 4\ \leq\ N\ \leq\ 10^5 $</li><li>$ 1\ \leq\ A_i\ \leq\ 10^9 $</li><li>$ A_i $ は整数</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1\ \times\ 2 $ の長方形を作ることができます．</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>長方形を作ることはできません．</p></blockquote><h2 id="思路-2">思路</h2><p>不难想到用桶来记录，用优先队列来找最大值。</p><p>可以这样实现：我们每次需要的是两根相同长度的木棒，只要找到两根相同的，那么就将这种木棒加入到有限队列中，注意需要清空原来的桶。否则可能记录混乱。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">map&lt;ll,<span class="type">int</span>&gt; m;</span><br><span class="line">priority_queue&lt;ll&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(m[a[i]])&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            m[a[i]]=<span class="number">0</span>;<span class="comment">//注意需要进行清空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> m[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">empty</span>())&#123;<span class="comment">//如果没有成对的木棒，则无解</span></span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll x=q.<span class="built_in">top</span>();<span class="comment">//取最大和第二大的木棒</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    ll y=q.<span class="built_in">top</span>();</span><br><span class="line">    cout&lt;&lt;x*y;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC071D-Coloring-Dominoes">[ABC071D] Coloring Dominoes</h1><h2 id="题面翻译-3">题面翻译</h2><p>Snuke有一个$2\times N$的矩阵,以及$N$个多米诺骨牌,每一个骨牌是$1\times 2$或者$2 \times 1$的<br>现在Snuke决定用红色、浅蓝色和绿色三种颜色来绘制这些骨牌,要保证每一个骨牌与其周围相邻的骨牌颜色都不一样<br>问一共有多少种不同的方案,答案对$1e9+7$取模</p><ul><li>每一个骨牌都会用一个英文字母表示</li><li>保证每一个骨牌的字母都不一样</li></ul><h2 id="题目描述-3">题目描述</h2><p>$ 2\ \times\ N $ のマス目があります． すぬけ君は，このマス目に $ N $ 個のドミノを，重ならないように敷き詰めました． ここで，ドミノは，$ 1\ \times\ 2 $ または $ 2\ \times\ 1 $ のマス目を覆うことができます．</p><p>すぬけ君は，赤色，水色，緑色の $ 3 $ 色を使って，これらのドミノを塗ることにしました． このとき，辺で接しているドミノは異なる色で塗るようにします． ここで，必ずしも $ 3 $ 色すべてを使う必要はありません．</p><p>このような塗り方が何通りあるかを mod $ 1000000007 $ で求めてください．</p><p>ただし，ドミノの敷き詰め方は，文字列 $ S_1,\ S_2 $ を用いて，次のようにして与えられます．</p><ul><li>各ドミノは，それぞれ異なる英小文字または英大文字で表される．</li><li>$ S_i $ の $ j $ 文字目は，マス目の上から $ i $ 番目，左から $ j $ 番目のマスにどのドミノがあるかを表す．</li></ul><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ S_1 $ $ S_2 $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>ドミノを塗る方法の数を mod $ 1000000007 $ で出力せよ．</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aab</span><br><span class="line">ccb</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">Z</span><br><span class="line">Z</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52</span><br><span class="line">RvvttdWIyyPPQFFZZssffEEkkaSSDKqcibbeYrhAljCCGGJppHHn</span><br><span class="line">RLLwwdWIxxNNQUUXXVVMMooBBaggDKqcimmeYrhAljOOTTJuuzzn</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">958681902</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ \leq\ N\ \leq\ 52 $</li><li>$ |S_1|\ =\ |S_2|\ =\ N $</li><li>$ S_1,\ S_2 $ は英小文字または英大文字からなる</li><li>$ S_1,\ S_2 $ は正しいドミノの敷き詰め方を表している</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>次の $ 6 $ 通りあります． ![](<a href="https://atcoder.jp/img/arc081/899673bd23529f4fb5e41c6e7d5bc372.png">https://atcoder.jp/img/arc081/899673bd23529f4fb5e41c6e7d5bc372.png</a>)</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>必ずしもすべての色を使わなくてもよいことに注意してください．</p></blockquote><h2 id="思路-3">思路</h2><p>找规律递推解决。可以发现不是摆放的情况只有以下两种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">aa<span class="comment">//a</span></span><br><span class="line">bb<span class="comment">//a</span></span><br></pre></td></tr></table></figure><p>并且颜色互不相同，发现情况都是循环重复的，所以使用递推解决。</p><p>先找出初始情况：可能是上面的前者，也可能是后者。</p><p>如果是前者，那么初始情况有6种，反之只有3种，注意下标要更新。</p><p>因为要考虑颜色互不相同，所以每次确定新的多米诺骨牌的颜色时，除了像上面一样考虑当前的颜色，还需要考虑前面的牌的颜色。具体看代码实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    string a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll ans=<span class="number">0</span>,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>]==b[<span class="number">0</span>])ans=<span class="number">3</span>,s=<span class="number">1</span>;<span class="comment">//对应第二种情况，注意下标的更新</span></span><br><span class="line">    <span class="keyword">else</span> ans=<span class="number">6</span>,s=<span class="number">2</span>;<span class="comment">//对应第一种情况，注意下标的更新</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s;i&lt;n;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]&amp;&amp;a[i<span class="number">-1</span>]==b[i<span class="number">-1</span>])ans*=<span class="number">2</span>;<span class="comment">//都是竖的</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==b[i]&amp;&amp;a[i<span class="number">-1</span>]!=b[i<span class="number">-1</span>])ans*=<span class="number">1</span>;<span class="comment">//前横后竖</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i]&amp;&amp;a[i<span class="number">-1</span>]==b[i<span class="number">-1</span>])ans*=<span class="number">2</span>;<span class="comment">//前竖后横</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i]&amp;&amp;a[i<span class="number">-1</span>]!=b[i<span class="number">-1</span>])ans*=<span class="number">3</span>;<span class="comment">//前横后横</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])i+=<span class="number">2</span>;<span class="comment">//下标的更新</span></span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">        ans%=mod;<span class="comment">//更新ans</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 杂项</title>
      <link href="/posts/84db90ab.html"/>
      <url>/posts/84db90ab.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-杂项">CPP复习 杂项</h1><p>虚继承（Virtual Inheritance）是C++中的一种技术，用于解决多重继承中的菱形继承问题（Diamond Problem）。菱形继承问题通常发生在多重继承中，当一个派生类通过多个路径继承自同一个基类时，导致基类的成员存在多个拷贝。</p><h3 id="菱形继承问题示例">菱形继承问题示例</h3><p>考虑以下示例，展示了菱形继承问题：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Final obj;</span><br><span class="line">    <span class="comment">// obj.show(); // Error: ambiguous</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，<code>Final</code> 类通过 <code>Derived1</code> 和 <code>Derived2</code> 两条路径继承自 <code>Base</code> 类，导致 <code>Base</code> 类的两个副本存在于 <code>Final</code> 类中。如果尝试通过 <code>Final</code> 类对象调用 <code>Base</code> 类的方法，会产生歧义。</p><h3 id="解决菱形继承问题的虚继承">解决菱形继承问题的虚继承</h3><p>通过虚继承，可以确保无论多少派生类从一个基类继承，基类成员只有一个副本。可以使用关键字 <code>virtual</code> 来实现虚继承。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Final obj;</span><br><span class="line">    obj.<span class="built_in">show</span>(); <span class="comment">// This works without ambiguity</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此例子中，<code>Derived1</code> 和 <code>Derived2</code> 类通过 <code>virtual</code> 关键字虚继承自 <code>Base</code> 类。这样，<code>Final</code> 类中只有一个 <code>Base</code> 类的实例，消除了歧义。</p><h3 id="虚继承的关键点">虚继承的关键点</h3><ol><li><strong>虚基类</strong>：使用 <code>virtual</code> 关键字指定继承关系，确保基类在最终派生类中只有一个实例。</li><li><strong>构造函数顺序</strong>：在构造派生类对象时，虚基类会在其他基类之前被初始化。</li></ol><h3 id="构造函数顺序示例">构造函数顺序示例</h3><p>虚继承改变了构造函数的调用顺序。虚基类的构造函数在所有派生类构造函数之前被调用。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base class constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived1</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1 class constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived2</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2 class constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Final</span> : <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Final</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Final class constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Final obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base class constructor</span><br><span class="line">Derived1 class constructor</span><br><span class="line">Derived2 class constructor</span><br><span class="line">Final class constructor</span><br></pre></td></tr></table></figure><p>从输出中可以看到，<code>Base</code> 类的构造函数首先被调用，接着是 <code>Derived1</code> 和 <code>Derived2</code> 类的构造函数，最后是 <code>Final</code> 类的构造函数。</p><h3 id="总结">总结</h3><p>虚继承是C++中解决多重继承菱形继承问题的强大工具。它确保基类的成员在派生类中只有一个副本，消除了歧义和潜在的错误。掌握虚继承的概念和使用方法对编写复杂的继承层次结构非常重要。</p><blockquote><p>在C++中，编译时多态性（compile-time polymorphism）是指在编译期间决定的多态行为。主要包括函数重载（function overloading）、运算符重载（operator overloading）和模板（templates）等机制。以下是对这些机制的详细介绍：</p><h3 id="1-函数重载（Function-Overloading）">1. 函数重载（Function Overloading）</h3><p>函数重载是指在同一个作用域中可以有多个同名函数，但这些函数具有不同的参数列表（参数的数量或类型不同）。编译器会根据调用函数时传递的参数类型和数量来选择匹配的函数。</p><h4 id="示例">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; f &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Printing string: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">print</span>(<span class="number">10</span>);          <span class="comment">// 调用 print(int)</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="number">3.14</span>);        <span class="comment">// 调用 print(double)</span></span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);     <span class="comment">// 调用 print(const std::string&amp;)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-运算符重载（Operator-Overloading）">2. 运算符重载（Operator Overloading）</h3><p>运算符重载允许开发者为用户定义的类型重新定义C++内置运算符的行为。这使得用户定义的类型可以像内置类型一样进行运算。</p><h4 id="示例-2">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">double</span> real;</span><br><span class="line"> <span class="type">double</span> imag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Complex</span>(<span class="type">double</span> r, <span class="type">double</span> i) : <span class="built_in">real</span>(r), <span class="built_in">imag</span>(i) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重载 + 运算符</span></span><br><span class="line"> Complex <span class="keyword">operator</span> + (<span class="type">const</span> Complex&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">Complex</span>(real + other.real, imag + other.imag);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; real &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; imag &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">1.0</span>, <span class="number">2.0</span>)</span></span>;</span><br><span class="line"> <span class="function">Complex <span class="title">c2</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line"> Complex c3 = c1 + c2;  <span class="comment">// 使用重载的 + 运算符</span></span><br><span class="line"> c3.<span class="built_in">display</span>();          <span class="comment">// 输出: (4.0, 6.0)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-模板（Templates）">3. 模板（Templates）</h3><p>模板是C++中实现泛型编程的一种机制。它允许函数或类的定义中使用类型参数，使得函数或类可以处理多种不同类型的数据，而不必重复编写代码。</p><h4 id="函数模板示例">函数模板示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl;        <span class="comment">// 输出: 8 (int)</span></span><br><span class="line"> std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2.5</span>, <span class="number">1.5</span>) &lt;&lt; std::endl;    <span class="comment">// 输出: 4.0 (double)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板示例">类模板示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> T value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Box</span>(T v) : <span class="built_in">value</span>(v) &#123;&#125;</span><br><span class="line"> <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">Box&lt;<span class="type">int</span>&gt; <span class="title">intBox</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line"> <span class="function">Box&lt;std::string&gt; <span class="title">stringBox</span><span class="params">(<span class="string">&quot;Template&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; intBox.<span class="built_in">getValue</span>() &lt;&lt; std::endl;       <span class="comment">// 输出: 123</span></span><br><span class="line"> std::cout &lt;&lt; stringBox.<span class="built_in">getValue</span>() &lt;&lt; std::endl;    <span class="comment">// 输出: Template</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译时多态性的优势">编译时多态性的优势</h3><ol><li><strong>类型安全</strong>：模板在编译时进行类型检查，减少了运行时错误。</li><li><strong>性能</strong>：编译时多态性避免了运行时开销（如虚函数的调用开销），通常比运行时多态性更高效。</li><li><strong>代码复用</strong>：模板允许编写泛型代码，可以处理多种数据类型，从而提高代码的复用性。</li></ol><h3 id="总结-2">总结</h3><p>编译时多态性是C++语言的一个强大特性，通过函数重载、运算符重载和模板，开发者可以编写高效、类型安全且复用性高的代码。理解和熟练运用这些特性是C++编程的重要技能之一。</p></blockquote><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T a,T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">double</span> a=<span class="number">1.1</span>;</span><br><span class="line"> <span class="type">int</span> b=<span class="number">10</span>;</span><br><span class="line"> a=<span class="built_in">func</span>(a,b);</span><br><span class="line"> cout&lt;&lt;a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在你的示例代码中，你使用了一个模板函数 <code>func</code> 来进行加法运算。然而，C++模板要求模板参数类型必须相同，而在你的 <code>main</code> 函数中，你传递了一个 <code>double</code> 类型的参数 <code>a</code> 和一个 <code>int</code> 类型的参数 <code>b</code> 给模板函数 <code>func</code>，这会导致类型不匹配的问题。</p><h3 id="解决方案">解决方案</h3><p>为了使代码能够编译并运行，有两种主要的解决方案：</p><ol><li><strong>类型转换</strong>：将参数类型转换为相同的类型。</li><li><strong>重载函数模板</strong>：使用不同类型的参数。</li></ol><h3 id="方案一：类型转换">方案一：类型转换</h3><p>你可以在调用模板函数时显式地将 <code>int</code> 类型的参数转换为 <code>double</code> 类型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    a = <span class="built_in">func</span>(a, <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(b));  <span class="comment">// 将 b 转换为 double 类型</span></span><br><span class="line">    cout &lt;&lt; a;  <span class="comment">// 输出: 11.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，模板函数 <code>func</code> 会被实例化为处理 <code>double</code> 类型的参数，避免了类型不匹配的问题。</p><h3 id="方案二：重载函数模板">方案二：重载函数模板</h3><p>你可以为模板函数 <code>func</code> 提供一个专门处理不同类型参数的重载版本：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载版本，处理不同类型的参数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    a = <span class="built_in">func</span>(a, b);  <span class="comment">// 使用重载版本</span></span><br><span class="line">    cout &lt;&lt; a;  <span class="comment">// 输出: 11.1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，重载版本的 <code>func</code> 使用了 <code>decltype</code> 来推断返回类型，该返回类型是两个参数相加的结果类型。这样，你就可以直接传递不同类型的参数。</p><h3 id="解释">解释</h3><ul><li><strong>类型转换</strong>：<code>static_cast&lt;double&gt;(b)</code> 将 <code>b</code> 转换为 <code>double</code> 类型，使得两个参数类型一致，从而可以调用模板函数。</li><li><strong>函数模板重载</strong>：使用模板重载和 <code>decltype</code> 关键字来自动推断返回类型，允许传递不同类型的参数。</li></ul><p>选择一种方案取决于你的具体需求和代码设计。对于简单的类型转换，显式转换参数类型可能更直接和清晰；对于需要处理多种类型组合的情况，使用模板重载可能更灵活和强大。</p></blockquote><p><code>const_cast</code>运算符</p><blockquote><p><code>const_cast</code> 是 C++ 中的一个类型转换运算符，用于移除对象的常量性（constness）或 volatile 修饰符。它可以将指向常量对象的指针或引用转换为指向非常量对象的指针或引用。</p><h3 id="用法">用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><code>new_type</code>：要转换成的类型。</li><li><code>expression</code>：要转换的表达式。</li></ul><h3 id="示例-3">示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：试图通过指向常量的指针修改常量对象</span></span><br><span class="line">    <span class="comment">// *ptr = 20;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 const_cast 移除常量性，修改对象的值</span></span><br><span class="line">    <span class="type">int</span>* non_const_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr);</span><br><span class="line">    *non_const_ptr = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value of x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个常量整数，通过 <code>const_cast</code> 将指向 <code>x</code> 的指针 <code>ptr</code> 转换为指向非常量整数的指针 <code>non_const_ptr</code>。然后，可以使用 <code>non_const_ptr</code> 修改 <code>x</code> 的值。需要注意的是，修改一个常量对象的值是未定义行为（undefined behavior），因此应该谨慎使用 <code>const_cast</code>。</p><h3 id="注意事项">注意事项</h3><ol><li><code>const_cast</code> 只能用于移除常量性或 volatile 修饰符，不能用于移除对象的指针或引用的底层 const。</li><li>修改一个常量对象的值是未定义行为，可能会导致程序崩溃或产生其他不可预测的结果。</li><li>使用 <code>const_cast</code> 应该尽可能避免，因为它通常会破坏程序的类型安全性和约束。</li></ol><h3 id="应用场景">应用场景</h3><ul><li>在需要修改由常量指针或引用指向的对象值时，可以使用 <code>const_cast</code>。</li><li>例如，在调用接受非常量参数的函数时，需要将指向常量对象的指针传递给该函数，然后在函数内部修改对象的值。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span>* ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* ptr = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误：试图通过指向常量的指针修改常量对象</span></span><br><span class="line">    <span class="comment">// modify(ptr);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 const_cast 移除常量性，调用 modify 函数</span></span><br><span class="line">    <span class="built_in">modify</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(ptr));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified value of x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 输出: 100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>const_cast</code> 应该谨慎使用，因为它可能会导致代码的不可预测行为。通常情况下，修改常量对象的值是不推荐的做法，应该避免使用 <code>const_cast</code>。</p></blockquote><blockquote><p><code>mutable</code> 是 C++ 中的一个关键字，用于修饰类的成员变量，表示该成员变量可以在 const 成员函数中被修改。通常情况下，如果一个成员函数被声明为 const，那么它不能修改类的成员变量。但是，如果一个成员变量被声明为 mutable，则即使在 const 成员函数中也可以修改它的值。</p><h3 id="用法示例">用法示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">mutable</span> <span class="type">int</span> mutableVar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Example</span>(<span class="type">int</span> value) : <span class="built_in">mutableVar</span>(value) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">modifyMutableVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     mutableVar = <span class="number">100</span>;  <span class="comment">// 在 const 成员函数中修改 mutable 变量的值</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">displayMutableVar</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Mutable variable: &quot;</span> &lt;&lt; mutableVar &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="function">Example <span class="title">obj</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"> obj.<span class="built_in">displayMutableVar</span>();     <span class="comment">// 输出: Mutable variable: 50</span></span><br><span class="line"> obj.<span class="built_in">modifyMutableVar</span>();      <span class="comment">// 调用 const 成员函数修改 mutable 变量的值</span></span><br><span class="line"> obj.<span class="built_in">displayMutableVar</span>();     <span class="comment">// 输出: Mutable variable: 100</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>mutableVar</code> 被声明为 <code>mutable</code>，所以即使在 <code>modifyMutableVar</code> 这个 const 成员函数中也可以修改它的值。</p><h3 id="适用场景">适用场景</h3><ul><li>当某个类的成员变量需要在 const 成员函数中被修改时，可以将该成员变量声明为 <code>mutable</code>。</li><li>通常情况下，应该避免在 const 成员函数中修改类的状态，但有些情况下，比如在缓存的更新或日志记录等情况下，可能需要使用 <code>mutable</code> 关键字。</li><li>举例：一个已经排好序的链表，可以通过记录最后一次成功找到的位置继续进行查找，这样可以提高效率，这就需要在负责查找的const成员函数中修改数据（记录最后一次成功找到的位置的变量A）。对A声明为multable，这样就可以在const成员函数中修改数据。</li></ul></blockquote><blockquote><p>命名空间（Namespace）是 C++ 中一种用来组织代码的机制，可以将全局作用域中的标识符划分为不同的区域，避免命名冲突，并提高代码的可读性和可维护性。</p><h3 id="用法示例-2">用法示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line"> <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">printX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 使用命名空间中的变量和函数</span></span><br><span class="line"> MyNamespace::<span class="built_in">printX</span>();  <span class="comment">// 输出: x = 10</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>MyNamespace</code> 是一个命名空间，它包含一个整型变量 <code>x</code> 和一个函数 <code>printX</code>。通过 <code>MyNamespace::</code> 作用域解析运算符，可以访问命名空间中的成员。</p><h3 id="命名空间嵌套">命名空间嵌套</h3><p>命名空间可以嵌套定义，形成多层次的命名空间结构，有助于组织更复杂的代码。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> OuterNamespace &#123;</span><br><span class="line"> <span class="keyword">namespace</span> InnerNamespace &#123;</span><br><span class="line">     <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">printY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> OuterNamespace::InnerNamespace::<span class="built_in">printY</span>();  <span class="comment">// 输出: y = 20</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间别名">命名空间别名</h3><p>可以为命名空间定义别名，使得命名空间更易读或更短。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MyNamespace = OuterNamespace::InnerNamespace;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> MyNamespace::<span class="built_in">printY</span>();  <span class="comment">// 输出: y = 20</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-using-指令">使用 using 指令</h3><p>可以使用 <code>using</code> 指令简化对命名空间成员的访问。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入命名空间中的指定成员</span></span><br><span class="line"><span class="keyword">using</span> OuterNamespace::InnerNamespace::y;</span><br><span class="line"><span class="keyword">using</span> OuterNamespace::InnerNamespace::printY;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printY</span>();  <span class="comment">// 输出: y = 20</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <span class="comment">// 输出: y = 20</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="命名空间的作用">命名空间的作用</h3><ol><li><strong>避免命名冲突</strong>：命名空间可以将相似的标识符隔离开来，防止命名冲突。</li><li><strong>提高可读性</strong>：命名空间提供了代码组织的结构，使得代码更易于理解和维护。</li><li><strong>限制作用域</strong>：命名空间中的标识符仅在命名空间内可见，可以控制标识符的可见性，降低了全局作用域的污染。</li><li><strong>组织代码</strong>：通过命名空间，可以将相关联的函数、类和变量组织到一个逻辑单元中，提高代码的模块化和组织性。</li></ol><p>总的来说，命名空间是 C++ 中一种重要的组织代码的机制，可以有效地避免命名冲突，并提高代码的可读性和可维护性。</p></blockquote><blockquote><p>在C++中，指向类成员的指针是一种特殊的指针，用于指向类的非静态成员。这些指针可以用来访问和操作类的成员变量和成员函数。以下是指向类成员的指针的基本语法和用法：</p><h3 id="定义指向类成员的指针">定义指向类成员的指针</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="type">int</span> data;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 成员函数体</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> MyClass::*ptrData = &amp;MyClass::data; <span class="comment">// 指向成员变量的指针</span></span><br><span class="line"> <span class="built_in">void</span> (MyClass::*ptrMemberFunction)() = &amp;MyClass::memberFunction; <span class="comment">// 指向成员函数的指针</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问成员变量">访问成员变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.data = <span class="number">10</span>; <span class="comment">// 直接访问成员变量</span></span><br><span class="line">obj.*ptrData = <span class="number">20</span>; <span class="comment">// 通过指向成员变量的指针访问</span></span><br></pre></td></tr></table></figure><h3 id="调用成员函数">调用成员函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">memberFunction</span>(); <span class="comment">// 直接调用成员函数</span></span><br><span class="line">(obj.*ptrMemberFunction)(); <span class="comment">// 通过指向成员函数的指针调用</span></span><br></pre></td></tr></table></figure><h3 id="指向类成员的指针数组">指向类成员的指针数组</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> MyClass::*ptrs[] = &#123; &amp;MyClass::data, &amp;MyClass::data2 &#125;; <span class="comment">// 指向成员变量的指针数组</span></span><br><span class="line"><span class="built_in">void</span> (MyClass::*ptrsFunc[])() = &#123; &amp;MyClass::memberFunction1, &amp;MyClass::memberFunction2 &#125;; <span class="comment">// 指向成员函数的指针数组</span></span><br></pre></td></tr></table></figure><p>指向类成员的指针的语法如上所示。需要注意的是，指向非静态成员变量的指针需要指定类名、成员变量名和类作用域解析运算符 <code>::</code>，而指向非静态成员函数的指针需要指定返回类型、类名、成员函数名和参数列表，并使用成员函数指针运算符 <code>.*</code> 来调用。</p><p>这种技术在一些场景下很有用，比如回调函数，设计模式中的策略模式等。然而，它需要小心使用，因为它可以绕过访问控制（private、protected、public）和动态多态性（虚函数）的限制，可能导致代码的可读性和安全性问题。</p><h3 id="使用auto关键字简化">使用auto关键字简化</h3><p>可以使用 <code>auto</code> 关键字来简化指向成员函数的指针的类型声明。下面是一个示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Member function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> MyClass obj;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用 auto 关键字声明指向成员函数的指针</span></span><br><span class="line"> <span class="keyword">auto</span> ptr = &amp;MyClass::memberFunction;</span><br><span class="line"></span><br><span class="line"> (obj.*ptr)(<span class="number">10</span>); <span class="comment">// 调用成员函数</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>auto</code> 关键字根据初始化表达式的类型推断了 <code>ptr</code> 的类型，使得代码更简洁。</p></blockquote><blockquote><p><code>.*</code> 和 <code>-&gt;*</code> 是 C++ 中用于访问指向成员的指针的成员函数和成员变量的操作符。</p><h3 id="操作符"><code>.*</code> 操作符</h3><p><code>.*</code> 操作符用于通过指向类成员的指针来访问成员函数或成员变量。它的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(obj.*ptrToMember)(args); <span class="comment">// 调用成员函数</span></span><br><span class="line">value = obj.*ptrToMember; <span class="comment">// 访问成员变量</span></span><br></pre></td></tr></table></figure><ul><li><code>obj</code> 是类对象；</li><li><code>ptrToMember</code> 是指向成员函数或成员变量的指针；</li><li><code>args</code> 是传递给成员函数的参数列表；</li><li><code>value</code> 是成员变量的值。</li></ul><h3 id="操作符-2"><code>-&gt;*</code> 操作符</h3><p><code>-&gt;*</code> 操作符用于通过指向类的指针来访问成员函数或成员变量。它的语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(objPtr-&gt;*ptrToMember)(args); <span class="comment">// 调用成员函数</span></span><br><span class="line">value = objPtr-&gt;*ptrToMember; <span class="comment">// 访问成员变量</span></span><br></pre></td></tr></table></figure><ul><li><code>objPtr</code> 是指向类对象的指针；</li><li><code>ptrToMember</code> 是指向成员函数或成员变量的指针；</li><li><code>args</code> 是传递给成员函数的参数列表；</li><li><code>value</code> 是成员变量的值。</li></ul><h3 id="示例-4">示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Member function called with argument: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.data = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ptrToMemberFunc = &amp;MyClass::memberFunction;</span><br><span class="line">    <span class="keyword">auto</span> ptrToMemberData = &amp;MyClass::data;</span><br><span class="line"></span><br><span class="line">    (obj.*ptrToMemberFunc)(<span class="number">5</span>); <span class="comment">// 调用成员函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data value: &quot;</span> &lt;&lt; obj.*ptrToMemberData &lt;&lt; std::endl; <span class="comment">// 访问成员变量</span></span><br><span class="line"></span><br><span class="line">    MyClass* objPtr = &amp;obj;</span><br><span class="line"></span><br><span class="line">    (objPtr-&gt;*ptrToMemberFunc)(<span class="number">8</span>); <span class="comment">// 通过指针调用成员函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data value: &quot;</span> &lt;&lt; objPtr-&gt;*ptrToMemberData &lt;&lt; std::endl; <span class="comment">// 通过指针访问成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3">总结</h3><p><code>.*</code> 和 <code>-&gt;*</code> 操作符提供了一种在运行时通过指针来访问成员函数和成员变量的方法。它们在处理通过指针调用成员函数和访问成员变量时非常有用。</p></blockquote><blockquote><p>让我们通过一个更具体的示例来解释 <code>.*</code> 和 <code>-&gt;*</code> 操作符的用法。假设有一个简单的事件处理系统，其中有一个 <code>EventHandler</code> 类负责处理事件，并且我们希望能够注册回调函数来处理特定类型的事件。</p><p>首先，我们定义一个 <code>EventHandler</code> 类，其中包含一个处理事件的成员函数 <code>handleEvent</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EventHandler</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">handleEvent</span><span class="params">(<span class="type">int</span> eventId)</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Handling event with ID: &quot;</span> &lt;&lt; eventId &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，假设我们有一个需要在事件发生时调用的回调函数。为了能够通用地处理不同类的事件处理器对象，我们希望将回调函数设计为接受事件处理器对象的指针和事件ID作为参数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callbackFunction</span><span class="params">(<span class="type">void</span> (EventHandler::*ptrToMember)(<span class="type">int</span>), EventHandler* obj, <span class="type">int</span> eventId)</span> </span>&#123;</span><br><span class="line"> (obj-&gt;*ptrToMember)(eventId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个回调函数中，<code>ptrToMember</code> 是一个指向成员函数的指针，它指向 <code>EventHandler</code> 类的 <code>handleEvent</code> 成员函数。<code>obj</code> 是一个指向 <code>EventHandler</code> 对象的指针，它表示事件处理器对象。<code>eventId</code> 是事件的标识符。</p><p>现在，我们可以在主函数中创建 <code>EventHandler</code> 对象和回调函数，并注册回调函数来处理事件：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> EventHandler handler;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 注册回调函数来处理事件</span></span><br><span class="line"> <span class="built_in">callbackFunction</span>(&amp;EventHandler::handleEvent, &amp;handler, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个 <code>EventHandler</code> 对象 <code>handler</code>。然后，我们使用 <code>callbackFunction</code> 函数注册了一个回调函数来处理事件。在注册时，我们传递了成员函数指针 <code>&amp;EventHandler::handleEvent</code>，这表示我们希望在事件发生时调用 <code>EventHandler</code> 类的 <code>handleEvent</code> 成员函数。我们还传递了 <code>handler</code> 对象的指针和事件ID <code>123</code>。</p><p>回调函数 <code>callbackFunction</code> 使用 <code>.*</code> 操作符来调用成员函数指针指向的成员函数。<code>(obj-&gt;*ptrToMember)(eventId)</code> 这行代码实际上调用了 <code>obj</code> 指向的对象的 <code>handleEvent</code> 成员函数，并传递了事件ID作为参数。</p><p>这样，我们就可以实现一个通用的回调函数，它能够处理不同类的事件处理器对象，并在事件发生时调用指定的成员函数。</p></blockquote><blockquote><p>回调函数是一种在编程中常见的技术，它允许你将一个函数作为参数传递给另一个函数，以便在需要时由另一个函数调用。换句话说，回调函数是一个由用户定义的函数，它用作另一个函数的参数，以便在特定事件发生时被调用。</p><p>回调函数通常用于以下几种情况：</p><ol><li><p><strong>事件处理</strong>：当某个特定事件发生时，调用者需要执行某些操作，但具体的操作在调用时可能未知。通过传递一个回调函数作为参数，调用者可以在事件发生时调用该回调函数来执行所需的操作。</p></li><li><p><strong>异步编程</strong>：在多线程或异步编程中，经常需要在某个任务完成时执行特定的回调操作。通过传递一个回调函数，可以在任务完成后通知调用者并执行所需的后续操作。</p></li><li><p><strong>事件驱动编程</strong>：在图形用户界面（GUI）开发中，经常需要在用户与界面交互时执行相应的操作。通过将回调函数与特定的用户操作或界面事件关联起来，可以实现用户界面的响应性和交互性。</p></li></ol><p>下面是一个简单的示例，演示了如何使用回调函数来实现事件处理：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*CallbackFunction)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerCallback</span><span class="params">(CallbackFunction callback)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Callback registered!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 模拟事件发生</span></span><br><span class="line">    <span class="type">int</span> eventId = <span class="number">123</span>;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    <span class="built_in">callback</span>(eventId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eventHandler</span><span class="params">(<span class="type">int</span> eventId)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Event handled with ID: &quot;</span> &lt;&lt; eventId &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注册回调函数</span></span><br><span class="line">    <span class="built_in">registerCallback</span>(eventHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>registerCallback</code> 函数，它接受一个指向回调函数的指针作为参数。然后，我们定义了一个名为 <code>eventHandler</code> 的回调函数，它用于处理事件。在 <code>main</code> 函数中，我们调用 <code>registerCallback</code> 函数，并将 <code>eventHandler</code> 函数的指针作为参数传递给它。当 <code>registerCallback</code> 函数被调用时，它会打印一条消息表示回调函数已注册，并模拟一个事件发生，然后调用传递的回调函数来处理事件。</p><p>回调函数是一种灵活且强大的技术，它可以使代码更具模块化和可重用性，同时也提高了程序的可扩展性和灵活性。</p></blockquote><blockquote><p>多重继承是一种面向对象编程的特性，允许一个类从多个基类派生。在 C++ 中，一个派生类可以同时继承多个基类的成员和方法。这样的继承关系形成了一个继承图，其中一个派生类可能有多个直接或间接的基类。</p><p><strong>各个基类的构造函数的调用顺序由多重继承时指定的顺序，如果在成员初始化器没有显式地调用基类的构造函数，还是会隐式地调用它们的默认构造函数</strong></p><h3 id="语法">语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"> <span class="comment">// Base1 类的成员和方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"> <span class="comment">// Base2 类的成员和方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"> <span class="comment">// Derived 类的成员和方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Derived</code> 类从 <code>Base1</code> 和 <code>Base2</code> 两个基类派生，它继承了这两个基类的成员和方法。</p><h3 id="优点">优点</h3><ol><li><p><strong>代码重用</strong>：多重继承允许派生类从多个基类继承成员和方法，从而可以更方便地重用已有的代码。</p></li><li><p><strong>组合</strong>：通过从多个基类继承，派生类可以将不同的功能组合在一起，形成更复杂的类。</p></li></ol><h3 id="注意事项-2">注意事项</h3><ol><li><p><strong>命名冲突</strong>：多重继承可能导致命名冲突，当多个基类拥有相同名称的成员或方法时，派生类必须明确指定要使用的成员或方法。</p></li><li><p><strong>虚继承</strong>：多重继承中可能出现菱形继承问题（Diamond Inheritance Problem），为了解决这个问题，可以使用虚继承（virtual inheritance）。</p></li><li><p><strong>设计复杂性</strong>：过度使用多重继承可能导致设计变得复杂，增加代码的理解和维护难度。在设计时需要权衡复杂性和灵活性。</p></li></ol><h3 id="示例-5">示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Base1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayBase1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Base2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayBase2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Derived</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayDerived</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    obj.<span class="built_in">displayBase1</span>(); <span class="comment">// 调用来自 Base1 的成员函数</span></span><br><span class="line">    obj.<span class="built_in">displayBase2</span>(); <span class="comment">// 调用来自 Base2 的成员函数</span></span><br><span class="line">    obj.<span class="built_in">displayDerived</span>(); <span class="comment">// 调用来自 Derived 的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Derived</code> 类从 <code>Base1</code> 和 <code>Base2</code> 两个基类派生，它继承了这两个基类的成员函数。在 <code>main</code> 函数中，我们创建了 <code>Derived</code> 类的对象，并调用了来自各个基类和派生类的成员函数。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十八章</title>
      <link href="/posts/66af458a.html"/>
      <url>/posts/66af458a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-第十八章">Cpp复习 第十八章</h1><p>C++中的模板是一种通用编程的工具，使得函数和类能够以独立于具体类型的方式进行定义，从而支持代码复用。模板分为函数模板和类模板，此外还有模板特化、非类型模板参数和模板元编程等高级特性。</p><h3 id="函数模板">函数模板</h3><p>函数模板允许编写独立于具体数据类型的函数。使用函数模板可以避免编写多个功能相同但参数类型不同的函数。</p><h4 id="基本语法">基本语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">max</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>max</code> 是一个函数模板，<code>T</code> 是一个模板参数，表示任意类型。可以用不同的类型实例化这个模板，例如 <code>int</code> 或 <code>double</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3</span>, <span class="number">7</span>) &lt;&lt; std::endl;          <span class="comment">// 实例化为 int 类型的 max 函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">max</span>(<span class="number">3.14</span>, <span class="number">2.71</span>) &lt;&lt; std::endl;    <span class="comment">// 实例化为 double 类型的 max 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类模板">类模板</h3><p>类模板允许编写独立于具体数据类型的类。使用类模板可以定义通用的数据结构，例如栈、队列、链表等。</p><h4 id="基本语法-2">基本语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp; elem)</span> </span>&#123;</span><br><span class="line">        elems.<span class="built_in">push_back</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elems.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用不同的类型实例化这个模板，例如 <code>int</code> 或 <code>std::string</code>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;<span class="type">int</span>&gt; intStack;</span><br><span class="line">    intStack.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line">    std::cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Stack&lt;std::string&gt; stringStack;</span><br><span class="line">    stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板特化">模板特化</h3><p>模板特化允许为特定类型提供不同的实现，分为全特化和偏特化。</p><h4 id="全特化">全特化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span>&lt;<span class="type">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">bool</span>&gt; elems;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">bool</span> elem)</span> </span>&#123;</span><br><span class="line">        elems.<span class="built_in">push_back</span>(elem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;bool&gt;::pop(): empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        elems.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">top</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;bool&gt;::top(): empty stack&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="偏特化（类模板）">偏特化（类模板）</h4><p>偏特化只适用于类模板，不适用于函数模板。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">    <span class="comment">// 通用实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="comment">// 指针类型的偏特化实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数">非类型模板参数</h3><p>非类型模板参数允许模板参数是一个常量值而不是类型。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T elems[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> elems[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以用不同的类型和大小实例化这个模板：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Array&lt;<span class="type">int</span>, <span class="number">10</span>&gt; intArray;</span><br><span class="line">    std::cout &lt;&lt; intArray.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Array&lt;<span class="type">double</span>, <span class="number">5</span>&gt; doubleArray;</span><br><span class="line">    std::cout &lt;&lt; doubleArray.<span class="built_in">getSize</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板元编程">模板元编程</h3><p>模板元编程是一种在编译期进行计算的编程技术，可以用于生成复杂的数据结构和算法。</p><h4 id="简单的例子：计算阶乘">简单的例子：计算阶乘</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial&lt;5&gt;::value = &quot;</span> &lt;&lt; Factorial&lt;<span class="number">5</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Factorial&lt;5&gt;::value = 120</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>Factorial&lt;5&gt;</code> 在编译期计算出结果 <code>120</code>。</p><h3 id="总结">总结</h3><ul><li><strong>函数模板</strong>：用于定义独立于数据类型的函数。</li><li><strong>类模板</strong>：用于定义独立于数据类型的类。</li><li><strong>模板特化</strong>：用于为特定类型提供不同的实现。</li><li><strong>非类型模板参数</strong>：允许模板参数是常量值。</li><li><strong>模板元编程</strong>：在编译期进行计算。</li></ul><p>模板是C++中非常强大且灵活的特性，使得编写高效、通用的代码成为可能。通过理解和使用模板，可以大大提升代码的复用性和可维护性。</p><blockquote><p><strong>注意：如果要使用用户自定义类型来创建一个模板的特化，那么用户提供的自定义类型，需要满足模板的要求。</strong><br>比方说可能要重载运算符&lt;或者需要调用某一个函数。</p></blockquote><blockquote><p>Class templates are called parameterized types, because they require one or more type parameters to specify how to customize a generic class template to form a class-template specialization.<br>When a particular specialization is needed, you use a concise, simple notation, and the compiler writes the specialization source code.</p><p>类模板称为参数化类型，因为它们需要一个或多个类型参数来指定如何自定义泛型类模板<br>以形成类模板专门化。<br>当需要特定的专门化时，使用简洁、简单的符号，由编译器编写专门化源代码。</p></blockquote><p><strong>注意：所有类模板都需要以关键字template开始，后面是括在一对尖括号(&lt;和&gt;)中的模板形参表</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>/<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br></pre></td></tr></table></figure><p><code>deque</code>（双端队列）和 <code>vector</code> 是 C++ 标准库中两种常用的容器，它们在内部实现、性能特征和使用场景上有显著区别。了解它们之间的区别有助于在编程中做出最佳选择。</p><h3 id="基本定义">基本定义</h3><ul><li><strong>vector</strong>：一种动态数组，提供连续的内存存储，支持高效的随机访问。</li><li><strong>deque</strong>：双端队列，支持在两端高效插入和删除操作，内部实现通常是分段连续的（即一系列连续的小块）。</li></ul><h3 id="内部实现">内部实现</h3><ul><li><strong>vector</strong>：使用单一的连续内存块存储元素。如果需要扩展容量，会分配一个更大的内存块，并将原有元素复制到新内存块。</li><li><strong>deque</strong>：使用一系列固定大小的内存块来存储元素，这些块由一个指向块指针的数组管理。这样实现使得在头尾插入和删除元素更加高效。</li></ul><h3 id="内存布局">内存布局</h3><ul><li><strong>vector</strong>：连续存储，所有元素在内存中是紧密排列的。这使得<code>vector</code>可以提供高效的随机访问，支持常数时间复杂度的索引操作。</li><li><strong>deque</strong>：分段存储，元素分布在多个小的连续内存块中。这使得在两端进行插入和删除操作更为高效，但随机访问的性能稍逊于<code>vector</code>。</li></ul><h3 id="访问和修改性能">访问和修改性能</h3><ul><li><strong>随机访问</strong>：<ul><li><code>vector</code>：提供常数时间复杂度的随机访问（通过索引）。</li><li><code>deque</code>：提供平均常数时间复杂度的随机访问，但由于分段存储，访问性能稍差于<code>vector</code>。</li></ul></li><li><strong>插入和删除</strong>：<ul><li><code>vector</code>：在尾部插入和删除操作是常数时间复杂度，但在中间或头部插入和删除需要线性时间复杂度，因为需要移动元素。</li><li><code>deque</code>：在头部和尾部插入和删除操作都是常数时间复杂度，因为只需调整指针而不必移动元素。</li></ul></li></ul><h3 id="迭代器">迭代器</h3><ul><li><strong>vector</strong>：由于连续存储，<code>vector</code> 的迭代器是随机访问迭代器，支持所有标准迭代器操作。</li><li><strong>deque</strong>：迭代器也是随机访问迭代器，但由于分段存储，其实现更复杂，性能可能不如 <code>vector</code> 的迭代器。</li></ul><h3 id="使用场景">使用场景</h3><ul><li><strong>vector</strong>：适合需要频繁随机访问，插入和删除操作主要在尾部进行的场景。典型使用包括动态数组、栈实现等。</li><li><strong>deque</strong>：适合需要在两端频繁插入和删除元素的场景，如双端队列、滑动窗口等。</li></ul><h3 id="示例代码">示例代码</h3><p>以下是 <code>vector</code> 和 <code>deque</code> 的一些简单示例，展示它们的用法和性能特征。</p><h4 id="vector-示例">vector 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 5: &quot;</span> &lt;&lt; vec[<span class="number">5</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾部插入</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 中间插入</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>() + <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="deque-示例">deque 示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        deq.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机访问</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 5: &quot;</span> &lt;&lt; deq[<span class="number">5</span>] &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尾部插入</span></span><br><span class="line">    deq.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 头部插入</span></span><br><span class="line">    deq.<span class="built_in">push_front</span>(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> elem : deq) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><ul><li><strong>vector</strong>：连续存储，适合需要高效随机访问和在尾部进行插入删除的场景。</li><li><strong>deque</strong>：分段存储，适合需要在两端高效插入删除的场景，随机访问性能稍逊于<code>vector</code>。</li></ul><p>选择合适的容器取决于具体的使用场景和性能需求。</p><blockquote><p>Class Template Stack<T>’s Data Representation<br>A stack requires insertions and deletions only at its top.<br>So, for example, a vector or a deque could be used to store the stack’s elements.<br>A vector supports fast insertions and deletions at its back.<br>A deque supports fast insertions and deletions at its front and its back.<br>A deque is the default representation for the Standard Library’s stack adapter because a deque grows more efficiently than a vector.</p><p>类模板栈<T>的数据表示<br>堆栈只需要在顶部进行插入和删除操作。<br>例如，可以使用vector或deque来存储堆栈的元素。<br>vector支持在其背面快速插入和删除。<br>deque支持前端和尾部的快速插入和删除操作。<br>deque是标准库堆栈适配器的默认表示形式，因为deque比vector增长更有效。</p></blockquote><blockquote><p>A vector is maintained as a contiguous block of memory—when that block is full and a new element is added, the vector allocates a larger contiguous block of memory and copies the old elements into that new block.<br>A deque, on the other hand, is typically implemented as list of fixed-size, built-in arrays—new fixed-size built-in arrays are added as necessary and none of the existing elements are copied when new items are added to the front or back.<br>For these reasons, we use a deque (line 42) as the underlying container for our Stack class.</p><p>vector是作为一个连续的内存块来维护的——当该内存块已满并添加新元素时，vector会分配一个更大的连续内存块，并将旧元素复制到新内存块中。<br>另一方面，deque通常是作为固定大小的内置数组列表实现的——根据需要添加新的固定大小的内置数组，并且当向前面或后面添加新项时，不会复制现有元素。<br>由于这些原因，我们使用deque(第42行)作为Stack类的底层容器。</p></blockquote><blockquote><p>Declaring a Class Template’s Member Functions Outside the Class Template Definition<br>Though we did not do so in our Stack class template, member-function definitions can appear outside a class template definition.<br>If you do this, each must begin with the template keyword followed by the same set of template parameters as the class template.<br>In addition, the member functions must be qualified with the class name and scope resolution operator.<br>在类模板定义之外声明类模板的成员函数<br>虽然在Stack类模板中没有这样做，但成员函数定义可以出现在类模板定义之外。<br>如果这样做，每个模板都必须以template关键字开头，后跟与类模板相同的一组模板参数。<br>此外，成员函数必须使用类名和作用域解析操作符进行限定。</p></blockquote><blockquote><p>For example, you can define the pop function outside the class-template definition as follows:<br>template&lt; typename T &gt;<br>inline void Stack<T>::pop()<br>{<br>stack.pop_front();<br>} // end function template pop<br>Stack<T>:: indicates that pop is in the scope of class Stack<T>.<br>The Standard Library’s container classes tend to define all their member functions inside their class definitions.<br>例如，你可以在类模板定义之外定义pop函数，如下所示:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>()</span><br><span class="line">&#123;</span><br><span class="line">stack.<span class="built_in">pop_front</span> ();</span><br><span class="line">&#125; <span class="comment">//结束函数模板pop</span></span><br></pre></td></tr></table></figure><p>Stack<T>::表示pop在类Stack<T>的作用域中。</p><p>标准库的容器类倾向于在其类定义中定义其所有成员函数。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608013650662.png" alt="image-20240608013650662"></p><p><img src="C:%5CUsers%5C22635%5CDesktop%5C%E6%95%B4%E5%90%88%5C%E7%AC%94%E8%AE%B0%5Ccpp%5Cimage-20240608013658864.png" alt="image-20240608013658864"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608013713874.png" alt="image-20240608013713874"></p><blockquote><p>Function template testStack uses T (specified at line 10) to represent the data type stored in the Stack<T>.<br>The function template takes five arguments (lines 12–16):<br>the Stack<T> to manipulate<br>a value of type T that will be the first value pushed onto the Stack<T><br>a value of type T used to increment the values pushed onto the Stack<T><br>the number of elements to push onto the Stack<T><br>a string that represents the name of the Stack<T> object for output purposes</p><p>函数模板testStack使用T(在第10行指定)来表示存储在Stack<T>中的数据类型。<br>函数模板接受5个参数(第12-16行):<br>要操作的Stack<T><br>类型为T的值，它将是第一个压入堆栈的值<T><br>一个T类型的值，用于增加压入Stack的值<T><br>要压入堆栈的元素数<T><br>用于输出目的的表示Stack<T>对象名称的字符串</p></blockquote><blockquote><p>Function main (lines 41–50) instantiates an object of type Stack<double> called doubleStack (line 43) and an object of type Stack<int> called intStack (line 47) and uses these objects in lines 45 and 49.<br>The compiler infers the type of T for testStack from the type used to instantiate the function’s first argument (i.e., the type used to instantiate doubleStack or intStack).</p><p>函数main(第41-50行)实例化了一个名为doubleStack的Stack<double>类型对象(第43行)和一个名为intStack的Stack<int>类型对象(第47行)，并在第45行和第49行使用了这些对象。</p><p>编译器从用于实例化函数第一个参数的类型，(即用于实例化doubleStack或intStack的类型)推断出testStack的T类型。</p></blockquote><blockquote><p>非类型形参：可以在模板的参数列表中使用非类型模板形参，它可以具有默认的实参，并且是作为常数处理。<br>eg：array类模板 template&lt;class T,size_t N&gt;</p></blockquote><blockquote><p>In addition, a type parameter can specify a default type argument.<br>For example, the C++ standard’s stack container adapter class template begins with:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt; T &gt; &gt;</span><br></pre></td></tr></table></figure><p>which specifies that a stack uses a deque by default to store the stack’s elements of type T.<br>此外，类型形参可以指定默认类型实参。<br>例如，c++标准的堆栈容器适配器类模板以：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = deque&lt; T &gt; &gt;</span><br></pre></td></tr></table></figure><p>它指定堆栈在默认情况下使用deque来存储堆栈的T类型元素。</p></blockquote><blockquote><p>Default type parameters must be the rightmost (trailing) parameters in a template’s type-parameter list.<br>When you instantiate a template with two or more default arguments, if an omitted argument is not the rightmost, then all type parameters to the right of it also must be omitted.<br>As of C++11, you can now use default type arguments for template type parameters in function templates.</p><p>默认类型参数必须是模板类型参数列表中最右边(末尾)的参数。</p><p><strong>当使用两个或更多默认实参实例化模板时，如果省略的实参不是最右边的，那么它右边的所有类型形参也必须省略。</strong></p><p>从c++11开始，现在可以在函数模板中为模板类型形参使用默认类型实参。</p></blockquote><blockquote><p>Function templates and overloading are intimately related.<br>In Section 6.19, you learned that when overloaded functions perform identical operations on different types of data, they can be expressed more compactly and conveniently using function templates.<br>You can then write function calls with different types of arguments and let the compiler generate separate function-template specializations to handle each function call appropriately.<br>The function-template specializations generated from a given function template all have the same name, so the compiler uses overload resolution to invoke the proper function.<br>函数模板和重载密切相关。<br>在第6.19节中，您了解了当重载函数对不同类型的数据执行相同的操作时，可以使用函数模板更紧凑、更方便地表示它们。</p><p>然后，您可以使用不同类型的参数编写函数调用，并让编译器生成单独的函数模板专门化，以适当地处理每个函数调用。</p><p>从给定函数模板生成的函数模板专门化都具有相同的名称，因此编译器使用重载解析来调用适当的函数。</p></blockquote><blockquote><p>You may also overload function templates.<br>For example, you can provide other function templates that specify the same function name but different function parameters.<br>A function template also can be overloaded by providing nontemplate functions with the same function name but different function parameters.<br>你也可以重载函数模板。</p><p>例如，您可以提供指定相同函数名称但不同函数参数的其他函数模板。</p><p>函数模板也可以通过提供具有相同函数名但不同函数参数的非模板函数来重载。</p></blockquote><blockquote><p>Matching Process for Overloaded Functions<br>The compiler performs a matching process to determine what function to call when a function is invoked.<br>It looks at both existing functions and function templates to locate a function or generate a function-template specialization whose function name and argument types are consistent with those of the function call.<br>If there are no matches, the compiler issues an error message. If there are multiple matches for the function call, the compiler attempts to determine the best match.<br>If there’s more than one best match, the call is ambiguous and the compiler issues an error message.</p><p>重载函数的匹配过程<br>编译器执行匹配过程，以确定在调用函数时调用哪个函数。</p><p>它查看现有函数和函数模板来定位函数或生成函数模板专门化，其函数名和参数类型与函数调用的函数名和参数类型一致。</p><p>如果没有匹配项，编译器将发出错误消息。</p><p>如果函数调用有多个匹配项，编译器将尝试确定最佳匹配项。</p><p>如果有多个最佳匹配，则调用是二义性的，编译器会发出错误消息。</p><p>如果调用时，函数模板和非模板函数都适用，那么将调用非模板的版本。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十七章</title>
      <link href="/posts/91c46dc9.html"/>
      <url>/posts/91c46dc9.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cpp复习-第十七章">Cpp复习 第十七章</h1><p>在浮点运算中，许多c++实现允许除零，在这种情况下，正无穷大或负无穷大分别显示为INF或-INF</p><blockquote><h3 id="C-中的异常处理-Exception-Handling">C++ 中的异常处理 (Exception Handling)</h3><p>异常处理是一种控制结构，用于处理程序中的错误和异常情况，使程序能够在遇到错误时采取适当的措施而不是直接崩溃。在 C++ 中，异常处理机制使用 <code>try</code>、<code>throw</code> 和 <code>catch</code> 关键字来实现。</p><h4 id="基本语法">基本语法</h4><ol><li><strong><code>try</code> 块</strong>：包含可能会抛出异常的代码。</li><li><strong><code>throw</code> 语句</strong>：用于抛出一个异常。</li><li><strong><code>catch</code> 块</strong>：用于捕获异常并处理。</li></ol><h4 id="示例">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  <span class="comment">// 包含标准异常类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> error = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常类">异常类</h3><p>C++ 标准库提供了一些常用的异常类，这些类都继承自 <code>std::exception</code>：</p><ul><li><code>std::logic_error</code></li><li><code>std::runtime_error</code></li><li><code>std::bad_alloc</code>（用于内存分配失败）</li><li><code>std::out_of_range</code></li><li><code>std::invalid_argument</code></li></ul><h4 id="自定义异常类">自定义异常类</h4><p>你可以定义自己的异常类，继承自 <code>std::exception</code> 或其他标准异常类：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My custom exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught my exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈展开-Stack-Unwinding">栈展开 (Stack Unwinding)</h3><p>当一个异常被抛出时，C++ 运行时系统会进行栈展开，即逐层退出函数调用栈直到找到一个匹配的 <code>catch</code> 块。如果在栈展开过程中需要执行清理操作（如释放资源），应该在类的析构函数中进行，因为析构函数会在对象离开作用域时自动调用。</p><h4 id="示例-2">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource released</span><br><span class="line">Caught an exception: Error occurred</span><br><span class="line">Program continues...</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><ol><li><strong>异常处理</strong>：使用 <code>try</code>、<code>throw</code> 和 <code>catch</code> 进行。</li><li><strong>标准异常类</strong>：C++ 标准库提供了一些常用的异常类，便于错误处理。</li><li><strong>自定义异常类</strong>：可以继承标准异常类来创建自定义异常。</li><li><strong>栈展开</strong>：异常抛出后，系统会进行栈展开，析构函数会在此过程中被调用，确保资源被释放。</li></ol><p>异常处理机制使得程序可以在遇到错误时采取适当的措施，而不是直接崩溃，从而提高程序的健壮性和可维护性。</p></blockquote><blockquote><p>A typical exception class that derives from the runtime_error class defines only a constructor (e.g., lines 11–12) that passes an error-message string to the base-class runtime_error constructor.<br>Every exception class that derives directly or indirectly from exception contains the virtual function what, which returns an exception object’s error message.<br>You are not required to derive a custom exception class, such as DivideByZeroException, from the standard exception classes provided by C++.<br>Doing so allows you to use the virtual function what to obtain an appropriate error message.<br>We use an object of this DivideByZeroException class in Fig. 17.2 to indicate when an attempt is made to divide by zero.<br>从runtime_error类派生的典型异常类只定义一个构造函数(例如，第11-12行)，该构造函数将错误消息字符串传递给基类runtime_error构造函数。<br>每个直接或间接从exception派生的异常类都包含虚函数what，它返回异常对象的错误消息。<br>您不需要从c++提供的标准异常类派生自定义异常类，例如DivideByZeroException。<br>但是，这样做允许您使用虚函数what来获得适当的错误消息。<br>在图17.2中，我们使用DivideByZeroException类的一个对象来指示何时尝试除零。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608155155834.png" alt="image-20240608155155834"></p><blockquote><p>Demonstrating Exception Handling<br>Fig. 17.2 uses exception handling to wrap code that might throw a DivideByZeroException and to handle that exception, should one occur.<br>Function quotient divides its first parameter (numerator) by its second parameter (denominator).<br>Assuming that the user does not specify 0 as the denominator for the division, quotient returns the division result.<br>However, if the user inputs 0 for the denominator, function quotient throws an exception.<br>演示异常处理<br>图17.2使用异常处理来包装可能抛出DivideByZeroException的代码，并在出现异常时处理该异常。<br>函数商将它的第一个参数(分子)除以它的第二个参数(分母)。<br>假设用户没有指定0作为除法的分母，那么quotient将返回除法结果。<br>但是，如果用户为分母输入0，则函数quotient抛出异常。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608155348998.png" alt="image-20240608155348998"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608155355435.png" alt="image-20240608155355435"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608155402213.png" alt="image-20240608155402213"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608155416381.png" alt="image-20240608155416381"></p><blockquote><p>Enclosing Code in a try Block<br>Exception handling is geared to situations in which the function that detects an error is unable to handle it.<br>try blocks enable exception handling.<br>The try block encloses statements that might cause exceptions and statements that should be skipped if an exception occurs.<br>In this example, because the invocation of function quotient (line 34) can throw an exception, we enclose this function invocation in a try block.<br>Enclosing the output statement (line 35) in the try block ensures that the output will occur only if function quotient returns a result.</p><p>在try块中封装代码<br>异常处理适用于检测到错误的函数无法处理错误的情况。<br>Try块启用异常处理。<br>try块包含可能导致异常的语句和在发生异常时应该跳过的语句。<br>在本例中，由于调用函数quotient(第34行)会抛出异常，因此我们将该函数调用包含在try块中。<br>在try块中封装输出语句(第35行)确保只有当函数quotient返回结果时才会输出。</p></blockquote><p><strong>异常可能出现在try语句块中明确提到的代码中，有可能在try语句块中的代码对其他函数的调用或者嵌套调用。</strong></p><blockquote><p>Defining a catch Handler to Process a DivideByZeroException<br>Exceptions are processed by catch handlers.<br>At least one catch handler (lines 37–41) must immediately follow each try block.<br>An exception parameter should always be declared as a reference to the type of exception the catch handler can process (DivideByZeroException in this case)—this prevents copying the exception object when it’s caught and allows a catch handler to properly catch derived-class exceptions as well.<br>When an exception occurs in a try block, the catch handler that executes is the first one whose type matches the type of the exception that occurred (i.e., the type in the catch block matches the thrown exception type exactly or is a direct or indirect base class of it).<br>定义一个catch处理程序来处理一个DivideByZeroException：<br>异常由catch处理程序处理。<br>在每个try块之后必须立即执行至少一个catch处理程序(第37-41行)。<br>异常参数应该始终声明为catch处理程序可以处理的异常类型的引用(在本例中是DivideByZeroException)——这可以防止在捕获异常对象时复制异常对象，并允许catch处理程序正确捕获派生类异常。<br>当在try块中发生异常时，执行的catch处理程序是第一个类型与发生的异常类型匹配的处理程序(即，catch块中的类型与抛出的异常类型完全匹配，或者是它的直接或间接基类)。</p><p>If an exception parameter includes an optional parameter name, the catch handler can use that parameter name to interact with the caught exception in the body of the catch handler, which is delimited by braces ({ and }).<br>A catch handler typically reports the error to the user, logs it to a file, terminates the program gracefully or tries an alternate strategy to accomplish the failed task.<br>In this example, the catch handler simply reports that the user attempted to divide by zero. Then the program prompts the user to enter two new integer values.<br>如果异常参数包含可选参数名，catch处理程序可以使用该参数名与catch处理程序体中捕获的异常进行交互，该处理程序体由大括号({和})分隔。<br>catch处理程序通常向用户报告错误，将其记录到文件中，优雅地终止程序或尝试替代策略来完成失败的任务。<br>在本例中，catch处理程序只是报告用户试图除以0。然后程序提示用户输入两个新的整数值。</p></blockquote><p>注意：1、<strong>try语句块和catch语句之间不能有其他的代码。</strong><br>2、<strong>一个catch处理器只能由一个参数。</strong><br>3、<strong>不同的catch处理器捕获的异常必须是不同的，否则会编译错误。</strong></p><blockquote><p><strong>Termination Model of Exception Handling</strong></p><p>If an exception occurs as the result of a statement in a try block, the try block expires (i.e., terminates immediately).</p><p>Next, the program searches for the first catch handler that can process the type of exception that occurred.</p><p>The program locates the matching catch by comparing the thrown exception’s type to each catch’s exception-parameter type until the program finds a match.</p><p>A match occurs if the types are <em>identical</em> or if the thrown exception’s type is a <em>derived class</em> of the exception-parameter type.</p><p>When a match occurs, the code in the matching catch handler executes.</p><p>异常处理的终止模型<br>如果由于try块中的语句而发生异常，则try块将过期(即立即终止)。<br>接下来，程序搜索第一个可以处理所发生异常类型的catch处理程序。<br>程序通过将抛出异常的类型与每个catch的异常参数类型进行比较，直至找到匹配的catch，从而定位匹配的catch。<br>如果类型相同，或者抛出异常的类型是异常参数类型的派生类，则会发生匹配。<br>当出现匹配时，执行匹配catch处理程序中的代码。</p><p>When a catch handler finishes processing by reaching its closing right brace (}), the exception is considered handled and the local variables defined within the catch handler (including the catch parameter) go out of scope.</p><p>Program control does <em>not</em> return to the point at which the exception occurred (known as the throw point), because the try block has <em>expired</em>.</p><p>Rather, control resumes with the first statement after the last catch handler following the try block.</p><p>This is known as the termination model of exception handling.</p><p>As with any other block of code, <em>when a</em> <em>try</em> <em>block terminates, local variables defined in the block go out of scope</em>.</p><p>当catch处理程序通过到达右括号(})结束处理时，认为异常已处理，并且在catch处理程序中定义的局部变量(包括catch形参)超出了作用域。<br>程序控制不会返回到发生异常的点(称为抛出点)，因为try块已经过期。<br>相反，控制在try块后面的最后一个catch处理程序之后的第一个语句中恢复。<br>这被称为异常处理的终止模型。<br>与任何其他代码块一样，当try块终止时，块中定义的局部变量将超出作用域。</p><p>还有另外一种模式：恢复模式，控制将在异常抛出后重新开始。</p><p>异常处理可以让程序在解决问题后，能够继续运行，保证了程序的健壮性。</p></blockquote><blockquote><p>Flow of Program Control When the User Enters a Denominator of Zero<br>As part of throwing an exception, the throw operand is created and used to initialize the parameter in the catch handler, which we discuss momentarily.<br>Central characteristic of exception handling: If your program explicitly throws an exception, it should do so before the error has an opportunity to occur.<br>In general, when an exception is thrown within a try block, the exception is caught by a catch handler that specifies the type matching the thrown exception.<br>当用户输入分母为零时的程序控制流程<br>作为抛出异常的一部分，将创建throw操作数，并使用该操作数初始化catch处理程序中的参数，稍后将对此进行讨论。<br>异常处理的核心特征：如果程序显式抛出异常，它应该在错误有机会发生之前抛出异常。<br>通常，当在try块中抛出异常时，该异常由catch处理程序捕获，该处理程序指定与所抛出异常匹配的类型。</p><p>throw语句用于指定一个抛出的操作数<br>In this program, the catch handler specifies that it catches DivideByZeroException objects—this type matches the object type thrown in function quotient.<br>Actually, the catch handler catches a reference to the DivideByZeroException object created by function quotient’s throw statement.<br>The exception object is maintained by the exception-handling mechanism.<br>在这个程序中，catch处理程序指定它捕获DivideByZeroException对象——该类型与函数quotient中抛出的对象类型匹配。<br>实际上，catch处理程序捕获对DivideByZeroException对象的引用，该对象是由function quotient的throw语句创建的。<br>异常对象由异常处理机制维护。</p></blockquote><p><strong>将每种运行时的错误与一个有相应名称的异常类型结合，可以提高程序的清晰度。</strong></p><p><strong>重新抛出异常，就是由异常处理器接受到异常后，再次抛出一个异常进行处理。</strong></p><p><strong>在处理器外部更进一步处理而重新抛出异常，外层的try语句将检测这个重新抛出的异常，其之后的catch语句负责捕捉处理异常。</strong></p><p>参考以下例子：</p><p>这里不需要用到异常参数，所以直接使用&amp;即可，不需要参数名</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608162505808.png" alt="image-20240608162505808"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608162513292.png" alt="image-20240608162513292"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608162526819.png" alt="image-20240608162526819"></p><p>堆栈展开：一般用于函数嵌套调用，如果在某一个函数中抛出异常，但是没有try…catch语句块来捕获，那么当前函数中所有在该函数体内初始化的局部变量都将被销毁，并且返回上一级函数，查看有没有try…catch语句，如果有，则捕获抛出异常并且处理，否则按照上面的内容类推。可以具体查看以下例子：</p><blockquote><p>When an exception is thrown but not caught in a particular scope, the function call stack is “unwound,” and an attempt is made to catch the exception in the next outer try…catch block.<br>Unwinding the function call stack means that the function in which the exception was not caught terminates, all local variables that have completed intitialization in that function are destroyed and control returns to the statement that originally invoked that function.<br>If a try block encloses that statement, an attempt is made to catch the exception.<br>If a try block does not enclose that statement, stack unwinding occurs again.<br>If no catch handler ever catches this exception, the program terminates.<br>The program of Fig. 17.4 demonstrates stack unwinding.<br>当抛出异常但未在特定范围内捕获异常时，将“展开”函数调用堆栈，并尝试在下一个外部try…catch块中捕获异常。<br>展开函数调用堆栈意味着未捕获异常的函数终止，该函数中已完成初始化的所有局部变量将被销毁，控制返回到最初调用该函数的语句。<br>如果try块包含该语句，则尝试捕获异常。<br>如果try块没有包含该语句，则再次执行堆栈展开。<br>如果没有捕获处理程序捕获此异常，则程序终止。<br>图17.4的程序演示了堆栈展开。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608163916400.png" alt="image-20240608163916400"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608163923105.png" alt="image-20240608163923105"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608163932020.png" alt="image-20240608163932020"></p><blockquote><p>Exception handling is designed to process synchronous errors, which occur when a statement executes, such as out-of-range array subscripts, arithmetic overflow (i.e., a value outside the representable range of values), division by zero, invalid function parameters and unsuccessful memory allocation (due to lack of memory).<br>Exception handling is not designed to process errors associated with asynchronous events (e.g., disk I/O completions, network message arrivals, mouse clicks and keystrokes), which occur in parallel with, and independent of, the program’s flow of control.<br>异常处理的设计目的是处理同步错误，这种错误在语句执行时发生，例如超出范围的数组下标、算术溢出(即值超出可表示范围)、除零、无效的函数参数和不成功的内存分配(由于缺乏内存)。<br>异常处理不是设计用来处理与异步事件(例如，磁盘I/O完成、网络消息到达、鼠标点击和击键)相关的错误的，这些错误与程序的控制流并行发生，并且独立于程序的控制流。</p></blockquote><p><strong>异常处理有助于在同一个大型项目中的程序员相互了解各自的错误处理代码。</strong></p><p><strong>带有常见错误情况的函数应该返回nullptr，0或者其他合适的值，而不是抛出异常，这样就可以让调用函数的程序通过检查返回值来确定函数调用是否成功。</strong></p><p>异常问题可以解决预定义组件和由预定义组件构成的特定组件的问题，当预定义组件遇到问题时，可以通过异常处理来与特定组件进行沟通。（预定义组件一开始就是定义好的，无法预知接下来可能会出现的问题）</p><blockquote><p>C++11: Declaring Functions That Do Not Throw Exceptions<br>As of C++11, if a function does not throw any exceptions and does not call any functions that throw exceptions, you should explicitly state that a function does not throw exceptions.<br>This indicates to client-code programmers that there’s no need to place calls to the function in a try block.<br>Add noexcept to the right of the function’s parameter list in both the prototype and the definition.<br>For a const member function, place noexcept after const.<br>If a function that’s declared noexcept calls another function that throws an exception or executes a throw statement, the program terminates.<br>c++ 11:声明不抛出异常的函数<br>从c++ 11开始，如果函数不抛出任何异常，也不调用任何抛出异常的函数，则应该显式声明函数不抛出异常。<br>这向客户端代码程序员表明，不需要将对函数的调用放在try块中。<br>在原型和定义的函数参数列表的右侧添加noexcept。<br>对于const成员函数，在const之后放置noexcept。<br>如果声明为noexcept的函数调用另一个抛出异常或执行throw语句的函数，则程序终止。</p></blockquote><p>下面的内容和上面的内容可能有点割裂，耐心看。</p><blockquote><p>The preferred alternative is to require the constructor to throw an exception that contains the error information, thus offering an opportunity for the program to handle the failure.<br>Before an exception is thrown by a constructor, destructors are called for any member objects whose constructors have run to completion as part of the object being constructed.<br>Destructors are called for every automatic object constructed in a try block before the exception is caught.<br>Stack unwinding is guaranteed to have been completed at the point that an exception handler begins executing.<br>If a destructor invoked as a result of stack unwinding throws an exception, the program terminates.<br>This has been linked to various security attacks.<br>首选的替代方法是要求构造函数抛出包含错误信息的异常，从而为程序提供处理故障的机会。</p><p><strong>在构造函数抛出异常之前，对其构造函数作为正在构造的对象的一部分运行到完成的任何成员对象调用析构函数。</strong><br><strong>在捕获异常之前，对在try块中构造的每个自动对象调用析构函数。</strong><br><strong>栈展开保证在异常处理程序开始执行时完成。</strong></p><p>如果由于堆栈展开而调用的析构函数抛出异常，则程序终止。这与各种安全攻击有关。</p></blockquote><p>注意：析构函数应该是捕捉异常，而不是抛出异常。</p><blockquote><p>在C++中，如果在异常传播过程中（即堆栈展开期间）一个析构函数抛出异常，将会导致程序调用<code>std::terminate</code>并立即终止。这是因为在C++中，异常的处理机制设计为在同一时间只能有一个活动异常。如果一个异常正在传播，而另一个异常在此过程中被抛出，系统将不知道如何处理多个同时存在的异常，因而选择终止程序。</p><h3 id="为什么在析构函数中抛出异常会导致程序终止">为什么在析构函数中抛出异常会导致程序终止</h3><p>堆栈展开期间，程序需要释放资源和调用栈上的所有对象的析构函数。如果析构函数在释放资源时抛出异常，这将会导致程序在处理中出现两个活动异常（一个是原本正在处理的异常，另一个是析构函数抛出的新异常）。这会导致无法正确管理异常的控制流。</p><p>以下是一个示例，展示了在堆栈展开期间析构函数抛出异常的情况：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Resource destructor called\n&quot;</span>;</span><br><span class="line">     <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Destructor exception&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Resource res;</span><br><span class="line"> <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Original exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">mightGoWrong</span>();</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当 <code>mightGoWrong</code> 函数抛出“Original exception”异常时，程序会进入堆栈展开过程，调用<code>Resource</code>对象的析构函数。而在析构函数中抛出了另一个异常“Destructor exception”，这会导致程序调用<code>std::terminate</code>并立即终止。</p><h3 id="与安全攻击的关系">与安全攻击的关系</h3><p>这种情况不仅仅是技术细节问题，还与安全性有关。在安全攻击中，攻击者可能会试图利用程序的不当行为或未处理的异常来执行恶意代码。如下几种情况：</p><ol><li><strong>资源泄漏</strong>：如果在堆栈展开过程中，析构函数抛出异常，资源可能无法正确释放。这可能导致资源泄漏，攻击者可能利用这一点耗尽系统资源。</li><li><strong>不确定行为</strong>：未处理的异常可能导致程序以不确定的方式行为，攻击者可以利用这种不确定性来破坏程序的正常执行流程。</li><li><strong>崩溃利用</strong>：攻击者可能通过故意触发异常并利用程序崩溃的行为来获得对系统的控制。</li></ol><h3 id="如何防止析构函数抛出异常">如何防止析构函数抛出异常</h3><p>为了避免这些问题，通常的做法是在析构函数中捕获并处理所有可能的异常，确保析构函数不会抛出异常。以下是一个示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Destructor exception&quot;</span>);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Exception caught in destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 处理异常（例如，记录日志、释放资源等），确保不抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Original exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><p>在析构函数中抛出异常会导致程序终止，这与异常处理机制设计有关，也是为了防止出现未处理的多个异常导致程序行为不确定或资源泄漏等问题。为了保证程序的健壮性和安全性，应该确保析构函数不会抛出异常，通常通过在析构函数中捕获并处理所有可能的异常来实现。这样可以确保在堆栈展开期间正确释放资源，避免程序因未处理的异常而崩溃。</p></blockquote><blockquote><p>If an object has member objects, and if an exception is thrown before the outer object is fully constructed, then destructors will be executed for the member objects that have been constructed prior to the occurrence of the exception.<br>If an array of objects has been partially constructed when an exception occurs, only the destructors for the constructed objects in the array will be called.<br>如果对象具有成员对象，并且在外部对象完全构造之前抛出异常，则将对在异常发生之前构造的成员对象执行析构函数。<br>如果在发生异常时已经部分构造了对象数组，则只调用数组中构造对象的析构函数。</p></blockquote><blockquote><p>在 C++ 中，正确地管理资源（如内存、文件句柄、网络连接等）是非常重要的。一个常见的模式是使用局部对象的构造函数和析构函数来管理资源的分配和释放。这种模式被称为 RAII（Resource Acquisition Is Initialization，资源获取即初始化）。</p><h3 id="RAII-模式">RAII 模式</h3><p>RAII 的核心思想是将资源的分配和释放绑定到对象的生命周期。在对象的构造函数中获取资源，在对象的析构函数中释放资源。这样可以确保在异常情况下资源也能得到正确释放。</p><h3 id="示例：文件资源管理">示例：文件资源管理</h3><p>下面是一个简单的示例，展示如何使用 RAII 模式管理文件资源：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 构造函数中打开文件</span></span><br><span class="line"> <span class="built_in">FileWrapper</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">file</span>(filename) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Could not open file&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 析构函数中关闭文件</span></span><br><span class="line"> ~<span class="built_in">FileWrapper</span>() &#123;</span><br><span class="line">     <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         file.<span class="built_in">close</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提供接口操作文件</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         file &lt;&lt; data;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::ofstream file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename, <span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line"> <span class="function">FileWrapper <span class="title">fileWrapper</span><span class="params">(filename)</span></span>;</span><br><span class="line"> fileWrapper.<span class="built_in">write</span>(data);</span><br><span class="line"> <span class="comment">// FileWrapper 对象离开作用域时，析构函数会自动关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">writeToFile</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;Hello, RAII!&quot;</span>);</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>FileWrapper</code> 类管理一个文件对象。它在构造函数中打开文件，在析构函数中关闭文件。即使在 <code>writeToFile</code> 函数中抛出异常，<code>FileWrapper</code> 的析构函数也会被调用，从而确保文件被正确关闭。</p><h3 id="使用智能指针管理动态内存">使用智能指针管理动态内存</h3><p>除了文件资源，RAII 模式还可以用于管理动态内存。C++11 引入了智能指针，提供了一种简单而安全的方式来管理动态分配的内存。</p><ul><li><code>std::unique_ptr</code>：独占所有权的智能指针。</li><li><code>std::shared_ptr</code>：共享所有权的智能指针。</li><li><code>std::weak_ptr</code>：与 <code>std::shared_ptr</code> 搭配使用，防止循环引用。</li></ul><h4 id="示例：使用-std-unique-ptr">示例：使用 <code>std::unique_ptr</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something with resource\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; resource = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">    resource-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="comment">// Resource 对象会在函数结束时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">useResource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::unique_ptr</code> 管理一个 <code>Resource</code> 对象。当 <code>useResource</code> 函数结束时，<code>std::unique_ptr</code> 会自动释放 <code>Resource</code> 对象的内存。</p><h3 id="其他资源管理">其他资源管理</h3><p>RAII 可以用于管理任何需要显式释放的资源，例如：</p><ul><li>数据库连接</li><li>互斥锁</li><li>网络连接</li></ul><h4 id="示例：使用-std-lock-guard-管理互斥锁">示例：使用 <code>std::lock_guard</code> 管理互斥锁</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThreadId</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// mtx 会在 lock 离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printThreadId, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printThreadId, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>std::lock_guard</code> 自动管理 <code>std::mutex</code> 的锁定和解锁操作，确保互斥锁在函数退出时被正确释放。</p><h3 id="总结-3">总结</h3><p>RAII 是 C++ 中一种重要的资源管理模式，它将资源的分配和释放绑定到对象的生命周期中，利用构造函数和析构函数确保资源在正常和异常情况下都能被正确释放。通过使用智能指针和其他 RAII 工具类（如 <code>std::lock_guard</code>），可以更安全、方便地管理各种资源，避免资源泄漏和其他潜在问题。</p></blockquote><blockquote><p>Various exception classes can be derived from a common base class, as we discussed in Section 17.2, when we created class DivideByZeroException as a derived class of class exception.<br>If a catch handler catches a reference to an exception object of a base-class type, it also can catch a reference to all objects of classes publicly derived from that base class—this allows for polymorphic processing of related exceptions.<br>正如我们在第17.2节中所讨论的，可以从公共基类派生出各种异常类，当时我们创建了类DivideByZeroException作为类exception的派生类。<br>如果catch处理程序捕获对基类类型的异常对象的引用，那么它也可以捕获对从该基类公开派生的类的所有对象的引用——这允许对相关异常进行多态处理。</p></blockquote><p><strong>异常处理器：一种方法是分别捕获每一个派生类异常对象的每种引用，另一种是捕获基类异常对象的指针和引用，更高效。</strong></p><blockquote><p>When operator new fails, it throws a bad_alloc exception (defined in header file <new>).<br>In this section, we present two examples of new failing.<br>The first uses the version of new that throws a bad_alloc exception when new fails.<br>The second uses function set_new_handler to handle new failures.<br>[Note: The examples in Figs. 17.5–17.6 allocate large amounts of dynamic memory, which could cause your computer to become sluggish.]<br>当operator new失败时，它抛出一个bad_alloc异常(在头文件<new>中定义)。<br>在本节中，我们将介绍两个新故障的示例。<br>第一个使用new的版本，当new失败时抛出bad_alloc异常。<br>第二个使用set_new_handler函数来处理新的故障。<br>[注意:图17.5-17.6中的例子分配了大量的动态内存，这可能会导致您的计算机变得迟钝。]</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608182753828.png" alt="image-20240608182753828"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608182801972.png" alt="image-20240608182801972"></p><p>这些异常的输出取决于内存和编译器等原因。</p><blockquote><p>new Returning nullptr on Failure<br>The C++ standard specifies that programmers can use an older version of new that returns nullptr upon failure.<br>For this purpose, header <new> defines object nothrow (of type nothrow_t), which is used as follows:<br>double *ptr = new( nothrow ) double[ 50000000 ];<br>The preceding statement uses the version of new that does not throw bad_alloc exceptions (i.e., nothrow) to allocate an array of 50,000,000 doubles.</p><p>new失败返回nullptr<br>c++标准规定程序员可以使用旧版本的new，在失败时返回nullptr。<br>为此，header <new>定义了nothrow对象(nothrow_t类型)，使用方法如下:<br>Double *ptr = new(nothrow) Double [50000000];<br>前面的语句使用不抛出bad_alloc异常(即nothrow)的new版本来分配一个包含50,000,000个double类型的数组。<br>推荐使用这种方法，使得代码更具有健壮性。</p></blockquote><blockquote><p>Handling new Failures Using Function set_new_handler<br>Function set_new_handler (prototyped in standard header file <new>) takes as its argument a pointer to a function that takes no arguments and returns void.<br>This pointer points to the function that will be called if new fails.<br>This provides you with a uniform approach to handling all new failures, regardless of where a failure occurs in the program.<br>Once set_new_handler registers a new handler in the program, operator new does not throw bad_alloc on failure; rather, it defers the error handling to the new-handler function.<br>If new fails to allocate memory and set_new_handler did not register a new-handler function, new throws a bad_alloc exception.<br>If new fails to allocate memory and a new-handler function has been registered, the new-handler function is called.<br>使用set_new_handler函数处理新的故障：<br>函数set_new_handler(原型在标准头文件<new>中)接受一个指针作为参数，该指针指向一个不接受参数并返回void的函数。<br>这个指针指向如果new失败将被调用的函数。<br>这为您提供了处理所有新故障的统一方法，而不管故障发生在程序中的哪个位置。<br>一旦set_new_handler在程序中注册了一个新的处理程序，operator new就不会抛出bad_alloc;相反，它将错误处理延迟到new-handler函数。<br>如果new分配内存失败，并且set_new_handler没有注册一个new-handler函数，new抛出一个bad_alloc异常。<br>如果new分配内存失败，并且注册了new-handler函数，则调用new-handler函数。</p></blockquote><blockquote><p>The new-handler function should perform one of the following tasks:<br>Make more memory available by deleting other dynamically allocated memory (or telling the user to close other applications) and return to operator new to attempt to allocate memory again.<br>Throw an exception of type bad_alloc.<br>Call function abort or exit (both found in header file <cstdlib>) to terminate the program. These were introduced in Section 9.7.<br>Figure 17.6 demonstrates set_new_handler.<br>Function customNewHandler (lines 9–13) prints an error message (line 11), then calls abort (line 12) to terminate the program.<br>The output shows that the loop iterated four times before new failed and invoked function customNewHandler.</p><p>new-handler函数应该执行以下任务之一:<br>通过删除其他动态分配的内存(或告诉用户关闭其他应用程序)来获得更多可用内存，并返回到operator new以尝试再次分配内存。<br>抛出类型为bad_alloc的异常。<br>调用函数abort或exit(都在头文件<cstdlib>中找到)来终止程序。第9.7节介绍了这些特性。<br>图17.6演示了set_new_handler。<br>函数customNewHandler(第9-13行)打印一条错误消息(第11行)，然后调用abort(第12行)终止程序。<br>输出显示，在new失败并调用函数customNewHandler之前，循环迭代了四次。<br>课本的例子这里不再展示 和下面的基本一样</p></blockquote><blockquote><p>在 C++ 中，<code>set_new_handler</code> 是一个非常有用的工具，用于在内存分配失败时自定义处理行为。默认情况下，如果 <code>new</code> 运算符无法分配足够的内存，会抛出 <code>std::bad_alloc</code> 异常。但是，通过使用 <code>set_new_handler</code>，你可以指定一个函数，当 <code>new</code> 无法分配内存时调用该函数，而不是直接抛出异常。</p><h3 id="set-new-handler-的用法"><code>set_new_handler</code> 的用法</h3><p>以下是如何使用 <code>set_new_handler</code> 的示例：</p><ol><li><strong>定义一个处理函数</strong>：<br>这个函数将在 <code>new</code> 运算符分配内存失败时调用。这个函数必须是无参的，并且返回类型为 <code>void</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含 std::set_new_handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed. Terminating.\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>设置处理函数</strong>：<br>使用 <code>std::set_new_handler</code> 函数设置你自定义的处理函数。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(myNewHandler); <span class="comment">// 设置新的内存分配失败处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配大量内存以触发内存分配失败</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 分配1GB内存块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>myNewHandler</code> 是一个处理函数，当 <code>new</code> 运算符无法分配内存时，它会被调用，输出错误信息并终止程序。</p><h3 id="处理函数的作用">处理函数的作用</h3><p>处理函数在 <code>new</code> 运算符分配内存失败时调用，你可以在处理函数中执行以下操作：</p><ul><li>记录日志或输出错误信息。</li><li>尝试释放一些内存，然后返回以重试内存分配。</li><li>调用 <code>std::abort</code> 或 <code>std::exit</code> 终止程序。</li></ul><h3 id="示例：尝试释放内存">示例：尝试释放内存</h3><p>假设你有一些可以释放的全局资源，可以在内存分配失败时释放这些资源并重试分配：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>*&gt; allocatedMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed. Freeing allocated memory.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一些已分配的内存</span></span><br><span class="line">    <span class="keyword">if</span> (!allocatedMemory.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] allocatedMemory.<span class="built_in">back</span>();</span><br><span class="line">        allocatedMemory.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 尝试再次分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 如果没有可释放的内存，则终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(myNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">char</span>* ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 分配10MB内存块</span></span><br><span class="line">            allocatedMemory.<span class="built_in">push_back</span>(ptr); <span class="comment">// 记录分配的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有已分配的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>* ptr : allocatedMemory) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当 <code>new</code> 运算符无法分配内存时，<code>myNewHandler</code> 释放一些已分配的内存，然后返回以重试内存分配。如果没有更多的内存可以释放，它将调用 <code>std::abort</code> 终止程序。</p><h3 id="注意事项">注意事项</h3><ol><li><strong><code>set_new_handler</code> 是全局性的</strong>：当你设置一个新的处理函数时，它会覆盖任何先前设置的处理函数，并且对整个程序有效。</li><li><strong>线程安全</strong>：C++11 及以后的标准中，<code>set_new_handler</code> 是线程安全的。不同线程可以有各自的处理函数。</li><li><strong>处理函数不应抛出异常</strong>：在处理函数中抛出异常是不明智的，因为这可能会导致未定义行为。处理函数应该确保完成它的任务并返回，或者终止程序。</li></ol><p>通过使用 <code>set_new_handler</code>，你可以更灵活地处理内存分配失败的情况，确保程序在资源紧张时能够有更好的应对措施。</p></blockquote><blockquote><p>A common programming practice is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory and deallocate the memory with delete when the memory is no longer needed.<br>If an exception occurs after successful memory allocation but before the delete statement executes, a memory leak could occur.<br>C++ 11 provides class template unique_ptr in header file <memory> to deal with this situation.<br>一种常见的编程做法是分配动态内存，将该内存的地址分配给指针，使用指针操作内存，并在不再需要内存时使用delete释放内存。<br>如果在成功分配内存之后但在执行delete语句之前发生异常，则可能发生内存泄漏。<br>c++ 11在头文件<memory>中提供了类模板unique_ptr来处理这种情况。</p></blockquote><blockquote><p>An object of class unique_ptr maintains a pointer to dynamically allocated memory.<br>When an unique_ptr object destructor is called (for example, when an unique_ptr object goes out of scope), it performs a delete operation on its pointer data member.<br>Class template unique_ptr provides overloaded operators * and -&gt; so that an unique_ptr object can be used just as a regular pointer variable is.<br>Figure 17.9 demonstrates an unique_ptr object that points to a dynamically allocated object of class Integer (Figs. 17.7–17.8).</p><p>unique_ptr类的对象维护一个指向动态分配内存的指针。<br>当调用unique_ptr对象析构函数时(例如，当unique_ptr对象超出作用域时)，它对其指针数据成员执行delete操作。<br>类模板unique_ptr提供了重载操作符*和-&gt;，这样unique_ptr对象就可以像普通指针变量一样使用。<br>图17.9演示了一个unique_ptr对象，它指向一个动态分配的Integer类对象(图17.7-17.8)。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608185945944.png" alt="image-20240608185945944"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608185954422.png" alt="image-20240608185954422"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608190002234.png" alt="image-20240608190002234"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608190010125.png" alt="image-20240608190010125"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608190016231.png" alt="image-20240608190016231"></p><blockquote><p>Because ptrToInteger is a local automatic variable in main, ptrToInteger is destroyed when main terminates.<br>The unique_ptr destructor forces a delete of the Integer object pointed to by ptrToInteger, which in turn calls the Integer class destructor.<br>The memory that Integer occupies is released, regardless of how control leaves the block (e.g., by a return statement or by an exception).<br>Most importantly, using this technique can prevent memory leaks.</p><p>因为ptrToInteger是main中的一个局部自动变量，所以当main终止时ptrToInteger将被销毁。<br>unique_ptr析构函数强制删除ptrToInteger所指向的Integer对象，而ptrToInteger又调用Integer类析构函数。<br>Integer占用的内存被释放，无论控制如何离开块(例如，通过返回语句或异常)。<br>最重要的是，使用这种技术可以防止内存泄漏。</p></blockquote><blockquote><p>unique_ptr Notes<br>The class is called unique_ptr because only one unique_ptr at a time can own a dynamically allocated object.<br>By using its overloaded assignment operator or copy constructor, an unique_ptr can transfer ownership of the dynamic memory it manages.<br>unique_ptr笔记<br>这个类被称为unique_ptr，因为一次只能有一个unique_ptr拥有一个动态分配的对象。<br>通过使用它的重载赋值操作符或复制构造函数，unique_ptr可以转移它所管理的动态内存的所有权。</p><p>The last unique_ptr object that maintains the pointer to the dynamic memory will delete the memory.<br>This makes unique_ptr an ideal mechanism for returning dynamically allocated memory to client code.<br>When the unique_ptr goes out of scope in the client code, the unique_ptr’s destructor destroys the dynamically allocated object and deletes its memory.<br>最后一个维护动态内存指针的unique_ptr对象将删除该内存。<br>这使得unique_ptr成为将动态分配的内存返回给客户端代码的理想机制。<br>当unique_ptr在客户端代码中超出作用域时，unique_ptr的析构函数会销毁动态分配的对象并删除其内存。</p></blockquote><blockquote><p>unique_ptr to a Built-In Array<br>You can also use a unique_ptr to manage a dynamically allocated built-in array.<br>For example, consider the statement<br>unique_ptr&lt; string[] &gt; ptr( new string[ 10 ] );<br>which dynamically allocates an array of 10 strings managed by ptr.<br>The type string[] indicates that the managed memory is a built-in array containing strings.<br>unique_ptr转换为内置数组<br>您还可以使用unique_ptr来管理动态分配的内置数组。<br>例如，考虑这个语句<br>unque_ptr &lt; string[] &gt; ptr(new string[10]);<br>它动态地分配一个由ptr管理的包含10个字符串的数组。<br>string[]类型表示托管内存是包含字符串的内置数组。</p><p>unique_ptr to a Built-In Array<br>You can also use a unique_ptr to manage a dynamically allocated built-in array.<br>For example, consider the statement<br>unique_ptr&lt; string[] &gt; ptr( new string[ 10 ] );<br>which dynamically allocates an array of 10 strings managed by ptr.<br>The type string[] indicates that the managed memory is a built-in array containing strings.<br>unique_ptr转换为内置数组<br>您还可以使用unique_ptr来管理动态分配的内置数组。<br>例如，考虑这个语句<br>unque_ptr &lt; string[] &gt; ptr(new string[10]);<br>它动态地分配一个由ptr管理的包含10个字符串的数组。<br>string[]类型表示托管内存是包含字符串的内置数组。</p></blockquote><blockquote><p>Experience has shown that exceptions fall nicely into a number of categories.<br>The C++ Standard Library includes a hierarchy of exception classes, some of which are shown in Fig. 17.10.<br>As we first discussed in Section 17.2, this hierarchy is headed by base-class exception (defined in header file <exception>), which contains virtual function what that derived classes can override to issue appropriate error messages.<br>经验表明，例外情况可以很好地分为几类。<br>c++标准库包括异常类的层次结构，其中一些异常类如图17.10所示。<br>正如我们在第17.2节中首先讨论的那样，这个层次结构以基类异常(在头文件<exception>中定义)为首，它包含虚函数，派生类可以覆盖该虚函数以发出适当的错误消息。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608191200111.png" alt="image-20240608191200111"></p><blockquote><p>Immediate derived classes of base-class exception include runtime_error and logic_error (both defined in header <stdexcept>), each of which has several derived classes.<br>Also derived from exception are the exceptions thrown by C++ operators—for example, bad_alloc is thrown by new (Section 17.8), bad_cast is thrown by dynamic_cast (Chapter 12) and bad_typeid is thrown by typeid (Chapter 12).<br>基类异常的直接派生类包括runtime_error和logic_error(两者都定义在头文件<stdexcept>中)，它们每个都有几个派生类。<br>c++操作符抛出的异常也派生自exception——例如，new抛出bad_alloc(第17.8节)，dynamic_cast抛出bad_cast(第12章)，typeid抛出bad_typeid(第12章)。</p></blockquote><blockquote><p>在 C++ 中，<code>std::bad_typeid</code> 是一个异常类，它在使用 <code>typeid</code> 运算符时出现问题时被抛出。特别地，当使用 <code>typeid</code> 运算符对一个空指针进行操作时，会抛出 <code>std::bad_typeid</code> 异常。</p><h3 id="typeid-运算符"><code>typeid</code> 运算符</h3><p><code>typeid</code> 运算符用于获取对象的类型信息，它返回一个 <code>std::type_info</code> 对象，该对象包含了类型的信息。通常情况下，<code>typeid</code> 运算符可以用来获取变量或对象的类型信息：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="keyword">new</span> Derived;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of pbase: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">delete</span> pbase;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-bad-typeid-异常"><code>std::bad_typeid</code> 异常</h3><p>当 <code>typeid</code> 运算符对一个空指针进行操作时，就会抛出 <code>std::bad_typeid</code> 异常。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Type of pbase: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>pbase</code> 是一个空指针，当对 <code>*pbase</code> 使用 <code>typeid</code> 运算符时，会抛出 <code>std::bad_typeid</code> 异常。</p><h3 id="捕获-std-bad-typeid-异常">捕获 <code>std::bad_typeid</code> 异常</h3><p>当你在程序中使用 <code>typeid</code> 运算符时，应当考虑到可能会出现的空指针问题，并捕获 <code>std::bad_typeid</code> 异常以避免程序崩溃：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(Base* pbase)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="built_in">printType</span>(pbase);</span><br><span class="line"></span><br><span class="line"> pbase = <span class="keyword">new</span> Derived;</span><br><span class="line"> <span class="built_in">printType</span>(pbase);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> pbase;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，函数 <code>printType</code> 尝试打印对象的类型信息。如果指针为空，会捕获 <code>std::bad_typeid</code> 异常，并输出相应的错误信息。</p><h3 id="总结-4">总结</h3><ul><li><code>std::bad_typeid</code> 是在使用 <code>typeid</code> 运算符对空指针操作时抛出的异常。</li><li>使用 <code>typeid</code> 运算符时，特别是对指针解引用进行类型查询时，应当考虑并处理可能出现的空指针情况。</li><li>捕获 <code>std::bad_typeid</code> 异常可以防止程序因空指针操作而崩溃，并提供适当的错误处理机制。</li></ul><p>通过理解和正确处理 <code>std::bad_typeid</code> 异常，可以提高程序的健壮性，确保在类型查询操作中能够有效处理空指针情况。</p></blockquote><blockquote><p>Class logic_error is the base class of several standard exception classes that indicate errors in program logic.<br>For example, class invalid_argument indicates that a function received an invalid argument.<br>Proper coding can, of course, prevent invalid arguments from reaching a function.<br>Class length_error indicates that a length larger than the maximum size allowed for the object being manipulated was used for that object.<br>Class out_of_range indicates that a value, such as a subscript into an array, exceeded its allowed range of values.</p><p>类logic_error是几个标准异常类的基类，用于指示程序逻辑中的错误。<br>例如，invalid_argument类表示函数收到了无效参数。<br>当然，正确的编码可以防止无效参数到达函数。<br>类length_error表示该对象使用的长度大于被操作对象所允许的最大长度。<br>类out_of_range表示一个值(例如数组的下标)超出了其允许的值范围。</p></blockquote><blockquote><p>Class runtime_error, which we used briefly in Section 17.4, is the base class of several other standard exception classes that indicate execution-time errors.<br>For example, class overflow_error describes an arithmetic overflow error (i.e., the result of an arithmetic operation is larger than the largest number that can be stored in the computer) and class underflow_error describes an arithmetic underflow error (i.e., the result of an arithmetic operation is smaller than the smallest number that can be stored in the computer).</p><p>类runtime_error(我们在第17.4节中简要使用过)是其他几个指示执行时错误的标准异常类的基类。<br>例如，类overflow_error描述了一个算术溢出错误(即，算术运算的结果大于计算机可存储的最大数字)，类underflow_error描述了一个算术下溢错误(即，算术运算的结果小于计算机可存储的最小数字)。</p></blockquote><p><strong>异常类可以不继承自exception类，所以当捕获类型为exception时，不能保证能够程序捕获到所有可能的异常。</strong></p><p><strong>为了捕获一个try语句中的所有异常，可以使用catch(…)语句，但是无法确定类型，也无法获得参数名，因此无法引用。</strong></p><p><strong>catch(…)语句可以用来不依赖于异常类型的恢复操作（eg：释放公有资源），异常可以被重新抛出，让其他特定的catch处理器捕获处理。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十四章</title>
      <link href="/posts/495494c8.html"/>
      <url>/posts/495494c8.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自<a href="https://blog.csdn.net/stay_alive001/article/details/121520290">14 chapter 文件处理（cpp大学教程）学习笔记</a><br>如有侵权，请联系作者删除。</p><hr><h1 id="Cpp复习-第十四章">Cpp复习 第十四章</h1><h2 id="14-1-文件和流">14.1 文件和流</h2><h3 id="文件">文件</h3><p>内存中数据的存储是临时的，而用文件存储的数据是永久的——文件被储存在辅助存储设备中，如硬盘、CD、DVD、闪存驱动器和磁带</p><p>特点：每个文件都以一个文件结束符或者以存储在操作系统维护、管理的数据结构中的一个特定字节数</p><h3 id="文件处理模板">文件处理模板</h3><p>typedef ifstream是一个对basic_ifstream的特化，允许文件输入字符（读）</p><p>typedef ofstream是一个对basic_ofstream的特化，允许文件输出字符（写）</p><p>typedef fstream是一个对basic_fstream的特化，允许文件输入、输出字符（读写）</p><p>注意：该模板都是从basic_iostream、basic_istream、basic_ostream中“继承”而来，包含其所有的成员函数</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608131628656.png" alt="image-20240608131628656"></p><h2 id="14-2-创建顺序文件">14.2 创建顺序文件</h2><h3 id="打开一个文件">打开一个文件</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;credit.dat&quot;</span>, ios::out)</span></span>;</span><br><span class="line"> <span class="keyword">if</span>(!outputFile)&#123;cerr&lt;&lt;<span class="string">&quot;File could not be opened&quot;</span>;<span class="built_in">exit</span>(EXIT_FAILURE);&#125;</span><br></pre></td></tr></table></figure><p>打开文件有两个参数：文件名和文件打开模式</p><p>文件名：若文件不存在，则自动创建该文件名的文件</p><p>文件打开模式ios::out——向一个文件输出数据：默认截顶，会自动清空文件里的数据重新输出</p><p>ofstream对象默认为ios::out文件打开模式</p><blockquote><p>模式描述<br>ios::app将输出文件添加到文件尾，不截顶<br>ios::ate可以再文件任何位置输出数据，默认为文件尾<br>ios::in打开文件输入<br>ios::out打开文件输出，截顶<br>ios::trunc丢弃文件的内容<br>ios::binary打开一个文件进行二进制输入/输出</p></blockquote><h3 id="使用open打开一个文件">使用open打开一个文件</h3><p>一个ofstream对象可以在没有打开特定文件的情况下被创建，之后文件再关联到这个对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream outputFile;</span><br><span class="line"> outputFile.<span class="built_in">open</span>(<span class="string">&quot;credit.dat&quot;</span>, ios::out);</span><br></pre></td></tr></table></figure><h3 id="测试一个文件是否被成功打开">测试一个文件是否被成功打开</h3><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608132702823.png" alt="image-20240608132702823"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608132711047.png" alt="image-20240608132711047"></p><blockquote><p><strong>Testing Whether a File Was Opened Successfully</strong></p><p>After creating an ofstream object and attempting to open it, the program tests whether the open operation was successful.</p><p>The if statement in lines 15–19 uses the overloaded ios member function operator! to determine whether the open operation succeeded.</p><p>◦The condition returns a true value if either the failbit or the badbit is set for the stream on the open operation.</p><p>Some possible errors are</p><p>◦attempting to open a nonexistent file for reading,</p><p>◦attempting to open a file for reading or writing with-out permission, and</p><p>◦opening a file for writing when no disk space is available.</p><p>测试文件是否成功打开：<br>在创建ofstream对象并尝试打开它之后，程序将测试打开操作是否成功。<br>第15-19行的if语句使用了重载的ios成员函数操作符!判断手术是否成功。<br>如果在打开操作中为流设置了failbit或badbit，则条件返回真值。<br>一些可能的错误包括：试图打开一个不存在的文件进行读取，试图在未经许可的情况下打开文件进行读写，并且<br>在没有可用的磁盘空间时打开文件以供写入。</p></blockquote><blockquote><p>Function exit terminates a program.</p><p>◦The argument to exit is returned to the environment from which the program was invoked.</p><p>◦Passing EXIT_SUCCESS (also defined in <cstdlib>) to exit indicates that the program terminated <em>normally</em>; passing any other value (in this case EXIT_FAILURE) indicates that the program terminated due to an <em>error</em>.</p><p>函数退出终止程序：<br>exit参数返回到调用程序的环境。<br>将EXIT_SUCCESS(也在<cstdlib>中定义)传入exit表示程序正常终止;传递任何其他值(在本例中为EXIT_FAILURE)表示程序因错误而终止。</p></blockquote><h3 id="重载void-指针">重载void* 指针</h3><blockquote><p>The Overloaded void * Operator<br>Another overloaded ios member function—operator void *—converts the stream to a pointer, so it can be tested as 0 (i.e., the null pointer) or nonzero (i.e., any other pointer value).<br>When a pointer value is used as a condition, C++ interprets a null pointer in a condition as the bool value false and interprets a non-null pointer as the bool value true.<br>If the failbit or badbit has been set for the stream, 0 (false) is returned.<br>The condition in the while statement of lines 29–33 invokes the operator void * member function on cin implicitly.<br>The condition remains true as long as neither the failbit nor the badbit has been set for cin.<br>Entering the end-of-file indicator sets the failbit for cin.</p><p>重载void *操作符：<br>另一个重载的ios成员函数——operator void *——将流转换为指针，因此它可以被测试为0(即空指针)或非零(即任何其他指针值)。<br>当将指针值用作条件时，c++将条件中的空指针解释为bool值false，将非空指针解释为bool值true。<br>如果为流设置了failbit或badbit，则返回0 (false)。<br>第29-33行while语句中的条件隐式地调用cin上的操作符void *成员函数。<br>只要cin的failbit和badbit都没有设置，条件就保持为真。<br>输入文件结束指示器设置cin的failbit。</p></blockquote><blockquote><p>The operator void * function can be used to test an input object for end-of-file, but you can also call member function eof on the input object.<br>Processing Data<br>Figure 14.5 lists the keyboard combinations for entering end-of-file for various computer systems.<br>操作符void *函数可用于测试输入对象是否有文件结束，但也可以在输入对象上调用成员函数eof。<br>处理数据图14.5列出了各种计算机系统中输入文件结束符的键盘组合。</p></blockquote><blockquote><p>When end-of-file is encountered or bad data is entered, operator void * returns the null pointer (which converts to the bool value false) and the while statement terminates.<br>The user enters end-of-file to inform the program to process no additional data.<br>The end-of-file indicator is set when the user enters the end-of-file key combination.<br>Line 31 writes a set of data to the file clients.txt, using the stream insertion operator &lt;&lt; and the outClientFile object associated with the file at the beginning of the program.<br>The data may be retrieved by a program designed to read the file (see Section 14.4).<br>The file created in Fig. 14.3 is simply a text file, so it can be viewed by any text editor.<br>当遇到文件结束符或输入错误数据时，操作符void *返回空指针(该指针将转换为bool值false)， while语句终止。<br>用户输入文件尾以通知程序不处理其他数据。<br>当用户输入文件结束键组合时，设置文件结束指示符。<br>第31行使用流插入操作符&lt;&lt;和程序开头与文件关联的outClientFile对象，将一组数据写入文件clients.txt。<br>数据可以通过一个程序来读取文件(参见第14.4节)。<br>图14.3中创建的文件只是一个文本文件，因此任何文本编辑器都可以查看它。</p></blockquote><blockquote><p>Closing a File<br>Once the user enters the end-of-file indicator, main terminates.<br>This implicitly invokes outClientFile’s destructor, which closes the clients.txt file.<br>You also can close the ofstream object explicitly, using member function close.<br>关闭文件：<br>一旦用户输入文件结束指示符，main就终止。<br>这将隐式调用outClientFile的析构函数，从而关闭clients.txt文件。还可以使用成员函数close显式地关闭ofstream对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">outClientFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure></blockquote><h2 id="14-3-从顺序文件中读取数据">14.3 从顺序文件中读取数据</h2><blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;credit.dat&quot;</span>, ios::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!inFile)&#123;cerr&lt;&lt;<span class="string">&quot;File coule not be opened&quot;</span>;<span class="built_in">exit</span>(EXIT_FAILURE);&#125;;</span><br></pre></td></tr></table></figure><p>默认为输入打开模式，也可以使用open成员函数打开文件</p><p>文件定位指针<br>seekg()成员函数重定位下一个文件读入的字节号</p><p>seekp()成员函数重定位下一个文件输出的字节号</p><p>传递给重定位成员函数的第一个参数通常是一个long类型的整数</p><p>参数2作用<br>ios::beg从流的开始位置定位<br>ios::cur从流的当前位置进行定位<br>ios::end相对于流的结尾进行定位<br>tellg();tellp();用于高速下一个文件输入/输出的字节号</p></blockquote><p>打开格式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inClientFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span></span><br></pre></td></tr></table></figure><p>可以再创建时不打开，后面再次关联。</p><p>如果文件的内容不应该被修改，那么打开方式应该是ios::in。</p><h3 id="文件定位指针">文件定位指针</h3><p>istream和ostream中都提供了成员函数来重定位文件的定位指针（文件中下一个要被读取或者写入的字节）</p><p>在istream中，这个为seekg，ostream中为seekp</p><p><strong><code>seekp</code> (seek put)</strong>：用于输出（写）操作，设置输出位置指针。</p><p><strong><code>seekg</code> (seek get)</strong>：用于输入（读）操作，设置输入位置指针。</p><p>格式为：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inClientFile.<span class="built_in">seekg</span>(<span class="number">0</span>)<span class="comment">//表示是从文件的起始位置开始</span></span><br><span class="line"><span class="comment">//第一个参数：通常是一个long类型的变量 指定位置（从文件开始位置到当前位置的字节数，或者说是文件的偏移量）</span></span><br><span class="line"><span class="comment">//第二个参数：指定方向：ios::beg（默认，一般是流的开始）ios::cur（当前位置）ios::end（流的末尾开始）</span></span><br></pre></td></tr></table></figure><p>tellp和tellg用来返回当前put和get指针的位置。</p><p>为了执行多次文件的搜索读取，我们可以在遍历完一次文件后，对流执行clear操作，使其状态设置为goodbit，然后seekg(0)，返回文件开头的位置，便于执行下一次I/O操作。</p><h2 id="14-5-更新顺序文件">14.5 更新顺序文件</h2><blockquote><p>采用格式化的输入输出模式，不方便用于更新记录。</p><p>The problem is that, in the formatted input/output model using the stream insertion operator &lt;&lt; and the stream extraction operator &gt;&gt;, fields—and hence records—can vary in size.</p><p>◦For example, values 7, 14, –117, 2074, and 27383 are all ints, which store the same number of “raw data” bytes internally (typically four bytes on 32-bit machines and eight bytes on 64-bit machines).</p><p>◦However, these integers become different-sized fields, depending on their actual values, when output as formatted text (character sequences).</p><p>◦Therefore, the formatted input/output model usually is not used to update records in <em>place</em>.</p><p>问题在于，在使用流插入操作符&lt;&lt;和流提取操作符&gt;&gt;的格式化输入/输出模型中，字段和记录的大小可能不同。<br>例如，值7、14、-117、2074和27383都是整数，它们在内部存储相同数量的“原始数据”字节(通常在32位机器上存储4个字节，在64位机器上存储8个字节)。<br>但是，当作为格式化文本(字符序列)输出时，这些整数将根据其实际值变成大小不同的字段（字符序列）。<br>因此，格式化的输入/输出模型通常不用于就地更新记录。</p></blockquote><h2 id="14-6-随机存取文件">14.6 随机存取文件</h2><p>将所有的记录的长度都固定，这样可以方便随机查找或者顺序读取，并且能够修改，删除，对其他数据也没有影响。</p><h2 id="14-7-创建随机存取文件">14.7 创建随机存取文件</h2><h3 id="输出和读取">输出和读取</h3><p>成员函数write()从内存中一个指定位置开始输出固定数目的字节到指定的流。</p><p>关联到文件，则从文件中&quot;put&quot;文件定位指针指定的位置开始写入数据</p><p>成员函数read()则将固定数目的字节从一个指定的流输入到内存中指定地址开始的一部分空间。</p><p>关联到文件，则从文件中“get”文件定位指针指定的位置开始读取字节数据。</p><blockquote><p>Writing Bytes with ostream Member Function write<br>Outputting a four-byte integer as text could print as few digits as one or as many as 11 (10 digits plus a sign, each requiring a single byte of storage)<br>The following statement always writes the binary version of the integer’s four bytes (on a machine with four-byte integers):<br>outFile.write( reinterpret_cast&lt;    const char * &gt;( &amp;number ), sizeof( number ) );<br>Function write treats its first argument as a group of bytes by viewing the object in memory as a const char *, which is a pointer to a byte.<br>Starting from that location, function write outputs the number of bytes specified by its second argument—an integer of type size_t.<br>istream function read can be used to read the four bytes back into an integer variable.<br>使用ostream成员函数write写入字节：<br>输出一个四字节的整数作为文本可以输出少到1的数字，多到11的数字(10个数字加一个符号，每个需要一个字节的存储空间)<br>下面的语句总是写入整数的四个字节的二进制版本(在具有四个字节整数的机器上):<br>outFile.write(reinterpret_cast &lt;Const char * &gt;(&amp;number)， sizeof(number);<br>write函数将其第一个参数视为一组字节，方法是将内存中的对象视为const char *，这是一个指向字节的指针。<br>从该位置开始，函数write输出其第二个参数指定的字节数——size_t类型的整数。<br>Istream函数read可用于将四个字节读入整数变量。</p></blockquote><p><strong>成员函数write()输出字节数据</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">outputFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;client), <span class="built_in">sizeof</span>(ClientData));</span><br></pre></td></tr></table></figure><p>write()函数将第一个参数作为一组字节数据，将内存中的对象看做const char*类型，表示指向一个字节的指针；第二个参数为对象的字节数大小</p><h3 id="reinterpret-cast-运算符转换指针类型">reinterpret_cast&lt;&gt;()运算符转换指针类型</h3><p>作用：把某种类型强制转换为其他无关类型</p><p>注意：该转换是在编译阶段完成，不会改变指针所指对象的类型</p><p>并且在不同的平台上运行结果可能是不同的，除非有绝对的必要，否则不使用。</p><blockquote><p>Converting Between Pointer Types with the reinterpret_cast Operator<br>Most pointers that we pass to function write as the first argument are not of type const char *.<br>Must convert the pointers to those objects to type const char *; otherwise, the compiler will not compile calls to function write.<br>C++ provides the reinterpret_cast operator for cases like this in which a pointer of one type must be cast to an unrelated pointer type.<br>Without a reinterpret_cast, the write statement that outputs the integer number will not compile because the compiler does not allow a pointer of type int * (the type returned by the expression &amp;number) to be passed to a function that expects an argument of type const char *—as far as the compiler is concerned, these types are inconsistent.<br>A reinterpret_cast is performed at compile time and does not change the value of the object to which its operand points.</p><p>使用reinterpret_cast操作符在指针类型之间进行转换<br>大多数传递给write函数作为第一个实参的指针都不是const char *类型的。<br>必须将指向这些对象的指针转换为const char *类型;否则，编译器将不会编译对write函数的调用。<br>c++为这种情况提供了reinterpret_cast操作符，在这种情况下，必须将一种类型的指针强制转换为不相关的指针类型。<br>如果没有reinterpret_cast，输出整数的write语句将无法编译，因为编译器不允许将int *类型的指针(由表达式&amp;number返回的类型)传递给需要const char *类型参数的函数——就编译器而言，这些类型是不一致的。<br>reinterpret_cast在编译时执行，不会改变其操作数所指向的对象的值。</p></blockquote><h4 id="string类成员函数copy">string类成员函数copy()</h4><p>string string1 = “stringCopy”;<br>char string2[10];<br>string1.copy(string2, 10);<br>成员函数copy()的两个参数：</p><p>第一个参数：将要复制赋值的string数组</p><p>第二个参数：要复制的字符个数</p><h4 id="用二进制模式打开一个输出文件">用二进制模式打开一个输出文件</h4><p>ofstream outputFile(“credit.dat”, ios::out|ios::binary);<br>通过运算符&quot;|&quot;可以组合多种打开模式</p><h2 id="14-8-向随机存取文件随机写入数据">14.8 向随机存取文件随机写入数据</h2><blockquote><p>Figure 14.12 writes data to the file credit.dat and uses the combination of fstream functions seekp and write to store data at exact locations in the file.<br>Function seekp sets the “put” file-position pointer to a specific position in the file, then write outputs the data.<br>Line 6 includes the header ClientData.h defined in Fig. 14.9, so the program can use ClientData objects.<br>图14.12将数据写入文件credit.dat，并使用fstream函数seekp和write的组合将数据存储在文件中的准确位置。<br>函数seekp将“put”文件位置指针设置为文件中的特定位置，然后write输出数据。<br>第6行包括图14.9中定义的头文件ClientData.h，因此程序可以使用ClientData对象。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608144044684.png" alt="image-20240608144044684"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608144056004.png" alt="image-20240608144056004"></p><p>可以发现：上面使用了：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">outCredit to the byte location calculated <span class="title">by</span></span></span><br><span class="line"><span class="function"><span class="params">( client.getAccountNumber() - <span class="number">1</span> )</span>*<span class="title">sizeof</span><span class="params">( ClientData )</span></span></span><br></pre></td></tr></table></figure><p>来定位新数据将要在文件中写入的位置。对于记录1，文件指针定位在0。</p><h2 id="14-9-从随机存取文件顺序读取数据">14.9 从随机存取文件顺序读取数据</h2><blockquote><p>In this section, we develop a program that reads a file sequentially and prints only those records that contain data.<br>The istream function read inputs a specified number of bytes from the current position in the specified stream into an object.<br>For example, lines 31–32 from Fig. 14.13 read the number of bytes specified by sizeof(ClientData) from the file associated with ifstream object inCredit and store the data in the client record.<br>Function read requires a first argument of type char *.<br>Since &amp;client is of type ClientData *, &amp;client must be cast to char * using the cast operator reinterpret_cast.<br>在本节中，我们将开发一个程序，它按顺序读取文件并只打印包含数据的记录。<br>istream函数read将指定流中当前位置的指定字节数输入到对象中。<br>例如，图14.13中的31-32行从与ifstream对象credit关联的文件中读取sizeof(ClientData)指定的字节数，并将数据存储在客户端记录中。<br>函数read需要char *类型的第一个参数。<br>由于&amp;client是ClientData *类型，因此必须使用强制转换操作符reinterpret_cast将&amp;client强制转换为char *类型。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608144853289.png" alt="image-20240608144853289"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608144901519.png" alt="image-20240608144901519"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608144908383.png" alt="image-20240608144908383"></p><h4 id="成员函数read-读取文件数据">成员函数read()读取文件数据</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inFile.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;client), <span class="built_in">sizeof</span>(ClientData));</span><br></pre></td></tr></table></figure><p>第一个参数：要求的参数类型为char *，需用强制类型转换</p><p>第二个参数：读取的字符数</p><h4 id="判断是否读取到文件尾">判断是否读取到文件尾</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(inFile &amp;&amp; !inFile.<span class="built_in">eof</span>())&#123;&#125;;</span><br></pre></td></tr></table></figure><p>如果出错，或者到达文件尾，都会报错。</p><h2 id="14-11-对象序列化">14.11 对象序列化</h2><p>对象序列化是指将对象的状态转换为可存储或传输的格式的过程，以便以后可以重建该对象。序列化的目标是将对象表示为字节流，从而可以保存到文件、数据库，或通过网络传输给其他应用程序。反序列化是序列化的逆过程，即从字节流重建对象。</p><p>在C++中，对象序列化不是语言本身提供的特性，而是通过编写自定义代码或使用第三方库来实现的。以下是几种常见的对象序列化方法：</p><h3 id="手动序列化">手动序列化</h3><p>你可以手动编写代码，将对象的成员变量写入字节流，然后读取这些字节流以重建对象。以下是一个示例，演示如何手动序列化和反序列化一个简单的对象：</p><h4 id="示例类">示例类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> nameLength = name.<span class="built_in">size</span>();</span><br><span class="line">        os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;nameLength), <span class="built_in">sizeof</span>(nameLength));</span><br><span class="line">        os.<span class="built_in">write</span>(name.<span class="built_in">c_str</span>(), nameLength);</span><br><span class="line">        os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deserialize</span><span class="params">(std::istream&amp; is)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> nameLength;</span><br><span class="line">        is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;nameLength), <span class="built_in">sizeof</span>(nameLength));</span><br><span class="line">        name.<span class="built_in">resize</span>(nameLength);</span><br><span class="line">        is.<span class="built_in">read</span>(&amp;name[<span class="number">0</span>], nameLength);</span><br><span class="line">        is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    p1.<span class="built_in">serialize</span>(ofs);</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    p2.<span class="built_in">deserialize</span>(ifs);</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Boost-Serialization库">使用Boost.Serialization库</h3><p>Boost.Serialization 是一个功能强大且灵活的库，可以简化序列化和反序列化过程。使用这个库，你只需为类定义序列化函数，然后使用库提供的接口进行序列化和反序列化。</p><h4 id="示例类-2">示例类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_oarchive.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_iarchive.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">boost</span>::serialization::access;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Archive&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">serialize</span><span class="params">(Archive &amp; ar, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> version)</span> </span>&#123;</span><br><span class="line">        ar &amp; name;</span><br><span class="line">        ar &amp; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>)</span></span>;</span><br><span class="line">        boost::<span class="function">archive::text_oarchive <span class="title">oa</span><span class="params">(ofs)</span></span>;</span><br><span class="line">        oa &lt;&lt; p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>)</span></span>;</span><br><span class="line">        boost::<span class="function">archive::text_iarchive <span class="title">ia</span><span class="params">(ifs)</span></span>;</span><br><span class="line">        ia &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-JSON-或-XML-进行序列化">使用 JSON 或 XML 进行序列化</h3><p>可以使用诸如 JSON 或 XML 格式来序列化对象。许多第三方库可以方便地处理这些格式，例如 nlohmann/json 库（用于 JSON）和 pugixml 库（用于 XML）。</p><h4 id="使用-nlohmann-json">使用 nlohmann/json</h4><p>以下是一个使用 nlohmann/json 库进行 JSON 序列化和反序列化的示例：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">json <span class="title">to_json</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json&#123;&#123;<span class="string">&quot;name&quot;</span>, name&#125;, &#123;<span class="string">&quot;age&quot;</span>, age&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j)</span> </span>&#123;</span><br><span class="line">        j.<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">get_to</span>(name);</span><br><span class="line">        j.<span class="built_in">at</span>(<span class="string">&quot;age&quot;</span>).<span class="built_in">get_to</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.json&quot;</span>)</span></span>;</span><br><span class="line">        json j = p1.<span class="built_in">to_json</span>();</span><br><span class="line">        ofs &lt;&lt; j.<span class="built_in">dump</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.json&quot;</span>)</span></span>;</span><br><span class="line">        json j;</span><br><span class="line">        ifs &gt;&gt; j;</span><br><span class="line">        p2.<span class="built_in">from_json</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>对象序列化在 C++ 中可以通过多种方式实现：</p><ol><li><strong>手动序列化</strong>：通过手动编写代码，将对象的成员变量写入字节流并读取。</li><li><strong>使用 Boost.Serialization 库</strong>：一个功能强大且灵活的库，可以简化序列化和反序列化过程。</li><li><strong>使用 JSON 或 XML 格式</strong>：使用第三方库（如 nlohmann/json 或 pugixml）来处理这些格式。</li></ol><p>选择哪种方法取决于具体的应用需求和项目环境。</p><h2 id="补充">补充</h2><p>Qt 中的 <code>QDataStream</code> 可以用于对象序列化，它提供了一种方便的方式将数据从一个对象写入字节流，或者从字节流中读取数据以构建对象。这与对象序列化的基本原理一致：将对象的状态转换为可存储或传输的格式（字节流），然后可以重建该对象。</p><p><code>QDataStream</code> 通常与 <code>QIODevice</code> 类（如 <code>QFile</code>）一起使用，以实现数据的持久化存储或网络传输。</p><h3 id="QDataStream-简介">QDataStream 简介</h3><p><code>QDataStream</code> 类用于序列化基本数据类型以及许多 Qt 类（如 <code>QString</code>、<code>QVector</code> 等）。它提供了简单的操作符重载来读取和写入数据。</p><h3 id="示例：使用-QDataStream-进行对象序列化">示例：使用 QDataStream 进行对象序列化</h3><p>以下示例展示了如何使用 <code>QDataStream</code> 将一个对象序列化到文件中，然后再从文件中反序列化出来。</p><h4 id="示例类-3">示例类</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QString name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(QString name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化操作符</span></span><br><span class="line">    <span class="keyword">friend</span> QDataStream&amp; <span class="keyword">operator</span>&lt;&lt;(QDataStream&amp; out, <span class="type">const</span> Person&amp; person) &#123;</span><br><span class="line">        out &lt;&lt; person.name &lt;&lt; person.age;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化操作符</span></span><br><span class="line">    <span class="keyword">friend</span> QDataStream&amp; <span class="keyword">operator</span>&gt;&gt;(QDataStream&amp; in, Person&amp; person) &#123;</span><br><span class="line">        in &gt;&gt; person.name &gt;&gt; person.age;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; p1;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        in &gt;&gt; p2;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age:&quot;</span> &lt;&lt; p2.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键步骤说明">关键步骤说明</h3><ol><li><p><strong>定义操作符重载</strong>：</p><ul><li><code>operator&lt;&lt;</code> 用于序列化对象，将对象的各个成员变量写入数据流。</li><li><code>operator&gt;&gt;</code> 用于反序列化对象，从数据流中读取各个成员变量。</li></ul></li><li><p><strong>序列化到文件</strong>：</p><ul><li>打开文件，创建 <code>QDataStream</code> 对象，并使用 <code>&lt;&lt;</code> 操作符将对象写入文件。</li></ul></li><li><p><strong>从文件反序列化</strong>：</p><ul><li>打开文件，创建 <code>QDataStream</code> 对象，并使用 <code>&gt;&gt;</code> 操作符从文件中读取对象。</li></ul></li></ol><h3 id="QDataStream-的其他用法">QDataStream 的其他用法</h3><p>除了基本的读写操作，<code>QDataStream</code> 还提供了许多其他功能，比如设置数据流的版本以确保不同版本之间的数据兼容性：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">out.<span class="built_in">setVersion</span>(QDataStream::Qt_5_15); <span class="comment">// 设置数据流版本</span></span><br></pre></td></tr></table></figure><h3 id="支持的类型">支持的类型</h3><p><code>QDataStream</code> 支持许多 Qt 的基本类型和容器类型，例如 <code>QString</code>、<code>QByteArray</code>、<code>QList</code>、<code>QMap</code> 等。对于用户自定义类型，您需要定义序列化和反序列化操作符。</p><h3 id="总结-2">总结</h3><p><code>QDataStream</code> 是 Qt 提供的一个方便的类，用于将对象序列化到字节流中或从字节流中读取对象。这与对象序列化的基本原理一致，使得数据的存储和传输变得更加容易和高效。通过定义序列化和反序列化操作符，可以方便地序列化自定义对象。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十三章</title>
      <link href="/posts/fe798dad.html"/>
      <url>/posts/fe798dad.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自<a href="https://blog.csdn.net/stay_alive001/article/details/121481813?spm=1001.2014.3001.5502">13 输入/输出流的深入剖析(cpp大学教程)学习笔记</a><br>如有侵权，请联系作者删除。</p><hr><h1 id="CPP复习-第十三章">CPP复习 第十三章</h1><h2 id="13-2-流">13.2 流</h2><h3 id="非格式化与格式化I-O">非格式化与格式化I/O</h3><p>非格式化I/O(低层次I/O)：通过字节的方式从设备传输到内存传输或者从内存传输到设备，提供速度快、容量大的传输，建议处理大容量文件时，使用这种方式处理</p><p>格式化I/O(高层次I/O)：通过字节组成特定的字符串、整数、浮点数和用户自定义类型传输，可能会导致性能的问题，传输大容量的文件速度较慢，并且可移植性也存在问题</p><h3 id="传统流和标准流">传统流和标准流</h3><p>传统流：传统流库允许输入/输出char类型的字符，一个char类型的字符占一个字节</p><p>标准流：标准流库允许输入/输出wchar_t类型的Unicode字符，一个wchar_t类型的字符占两个字节</p><p>Unicode字符的新类型：char16_tchar32_t</p><h3 id="iostream库的头文件">iostream库的头文件</h3><p><iostream>头文件包换I/O流操作基本服务cin、cout、cerr、clog</p><p><iomanip>头文件包括参数化流操纵符setw、setprecision</p><p><fstream>头文件包含文件处理服务</p><h3 id="输入-输出流的类和对象">输入/输出流的类和对象</h3><h4 id="typedef声明数据类型同义词">typedef声明数据类型同义词</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef Card *CardPtr;//将类型名CardPtr定义为Card*的同义词</span><br></pre></td></tr></table></figure><p>使用typedef定义的同义词知识创建了一个名称，而并没有创建新的数据类型</p><blockquote><p>iostream库就是用typedef为类模板提供别名</p><p>Class template basic_istream supports stream-input operations, class template basic_ostream supports stream-output operations, and class template basic_iostream supports both stream-input and stream-output operations.</p><p>类模板basic_istream支持流输入操作，类模板basic_ostream支持流输出操作，类模板basic_iostream同时支持流输入和流输出操作。</p><p>The typedef istream represents a basic_istream<char> that enables char input.</p><p>The typedef ostream represents a basic_ostream<char> that enables char output.</p><p>The typedef iostream represents a basic_iostream<char> that enables both char input and output.</p><p>We use these typedefs throughout this chapter.</p><p>typepedef istream表示basic_istream<char>，它支持char输入。<br>typepedef ostream表示basic_ostream<char>，它允许char输出。<br>typepedef iostream表示basic_iostream<char>，它支持char输入和输出。</p></blockquote><p>UML图表示继承关系</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608100632510.png" alt="image-20240608100632510"></p><h4 id="标准流对象">标准流对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;用于从cin输入到内存 编译器是通过输入时 变量的类型来选择合适的流提取运算符重载函数 </span><br><span class="line">内置类型或者string或者指针需要override</span><br><span class="line">&lt;&lt;原理相似</span><br></pre></td></tr></table></figure><p>cin连接标准输入设备，通常是键盘</p><p>cout连接标准输出设备，通常是显示屏</p><p>cerr连接标准错误设备，对象cerr的输出无缓冲，每个针对cerr的对象必须立刻输出显示，用于迅速提示用户出现错误</p><p>clog连接标准错误设备，对象clog的输出有缓冲，对于clog的错误输出将会保存在缓存区内，直到缓存区被填满时才会输出，使用缓冲技术可以提高I/O的性能</p><h4 id="文件处理模板">文件处理模板</h4><blockquote><p>C++ file processing uses class templates basic_ifstream (for file input), basic_ofstream (for file output) and basic_fstream (for file input and output).</p><p>As with standard streams, C++ provides typedefs for working with these class template.</p><p>The typedef ifstream represents a basic_ifstream<char> that enables char input from a file.</p><p>The typedef ofstream represents a basic_ofstream<char> that enables char output to a file.</p><p>The typedef fstream represents a basic_fstream<char> that enables char input from, and output to, a file.</p><p>c++文件处理使用类模板basic_ifstream(用于文件输入)，basic_ofstream(用于文件输出)和basic_fstream(用于文件输入和输出)。<br>与标准流一样，c++提供了用于处理这些类模板的类型定义。<br>typepedef ifstream表示basic_ifstream<char>，它允许从文件输入char。<br>typepedef ofstream表示basic_ofstream<char>，允许向文件输出字符。<br>typepedef fstream表示basic_fstream<char>，它允许从文件输入和输出char。</p></blockquote><p>UML继承关系图</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608101209142.png" alt="image-20240608101209142"></p><h2 id="13-3-输出流">13.3 输出流</h2><p>ostream提供格式化和非格式化的输出功能<br>流插入运算符（&lt;&lt;）执行标准数据类型的输出；成员函数cin.put()进行字符输出；成员函数cin.write()进行非格式化输出</p><p>hex;oct;dec进行十六进制、八进制、十进制输出，参数化流操纵符setbase()设置制定进制输出</p><p>setprecision();指定浮点数精度输出；fixed;选择小数点后位数而不是有效数字； scientific; 指定使用可续计数法输出；showpoint;指定小数格式的输出</p><p>setw();width();用于设置输出/输入域宽</p><p>cout.fill();setfill()用于填充空白区域</p><p>uppercase;用于设置科学计数法或者十六进制的字母大写格式输出</p><h3 id="char-变量的输出">char*变量的输出</h3><p>当要输出字符串第一个字符的地址时，应该将地址的char* 类型转换为void* 类型，因为&lt;&lt;运算法被重载为读取到最后一个以空字符串结尾的字符串</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> word = <span class="string">&quot;again&quot;</span>;</span><br><span class="line">    cout&lt;&lt;word&lt;&lt;endl;<span class="comment">//输出的C风格的字符串</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span>*&gt;(word)&lt;&lt;endl;<span class="comment">//静态类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用成员函数put进行字符输出">使用成员函数put进行字符输出</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout.<span class="built_in">put</span>(<span class="string">&#x27;A&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>).<span class="built_in">put</span>(<span class="number">65</span>)</span><br><span class="line"><span class="comment">//cout.put(65)输出也是A</span></span><br></pre></td></tr></table></figure><p>1、成员函数put可以输出单个字符，可以使用级联输出</p><p>2、可以使用代表ASCII值的数字表达式作为参数进行输出</p><h3 id="成员函数cout-write-string-size">成员函数cout.write(string, size)</h3><p>两个参数分表示输出的字符串以及输出的长度，可以结合cin.gcount()一起使用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> size = <span class="number">80</span>;</span><br><span class="line">    <span class="type">char</span> buffer[size];</span><br><span class="line">    cin.<span class="built_in">read</span>(buffer, <span class="number">20</span>);<span class="comment">//读取20个字符</span></span><br><span class="line">    cout.<span class="built_in">write</span>(buffer, cin.<span class="built_in">gcount</span>());<span class="comment">//输出20个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-4-输入流">13.4 输入流</h2><h3 id="流提取运算符（-）">流提取运算符（&gt;&gt;）</h3><p>流提取运算符跳过输入流中空白字符（空格符 换行符 制表符）进行读取，并且每次读取会返回一个cin对象的引用，读取到文件尾会返回一个空指针</p><blockquote><p>Formatted and unformatted input capabilities are provided by istream.</p><p>The stream extraction operator (&gt;&gt;) normally skips white-space characters (such as blanks, tabs and newlines) in the input stream; later we’ll see how to change this behavior.</p><p>After each input, the stream extraction operator returns a reference to the stream object that received the extraction message (e.g., cin in the expression cin &gt;&gt; grade).</p><p>If that reference is used as a condition, the stream’s overloaded void * cast operator function is implicitly invoked to convert the reference into a non-null pointer value or the null pointer based on the success or failure, respectively of the last input operation.</p><p>A non-null pointer converts to the bool value true to indicate success and the null pointer converts to the bool value false to indicate failure.</p><p>}When an attempt is made to read past the end of a stream, the stream’s overloaded void * cast operator returns the <em>null pointer</em> to indicate <em>end-of-file</em>.</p><p>istream提供了格式化和非格式化的输入功能。<br>流提取操作符(&gt;&gt;)通常跳过输入流中的空白字符(如空格、制表符和换行符);稍后我们将看到如何更改此行为。<br>每次输入后，流提取操作符返回一个对接收提取消息的流对象的引用(例如，表达式cin &gt;&gt; grade中的cin)。<br>如果将该引用用作条件，则隐式调用流重载的void *强制转换操作符函数，根据最后一次输入操作的成功或失败分别将引用转换为非空指针值或空指针。<br>非空指针转换为bool值true表示成功，空指针转换为bool值false表示失败。<br>当试图读取超过流的末尾时，流的重载void *强制转换操作符返回空指针，表示文件结束。</p></blockquote><blockquote><p>Each stream object contains a set of state bits used to control the stream’s state (i.e., formatting, setting error states, etc.).</p><p>These bits are used by the stream’s overloaded void * cast operator to determine whether to return a non-null pointer or the null pointer.</p><p>Stream extraction causes the stream’s failbit to be set if data of the wrong type is input and causes the stream’s badbit to be set if the operation fails.</p><p>每个流对象包含一组状态位，用于控制流的状态(即格式化、设置错误状态等)。<br>流的重载void *强制转换操作符使用这些位来确定是返回非空指针还是空指针。<br>如果输入了错误类型的数据，流提取会导致设置流的failbit，如果操作失败，则会导致设置流的badbit。</p></blockquote><h3 id="istream成员函数">istream成员函数</h3><blockquote><p>The get member function with no arguments inputs one character from the designated stream (including white-space characters and other nongraphic characters, such as the key sequence that represents end-of-file) and returns it as the value of the function call.</p><p>This version of get returns EOF when end-of-file is encountered on the stream.</p><p>没有参数的get成员函数从指定流输入一个字符(包括空白字符和其他非图形字符，例如表示文件结束的键序列)，并将其作为函数调用的值返回。<br>当在流上遇到文件结束时，这个版本的get返回EOF。</p></blockquote><p><strong>注意这里character用的是int类型 因为char类型无法表示每个字符是否到达了文件尾</strong></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608103248064.png" alt="image-20240608103248064"></p><p>输出示例：<br><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608103314556.png" alt="image-20240608103314556"></p><p>Crtl+z对应的是^Z，（Windows系统），UNIX和Macinotsh是Crtl+d组合，表示输入文件结尾运算符</p><p>带有字符引用参数的get成员函数从输入流输入下一个字符(即使这是一个空白字符)，并将其存储在字符参数中。<br>这个版本的get返回对正在为其调用get成员函数的istream对象的引用。<br>第三个版本的get有三个参数——<strong>一个内置数组或字符、一个大小限制和一个分隔符(默认值为’\n’)。</strong><br>这个版本从输入流中读取字符。</p><p>它要么读取<strong>比指定的最大字符数少一个</strong>的字符，然后终止，要么<strong>在读取分隔符后立即终止。</strong><br>插入一个空字符，来终止字符数组中的输入字符串，字符数组在程序中是作为缓冲区的。</p><p><strong>分隔符不放在字符数组中，而是留在输入流中(分隔符将是下一个读取的字符)</strong>。</p><h4 id="成员函数cin-eof">成员函数cin.eof()</h4><p>当读取到文件尾之后的字符时被设置为true，否则为false，判定是否读取到文件尾的标识符是EOF，windows下为ctrl+z，表示的值为-1</p><h4 id="成员函数cin-get">成员函数cin.get()</h4><p>无参数cin.get()，读取一个字符，包括空白字符，读取到’\n’停止，会返回提取值</p><p>带一个字符引用参数的cin.get(string1);,将输入流中的下一个字符输入包括空白字符并保存至该字符引用参数内</p><p>带三个参数cin.get(string1, size, interval);三个参数分别是字符串数组，字符串长度，分隔符(默认为’\n’)。</p><p>注意：分隔符不会放入数组中，一个数组最多可以读取“最大长度-1”，因为最后一个位置放置结尾符。分隔符仍将保存在输入流中，因此如果不进行跳过(cin.ignore())则下一个数组为空</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608104954530.png" alt="image-20240608104954530"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608105002166.png" alt="image-20240608105002166"></p><p>这里输入了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Contrasting string input with cin and cin.get</span><br></pre></td></tr></table></figure><p>一开始使用的是cin， 因为有空格符，所以打印buffer1时，只有Contrasting</p><p>Contrasing后的&quot; “字符被留在了缓冲区中，所以后来cin.get调用时，也被缓冲区中的字符输入到buffer2中，直到”\n&quot;才结束。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size=<span class="number">12</span>;</span><br><span class="line">    <span class="type">char</span> str1[size];</span><br><span class="line">    <span class="type">char</span> str2[size];</span><br><span class="line">    <span class="type">char</span> str3[size];</span><br><span class="line">    cin&gt;&gt;str1;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;string with cin&quot;</span>&lt;&lt;endl&lt;&lt;str1&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>(str2,size);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;string with cin.get1&quot;</span>&lt;&lt;endl&lt;&lt;str2&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cin.<span class="built_in">get</span>(str3,size,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;string with cin.get2&quot;</span>&lt;&lt;endl&lt;&lt;str3&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">compare between cin <span class="keyword">and</span> cin.get</span><br><span class="line">string with cin</span><br><span class="line">compare</span><br><span class="line"></span><br><span class="line">string with cin.get1</span><br><span class="line"> between ci</span><br><span class="line"></span><br><span class="line">string with cin.get2</span><br><span class="line">n</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="成员函数cin-getline-string1-size-interval">成员函数cin.getline(string1, size, interval)</h4><p>其功能与带三个参数的成员函数cin.get(string1, size, interval)相似，不同点是：</p><p>getline()读到分隔符后停止并且会将分隔符从输入流中删除；get()读到分隔符后停止但分隔符仍保存在输入流中</p><h4 id="成员函数cin-peek">成员函数cin.peek()</h4><p>返回输出流中的下一个字符，并且不将他从流中去除</p><h4 id="成员函数cin-ignore">成员函数cin.ignore()</h4><p>读取并丢弃一定数量的字符(默认为一个字符)，或者遇到指定分隔符(EOF)停止</p><h4 id="成员函数cin-putback">成员函数cin.putback()</h4><p>将先前使用get()函数从输入流里获得的字符，再放回到流中。</p><p>一般用于扫描输入流，尤其是搜索以特定字符开头的字段的应用程序很有用。</p><blockquote><p><code>cin.putback</code> 是 C++ 标准库中的一个方法，用于将一个字符放回输入流。这样做可以让该字符成为输入流中的下一个字符，从而可以被再次读取。这在处理输入时非常有用，尤其是在处理复杂输入或者需要根据某个字符决定不同的处理方式时。</p><h3 id="用途和使用场景">用途和使用场景</h3><ol><li><strong>处理复杂输入</strong>：当读取输入时，遇到某个字符需要重新判断时，可以将其放回流中以便再次读取。</li><li><strong>回退字符</strong>：在读取一系列字符后，如果发现不符合预期，可以将最后一个字符放回流中。</li><li><strong>解析输入</strong>：在解析输入时，可以根据读取的字符决定不同的解析路径。</li></ol><h3 id="使用示例">使用示例</h3><p>下面是一个简单的示例，展示了 <code>cin.putback</code> 的使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">input</span><span class="params">(<span class="string">&quot;123 456&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取一个字符</span></span><br><span class="line">    input &gt;&gt; ch;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read character: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符放回输入流</span></span><br><span class="line">    input.<span class="built_in">putback</span>(ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取这个字符</span></span><br><span class="line">    input &gt;&gt; ch;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read character again: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Read character: 1</span><br><span class="line">Read character again: 1</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先读取一个字符 <code>1</code>，然后使用 <code>putback</code> 将其放回输入流。再次读取时，仍然是字符 <code>1</code>，说明 <code>putback</code> 成功地将字符放回了输入流。</p><h3 id="实际应用">实际应用</h3><p>考虑一个更复杂的应用场景，比如解析一个简单的数学表达式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parseExpression</span><span class="params">(std::istringstream&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (input &gt;&gt; ch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            input.<span class="built_in">putback</span>(ch);</span><br><span class="line">            <span class="type">int</span> number;</span><br><span class="line">            input &gt;&gt; number;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Parsed number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;+&#x27;</span> || ch == <span class="string">&#x27;-&#x27;</span> || ch == <span class="string">&#x27;*&#x27;</span> || ch == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Parsed operator: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown character: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">input</span><span class="params">(<span class="string">&quot;12 + 34 - 56 * 78 / 90&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">parseExpression</span>(input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parsed number: 12</span><br><span class="line">Parsed operator: +</span><br><span class="line">Parsed number: 34</span><br><span class="line">Parsed operator: -</span><br><span class="line">Parsed number: 56</span><br><span class="line">Parsed operator: *</span><br><span class="line">Parsed number: 78</span><br><span class="line">Parsed operator: /</span><br><span class="line">Parsed number: 90</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>parseExpression</code> 函数读取输入流中的字符。如果读取到的是数字，则将其放回输入流，然后读取整个数字。如果读取到的是操作符，则直接处理。这样，我们可以灵活地处理和解析复杂的输入。</p><h3 id="总结">总结</h3><p><code>cin.putback</code> 是一个有用的工具，允许程序员将字符放回输入流，从而在处理输入时有更多的灵活性。它特别适用于需要回溯或者重新判断的场景，比如解析复杂的输入或者表达式。理解和使用 <code>putback</code> 可以让你在处理输入流时更加得心应手。</p></blockquote><blockquote><p>C++ offers type-safe I/O.</p><p>The &lt;&lt; and &gt;&gt; operators are overloaded to accept data items of specific types.</p><p>If unexpected data is processed, various error bits are set, which the user may test to determine whether an I/O operation succeeded or failed.</p><p>If operator &lt;&lt; has not been overloaded for a user-defined type and you attempt to input into or output the contents of an object of that user-defined type, the compiler reports an error.</p><p>This enables the program to “stay in control.”</p><p>c++提供类型安全的I/O。<br>&lt;&lt;和&gt;&gt;操作符被重载以接受特定类型的数据项。<br>如果处理了意外数据，则设置各种错误位，用户可以通过测试来确定I/O操作是成功还是失败。<br>如果操作符&lt;&lt;没有为用户定义类型重载，并且您试图输入或输出该用户定义类型对象的内容，编译器将报告错误。这使程序能够“保持控制”。</p></blockquote><h4 id="成员函数cin-read-string1-size">成员函数cin.read(string1, size)</h4><p>两个参数分别表示读取字符存入的数组以及存入字符的数量，读取的字符包括空白字符</p><p>read用于将一定数量的字节读入到字符数组中。</p><p><strong>注意：如果当读取的字符数量少于size，则failbit则会被设置</strong></p><h4 id="成员函数cin-write">成员函数cin.write()</h4><p>用于从字符数组中输出字节，包括空字符</p><h4 id="成员函数cin-gcount">成员函数cin.gcount()</h4><p>返回最近一次输入操作所读取的字符数</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608112249518.png" alt="image-20240608112249518"></p><p>这里cin.gccount对应的就是上面的20</p><h2 id="13-6-流操纵符">13.6 流操纵符</h2><h3 id="整形流的基数：doc-oct-hex-setbase">整形流的基数：doc, oct, hex, setbase()</h3><p>doc：十进制输出</p><p>oct：八进制输出</p><p>hex：十六进制输出</p><p>setbase(size)：指定进制输出（必须包含<iomanip>header）</p><p>四者都为“黏性”流操纵符，对之后的输出都有效</p><p>注意都是在输出的变量前插入</p><h3 id="浮点精度precision-setprecision">浮点精度precision(), setprecision()</h3><p>precision()为ios_base成员函数，不含参数返回当前的精度设置（这样就可以在不再使用黏性设置时，返回原原来的设置精度），含有一个参数返回先前精度设置</p><p>流操纵符setprecision(accuracy)</p><p>二者都为“黏性”设置，会总用于之后的所有输出</p><h3 id="域宽cout-width-setw-size">域宽cout.width(), setw(size)</h3><p>width()为ios_base成员函数，不含参数返回当前的域宽设置，含参数的返回先前的域宽设置</p><p>如果输出值的宽度比域宽小，则插入字符进行填充。</p><p>宽度大于指定宽度的值不会被截断，会将整个值全部输出。</p><p>width()可以控制输入输出的精度</p><p>width是非黏性的，使用后被隐式地设置为0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> widthValue = <span class="number">4</span>;</span><br><span class="line">     <span class="type">char</span> sentence[<span class="number">10</span>];</span><br><span class="line">     cin.<span class="built_in">width</span>(<span class="number">5</span>);<span class="comment">//每次会读取4个字符，最后一个字符为结尾符</span></span><br><span class="line">     cin&gt;&gt;sentence;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="流操纵符setw-size">流操纵符setw(size)</h3><p>二者都为“非黏性”设置，之后会默认设置为0</p><h3 id="自定义流操纵符">自定义流操纵符</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span>&amp; <span class="title">carriageReturn</span><span class="params">(ostream&amp; output)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> output&lt;&lt;<span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;......&#x27;</span>&lt;&lt;carriageReturn&lt;&lt;<span class="string">&#x27;----&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-7-流的格式状态和流操纵符">13.7 流的格式状态和流操纵符</h2><p>以下所有流操纵符都属于类ios_base</p><blockquote><p>Various stream manipulators can be used to specify the kinds of formatting to be performed during stream-I/O operations.</p><p>Stream manipulators control the output’s format settings.</p><p>Figure 13.12 lists each stream manipulator that controls a given stream’s format state.</p><p>All these manipulators belong to class ios_base.</p><p>We show examples of most of these stream manipulators in the next several sections.</p><p>可以使用各种流操纵符来指定在流i /O操作期间执行的格式化类型。<br>流操纵符控制输出的格式设置。<br>图13.12列出了控制给定流格式状态的每个流操纵符。<br>所有这些操纵符都属于ios_base类。<br>在接下来的几节中，我们将展示大多数流操作符的示例。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608124241579.png" alt="image-20240608124241579"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608124250850.png" alt="image-20240608124250850"></p><h3 id="尾数零和小数点showpoint">尾数零和小数点showpoint</h3><p>showpoint强制要求浮点数的输出必须带小数点和尾数零</p><p>cout&lt;&lt;showpoint&lt;&lt;79.0;<a href="//xn--79-4j7d950apie.xn--0showpoint79-9x4s25ns65e9gwa88ai10p8fq">//浮点数79.0当不使用showpoint时显示79</a>，使用时显示79.000000</p><p>要重置showpoint的设置时，需要使用noshowpoint</p><p>浮点数的默认精度是6，精度值显示的是有效位数</p><h3 id="对齐left-right-internal">对齐left, right, internal</h3><p>left：让输出左对齐，并且右边填充字符</p><p>right：让输出右对齐，并且左边填充字符</p><p>internal：让数字的符号左对齐，数值部分右对齐，中间用填充字符填充</p><p>showpos强制要求输出符号，noshowpos可以关闭</p><h3 id="内容填充fill-setfill">内容填充fill(), setfill()</h3><p>成员函数cout.fill()指定对齐域填充字符，如果没有指定则用空字符，无参数时返回之前的填充字符</p><p>setfill也是相同的功能。</p><blockquote><p>在 C++ 标准库中，<code>fill</code> 和 <code>setfill</code> 是两个用于格式化输出流的成员函数，但它们的作用和使用方式略有不同。以下是这两个函数的详细介绍及它们的区别。</p><h3 id="fill"><code>fill</code></h3><p><code>fill</code> 是一个成员函数，用于设置填充字符。当输出宽度大于实际输出内容的宽度时，会用填充字符来填充剩余的空位。<code>fill</code> 函数的返回值是上一次的填充字符。</p><h4 id="语法">语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">fill</span><span class="params">(<span class="type">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="示例">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line"> std::cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line"> std::cout &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="type">char</span> previousFill = std::cout.<span class="built_in">fill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"> std::cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line"> std::cout &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Previous fill character: &quot;</span> &lt;&lt; previousFill &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********42</span><br><span class="line">     42</span><br><span class="line">Previous fill character: *</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>fill('*')</code> 设置了填充字符为 <code>*</code>，并且设置了输出宽度为 10。然后，恢复到默认的填充字符 <code>' '</code>。</p><h3 id="setfill"><code>setfill</code></h3><p><code>setfill</code> 是一个操纵器，用于设置填充字符。操纵器是一种特殊的函数，可以直接插入到输出流中，改变流的状态。</p><h4 id="语法-2">语法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::<span class="built_in">setfill</span>(<span class="type">char</span> ch);</span><br></pre></td></tr></table></figure><h4 id="示例-2">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********42</span><br><span class="line">     42</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>std::setfill('*')</code> 设置了填充字符为 <code>*</code>，并且设置了输出宽度为 10。然后，通过 <code>std::setfill(' ')</code> 恢复到默认的填充字符 <code>' '</code>。</p><h3 id="区别">区别</h3><ol><li><p><strong>类型和用法</strong>：</p><ul><li><code>fill</code> 是输出流的成员函数。你需要通过输出流对象来调用它（如 <code>std::cout.fill('*')</code>）。</li><li><code>setfill</code> 是一个操纵器，直接插入到输出流中（如 <code>std::cout &lt;&lt; std::setfill('*')</code>），这使得它更适合与其他操纵器（如 <code>std::setw</code>）结合使用。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>fill</code> 返回先前的填充字符，可以用于恢复以前的设置。</li><li><code>setfill</code> 不返回值，它是一个流操纵器，直接作用于输出流。</li></ul></li><li><p><strong>结合其他操纵器使用</strong>：</p><ul><li><code>setfill</code> 更加方便地与其他操纵器（如 <code>std::setw</code>）一起使用，因为它可以链式调用，使得代码更加简洁。</li></ul></li></ol><h3 id="示例对比">示例对比</h3><h4 id="使用-fill">使用 <code>fill</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout.<span class="built_in">fill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    std::cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout.<span class="built_in">fill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    std::cout.<span class="built_in">width</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-setfill">使用 <code>setfill</code></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">42</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，使用 <code>setfill</code> 使代码更简洁，更容易与其他操纵器结合。</p><h3 id="总结-2">总结</h3><ul><li><strong><code>fill</code></strong>：成员函数，需要通过输出流对象调用，返回先前的填充字符。</li><li><strong><code>setfill</code></strong>：操纵器，可以直接插入到输出流中，与其他操纵器结合使用更加方便。</li></ul><p>根据具体需求和代码风格选择使用哪种方法来设置填充字符。</p></blockquote><h3 id="整形流的基数showbase">整形流的基数showbase</h3><p>showbase要求进制输出时显示前面的基数，如十六进制以0x或者0X开头，八进制以0开头</p><p>该流操纵符为&quot;黏性&quot;。</p><p>当流被指定为一个特定的基数时，流中的所有整数都按照该基数处理，除非指定另外一个，或者直到程序结束</p><h3 id="浮点数、科学计数法、定点小数计数法scientific-fixed">浮点数、科学计数法、定点小数计数法scientific, fixed</h3><p>scientific要求以科学计数法输出</p><p>fixed要求输出的精度为小数点后位数，而不是有效数字个数</p><p>二者为“黏性”设置</p><h3 id="大小写控制uppercase">大小写控制uppercase</h3><p>uppercase要求科学计数法中的e和十六进制输出的x用大写输出</p><p>科学计数法默认情况下保证小数点后6位</p><h3 id="指定布尔格式boolalpha">指定布尔格式boolalpha</h3><p>boolalpha指定输出bool类型时以true或者false输出</p><p>关闭使用noboolalpha，这两个都是黏性的</p><h3 id="通过成员函数cout-flags-设置和重置格式状态">通过成员函数cout.flags()设置和重置格式状态</h3><p>成员函数cout.flags()无参数时返回之前格式状态以fmtflags数据类型（ios_base）的形式返回；有参数时返回之前的格式状态并将当前状态设置成参数的格式状态</p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608130350304.png" alt="image-20240608130350304"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240608130359292.png" alt="image-20240608130359292"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;include.......&quot;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> integer1 = <span class="number">100</span>;</span><br><span class="line">    ios_base::fmtflags originalFormat = cout.<span class="built_in">flags</span>();<span class="comment">//返回当前格式状态</span></span><br><span class="line">    cout&lt;&lt; showbase&lt;&lt;oct&lt;&lt;scientific;</span><br><span class="line">    cout&lt;&lt;cout.<span class="built_in">flags</span>()&lt;&lt;integer;</span><br><span class="line">    </span><br><span class="line">    cout.<span class="built_in">flags</span>(originalFormat);<span class="comment">//设置成原来的格式</span></span><br><span class="line">    cout&lt;&lt;cout.<span class="built_in">flags</span>()&lt;&lt;integer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-8-流的错误状态">13.8 流的错误状态</h2><p>通过检测ios_base类中的相应位来判断</p><p>当遇到文件尾时，输入流的eofbit位将被设置，调用函数cin.eof()进行判断</p><p>当发生格式错误时，failbit位将被设置，并且不会读取任何字符，通过cin.fail()判断</p><p>当发生数据错误时，badbit位将被设置，通常这种错误无法修复，通过cin.bad()判断</p><p>当bad, fail, eof都为false时，goodbit将被设置成true，通过cin.good()判断</p><p>成员函数rdstate返回流的错误状态，通过switch语句检查这些状态：eofbitbadbitfailbitgoodbit。</p><p>成员函数cin.clear()可以清空cin，然后将goodbit设置成true保持I/O状态良好继续执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cin.clear(ios::failbit)将cin清空并且为该流设置为goodbit位</span><br></pre></td></tr></table></figure><p>如果badbit或者failbit被设置，那么basic_ios中的!会被设置为true值，operator void* 也会返回false值。</p><p>可以用于文件操作中的文件处理。</p><h2 id="13-9-将输出流连接到输入流">13.9 将输出流连接到输入流</h2><p>成员函数tie()让输出和输入同步操作</p><p>cin.tie(&amp;cout);//让输出在接下来的输入操作之前被显示</p><p>inputStream.tie(0);//解除绑定</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十二章</title>
      <link href="/posts/b3672eff.html"/>
      <url>/posts/b3672eff.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第十二章">CPP复习 第十二章</h1><p>多态的使用条件：父类指针或者引用指向子类对象.</p><blockquote><p>With polymorphism, we can design and implement systems that are easily extensible.<br>New classes can be added with little or no modification to the general portions of the program, as long as the new classes are part of the inheritance hierarchy that the program processes generally.<br>The only parts of a program that must be altered to accommodate new classes are those that require direct knowledge of the new classes that you add to the hierarchy.<br>使用多态性，我们可以设计和实现易于扩展的系统。<br>只要新类是程序通常处理的继承层次结构的一部分，就可以在对程序的一般部分进行很少或不进行修改的情况下添加新类。<br>只有那些需要直接了解添加到层次结构中的新类的部分才需要对程序进行修改以适应新类</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607170206131.png" alt="image-20240607170206131"></p><blockquote><p>属于同一个层次的派生类，通过一个共同的基类指针或者引用来访问，可以让不同的派生类对象执行与它们相符合的行为。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607170221385.png" alt="image-20240607170221385"></p><blockquote><p>多态可以程序员不用修改原有的系统，只需要把能够响应现有信息的新类型的对象添加到系统即可。</p></blockquote><blockquote><p>The next several sections present a series of examples that demonstrate how base-class and derived-class pointers can be aimed at base-class and derived-class objects, and how those pointers can be used to invoke member functions that manipulate those objects.<br>A key concept in these examples is to demonstrate that an object of a derived class can be treated as an object of its base class.<br>Despite the fact that the derived-class objects are of different types, the compiler allows this because each derived-class object is an object of its base class.<br>However, we cannot treat a base-class object as an object of any of its derived classes.<br>The is-a relationship applies only from a derived class to its direct and indirect base classes.<br>接下来的几节将提供一系列示例，演示基类和派生类指针如何指向基类和派生类对象，以及如何使用这些指针调用操作这些对象的成员函数。<br>这些示例中的一个关键概念是演示派生类的对象可以被视为其基类的对象。<br>尽管派生类对象具有不同的类型，但编译器允许这样做，因为每个派生类对象都是其基类的对象。<br>但是，不能将基类对象视为其任何派生类的对象。<br>is-a关系仅适用于派生类的直接和间接基类。</p></blockquote><blockquote><p>Aiming a Base-Class Pointer at a Derived-Class Object<br>Line 49 assigns the address of derived-class object base-PlusCommissionEmployee to base-class pointer commissionEmployeePtr, which line 53 uses to invoke member function print.<br>This “crossover” is allowed because an object of a derived class is an object of its base class.<br>Note that despite the fact that the base class CommissionEmployee pointer points to a derived class BasePlusCommissionEmployee object, the base class CommissionEmployee’s print member function is invoked (rather than BasePlusCommissionEmployee’s print function).<br>The output of each print member-function invocation in this program reveals that the invoked functionality depends on the type of the pointer (or reference) used to invoke the function, not the type of the object for which the member function is called.<br>将基类指针指向派生类对象<br>第49行将派生类对象base-PlusCommissionEmployee的地址赋值给基类指针commissionEmployeePtr，第53行使用该指针调用成员函数print。<br>这种“交叉”是允许的，因为派生类的对象是其基类的对象。</p><p>注意，尽管基类CommissionEmployee指针指向派生类BasePlusCommissionEmployee对象，<br>但调用的是<strong>基类CommissionEmployee的print成员函数(而不是BasePlusCommissionEmployee的print函数)。</strong></p><p>该程序中每个print成员函数调用的输出表明，被调用的功能取决于<strong>用于调用该函数的指针(或引用)的类型，而不是调用该成员函数的对象的类型。</strong></p></blockquote><blockquote><p>Off a base-class pointer, the compiler allows us to invoke only base-class member functions.<br>If a base-class pointer is aimed at a derived-class object, and an attempt is made to access a derived-class-only member function, a compilation error will occur.<br>Figure 12.3 shows the consequences of attempting to invoke a derived-class member function off a base-class pointer.<br>在基类指针之外，编译器只允许调用基类成员函数。<br>如果基类指针指向派生类对象，并且试图访问仅派生类成员函数，则会发生编译错误。<br>图12.3显示了试图从基类指针调用派生类成员函数的结果。</p></blockquote><blockquote><p>Downcasting<br>The compiler will allow access to derived-class-only members from a base-class pointer that is aimed at a derived-class object if we explicitly cast the base-class pointer to a derived-class pointer—known as downcasting.<br>Downcasting allows a derived-class-specific operation on a derived-class object pointed to by a base-class pointer.<br>After a downcast, the program can invoke derived-class functions that are not in the base class.<br>Section 12.8 demonstrates how to safely use downcasting.<br>向下类型转换：<br>如果显式地将基类指针转换为派生类指针(称为向下转换)，编译器将允许从指向派生类对象的基类指针访问仅派生类成员。<br>向下转换允许在基类指针指向的派生类对象上执行特定于派生类的操作。向下转换后，程序可以调用不在基类中的派生类函数。<br>第12.8节演示了如何安全地使用向下转换。</p></blockquote><p><strong>将一个基类指针强制类型转换为其直接派生类或者间接派生类是允许的 为了发送那些在基类中不出现的派生类对象的信息 这种转换是必要的</strong></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607193306336.png" alt="image-20240607193306336"></p><blockquote><p>Why virtual Functions Are Useful<br>Consider why virtual functions are useful: Suppose that shape classes such as Circle, Triangle, Rectangle and Square are all derived from base class Shape.<br>Each of these classes might be endowed with the ability to draw itself via a member function draw, but the function for each shape is quite different.<br>In a program that draws a set of shapes, it would be useful to be able to treat all the shapes generally as objects of the base class Shape.<br>To draw any shape, we could simply use a base-class Shape pointer to invoke function draw and let the program determine dynamically (i.e., at runtime) which derived-class draw function to use, based on the type of the object to which the base-class Shape pointer points at any given time.<br>This is polymorphic behavior.<br>虚函数为什么有用：考虑一下虚函数有用的原因:假设形状类(如Circle、Triangle、Rectangle和Square)都派生自基类shape。<br>这些类中的每一个都可以通过成员函数draw来赋予自己绘图的能力，</p><p>但是每个形状的函数是完全不同的。</p><p>在绘制一组形状的程序中，如果能够将所有形状一般视为Shape基类的对象，这将是很有用的。</p><p>要绘制任何形状，我们可以简单地使用一个基类shape指针来调用函数draw，并让程序动态地(即，在运行时)</p><p>根据基类shape指针在任何给定时间所指向的对象的类型来决定要使用哪个派生类的绘制函数。这就是多态行为.</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607194403976.png" alt="image-20240607194403976"></p><blockquote><p>Declaring virtual Functions<br>To enable this behavior, we declare draw in the base class as a virtual function, and we override draw in each of the derived classes to draw the appropriate shape.<br>From an implementation perspective, overriding a function is no different than redefining one.<br>An overridden function in a derived class has the same signature and return type (i.e., prototype) as the function it overrides in its base class.<br>If we declare the base-class function as virtual, we can override that function to enable polymorphic behavior.<br>We declare a virtual function by preceding the function’s prototype with the key-word virtual in the base class.</p><p>声明虚函数<br>为了启用这种行为，我们在基类中将draw声明为虚函数，并在每个派生类中重写draw以绘制适当的形状。<br>从实现的角度来看，重写函数与重新定义函数没有什么不同。</p><p><strong>派生类中被重写的函数与它在基类中重写的函数具有相同的签名和返回类型(即原型)。</strong></p><p><strong>如果将基类函数声明为virtual，则可以重写该函数以启用多态行为。</strong></p><p><strong>通过在基类中在函数原型前面加上关键字virtual来声明虚函数。</strong></p></blockquote><p>一个函数一旦声明为virtual，那么从它开始的所有继承的派生类中，它将始终保持是virtual的。</p><p>建议：即使一个函数在层次结构的高层中已经被声明为了virtual（也就是其已经成为了隐式的virtual函数），仍然建议在其前面添加virtual，在类层次结构的每一级中都把它显式声明为virtual。</p><p>override关键词：在每一个重载后的函数后面加上，声明是从父类的成员函数重载下来，会迫使编译器检查基类有没有对应的virtual成员函数，如果没有，则编译器会报错。</p><p>如果派生类函数不重载virtual函数，那么它会简单继承其父类的virtual函数。</p><blockquote><p>Invoking a virtual Function Through a Base-Class Pointer or Reference<br>If a program invokes a virtual function through a base-class pointer to a derived-class object (e.g., shapePtr-&gt;draw()) or a base-class reference to a derived-class object (e.g., shapeRef.draw()), the program will choose the correct derived-class function dynamically (i.e., at execution time) based on the object type—not the pointer or reference type.<br>Known as dynamic binding or late binding.<br>通过基类指针或引用调用虚函数</p><p>如果程序通过指向派生类对象的基类指针(例如shapetr -&gt;draw())或指向派生类对象的基类引用(例如shapeRef.draw())调用虚函数，</p><p>程序将根据对象类型(即在执行时)动态地(即在执行时)选择正确的派生类函数，而不是指针或引用类型。</p><p>称为动态绑定或延迟绑定。</p></blockquote><blockquote><p>Invoking a virtual Function Through an Object’s Name<br>When a virtual function is called by referencing a specific object by name and using the dot member-selection operator (e.g., squareObject.draw()), the function invocation is re-solved at compile time (this is called static binding) and the virtual function that is called is the one defined for (or inherited by) the class of that particular object—this is not polymorphic behavior.<br>Dynamic binding with virtual functions occurs only off pointers (and, as we’ll soon see, references).<br>通过对象的名称调用虚函数</p><p>当通过引用特定对象的名称并使用点成员选择操作符(例如，squareObject.draw())调用虚函数时，函数调用在编译时被重新解析(这称为静态绑定)，并且被调用的虚函数是为该特定对象的类定义的(或由该类继承的)虚函数——这不是多态行为。</p><p>与虚函数的动态绑定只发生在指针之外(我们很快就会看到，还有引用)。</p></blockquote><p>静态绑定：virtual函数通过，按名引用特定对象，或者，使用圆点成员运算符，来调用 这个是在编译的时候已经被确定了。<br>动态绑定：只能通过指针，或者，引用句柄来完成 。</p><p>声明成员函数virtual会导致程序根据句柄指向的对象类型(而不是句柄的类型)动态地确定调用哪个函数。</p><blockquote><p>virtual Destructors<br>A problem can occur when using polymorphism to process dynamically allocated objects of a class hierarchy.<br>If a derived-class object with a non-virtual destructor is destroyed by applying the delete operator to a base-class pointer to the object, the C++ standard specifies that the behavior is undefined.<br>The simple solution to this problem is to create a public virtual destructor in the base class.<br>If a base class destructor is declared virtual, the destructors of any derived classes are also virtual and they override the base class destructor.</p><p>虚拟析构函数：<br>当使用多态性处理类层次结构中动态分配的对象时，可能会出现问题。<br>如果通过对指向该对象的基类指针应用delete操作符来销毁带有非虚析构函数的派生类对象，则c++标准规定该行为未定义。<br>这个问题的简单解决方案是在基类中创建一个公共虚析构函数。<br>如果将基类析构函数声明为虚函数，则任何派生类的析构函数也是虚函数，并且它们覆盖基类析构函数。</p></blockquote><blockquote><p>在C++中，当我们使用基类指针指向一个派生类对象，并通过这个基类指针调用派生类对象的方法时，<br>如果这些方法在基类中被声明为虚函数（virtual），那么会发生动态绑定（或称为多态）。<br>然而，当涉及到析构函数时，如果基类的析构函数不是虚函数，那么就会有问题。<br>具体来说，当我们通过基类指针删除派生类对象时，<br>如果基类的析构函数不是虚函数，只会调用基类的析构函数，而不会调用派生类的析构函数。<br>这会导致派生类中特有的数据成员没有被正确释放，造成内存泄漏。</p></blockquote><blockquote><p>如果一个类含有一个virtual函数，那么该类就要提供一个virtual析构函数，即使不一定需要。<br>这样可以保证一个派生类对象通过基类指针删除时，这个派生类对象的析构函数能够被调用 。</p><p>但是构造函数不能是virtual函数。</p></blockquote><blockquote><p>C++11: final Member Functions and Classes<br>In C++11, a base-class virtual function that’s declared final in its prototype, as in<br>virtual someFunction( parameters ) final;<br>cannot be overridden in any derived class—this guarantees that the base class’s final member function definition will be used by all base-class objects and by all objects of the base class’s direct and indirect derived classes.<br>c++ 11: final成员函数和类</p><p>在c++ 11中，在原型中声明为final的基类虚函数，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">someFunction</span><span class="params">( parameters )</span> <span class="keyword">final</span></span>;</span><br></pre></td></tr></table></figure><p>保证了该函数在任何派生类中都不能被覆盖。</p><p>不能在任何派生类中重写——这保证了基类的最终成员函数定义将被所有基类对象以及基类的直接和间接派生类的所有对象使用。</p></blockquote><blockquote><p>As of C++11, you can declare a class as final to prevent it from being used as a base class, as in</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">final</span> <span class="comment">// this class cannot be a base class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// class body</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>Attempting to override a final member function or inherit from a final base class results in a compilation error.</p><p>从c++ 11开始，可以将一个类声明为final，以防止它被用作基类，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">final</span> <span class="comment">//这个类不能是基类</span></span><br><span class="line">｛</span><br><span class="line"><span class="comment">//类主体</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>尝试重写final成员函数或从final基类继承将导致编译错误。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607204035143.png" alt="image-20240607204035143"></p><p><strong>使用多态可以避免上述使用switch语句遇到的问题，并且可以完成同样的功能</strong></p><blockquote><p>There are cases in which it’s useful to define classes from which you never intend to instantiate any objects.<br>Such classes are called abstract classes.<br>Because these classes normally are used as base classes in inheritance hierarchies, we refer to them as abstract base classes.<br>These classes cannot be used to instantiate objects, because, as we’ll soon see, abstract classes are incomplete—derived classes must define the “missing pieces.”<br>An abstract class is a base class from which other classes can inherit.<br>Classes that can be used to instantiate objects are called concrete classes.<br>Such classes define every member function they declare.</p><p>在某些情况下，定义您从未打算从中实例化任何对象的类是有用的。<br>这样的类被称为抽象类。<br>由于这些类通常用作继承层次结构中的基类，因此我们将它们称为抽象基类。</p><p><strong>这些类不能用于实例化对象，因为我们很快就会看到，抽象类是不完整的——派生类必须定义“缺失的部分”。</strong></p><p><strong>抽象类是其他类可以继承的基类。</strong></p><p><strong>可用于实例化对象的类称为具体类。</strong></p><p><strong>这样的类定义了它们声明的每个成员函数。</strong></p><p>抽象基类的目的是为其他类提供合适的基类.</p></blockquote><blockquote><p>Pure Virtual Functions<br>A class is made abstract by declaring one or more of its virtual functions to be “pure.” A pure virtual function is specified by placing “= 0” in its declaration, as in</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual function</span></span><br></pre></td></tr></table></figure><p>The “= 0” is a pure specifier.<br>Pure virtual functions typically do not provide implementations, though they can.</p><p>纯虚函数：<br>通过将类的一个或多个虚函数声明为“纯”，使类成为抽象的。纯虚函数通过在其声明中放置&quot; = 0 &quot;来指定，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual function</span></span><br></pre></td></tr></table></figure><p>“= 0”是一个纯说明符。</p><p>纯虚函数通常不提供实现，尽管它们可以。</p></blockquote><blockquote><p>Each concrete derived class must override all base-class pure virtual functions with concrete implementations of those functions; otherwise the derived class is also abstract.<br>The difference between a virtual function and a pure virtual function is that a virtual function has an implementation and gives the derived class the option of overriding the function.<br>By contrast, a pure virtual function does not have an implementation and requires the derived class to override the function for that derived class to be concrete; otherwise the derived class remains abstract.<br>Pure virtual functions are used when it does not make sense for the base class to have an implementation of a function, but you want all concrete derived classes to implement the function.</p><p>每个具体的派生类必须用这些函数的具体实现覆盖所有基类的纯虚函数，否则派生类也是抽象的。</p><p>虚函数和纯虚函数的区别在于虚函数有一个实现，并为派生类提供了重写函数的选项。</p><p>相比之下，纯虚函数没有实现，并且需要派生类重写该函数，以便派生类是具体的，<strong>否则派生类仍然是抽象的。</strong></p><p><strong>纯虚函数用于基类没有必要实现某个函数，但希望所有具体派生类都实现该函数的情况。</strong></p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607205018334.png" alt="image-20240607205018334"></p><p><strong>抽象类为各个层次中的类提供了公共的通用函数接口，抽象类包含一个或者多个pure virtual函数，这些函数在具体的派生类中必须被重写。</strong></p><p><strong>如果在派生类没有重写pure virtual函数，那么这个派生类也会变成抽象类。</strong></p><p><strong>抽象类至少有一个pure virtual函数，也可以有自己的数据成员，具体的成员函数（包括构造和析构），它们被继承时符合继承的一般规则。</strong></p><p><strong>注意：虽然不能实例化抽象基类，但是可以使用抽象基类的指针或者引用，指向实例化的具体的派生类，从而实现多态。</strong></p><blockquote><p>Although we cannot instantiate objects of an abstract base class, we can use the abstract base class to declare pointers and references that can refer to objects of any concrete classes derived from the abstract class.<br>Programs typically use such pointers and references to manipulate derived-class objects polymorphically.</p><p>虽然不能实例化抽象基类的对象，但可以使用抽象基类声明指针和引用，这些指针和引用可以引用从抽象类派生的任何具体类的对象。<br>程序通常使用这样的指针和引用以多态方式操作派生类对象。</p></blockquote><p><strong>实现继承：<br>是指一个类从另一个类派生，并继承其成员变量和成员函数。在C++中，继承可以是public、protected或private三种访问控制方式。实现继承的关键是派生类能够复用基类的代码，派生类可以增加新的功能或重写基类的方法。</strong></p><p><strong>接口继承：<br>是指一个类实现一个接口，接口定义了类必须提供的行为，但不包含任何实现。在C++中，接口通常用纯虚函数来实现，一个包含纯虚函数的类称为抽象类。</strong></p><blockquote><p>This section discusses how C++ can implement polymorphism, virtual functions and dynamic binding internally.<br>This will give you a solid understanding of how these capabilities really work.<br>More importantly, it will help you appreciate the overhead of polymorphism—in terms of additional memory consumption and processor time.<br>You’ll see that polymorphism is accomplished through three levels of pointers (i.e., “triple indirection”).<br>Then we’ll show how an executing program uses these data structures to execute virtual functions and achieve the dynamic binding associated with polymorphism.<br>Our discussion explains one possible implementation; this is not a language requirement.<br>本节讨论c++如何在内部实现多态性、虚函数和动态绑定。<br>这将使您对这些功能的实际工作方式有一个坚实的理解。<br>更重要的是，它将帮助您了解多态的开销——就额外的内存消耗和处理器时间而言。<br>您将看到，多态性是通过三层指针实现的(即“三重间接”)。<br>然后，我们将展示正在执行的程序如何使用这些数据结构来执行虚函数并实现与多态性相关的动态绑定。<br>我们的讨论解释了一种可能的实现;这不是语言要求。</p></blockquote><blockquote><p>When C++ compiles a class that has one or more virtual functions, it builds a virtual function table (vtable) for that class.<br>The vtable contains pointers to the class’s virtual functions.<br>Just as the name of a built-in array contains the address in memory of the array’s first element, a pointer to a function contains the starting address in memory of the code that performs the function’s task.<br>An executing program uses the vtable to select the proper function implementation each time a virtual function of that class is called.<br>The leftmost column of Fig. 12.18 illustrates the vtables for classes Employee, SalariedEmployee, CommissionEmployee and BasePlusCommissionEmployee.<br>当c++编译一个具有一个或多个虚函数的类时，它为该类构建一个虚函数表(vtable)。<br>虚函数表包含指向该类虚函数的指针。<br>正如内置数组的名称包含该数组第一个元素在内存中的地址一样，</p><p>指向函数的指针包含执行该函数任务的代码在内存中的起始地址。</p><p>正在执行的程序在每次调用该类的虚函数时使用虚函数表选择适当的函数实现。</p><p>图12.18最左边的一列显示了Employee、salarieemployee、CommissionEmployee和BasePlusCommissionEmployee类的变量。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607222304683.png" alt="image-20240607222304683"></p><blockquote><p>Employee Class vtable<br>In the Employee class vtable, the first function pointer is set to 0 (i.e., the nullptr), because function earnings is a pure virtual function and therefore lacks an implementation.<br>The second function pointer points to function print, which displays the employee’s full name and social security number.<br>Any class that has one or more null pointers in its vtable is an abstract class.<br>Classes without any null vtable pointers are concrete classes.</p><p>雇员类虚表<br>在Employee类虚函数表中，第一个函数指针被设置为0(即nullptr)，因为函数earnings是一个纯虚函数，因此缺乏实现。<br>第二个函数指针指向函数print，该函数显示员工的全名和社会保险号。</p><p><strong>任何在虚函数表中有一个或多个空指针的类都是抽象类。</strong></p><p><strong>没有空虚参指针的类是具体类。</strong></p></blockquote><blockquote><p>SalariedEmployee Class vtable<br>Class SalariedEmployee overrides function earnings to return the employee’s weekly salary, so the function pointer points to the earnings function of class SalariedEmployee.<br>SalariedEmployee also overrides print, so the corresponding function pointer points to the SalariedEmployee member function that prints &quot;salaried employee: &quot; followed by the employee’s name, social security number and weekly salary.</p><p>salarieemployee类变量表<br>类salariedemploye重写函数earnings以返回员工的周工资，因此函数指针指向类salariedemploye的收益函数。<br>SalariedEmployee也覆盖了print，因此对应的函数指针指向SalariedEmployee成员函数，该函数打印“salaried employee:”，后面跟着员工的姓名、社会保险号和周薪。</p></blockquote><blockquote><p>CommissionEmployee Class vtable<br>The earnings function pointer in the vtable for class CommissionEmployee points to CommissionEmployee’s earnings function that returns the employee’s gross sales multiplied by the commission rate.<br>The print function pointer points to the CommissionEmployee version of the function, which prints the employee’s type, name, social security number, commission rate and gross sales.<br>As in class SalariedEmployee, both functions override the functions in class Employee.</p><p>CommissionEmployee类函数表<br>类CommissionEmployee的实值表中的收益函数指针指向CommissionEmployee的收益函数，该函数返回雇员的销售总额乘以佣金率。<br>print函数指针指向该函数的CommissionEmployee版本，后者打印员工的类型、姓名、社会保险号、佣金率和销售总额。<br>与salarieemployee类一样，这两个函数都覆盖了Employee类中的函数。</p></blockquote><blockquote><p>BasePlusCommissionEmployee Class vtable<br>The earnings function pointer in the vtable for class BasePlusCommissionEmployee points to the BasePlusCommissionEmployee’s earnings function, which returns the employee’s base salary plus gross sales multiplied by commission rate.<br>The print function pointer points to the BasePlusCommissionEmployee version of the function, which prints the employee’s base salary plus the type, name, social security number, commission rate and gross sales.<br>Both functions override the functions in class CommissionEmployee.<br>BasePlusCommissionEmployee类虚表</p><p>类BasePlusCommissionEmployee的实值表中的收益函数指针指向BasePlusCommissionEmployee的收益函数，该函数返回员工的基本工资加上总销售额乘以佣金率。<br>print函数指针指向该函数的BasePlusCommissionEmployee版本，该版本打印员工的基本工资加上类型、姓名、社会保险号、佣金率和总销售额。<br>这两个函数都覆盖了CommissionEmployee类中的函数。</p></blockquote><blockquote><p>Three Levels of Pointers to Implement Polymorphism<br>Polymorphism is accomplished through an elegant data structure involving three levels of pointers.<br>We’ve discussed one level—the function pointers in the vtable.<br>These point to the actual functions that execute when a virtual function is invoked.<br>Now we consider the second level of pointers.<br>Whenever an object of a class with one or more virtual functions is instantiated, the compiler attaches to the object a pointer to the vtable for that class.<br>This pointer is normally at the front of the object, but it isn’t required to be implemented that way.<br>实现多态的三层指针<br>多态是通过包含三层指针的优雅数据结构实现的。</p><p>我们已经讨论了一个级别——虚函数表中的函数指针，这些指向在调用虚函数时执行的实际函数。</p><p>现在我们考虑第二级指针：每当实例化具有一个或多个虚函数的类的对象时，编译器将指向该类虚函数表的指针附加到该对象上。</p><p>该指针通常位于对象的前面，但并不需要以这种方式实现。</p></blockquote><blockquote><p>In Fig. 12.18, these pointers are associated with the objects created in Fig. 12.17.<br>Notice that the diagram displays each of the object’s data member values.<br>The third level of pointers simply contains the handles to the objects that receive the virtual function calls.<br>The handles in this level may also be references.<br>Fig. 12.18 depicts the vector employees that contains Employee pointers.</p><p>在图12.18中，这些指针与图12.17中创建的对象相关联。<br>注意，图中显示了对象的每个数据成员值。</p><p><strong>第三层指针仅包含接收虚函数调用的对象的句柄。</strong></p><p>这个级别的句柄也可以是引用。<br>图12.18描述了包含Employee指针的vector employees。</p></blockquote><blockquote><p>Thus, the compiler compiles an offset or displacement of four bytes (four bytes for each pointer on today’s popular 32-bit machines, and only one pointer needs to be skipped) into the table of machine-language object-code pointers to find the code that will execute the virtual function call.</p><p>因此，编译器将四个字节的偏移量或位移(在当今流行的32位机器上每个指针四个字节，只需要跳过一个指针)<br>编译到机器语言对象代码指针表中，以查找将执行虚函数调用的代码。64位操作系统上是8个字节。</p></blockquote><blockquote><p>The compiler generates code that performs the following operations.<br>Select the ith entry of employees, and pass it as an argument to function virtualViaPointer. This sets parameter baseClassPtr to point to commissionEmployee.<br>Dereference that pointer to get to the commissionEmployee object.<br>Dereference commissionEmployee’s vtable pointer to get to the CommissionEmployee vtable.<br>Skip the offset of four bytes to select the print function pointer.<br>Dereference the print function pointer to form the “name” of the actual function to execute, and use the function call operator () to execute the appropriate print function.</p><p>编译器生成执行以下操作的代码。<br>选择雇员的第i个条目，并将其作为参数传递给函数virtualViaPointer。这将baseClassPtr参数设置为指向commissionEmployee。<br>解引用该指针以获得commissionEmployee对象。<br>解引用commissionEmployee的实参表指针，以获得commissionEmployee实参表。<br>跳过四个字节的偏移量以选择打印函数指针。</p><p>取消对打印函数指针的引用，形成要执行的实际函数的“名称”，并使用函数调用operator()来执行相应的打印函数。</p></blockquote><p>优化后的Cpp编译器生成的多态代码执行效率和switch语句的效率是一样的，但是对于性能要求很高的需要实时更新的应用程序，多态性的消耗就太高了。</p><blockquote><p>当我们调用<code>delete</code>时，C++会检查指针是否为空。如果指针为空（即指向<code>nullptr</code>），<code>delete</code>操作符会立即返回，而不会尝试释放任何内存。这种行为的设计是为了简化内存管理，使得程序员不必在调用<code>delete</code>之前检查指针是否为空。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 安全地删除空指针</span></span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重新分配并删除</span></span><br><span class="line"> ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 再次删除空指针</span></span><br><span class="line"> ptr = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;All delete operations completed successfully.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="重要注意事项">重要注意事项</h3><ol><li><strong>多次删除同一个指针</strong>：对同一个指针多次调用<code>delete</code>会导致未定义行为。程序员应确保每个指针只调用一次<code>delete</code>，并在删除后将其设置为<code>nullptr</code>以避免重复删除。</li><li><strong>指针悬挂（Dangling Pointer）</strong>：在删除指针后，继续使用这个指针会导致悬挂指针问题。这种情况下指针指向的内存已经被释放，再次访问该内存会导致未定义行为。</li></ol><h3 id="总结">总结</h3><ul><li>对空指针调用<code>delete</code>是安全的，不会引发任何问题。</li><li>删除指针后，应将指针设置为<code>nullptr</code>以避免悬挂指针和重复删除问题。</li><li>多次删除同一个非空指针会导致未定义行为，程序员应避免这种情况。</li></ul></blockquote><blockquote><p>This section demonstrates the powerful capabilities of runtime type information (RTTI) and dynamic casting, which enable a program to determine an object’s type at execution time and act on that object accordingly.<br>Figure 12.19 uses the Employee hierarchy developed in Section 12.6 and increases by 10 percent the base salary of each BasePlusCommissionEmployee.</p><p>本节演示运行时类型信息(RTTI)和动态类型转换的强大功能，它们使程序能够在执行时确定对象的类型，并相应地对该对象进行操作。<br>图12.19使用第12.6节中开发的Employee层次结构，并将每个BasePlusCommissionEmployee的基本工资增加10%。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607233428216.png" alt="image-20240607233428216"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607233438656.png" alt="image-20240607233438656"></p><blockquote><p>Since we process the Employees polymorphically, we cannot (with the techniques you’ve learned so far) be certain as to which type of Employee is being manipulated at any given time.<br>BasePlusCommissionEmployee employees must be identified when we encounter them so they can receive the 10 percent salary increase.<br>To accomplish this, we use operator dynamic_cast (line 39) to determine whether the current Employee’s type is BasePlusCommissionEmployee.<br>This is the downcast operation we referred to in Section 12.3.3.<br>Lines 38–39 dynamically downcast employeePtr from type Employee * to type BasePlusCommissionEmployee *.</p><p>由于我们以多态方式处理Employee，</p><p>因此我们无法(使用到目前为止学到的技术)确定在任何给定时间正在操作哪种类型的Employee。<br>当我们遇到员工时，必须确认他们的身份，这样他们才能获得10%的加薪。</p><p>为此，我们使用操作符dynamic_cast(第39行)来确定当前Employee的类型是BasePlusCommissionEmployee。</p><p>这是我们在12.3.3节中提到的向下转换操作。<br>第38-39行动态地将employeePtr从Employee *类型向下转换为BasePlusCommissionEmployee *类型。</p></blockquote><p><code>dynamic_cast</code> 是 C++ 中用于类型安全的向下转换（downcasting）和横向转换（cross-casting）的运算符。它主要用于带有多态的继承层次中，确保在运行时类型转换的安全性。</p><h3 id="使用场景">使用场景</h3><ol><li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li><li><strong>横向转换（Cross-casting）</strong>：在具有共同基类的不同派生类之间进行转换。</li></ol><h3 id="语法">语法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><ul><li><code>new_type</code>：目标类型，必须是指针或引用类型。</li><li><code>expression</code>：要转换的表达式，必须是指针或引用类型，并且是多态类型（即基类中至少有一个虚函数）。</li></ul><h3 id="动态类型检查">动态类型检查</h3><p><code>dynamic_cast</code> 在运行时进行类型检查，如果转换是安全的，则返回一个指向新类型的指针或引用；如果转换不安全，则返回 <code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code> 异常（对于引用）。</p><h3 id="示例代码">示例代码</h3><h4 id="基本用法">基本用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; <span class="comment">// 必须有一个虚函数，通常是虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkAndCast</span><span class="params">(Base* base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Derived1* d1 = <span class="built_in">dynamic_cast</span>&lt;Derived1*&gt;(base)) &#123;</span><br><span class="line">        d1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Derived2* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(base)) &#123;</span><br><span class="line">        d2-&gt;<span class="built_in">display</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unknown type&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b1 = <span class="keyword">new</span> <span class="built_in">Derived1</span>();</span><br><span class="line">    Base* b2 = <span class="keyword">new</span> <span class="built_in">Derived2</span>();</span><br><span class="line">    Base* b3 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b1); <span class="comment">// 输出: Derived1</span></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b2); <span class="comment">// 输出: Derived2</span></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b3); <span class="comment">// 输出: Unknown type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">    <span class="keyword">delete</span> b3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>checkAndCast</code> 函数使用 <code>dynamic_cast</code> 将基类指针转换为派生类指针，并根据转换结果调用相应的方法。</p><h3 id="注意事项">注意事项</h3><ol><li><strong>必须是多态类型</strong>：<code>dynamic_cast</code> 只能用于具有虚函数的类（多态类型）。</li><li><strong>性能开销</strong>：由于 <code>dynamic_cast</code> 需要在运行时进行类型检查，所以比 <code>static_cast</code> 有更大的性能开销。</li><li><strong>转换失败</strong>：对于指针类型，转换失败会返回 <code>nullptr</code>；对于引用类型，转换失败会抛出 <code>std::bad_cast</code> 异常。</li></ol><h4 id="失败处理示例">失败处理示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Derived&amp; d = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*base);</span><br><span class="line">        d.<span class="built_in">show</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Bad cast: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尝试将基类引用转换为派生类引用失败，<code>dynamic_cast</code> 抛出了 <code>std::bad_cast</code> 异常。</p><h3 id="总结-2">总结</h3><ul><li><code>dynamic_cast</code> 用于类型安全的向下转换和横向转换。</li><li>运行时类型检查，确保转换的安全性。</li><li>只能用于具有虚函数的多态类型。</li><li>转换失败时，对于指针返回 <code>nullptr</code>，对于引用抛出 <code>std::bad_cast</code> 异常。</li></ul><p>使用 <code>dynamic_cast</code> 可以显著提高代码的类型安全性，尤其是在复杂的继承层次结构中。</p><p><strong>能够转化成功的条件是：该基类指向的派生类对象 与dynamic_cast<newType> 中的 newType相同</strong></p><p><strong>否则，如果是指针：则会赋值为nullptr，另外：则是抛出std::bad_cast异常。</strong></p><blockquote><p><code>typeid</code> 运算符是C++中的一种运行时类型信息（RTTI）工具，用于获取对象的实际类型。它返回一个 <code>std::type_info</code> 对象，该对象可以用来比较和识别类型。<code>typeid</code> 运算符在编译时和运行时都可以使用，但在运行时更有用，尤其是处理多态对象时。</p><h3 id="基本用法-2">基本用法</h3><p><code>typeid</code> 运算符的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(expression)</span><br></pre></td></tr></table></figure><p>其中，<code>expression</code> 可以是任何表达式或类型。</p><h3 id="示例代码-2">示例代码</h3><p>以下是一些示例，展示了 <code>typeid</code> 运算符的用法：</p><h4 id="获取基本类型的类型信息">获取基本类型的类型信息</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"> <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of a: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of b: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type of a: i</span><br><span class="line">Type of b: d</span><br></pre></td></tr></table></figure><p>注意：<code>typeid().name()</code> 返回的类型名是实现定义的（通常是编译器特定的表示形式），在不同的编译器中可能有所不同。</p><h4 id="用于多态对象">用于多态对象</h4><p>在多态对象的情况下，<code>typeid</code> 可以用来获取对象的实际类型，而不仅仅是基类的类型。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of b: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of *b: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> b;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type of b: P4Base</span><br><span class="line">Type of *b: 7Derived</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>typeid(b)</code> 返回的是指针类型 <code>Base*</code>，而 <code>typeid(*b)</code> 返回的是 <code>Derived</code>，因为 <code>b</code> 实际上指向一个 <code>Derived</code> 对象。</p><h3 id="比较类型">比较类型</h3><p>可以使用 <code>typeid</code> 运算符来比较两个对象的类型是否相同。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"> Base* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*base) == <span class="built_in">typeid</span>(*derived)) &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;base and derived are of the same type.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;base and derived are of different types.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> base;</span><br><span class="line"> <span class="keyword">delete</span> derived;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base and derived are of different types.</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>typeid(*base)</code> 和 <code>typeid(*derived)</code> 返回不同的类型信息，因此输出表明它们是不同类型的对象。</p><h3 id="注意事项-2">注意事项</h3><ol><li><strong>必须包含虚函数</strong>：在使用 <code>typeid</code> 进行多态类型检查时，基类必须包含至少一个虚函数，否则 <code>typeid</code> 会返回基类的类型而不是派生类的类型。</li><li><strong>类型名的实现依赖</strong>：<code>typeid().name()</code> 返回的类型名是实现定义的，通常在不同的编译器中可能不同。</li><li><strong>空指针</strong>：如果对空指针使用 <code>typeid</code>（如 <code>typeid(*p)</code>），会抛出 <code>std::bad_typeid</code> 异常。</li></ol><h4 id="处理空指针的示例">处理空指针的示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Type of *p: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*p).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，对空指针使用 <code>typeid</code> 会抛出 <code>std::bad_typeid</code> 异常，并输出错误信息。</p><h3 id="总结-3">总结</h3><ul><li><code>typeid</code> 用于获取对象或类型的类型信息，返回一个 <code>std::type_info</code> 对象。</li><li>在多态情况下，<code>typeid</code> 可以用于确定对象的实际类型。</li><li>可以使用 <code>typeid</code> 比较两个对象的类型是否相同。</li><li>对空指针使用 <code>typeid</code> 会抛出 <code>std::bad_typeid</code> 异常。</li><li><code>typeid().name()</code> 返回的类型名是实现定义的，可能因编译器而异。</li></ul></blockquote><p>试图通过基类指针来调用仅在派生类中实现的函数是不允许的，只能调用在基类中实现的函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十一章</title>
      <link href="/posts/8371c227.html"/>
      <url>/posts/8371c227.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第十一章">CPP复习 第十一章</h1><h2 id="public-private-protected-继承">public private protected 继承</h2><p><strong>注意： 以上三种中 基类的private成员都是不可以被它的派生类直接访问的 但是它们仍然被继承下来</strong><br>public继承中：其他类型的成员仍然在作为派生类的成员时保持看其原有的访问权限 如public还是public，protected还是protected<br>通过基类继承来的成员函数，派生类可以操作积累的private成员（前提是原来基类有提供这种功能）<br>注意：友元函数是不被继承的</p><p><strong>注意：由public继承的派生类，继承了所有基类中处构造函数外的所有成员，每个类都提供了自己的构造函数。析构也是同理。</strong></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607150422748.png" alt="image-20240607150422748"></p><p>注意：这里虽然没有继承基类的构造函数，但是可以调用基类的构造函数来实现派生类的构造函数。setBaseSalary是新增的内容<br>cpp要求派生类构造函数调用其基类的构造函数，来初始化继承到派生类的基类的数据成员，所以使用成员初始化器来初始化基类的数据成员，将参数传递给基类的构造函数，<strong>注意参数需要与基类的构造函数定义相符合</strong>。</p><blockquote><p>Figure 11.11 shows BasePlusCommissionEmployee’s member-function implementations.<br>The constructor introduces base-class initializer syntax, which uses a member initializer to pass arguments to the base-class constructor.<br>C++ requires that a derived-class constructor call its base-class constructor to initialize the base-class data members that are inherited into the derived class.<br>If BasePlusCommissionEmployee’s constructor did not invoke class CommissionEmployee’s constructor explicitly, C++ would attempt to invoke class CommissionEmployee’s default constructor—but the class does not have such a constructor, so the compiler would issue an error.<br>图11.11显示了BasePlusCommissionEmployee的成员函数实现。<br>构造函数引入基类初始化式语法，该语法使用成员初始化式将参数传递给基类构造函数。<br>c++要求派生类构造函数调用其基类构造函数来初始化继承到派生类中的基类数据成员。<br>如果BasePlusCommissionEmployee的构造函数没有显式地调用类CommissionEmployee的构造函数，c++将尝试调用类CommissionEmployee的默认构造函数——但是类没有这样的构造函数，因此编译器将发出错误。</p></blockquote><p><strong>C++严格执行访问私有数据成员的限制，因此即使是派生类(与其基类密切相关)也不能访问基类的私有数据。</strong></p><blockquote><p>Including the Base-Class Header in the Derived-Class Header with #include<br>We #include the base class’s header in the derived class’s header (line 8 of Fig. 11.10).<br>This is necessary for three reasons.<br>The derived class uses the base class’s name in line 10, so we must tell the compiler that the base class exists.<br>The compiler uses a class definition to determine the size of an object of that class. A client program that creates an object of a class #includes the class definition to enable the compiler to reserve the proper amount of memory for the object.<br>The compiler must determine whether the derived class uses the base class’s inherited members properly.</p><p>用#include将基类头包含在派生类头中<br>我们将基类的头文件包含在派生类的头文件中(图11.10的第8行)。<br>这是必要的，原因有三。<br>1、派生类在第10行使用基类的名称，<strong>因此必须告诉编译器基类存在</strong>。<br>2、编译器使用类定义来确定该类对象的大小。创建类的对象的客户端程序包含类定义，<strong>以使编译器能够为该对象保留适当数量的内存。</strong><br>3、编译器必须确定派生类是否正确地使用基类的继承成员</p></blockquote><blockquote><p>Linking Process in an Inheritance Hierarchy<br>In Section 3.7, we discussed the linking process for creating an executable GradeBook application.<br>The linking process is similar for a program that uses classes in an inheritance hierarchy.<br>The process requires the object code for all classes used in the program and the object code for the direct and indirect base classes of any derived classes used by the program.<br>The code is also linked with the object code for any C++ Standard Library classes used in the classes or the client code.<br>继承层次结构中的链接过程<br>在第3.7节中，我们讨论了创建可执行的GradeBook应用程序的链接过程。<br>链接过程与在继承层次结构中使用类的程序类似。<br>该过程需要程序中使用的所有类的目标代码，以及程序使用的任何派生类的直接和间接基类的目标代码。<br>代码还与类或客户端代码中使用的任何c++标准库类的目标代码链接。</p></blockquote><p><strong>基类的受保护成员可以在基类的主体内访问，基类的成员和友类，以及从基类派生的任何类的成员和友类都可以访问。</strong></p><blockquote><p>Defining Base Class CommissionEmployee with protected Data<br>Class CommissionEmployee (Fig. 11.12) now declares data members firstName, lastName, socialSecurityNumber, grossSales and commissionRate as protected (lines 31–36) rather than private.<br>The member-function implementations are identical to those in Fig. 11.5.<br>用受保护的数据定义基类CommissionEmployee<br>类CommissionEmployee(图11.12)现在将数据成员firstName、lastName、socialSecurityNumber、grossSales和commissionRate声明为protected(第31-36行)，而不是private。<br>成员函数的实现与图11.5中的实现相同。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607154700559.png" alt="image-20240607154700559"></p><p><strong>派生类的对象也可以访问该派生类的任何间接基类中的受保护成员。</strong></p><blockquote><p>Notes on Using protected Data<br>Inheriting protected data members slightly increases performance, because we can directly access the members without incurring the overhead of calls to set or get member functions.<br>使用受保护资料须知<br>继承受保护的数据成员会略微提高性能，因为我们可以直接访问成员，而不会产生设置或获取成员函数的调用开销。</p><p>在多数情况下，使用private数据成员是更好的软件工程方法，把代码优化交给编译器就可以了。代码也过冗余维护修改和调试</p></blockquote><blockquote><p>Using protected data members creates two serious problems.<br>The derived-class object does not have to use a member function to set the value of the base class’s protected data member.<br>Derived-class member functions are more likely to be written so that they depend on the base-class implementation. Derived classes should depend only on the base-class services (i.e., non-private member functions) and not on the base-class implementation.<br>With protected data members in the base class, if the base-class implementation changes, we may need to modify all derived classes of that base class.<br>Such software is said to be fragile or brittle, because a small change in the base class can “break” derived-class implementation.</p><p>使用受保护的数据成员会产生两个严重的问题。<br>派生类对象不必使用成员函数来设置基类受保护的数据成员的值。<br>派生类成员函数更有可能被编写为依赖于基类实现。派生类应该只依赖于基类服务(即，非私有成员函数)，而不依赖于基类实现。<br>对于基类中受保护的数据成员，如果基类实现发生变化，我们可能需要修改该基类的所有派生类。<br>这样的软件被认为是脆弱的，因为基类中的一个小变化就可以“破坏”派生类的实现。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607160220270.png" alt="image-20240607160220270"></p><blockquote><p>在基类仅向其派生类或者友元，提供服务时（例如非private成员函数时），使用protected成员访问标识符是合适的。</p><p>将基类的数据成员声明为private，可以在修改基类的实现时，不需要修改派生类的实现。</p></blockquote><blockquote><p>注意：从派生类调用重新定义的基类成员函数时使用的语法——将基类名称和二进制作用域解析操作符(::)放在基类成员函数名称之前。<br>注意：必须加上基类类名和:: 否则会造成无限递归的错误，即自己调用自己。</p><p>良好的软件工程实践:如果一个对象的成员函数执行了另一个对象所需的操作，我们应该调用该成员函数，而不是复制它的代码体。</p></blockquote><blockquote><p>子类对象可以直接访问子类中的同名成员。<br>子类对象可以通过加：父类名+::，来访问子类中同名成员。<br>当子类和父类具有相同名字的成员时，子类会隐藏从父类中同名的数据成员，加上父类名+::才可以访问。<br>同名的静态成员和非静态成员的处理方式也一样</p></blockquote><blockquote><p>Instantiating a derived-class object begins a chain of constructor calls in which the derived-class constructor, before performing its own tasks, invokes its direct base class’s constructor either explicitly (via a base-class member initializer) or implicitly (calling the base class’s default constructor).<br>If the base class is derived from another class, the base-class constructor is required to invoke the constructor of the next class up in the hierarchy, and so on.<br>The last constructor called in this chain is the constructor of the class at the base of the hierarchy, whose body actually finishes executing first.<br>The most derived-class constructor’s body finishes executing last.<br>Each base-class constructor initializes the base-class data members that the derived-class object inherits.</p><p>派生类对象的实例化开始了构造函数调用链，其中派生类构造函数在执行自己的任务之前，显式(通过基类成员初始化项)或隐式(调用基类的默认构造函数)调用其直接基类的构造函数。<br>如果基类派生自另一个类，则基类构造函数需要调用层次结构中上一个类的构造函数，依此类推。<br>在此链中调用的最后一个构造函数是位于层次结构基础的类的构造函数，它的主体实际上首先完成执行。<br>派生最多的类的构造函数体最后完成执行。<br>每个基类构造函数初始化派生类对象继承的基类数据成员。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607163345485.png" alt="image-20240607163345485"></p><p>先构造父类，在构造子类，析构的顺序相反。<br>派生类对象被创建时，派生类的构造函数先被调用（立即调用父类的构造函数，父类的构造函数被执行）。后调用成员初始化器，最后调用派生类构造函数的函数体执行。</p><blockquote><p>When a derived-class object is destroyed, the program calls that object’s destructor.<br>This begins a chain (or cascade) of destructor calls in which the derived-class destructor and the destructors of the direct and indirect base classes and the classes’ members execute in reverse of the order in which the constructors executed.<br>When a derived-class object’s destructor is called, the destructor performs its task, then invokes the destructor of the next base class up the hierarchy.<br>This process repeats until the destructor of the final base class at the top of the hierarchy is called.<br>Then the object is removed from memory.<br>当一个派生类对象被销毁时，程序调用该对象的析构函数。<br>这开始了析构函数调用链(或级联)，其中派生类的析构函数、直接基类和间接基类的析构函数以及类成员的执行顺序与构造函数的执行顺序相反。<br>当调用派生类对象的析构函数时，析构函数执行其任务，然后调用层次结构上的下一个基类的析构函数。<br>这个过程一直重复，直到调用位于层次结构顶端的最后一个基类的析构函数。<br>然后从内存中删除对象。</p></blockquote><blockquote><p>Base-class constructors, destructors and overloaded assignment operators (Chapter 10) are not inherited by derived classes.<br>Derived-class constructors, destructors and overloaded assignment operators, however, can call base-class versions.<br>基类的构造函数、析构函数和重载赋值操作符(第10章)不能被派生类继承。<br>但是，派生类的构造函数、析构函数和重载赋值操作符可以调用基类的版本。</p></blockquote><h2 id="C-11：继承自基类的构造函数">C++11：继承自基类的构造函数</h2><blockquote><p>在C++中，继承基类的构造函数是一个非常有用的功能，特别是当你希望子类继承和使用基类的构造函数。自C++11起，C++引入了一种新的语法来简化这个过程。下面是如何在C++中实现继承基类的构造函数。</p><h3 id="基类和子类的定义">基类和子类的定义</h3><p>假设你有一个基类 <code>Base</code> 和一个子类 <code>Derived</code>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类 Base</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 基类构造函数</span></span><br><span class="line"> <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">double</span> b) : <span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b) &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Base constructor called with a = &quot;</span> &lt;&lt; m_a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; m_b &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> m_a;</span><br><span class="line"> <span class="type">double</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义子类 Derived</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 继承基类的构造函数</span></span><br><span class="line"> <span class="comment">//使用Base::Base;</span></span><br><span class="line"><span class="comment">//在派生类定义中的任何地方。</span></span><br><span class="line"> <span class="keyword">using</span> Base::Base;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 你可以在子类中添加更多成员和函数</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Derived class function called.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 使用继承的基类构造函数来创建 Derived 对象</span></span><br><span class="line"> <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">42</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line"> obj.<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码解释">代码解释</h3><ol><li><p><strong>基类定义：</strong></p><ul><li><code>Base</code> 类包含一个带有两个参数（<code>int</code> 和 <code>double</code>）的构造函数。</li><li>构造函数的实现打印出传递给它的参数值。</li></ul></li><li><p><strong>子类定义：</strong></p><ul><li><code>Derived</code> 类继承自 <code>Base</code> 类。</li><li><code>using Base::Base;</code> 这一行代码告诉编译器将基类 <code>Base</code> 的构造函数引入到子类 <code>Derived</code> 中。这允许你使用 <code>Base</code> 的构造函数来创建 <code>Derived</code> 对象。</li><li><code>Derived</code> 类中还定义了一个 <code>display</code> 函数，用于演示子类特有的功能。</li></ul></li><li><p><strong>主函数：</strong></p><ul><li>在 <code>main</code> 函数中，我们使用 <code>Base</code> 的构造函数来创建一个 <code>Derived</code> 对象，并传递两个参数。</li><li>创建对象时，将调用 <code>Base</code> 的构造函数，并输出相应的信息。</li><li>然后调用 <code>display</code> 函数来展示 <code>Derived</code> 类的特有功能。</li></ul></li></ol><h3 id="结果">结果</h3><p>运行上述代码将输出：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Base constructor called with a = 42, b = 3.14</span><br><span class="line">Derived class function called.</span><br></pre></td></tr></table></figure><p>这种方式简化了代码，特别是在基类有多个构造函数的情况下，子类可以通过 <code>using</code> 语句一次性继承所有这些构造函数，而不必逐个定义。</p><p>希望这个示例能帮助你理解如何在C++中继承基类的构造函数。如果有更多问题或需要进一步的解释，请随时问我！</p></blockquote><blockquote><p>When you inherit constructors:<br>By default, each inherited constructor has the same access level (public, protected or private) as its corresponding base-class constructor.<br>The default, copy and move constructors are not inherited.<br>If a constructor is deleted in the base class by placing = delete in its prototype, the corresponding constructor in the derived class is also deleted.<br>If the derived class does not explicitly define constructors, the compiler generates a default constructor in the derived class—even if it inherits other constructors from its base class.<br>If a constructor that you explicitly define in a derived class has the same parameter list as a base-class constructor, then the base-class constructor is not inherited.<br>A base-class constructor’s default arguments are not inherited. Instead, the compiler generates overloaded constructors in the derived class.<br>当你继承构造函数时:<br>默认情况下，每个继承的构造函数与其相应的基类构造函数具有相同的访问级别(public、protected或private)。<br>默认的、复制的和移动的构造函数是不被继承的。<br>如果通过在原型中放置= delete来删除基类中的构造函数，则派生类中相应的构造函数也会被删除。<br>如果派生类没有显式定义构造函数，则编译器在派生类中生成默认构造函数——即使它从基类继承了其他构造函数。<br>如果在派生类中显式定义的构造函数具有与基类构造函数相同的参数列表，则不继承基类构造函数。<br>基类构造函数的默认参数不被继承。相反，编译器在派生类中生成重载构造函数。</p></blockquote><blockquote><p>When deriving a class from a base class, the base class may be inherited through public, protected or private inheritance.<br>Use of protected and private inheritance is rare.<br>Figure 11.16 summarizes for each type of inheritance the accessibility of base-class members in a derived class.<br>The first column contains the base-class access specifiers.<br>A base class’s private members are never accessible directly from a derived class, but can be accessed through calls to the public and protected members of the base class.<br>从基类派生类时，基类可以通过公共继承、保护继承或私有继承继承。很少使用受保护的私有继承。<br>图11.16总结了每种继承类型对派生类中基类成员的可访问性。<br>第一列包含基类访问说明符。<br>基类的私有成员永远不能从派生类直接访问，但可以通过调用基类的公共成员和受保护成员来访问</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240607164759069.png" alt="image-20240607164759069"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第十章</title>
      <link href="/posts/fa563def.html"/>
      <url>/posts/fa563def.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第十章">CPP复习 第十章</h1><blockquote><p>string类中的[]重载运算符没有提供任何的边界检查 。<br>而at有提供边界检查，如果是一个无效的下标，会抛出一个异常。如果在范围内，返回的是一个可以修改的左值或者const引用(右值)<br>cpp不允许创建新的运算符 但允许大部分运算符被重载</p></blockquote><blockquote><p>Operator overloading is not automatic—you must write operator-overloading functions to perform the desired operations.<br>An operator is overloaded by writing a non-static member function definition or non-member function definition as you normally would, except that the function name starts with the keyword operator followed by the symbol for the operator being overloaded.<br>For example, the function name operator+ would be used to overload the addition operator (+) for use with objects of a particular class (or enum).<br>操作符重载不是自动的，您必须编写操作符重载函数来执行所需的操作。<br>操作符通过编写非静态成员函数定义或通常的非成员函数定义来重载，只是函数名以关键字operator开头，后跟被重载操作符的符号。<br>例如，函数名operator+可用于重载加法操作符(+)，以便与特定类(或enum)的对象一起使用。</p></blockquote><p><strong>运算符优先级：算术运算、逻辑运算、赋值运算</strong></p><blockquote><p>When operators are overloaded as member functions, they must be non-static, because they must be called on an object of the class and operate on that object.<br>To use an operator on class objects, you must define overloaded operator functions for that class—with three exceptions.<br>The assignment operator (=) may be used with most classes to perform memberwise assignment of the data members—each data member is assigned from the assignment’s “source” object (on the right) to the “target” object (on the left).<br>Memberwise assignment is dangerous for classes with pointer members, so we’ll explicitly overload the assignment operator for such classes.<br>The address operator (&amp;) returns a pointer to the object; this operator also can be overloaded.<br>The comma operator evaluates the expression to its left then the expression to its right, and returns the value of the latter expression.</p><p>当操作符作为成员函数重载时，它们必须是非静态的，因为它们必须在类的对象上调用并对该对象进行操作。<br>要在类对象上使用操作符，必须为该类定义重载的操作符函数——有三个例外。<br>大多数类都可以使用赋值操作符(=)来执行数据成员的成员赋值——每个数据成员从赋值的“源”对象(右侧)赋值到“目标”对象(左侧)。<br>对于具有指针成员的类，按成员赋值是危险的，因此将显式重载此类类的赋值操作符。<br>地址操作符(&amp;)返回指向该对象的指针;该操作符也可以被重载。<br>逗号操作符对左边的表达式求值，然后对右边的表达式求值，并返回后一个表达式的值。</p></blockquote><blockquote><p><em><em>不允许重载的运算符：.     .</em>     ::    ?:</em>*</p></blockquote><blockquote><p>The precedence of an operator cannot be changed by overloading.<br>However, parentheses can be used to force the order of evaluation of overloaded operators in an expression.<br>The associativity of an operator cannot be changed by overloading<br>if an operator normally associates from left to right, then so do all of its overloaded versions.<br>You cannot change the “arity” of an operator (that is, the number of operands an operator takes)<br>overloaded unary operators remain unary operators; overloaded binary operators remain binary operators. Operators &amp;, * , + and - all have both unary and binary versions; these unary and binary versions can be separately overloaded.<br>操作符的优先级不能通过重载来改变。<br>但是，括号可用于强制表达式中重载操作符的求值顺序。<br>操作符的结合性不能通过重载来改变<br>如果操作符通常从左到右关联，那么它的所有重载版本也是如此。<br>不能更改操作符的“arity”(即操作数的个数)。<br>重载一元操作符仍然是一元操作符;重载的二元操作符仍然是二元操作符。操作符&amp;、*、+和-都有一元和二元版本;这些一元和二进制版本可以分别重载。</p></blockquote><blockquote><p>You cannot create new operators; only existing operators can be overloaded.<br>The meaning of how an operator works on values of fundamental types cannot be changed by operator overloading.<br>For example, you cannot make the + operator subtract two ints. Operator overloading works only with objects of user-defined types or with a mixture of an object of a user-defined type and an object of a fundamental type.<br>你不能创建新的运营商;只能重载现有的操作符。<br>操作符对基本类型的值的操作方式不能通过操作符重载来改变。<br>例如，不能使用+操作符减去两个int型。操作符重载只适用于用户定义类型的对象，或者用户定义类型的对象和基本类型的对象的混合。</p></blockquote><blockquote><p>Related operators, like + and +=, must be overloaded separately.<br>When overloading (), [], -&gt; or any of the assignment operators, the operator overloading function must be declared as a class member.<br>For all other overloadable operators, the operator overloading functions can be member functions or non-member functions.<br>相关操作符，如+和+=，必须分别重载。<br>当重载()、[]、-&gt;或任何赋值操作符时，必须将操作符重载函数声明为类成员。<br>对于所有其他可重载操作符，操作符重载函数可以是成员函数或非成员函数。</p></blockquote><blockquote><p>A binary operator can be overloaded as a non-static member function with one parameter or as a non-member function with two parameters (one of those parameters must be either a class object or a reference to a class object).<br>As a non-member function, binary operator &lt; must take two arguments—one of which must be an object (or a reference to an object) of the class.<br>二元操作符可以重载为带有一个形参的非静态成员函数，也可以重载为带有两个形参的非成员函数(其中一个形参必须是类对象或对类对象的引用)。<br>作为非成员函数，二元操作符&lt;必须接受两个实参——其中一个必须是类的对象(或对对象的引用)。<br>一个非成员运算符函数因为性能原因 通常被声明为类的友元</p></blockquote><blockquote><p><strong>作为成员函数的二元重载运算符：<br>仅当左操作数是该类的对象且重载函数是一个成员时，二元运算符的重载函数才能作为成员函数。</strong></p><p><strong>作为非成员函数：<br>必须带有两个参数：其中一个必须是运算符有关系的类的对象或者是该类对象的引用。</strong></p></blockquote><blockquote><p><strong>istream的ignore成员函数: ignore(n)n指的是跳过的字符个数，不设置默认为1个字符</strong></p></blockquote><blockquote><p>Function operator&gt;&gt; returns istream reference input (i.e., cin).<br>This enables input operations on PhoneNumber objects to be cascaded with input operations on other PhoneNumber objects or on objects of other data types.<br>函数操作符&gt;&gt;返回istream引用输入(即cin)。<br>这使得PhoneNumber对象上的输入操作可以与其他PhoneNumber对象或其他数据类型的对象上的输入操作级联。</p></blockquote><blockquote><p>二元运算符的重载运算符函数可以作为成员函数来实现的前提条件是仅当左操作数是该函数所在类的对象</p></blockquote><blockquote><p>Why Overloaded Stream Insertion and Stream Extraction Operators Are Overloaded as Non-Member Functions<br>The overloaded stream insertion operator (&lt;&lt;) is used in an expression in which the left operand has type ostream &amp;, as in cout &lt;&lt; classObject.<br>To use the operator in this manner where the right operand is an object of a user-defined class, it must be overloaded as a non-member function.<br>为什么重载流插入和流提取操作符重载为非成员函数<br>重载流插入操作符(&lt;&lt;)用于左操作数类型为ostream &amp;的表达式，如cout &lt;&lt; classsobject。<br>若要以这种方式使用操作符，右操作数是用户定义类的对象，则必须将其重载为非成员函数。</p><p>Similarly, the overloaded stream extraction operator (&gt;&gt;) is used in an expression in which the left operand has type istream &amp;, as in cin &gt;&gt; classObject, and the right operand is an object of a user-defined class, so it, too, must be a non-member function.<br>Each of these overloaded operator functions may require access to the private data members of the class object being output or input, so these overloaded operator functions can be made friend functions of the class for performance reasons.<br>类似地，在左操作数类型为istream &amp;的表达式中使用重载流提取操作符(&gt;&gt;)，如cin &gt;&gt; classsobject，右操作数是用户定义类的对象，因此它也必须是非成员函数。<br>这些重载操作符函数中的每一个都可能需要访问作为输出或输入的类对象的私有数据成员，因此出于性能原因，可以将这些重载操作符函数设置为类的友元函数。</p></blockquote><blockquote><p>A unary operator for a class can be overloaded as a non-static member function with no arguments or as a non-member function with one argument that must be an object (or a reference to an object) of the class.<br>A unary operator such as ! may be overloaded as a non-member function with one parameter.<br>类的一元操作符可以重载为不带参数的非静态成员函数，也可以重载为带一个参数的非成员函数，该参数必须是类的对象(或对对象的引用)。<br>一元操作符，如!可以作为带有一个形参的非成员函数重载。</p></blockquote><blockquote><p>The prefix and postfix versions of the increment and decrement operators can all be overloaded.<br>To overload the increment operator to allow both prefix and postfix increment usage, each overloaded operator function must have a distinct signature, so that the compiler will be able to determine which version of ++ is intended.<br>The prefix versions are overloaded exactly as any other prefix unary operator would be.<br>自增和自减操作符的前缀和后缀版本都可以重载。<br>要重载自增操作符以允许同时使用前缀和后缀自增，每个重载的操作符函数必须具有不同的签名，以便编译器能够确定要使用哪个版本的++。<br>前缀版本的重载与任何其他前缀一元操作符完全相同</p></blockquote><blockquote><p>Suppose that we want to add 1 to the day in Date object d1.<br>When the compiler sees the preincrementing expression ++d1, the compiler generates the member-function call<br>d1.operator++()<br>The prototype for this operator function would be<br>Date &amp;operator++();<br>If the prefix increment operator is implemented as a non-member function, then, when the compiler sees the expression ++d1, the compiler generates the function call<br>operator++( d1 )<br>The prototype for this operator function would be declared in the Date class as<br>Date &amp;operator++( Date &amp; );<br>前置运算符返回的是类对象的引用 后置运算返回的是一个类的副本<br>不能返回对一个局部对象的引用（或者指针）</p></blockquote><blockquote><p>Overloading the Postfix Increment Operator<br>Overloading the postfix increment operator presents a challenge, because the compiler must be able to distinguish between the signatures of the overloaded prefix and postfix increment operator functions.<br>The convention that has been adopted in C++ is that, when the compiler sees the postincrementing expression d1++, it generates the member-function call<br>d1.operator++( 0 )<br>The prototype for this function is<br>Date operator++( int )<br>The argument 0 is strictly a “dummy value” that enables the compiler to distinguish between the prefix and postfix increment operator functions.<br>The same syntax is used to differentiate between the prefix and postfix decrement operator functions.<br>重载后缀自增操作符<br>参数0是严格意义上的“假值”，它使编译器能够区分前缀和后缀自增操作符函数。<br>相同的语法用于区分前缀和后缀递减操作符函数。</p></blockquote><blockquote><p>Obtaining Dynamic Memory with new<br>The new operator allocates storage of the proper size for an object of type Time, calls the default constructor to initialize the object and returns a pointer to the type specified to the right of the new operator (i.e., a Time *).<br>If new is unable to find sufficient space in memory for the object, it indicates that an error occurred by “throwing an exception.”<br>使用new获取动态内存<br>new操作符为Time类型的对象分配适当大小的存储空间，调用默认构造函数初始化该对象，并返回指向new操作符右侧指定的类型的指针(即Time *)。<br>如果new无法在内存中为对象找到足够的空间，则通过“抛出异常”表示发生了错误。</p></blockquote><blockquote><p>Releasing Dynamic Memory with delete<br>To destroy a dynamically allocated object, use the delete operator as follows:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure><p>This statement first calls the destructor for the object to which ptr points, then deallocates the memory associated with the object, returning the memory to the free store.<br>使用delete释放动态内存<br>要销毁动态分配的对象，使用delete操作符，如下所示:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure><p>该语句首先调用ptr所指向对象的析构函数，然后释放与该对象关联的内存，将内存返回给自由存储区。</p></blockquote><blockquote><p>Initializing Dynamic Memory<br>You can provide an initializer for a newly created fundamental-type variable, as in<br>double *ptr = new double( 3.14159 );<br>The same syntax can be used to specify a comma-separated list of arguments to the constructor of an object.<br>初始化动态内存<br>可以为新创建的基本类型变量提供初始化项，如<br>Double *ptr = new Double (3.14159);<br>可以使用相同的语法为对象的构造函数指定以逗号分隔的参数列表。</p></blockquote><blockquote><p>Dynamically Allocating Built-In Arrays with new []<br>You can also use the new operator to allocate built-in arrays dynamically.<br>For example, a 10-element integer array can be allocated and assigned to gradesArray as follows:<br>int *gradesArray = new int<a href=""> 10 </a>;<br>The parentheses following new int[10] value initialize the array’s elements—fundamental numeric types are set to 0, bools are set to false, pointers are set to nullptr and class objects are initialized by their default constructors.<br>A dynamically allocated array’s size can be specified using any non-negative integral expression that can be evaluated at execution time.<br>使用new[]动态分配内置数组<br>还可以使用new操作符动态分配内置数组。<br>例如，一个包含10个元素的整数数组可以这样分配给gradesArray:<br>int *gradesArray = new int<a href="">10</a>;<br>new int[10] value后面的圆括号初始化数组的元素——基本数字类型设置为0,bool设置为false，指针设置为nullptr，类对象由其默认构造函数初始化。</p><p>动态分配数组的大小可以使用任何可以在执行时计算的非负积分表达式来指定。</p></blockquote><blockquote><p>C++11: Using a List Initializer with a Dynamically Allocated Built-In Array<br>Prior to C++11, when allocating a built-in array of objects dynamically, you could not pass arguments to each object’s constructor—each object was initialized by its default constructor. In C++11, you can use a list initializer to initialize the elements of a dynamically allocated built-in array, as in<br>int *gradesArray = new int[ 10 ]{};<br>The empty set of braces as shown here indicates that default initialization should be used for each element—for fundamental types each element is set to 0.<br>The braces may also contain a comma-separated list of initializers for the array’s elements.<br>c++ 11:在动态分配的内置数组中使用列表初始化式<br>在c++ 11之前，当动态分配内置对象数组时，不能向每个对象的构造函数传递参数——每个对象都由其默认构造函数初始化。在c++ 11中，可以使用列表初始化器初始化动态分配的内置数组的元素，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *gradesArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里所示的空大括号表明应该对每个元素使用默认初始化—对于基本类型，每个元素都设置为0。<br>大括号还可以包含一个以逗号分隔的数组元素初始化式列表。</p></blockquote><blockquote><p>Releasing Dynamically Allocated Built-In Arrays with delete []<br>To deallocate a dynamically allocated array, use the statement</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure><p>If the pointer points to a built-in array of objects, the statement first calls the destructor for every object in the array, then deallocates the memory.<br>Using delete or [] on a nullptr has no effect.<br>使用delete释放动态分配的内置数组[]<br>要释放动态分配的数组，请使用语句</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Delete [] ptr;</span><br></pre></td></tr></table></figure><p>如果指针指向内置的对象数组，则语句首先为数组中的每个对象调用析构函数，然后释放内存。<br>在nullptr上使用delete或[]不起作用。</p></blockquote><blockquote><p>用delete []来删除单个对象的结果 是没有定义的（根据不同的编译器 结果可能不同）</p></blockquote><blockquote><p>C++11: Managing Dynamically Allocated Memory with unique_ptr<br>C++11’s new unique_ptr is a “smart pointer” for managing dynamically allocated memory.<br>When a unique_ptr goes out of scope, its destructor automatically returns the managed memory to the free store.<br>c++ 11:用unique_ptr管理动态分配的内存<br>c++ 11新增的unique_ptr是一个“智能指针”，用于管理动态分配的内存。<br>当unique_ptr超出作用域时，它的析构函数自动将托管内存返回给自由存储区。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第九章</title>
      <link href="/posts/7f64182b.html"/>
      <url>/posts/7f64182b.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第九章">CPP复习 第九章</h1><blockquote><p>Coverage includes (cont.):<br>How default arguments can be used in constructors.<br>Destructors that perform “termination housekeeping” on objects before they’re destroyed.<br>The order in which constructors and destructors are called.<br>We show that returning a reference or pointer to private data breaks the encapsulation of a class, allowing client code to directly access an object’s data.<br>We use default memberwise assignment to assign an object of a class to another object of the same class.<br>承保范围包括(续):<br>如何在构造函数中使用默认实参。<br>在对象被销毁之前对其执行“终止管理”的析构函数。<br>调用构造函数和析构函数的顺序。<br>我们展示了返回私有数据的引用或指针打破了类的封装，允许客户端代码直接访问对象的数据。<br>使用默认的成员赋值将类的一个对象赋值给同一类的另一个对象。</p></blockquote><blockquote><p>Coverage includes (cont.):<br>const objects and const member functions to prevent modifications of objects and enforce the principle of least privilege.<br>Composition—a form of reuse in which a class can have objects of other classes as members.<br>Friendship to specify that a nonmember function can also access a class’s non-public members—a technique that’s often used in operator overloading for performance reasons.<br>this pointer, which is an implicit argument in all calls to a class’s non-static member functions, allowing them to access the correct object’s data members and non-static member functions.<br>承保范围包括(续):<br>Const对象和Const成员函数，以防止对对象的修改并执行最小权限原则。<br>组合——一种重用形式，其中一个类可以拥有其他类的对象作为成员。<br>指定非成员函数也可以访问类的非公共成员——出于性能原因，在操作符重载中经常使用这种技术。<br>这个指针是所有调用类的非静态成员函数的隐式参数，允许它们访问正确对象的数据成员和非静态成员函数。</p></blockquote><blockquote><p>Prevents the code between #ifndef and #endif from being included if the name TIME_H has been defined.<br>If the header has not been included previously in a file, the name TIME_H is defined by the #define directive and the header file statements are included.<br>If the header has been included previously, TIME_H is defined already and the header file is not included again.<br>如果已经定义了名称TIME_H，则防止包含#ifndef和#endif之间的代码。<br>如果头文件之前没有包含在文件中，则名称TIME_H由#define指令定义，并包含头文件语句。<br>如果头文件之前已经包含，TIME_H已经被定义，并且头文件不再被包含。</p></blockquote><blockquote><p>Before C++11, only static const int data members (which you saw in Chapter 7) could be initialized where they were declared in the class body.<br>For this reason, data members typically should be initialized by the class’s constructor as there is no default initialization for fundamental-type data members.<br>As of C++11, you can now use an in-class initializer to initialize any data member where it’s declared in the class definition.</p><p>在c++11之前，只有静态const int数据成员(你在第7章看到过)可以在类体中声明的地方初始化。<br>由于这个原因，数据成员通常应该由类的构造函数初始化，因为基本类型数据成员没有默认初始化。<br>从c++11开始，您现在可以使用类内初始化器来初始化在类定义中声明的任何数据成员。</p></blockquote><blockquote><p>Parameterized stream manipulator setfill specifies the fill character that is displayed when an integer is output in a field wider than the number of digits in the value.<br>The fill characters appear to the left of the digits in the number, because the number is right aligned by default—for left aligned values, the fill characters would appear to the right.<br>If the number being output fills the specified field, the fill character will not be displayed.<br>Once the fill character is specified with setfill, it applies for all subsequent values that are displayed in fields wider than the value being displayed.<br>参数化流操纵符setfill指定当在大于值中位数的字段中输出整数时显示的填充字符。<br>填充字符出现在数字中数字的左边，因为默认情况下数字是右对齐的——对于左对齐的值，填充字符将出现在右边。<br>如果正在输出的数字填充了指定的字段，则不显示填充字符。<br>一旦用setfill指定了填充字符，它就应用于显示在比所显示的值更宽的字段中的所有后续值。<br>即setfill是黏性设置，注意setw不是黏性设置。</p></blockquote><blockquote><p>Defining Member Functions Outside the Class Definition; Class Scope<br>Even though a member function declared in a class definition may be defined outside that class definition, that member function is still within that class’s scope.<br>If a member function is defined in the class’s body, the compiler attempts to inline calls to the member function.<br>在类定义之外定义成员函数;类作用域<br>即使在类定义中声明的成员函数可以在该类定义之外定义，该成员函数仍然在该类的作用域中。<br>如果在类的主体中定义了成员函数，则编译器会尝试内联调用该成员函数。</p></blockquote><blockquote><p>A class’s data members and member functions belong to that class’s scope.<br>Nonmember functions are defined at global namespace scope, by default.<br>Within a class’s scope, class members are immediately accessible by all of that class’s member functions and can be referenced by name.<br>Outside a class’s scope, public class members are referenced through one of the handles on an object—an object name, a reference to an object or a pointer to an object.<br>类的数据成员和成员函数属于该类的作用域。<br>默认情况下，非成员函数在全局命名空间范围内定义。<br>在类的作用域中，类的所有成员函数都可以立即访问类成员，并且可以通过名称引用类成员。<br>在类的作用域之外，通过对象的句柄之一(对象名称、对象引用或对象指针)引用公共类成员。</p></blockquote><blockquote><p>Class Scope and Block Scope<br>If a member function defines a variable with the same name as a variable with class scope, the class-scope variable is hidden in the function by the block-scope variable.<br>Such a hidden variable can be accessed by preceding the variable name with the class name followed by the scope resolution operator (::).<br>类作用域和块作用域<br>如果成员函数定义了与具有类作用域的变量同名的变量，则类作用域变量被块作用域变量隐藏在函数中。<br>可以通过在变量名前面加上类名和作用域解析操作符(::)来访问这样的隐藏变量</p></blockquote><blockquote><p>Dot (.) and Arrow (-&gt;) Member Selection Operators<br>The dot member selection operator (.) is preceded by an object’s name or with a reference to an object to access the object’s members.<br>The arrow member selection operator (-&gt;) is preceded by a pointer to an object to access the object’s members.<br>点(.)和箭头(-&gt;)成员选择操作符<br>点成员选择运算符(.)前面是对象的名称或对象的引用，以访问对象的成员。<br>箭头成员选择操作符(-&gt;)前面有一个指向对象的指针，用于访问对象的成员。</p></blockquote><blockquote><p>Access Functions<br>Access functions can read or display data.<br>A common use for access functions is to test the truth or falsity of conditions—such functions are often called predicate functions.<br>Utility Functions<br>A utility function (also called a helper function) is a private member function that supports the operation of the class’s other member functions.<br>访问函数<br>访问函数可以读取或显示数据。<br>访问函数的一个常见用途是测试条件的真假——这类函数通常称为谓词函数。<br>效用函数<br>实用函数(也称为辅助函数)是一个私有成员函数，它支持类的其他成员函数的操作</p></blockquote><blockquote><p>C++11: Using List Initializers to Call Constructors<br>C++11 now provides a uniform initialization syntax called list initializers that can be used to initialize any variable. Lines 11–13 of Fig. 9.6 can be written using list initializers as follows:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t2&#123; <span class="number">2</span> &#125;; <span class="comment">// hour specified; minute and second defaulted     </span></span><br><span class="line">Time t3&#123; <span class="number">21</span>, <span class="number">34</span> &#125;; <span class="comment">// hour and minute specified; second defaulted</span></span><br><span class="line">Time t4&#123; <span class="number">12</span>, <span class="number">25</span>, <span class="number">42</span> &#125;; <span class="comment">// hour, minute and second specified </span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">Time t2 = &#123; <span class="number">2</span> &#125;; <span class="comment">// hour specified; minute and second defaulted     </span></span><br><span class="line">Time t3 = &#123; <span class="number">21</span>, <span class="number">34</span> &#125;; <span class="comment">// hour and minute specified; second defaulted</span></span><br><span class="line">Time t4 = &#123; <span class="number">12</span>, <span class="number">25</span>, <span class="number">42</span> &#125;; <span class="comment">// hour, minute and second specified </span></span><br></pre></td></tr></table></figure><p>c++ 11:使用列表初始化式调用构造函数<br>c++ 11现在提供了一种统一的初始化语法，称为列表初始化器，可用于初始化任何变量。图9.6中的第11-13行可以使用列表初始化式编写如下:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t2&#123; <span class="number">2</span> &#125;; <span class="comment">// hour specified; minute and second defaulted     </span></span><br><span class="line">Time t3&#123; <span class="number">21</span>, <span class="number">34</span> &#125;; <span class="comment">// hour and minute specified; second defaulted</span></span><br><span class="line">Time t4&#123; <span class="number">12</span>, <span class="number">25</span>, <span class="number">42</span> &#125;; <span class="comment">// hour, minute and second specified </span></span><br><span class="line"><span class="keyword">or</span></span><br><span class="line">Time t2 = &#123; <span class="number">2</span> &#125;; <span class="comment">// hour specified; minute and second defaulted     </span></span><br><span class="line">Time t3 = &#123; <span class="number">21</span>, <span class="number">34</span> &#125;; <span class="comment">// hour and minute specified; second defaulted</span></span><br><span class="line">Time t4 = &#123; <span class="number">12</span>, <span class="number">25</span>, <span class="number">42</span> &#125;; <span class="comment">// hour, minute and second specified </span></span><br></pre></td></tr></table></figure><p>不带=的形式是首选的。</p></blockquote><blockquote><p>C++11: Overloaded Constructors and Delegating Constructors<br>A class’s constructors and member functions can also be overloaded.<br>Overloaded constructors typically allow objects to be initialized with different types and/or numbers of arguments.<br>To overload a constructor, provide in the class definition a prototype for each version of the constructor, and provide a separate constructor definition for each overloaded version.<br>This also applies to the class’s member functions.</p><p>c++ 11:重载构造函数和委托构造函数<br>类的构造函数和成员函数也可以被重载。<br>重载构造函数通常允许使用不同类型和/或数量的参数初始化对象。<br>要重载构造函数，请在类定义中为每个版本的构造函数提供原型，并为每个重载版本提供单独的构造函数定义。<br>这也适用于类的成员函数。</p></blockquote><blockquote><p>In Figs. 9.4–9.6, the Time constructor with three parameters had a default argument for each parameter. We could have defined that constructor instead as four overloaded constructors with the following prototypes:<br>Time(); // default hour, minute and second to 0<br>Time( int ); // initialize hour; default minute and second to 0<br>Time( int, int); // initialize hour and minute; default second to 0<br>Time( int, int, int ); // initialize hour, minute and second<br>C++11 now allows constructors to call other constructors in the same class.<br>The calling constructor is known as a delegating constructor—it delegates its work to another constructor.</p><p>在图9.4-9.6中，带有三个形参的Time构造函数对每个形参都有一个默认实参。我们可以将该构造函数定义为四个重载构造函数，并使用以下原型:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Time</span>(); <span class="comment">// default hour, minute and second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span> ); <span class="comment">// initialize hour; default minute and second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span>, <span class="type">int</span>); <span class="comment">// initialize hour and minute; default second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> ); <span class="comment">// initialize hour, minute and second</span></span><br></pre></td></tr></table></figure><p>c++ 11现在允许构造函数调用同一类中的其他构造函数。<br>调用构造函数称为委托构造函数——它将自己的工作委托给另一个构造函数。</p><p>The first three of the four Time constructors declared on the previous slide can delegate work to one with three int arguments, passing 0 as the default value for the extra parameters.<br>Use a member initializer with the name of the class as follows:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line"><span class="built_in">Time</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> ) <span class="comment">//delegate to Time( int, int, int )</span></span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="comment">// end constructor with no arguments</span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>( <span class="type">int</span> hour )</span><br><span class="line"><span class="built_in">Time</span>( hour, <span class="number">0</span>, <span class="number">0</span> ) <span class="comment">//delegate to Time( int, int, int )   </span></span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="comment">// end constructor with one argument</span></span><br><span class="line">Time::<span class="built_in">Time</span>( <span class="type">int</span> hour, <span class="type">int</span> minute )</span><br><span class="line"><span class="built_in">Time</span>( hour, minute, <span class="number">0</span> ) <span class="comment">//delegate to Time( int, int, int )</span></span><br><span class="line">&#123;</span><br><span class="line">&#125; <span class="comment">// end constructor with two arguments</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>The name of the destructor for a class is the tilde character (~) followed by the class name.<br>Called implicitly when an object is destroyed.<br>The destructor itself does not actually release the object’s memory—it performs termination housekeeping before the object’s memory is reclaimed, so the memory may be reused to hold new objects.<br>Receives no parameters and returns no value.<br>May not specify a return type—not even void.<br>A class has one destructor.<br>A destructor must be public.<br>If you do not explicitly define a destructor, the compiler defines an “empty” destructor.<br>类的析构函数的名称是类名后面的波浪字符(~)。<br>当对象被销毁时隐式调用。<br>析构函数本身实际上并不释放对象的内存——它在回收对象的内存之前执行终止管理，因此可以重用内存来保存新对象。<br>不接收参数也不返回值。<br>不能指定返回类型——甚至不能指定void。<br>一个类有一个析构函数。<br>析构函数必须是公共的。<br>如果没有显式定义析构函数，编译器将定义一个“空”析构函数。</p></blockquote><blockquote><p>Constructors and destructors are called implicitly.<br>The order in which these function calls occur depends on the order in which execution enters and leaves the scopes where the objects are instantiated.<br>Generally, destructor calls are made in the reverse order of the corresponding constructor calls<br>The storage classes of objects can alter the order in which destructors are called.<br>隐式调用构造函数和析构函数。<br>这些函数调用发生的顺序取决于执行进入和离开对象实例化的作用域的顺序。<br>通常，析构函数调用的顺序与相应的构造函数调用的顺序相反<br>对象的存储类可以改变调用析构函数的顺序。</p></blockquote><blockquote><p>Constructors and destructors are called implicitly.<br>The order in which these function calls occur depends on the order in which execution enters and leaves the scopes where the objects are instantiated.<br>Generally, destructor calls are made in the reverse order of the corresponding constructor calls<br>The storage classes of objects can alter the order in which destructors are called.<br>隐式调用构造函数和析构函数。<br>这些函数调用发生的顺序取决于执行进入和离开对象实例化的作用域的顺序。<br>通常，析构函数调用的顺序与相应的构造函数调用的顺序相反<br>对象的存储类可以改变调用析构函数的顺序。</p></blockquote><blockquote><p>Constructors and Destructors for Local Objects<br>Constructors and destructors for local objects are called each time execution enters and leaves the scope of the object.<br>Destructors are not called for local objects if the program terminates with a call to function exit or function abort.<br>局部对象的构造函数和析构函数<br>每次执行进入和离开对象的作用域时，都会调用局部对象的构造函数和析构函数。<br>如果程序因调用函数exit或函数abort而终止，则不会调用局部对象的析构函数。</p></blockquote><blockquote><p>A reference to an object is an alias for the name of the object and, hence, may be used on the left side of an assignment statement.<br>In this context, the reference makes a perfectly acceptable lvalue that can receive a value.<br>Unfortunately a public member function of a class can return a reference to a private data member of that class.<br>Such a reference return actually makes a call to that member function an alias for the private data member!<br>The function call can be used in any way that the private data member can be used, including as an lvalue in an assignment statement<br>The same problem would occur if a pointer to the private data were to be returned by the function.<br>If a function returns a reference that’s declared const, the reference is a non-modifiable lvalue and cannot be used to modify the data.<br>对对象的引用是该对象名称的别名，因此可以在赋值语句的左侧使用。<br>在这个上下文中，引用创建了一个完全可以接受的左值，它可以接收值。<br>不幸的是，类的公共成员函数可以返回对该类私有数据成员的引用。<br>这样的引用返回实际上使对该成员函数的调用成为私有数据成员的别名！<br>函数调用可以以私有数据成员的任何方式使用，包括作为赋值语句中的左值<br>如果函数返回指向私有数据的指针，也会出现同样的问题。<br>如果函数返回声明为const的引用，则该引用是不可修改的左值，不能用于修改数据。</p></blockquote><blockquote><p>The assignment operator (=) can be used to assign an object to another object of the same type.<br>By default, such assignment is performed by memberwise assignment (also called copy assignment).<br>Each data member of the object on the right of the assignment operator is assigned individually to the same data member in the object on the left of the assignment operator.<br>[Caution: Memberwise assignment can cause serious problems when used with a class whose data members contain pointers to dynamically allocated memory; we discuss these problems in Chapter 10 and show how to deal with them.]<br>赋值操作符(=)可用于将一个对象赋值给同一类型的另一个对象。<br>默认情况下，这种赋值是通过成员赋值(也称为拷贝赋值)执行的。<br>赋值操作符右侧对象的每个数据成员分别赋值给赋值操作符左侧对象中的相同数据成员。<br>注意:如果类的数据成员包含指向动态分配内存的指针，则按成员赋值可能会导致严重的问题。我们将在第10章讨论这些问题，并说明如何处理它们。</p></blockquote><blockquote><p>Objects may be passed as function arguments and may be returned from functions.<br>Such passing and returning is performed using pass-by-value by default—a copy of the object is passed or returned.<br>C++ creates a new object and uses a copy constructor to copy the original object’s values into the new object.<br>For each class, the compiler provides a default copy constructor that copies each member of the original object into the corresponding member of the new object.<br>Copy constructors can cause serious problems when used with a class whose data members contain pointers to dynamically allocated memory.<br>Chapter 10 discusses customized copy constructors.<br>对象可以作为函数参数传递，也可以从函数返回。<br>默认情况下，这种传递和返回是使用按值传递来执行的——传递或返回对象的副本。<br>c++创建一个新对象，并使用复制构造函数将原始对象的值复制到新对象中。<br>对于每个类，编译器提供默认的复制构造函数，将原始对象的每个成员复制到新对象的相应成员中。<br>当将复制构造函数用于数据成员包含指向动态分配内存的指针的类时，可能会导致严重的问题。<br>第10章讨论自定义复制构造函数。</p></blockquote><blockquote><p>C++ disallows member function calls for const objects unless the member functions themselves are also declared const.<br>This is true even for get member functions that do not modify the object.<br>This is also a key reason that we’ve declared as const all member-functions that do not modify the objects on which they’re called.<br>A member function is specified as const both in its prototype by inserting the keyword const after the function’s parameter list and, in the case of the function definition, before the left brace that begins the function body.</p><p>c++不允许对const对象调用成员函数，除非成员函数本身也声明为const。<br>即使对于不修改对象的get成员函数也是如此。<br>这也是我们将所有成员函数声明为const的一个关键原因，这些成员函数不会修改调用它们的对象。<br>成员函数在原型中被指定为const，方法是在函数的形参列表之后插入关键字const，在函数定义中，在函数体开始的左大括号之前插入关键字const。</p></blockquote><blockquote><p>A constructor must be allowed to modify an object so that the object can be initialized properly.<br>A destructor must be able to perform its termination housekeeping chores before an object’s memory is reclaimed by the system.<br>Attempting to declare a constructor or destructor const is a compilation error.<br>The “constness” of a const object is enforced from the time the constructor completes initialization of the object until that object’s destructor is called.<br>必须允许构造函数修改对象，以便正确初始化对象。<br>析构函数必须能够在系统回收对象的内存之前执行其终止家务。<br>试图声明构造函数或析构函数const是编译错误。<br>从构造函数完成对象初始化到调用该对象的析构函数，const对象的“constness”被强制执行。</p></blockquote><blockquote><p>What Happens When You Do Not Use the Member Initializer List?<br>If a member object is not initialized through a member initializer, the member object’s default constructor will be called implicitly.<br>Values, if any, established by the default constructor can be overridden by set functions.<br>However, for complex initialization, this approach may require significant additional work and time.<br>当不使用成员初始化列表时会发生什么?<br>如果成员对象没有通过成员初始化器初始化，则将隐式调用成员对象的默认构造函数。<br>默认构造函数建立的值(如果有)可以被set函数覆盖。<br>然而，对于复杂的初始化，这种方法可能需要大量的额外工作和时间。</p></blockquote><blockquote><p>A friend function of a class is a non-member function that has the right to access the public and non-public class members.<br>Standalone functions, entire classes or member functions of other classes may be declared to be friends of another class.<br>类的友元函数是具有访问公共和非公共类成员权限的非成员函数。<br>可以将独立函数、整个类或其他类的成员函数声明为另一个类的友元。</p></blockquote><blockquote><p>Declaring a friend<br>To declare a function as a friend of a class, precede the function prototype in the class definition with keyword friend.<br>To declare all member functions of class ClassTwo as friends of class ClassOne, place a declaration of the form<br>friend class ClassTwo;<br>in the definition of class ClassOne.<br>Friendship is granted, not taken—for class B to be a friend of class A, class A must explicitly declare that class B is its friend.<br>Friendship is not symmetric—if class A is a friend of class B, you cannot infer that class B is a friend of class A.<br>Friendship is not transitive—if class A is a friend of class B and class B is a friend of class C, you cannot infer that class A is a friend of class C.<br>宣布成为朋友<br>要将函数声明为类的友元，可以在类定义中的函数原型前面加上关键字friend。<br>要将类ClassTwo的所有成员函数声明为类ClassOne的友元，请放置一个窗体声明<br>朋友班班二;<br>在ClassOne类的定义中。<br>友谊是授予的，而不是索取的——类B要成为类a的朋友，类a必须明确声明类B是它的朋友。<br>友谊不是对称的——如果A类是B类的朋友，你就不能推断B类是A类的朋友。<br>友谊是不可传递的——如果类A是类B的朋友，类B是类C的朋友，你不能推断类A是类C的朋友。</p></blockquote><blockquote><p>Overloaded friend Functions<br>It’s possible to specify overloaded functions as friends of a class.<br>Each function intended to be a friend must be explicitly declared in the class definition as a friend of the class.<br>重载友元函数<br>可以将重载函数指定为类的友元。<br>每个想要成为友元的函数都必须在类定义中显式声明为类的友元。</p></blockquote><blockquote><p>Every object has access to its own address through a pointer called this (a C++ keyword).<br>The this pointer is not part of the object itself—i.e., the memory occupied by the this pointer is not reflected in the result of a sizeof operation on the object.<br>Rather, the this pointer is passed (by the compiler) as an implicit argument to each of the object’s non-static member functions.<br>每个对象都可以通过一个名为this的指针(c++关键字)访问自己的地址。<br>this指针不是对象本身的一部分。， this指针占用的内存不会反映在对对象进行sizeof操作的结果中。<br>相反，this指针(由编译器)作为隐式参数传递给对象的每个非静态成员函数。</p></blockquote><blockquote><p>Using the this Pointer to Avoid Naming Collisions<br>Member functions use the this pointer implicitly (as we’ve done so far) or explicitly to reference an object’s data members and other member functions.<br>A common explicit use of the this pointer is to avoid naming conflicts between a class’s data members and member-function parameters (or other local variables).<br>使用this指针避免命名冲突<br>成员函数隐式或显式地使用this指针来引用对象的数据成员和其他成员函数。<br>this指针的一个常见显式用法是避免类的数据成员和成员函数参数(或其他局部变量)之间的命名冲突。</p></blockquote><blockquote><p>Type of the this Pointer<br>The type of the this pointer depends on the type of the object and whether the member function in which this is used is declared const.<br>For example, in a non-const member function of class Employee, the this pointer has the type Employee *. In a const member function, the this pointer has the type const Employee *.<br>this指针的类型：<br>this指针的类型取决于对象的类型以及使用this的成员函数是否声明为const。<br>例如，在Employee类的非const成员函数中，this指针的类型是Employee *。在const成员函数中，this指针的类型为const Employee *。</p></blockquote><p><strong>.圆点运算符具有比-&gt;箭头运算符更高的优先级</strong></p><blockquote><p>In certain cases, only one copy of a variable should be shared by all objects of a class.<br>A static data member is used for these and other reasons.<br>Such a variable represents “class-wide” information, i.e., data that is shared by all instances and is not specific to any one object of the class.<br>在某些情况下，一个类的所有对象只能共享一个变量的副本。<br>静态数据成员用于这些和其他原因。<br>这样的变量表示“类范围”信息，即由所有实例共享的数据，而不是特定于类的任何一个对象。</p></blockquote><blockquote><p>Scope and Initialization of static Data Members<br>static data members have class scope.<br>A static data member must be initialized exactly once.<br>Fundamental-type static data members are initialized by default to 0.<br>Prior to C++11, a static const data member of int or enum type could be initialized in its declaration in the class definition and all other static data members had to be defined and initialized at global namespace scope (i.e., outside the body of the class definition).<br>Again, C++11’s in-class initializers also allow you to initialize these variables where they’re declared in the class definition.<br>静态数据成员的作用域和初始化<br>静态数据成员具有类作用域。<br>静态数据成员必须只初始化一次。<br>基本类型静态数据成员默认初始化为0。<br>在c++11之前，int或enum类型的静态const数据成员可以在类定义的声明中初始化，而所有其他静态数据成员必须在全局命名空间范围内定义和初始化(即，在类定义的主体之外)。<br>同样，c++11的类内初始化器还允许您在类定义中声明这些变量的地方初始化它们。</p></blockquote><blockquote><p>Accessing static Data Members<br>A class’s private and protected static members are normally accessed through the class’s public member functions or friends.<br>A class’s static members exist even when no objects of that class exist.<br>To access a public static class member when no objects of the class exist, simply prefix the class name and the scope resolution operator (::) to the name of the data member.<br>To access a private or protected static class member when no objects of the class exist, provide a public static member function and call the function by prefixing its name with the class name and scope resolution operator.<br>A static member function is a service of the class, not of a specific object of the class.<br>访问静态数据成员：<br>类的私有和受保护的静态成员通常通过类的公共成员函数或友元来访问。<br>即使类的对象不存在，类的静态成员仍然存在。<br>要在不存在类的对象时访问公共静态类成员，只需在数据成员的名称前加上类名和范围解析操作符(::)。<br>若要在不存在类的对象时访问私有或受保护的静态类成员，请提供一个公共静态成员函数，并在函数名前加上类名和作用域解析操作符来调用该函数。<br>静态成员函数是类的服务，而不是类的特定对象的服务。</p><p>局部变量在他们定义的作用域结束时被销毁：<br>static成员函数没有this指针，因为static数据成员和函数都是独立于对象存在的<br>将static成员函数定义为const是一个编译错误 因为static函数需要对数据进行修改</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第七章</title>
      <link href="/posts/f2c21137.html"/>
      <url>/posts/f2c21137.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第七章">CPP复习 第七章</h1><blockquote><p>This chapter introduces the topic of data structures—<em>collections</em> of related data items.</p><p>We discuss arrays which are <em>fixed-size</em> collections consisting of data items of the <em>same</em> type, and vectors which are collections (also of data items of the <em>same</em> type) that can grow and shrink <em>dynamically</em> at execution time.</p><p>Both array and vector are C++ standard library class templates.</p><p>After discussing how arrays are declared, created and initialized, we present examples that demonstrate several common array manipulations.</p><p>本章介绍数据结构的主题——相关数据项的集合。<br>我们讨论的数组是由相同类型的数据项组成的固定大小的集合，而向量是可以在执行时动态增长和收缩的集合(也包含相同类型的数据项)。<br>数组和向量都是c++标准库类模板。<br>在讨论了如何声明、创建和初始化数组之后，我们将提供一些示例来演示几种常见的数组操作。</p></blockquote><blockquote><p>An array is a <em>contiguous</em> group of memory locations that all have the same type.</p><p>To refer to a particular location or element in the array, specify the name of the array and the position number of the particular element.</p><p>Figure 7.1 shows an integer array called c.</p><p><strong>int c[12]</strong> declares 12 elements.</p><p>The position number is more formally called a subscript or index (this number specifies the number of elements from the beginning of the array).</p><p>The first element in every array has subscript 0 (zero) and is sometimes called the zeroth element.</p><p>The highest subscript in array c is 11, which is 1 less than the number of elements in the array (12).</p><p>A subscript must be an integer or integer expression (using any integral type).</p><p>数组是一组具有相同类型的连续内存位置。<br>要引用数组中的特定位置或元素，请指定数组的名称和特定元素的位置号。<br>图7.1显示了一个名为c的整数数组。<br>Int c[12]声明了12个元素。<br>位置号更正式地称为下标或索引(这个数字指定从数组开始的元素数量)。<br>每个数组中的第一个元素下标为0(0)，有时称为第零元素。<br>数组c中最大的下标是11，比数组中的元素数(12)少1。<br>下标必须是整数或整数表达式(使用任何整数类型)。</p></blockquote><blockquote><p>在C++中，数组（array）是一种非常重要且常用的数据结构。下面是关于C++数组的一些详细介绍和示例。</p><h3 id="C-中的数组">C++中的数组</h3><h4 id="声明和初始化">声明和初始化</h4><ol><li><strong>声明数组</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];  <span class="comment">// 声明一个包含5个整数的数组，未初始化</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>初始化数组</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 声明并初始化一个包含5个整数的数组</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>部分初始化</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// 只有前两个元素被初始化为1和2，其余元素默认为0</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>自动推断大小</strong>:</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 编译器会根据初始化列表自动推断数组大小</span></span><br></pre></td></tr></table></figure><h4 id="访问和修改数组元素">访问和修改数组元素</h4><p>数组元素可以通过索引进行访问和修改，索引从0开始。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 0: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified element at index 0: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历数组">遍历数组</h4><p>可以使用循环遍历数组中的元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用for循环遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多维数组">多维数组</h4><p>C++也支持多维数组（例如二维数组），用于表示矩阵或表格。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化一个3x3的二维数组</span></span><br><span class="line">    <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问二维数组的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at [0][0]: &quot;</span> &lt;&lt; matrix[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            std::cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态数组">动态数组</h4><p>C++中的数组大小固定，但可以使用指针和动态内存分配（<code>new</code>和<code>delete</code>）创建动态数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter the size of the array: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配数组</span></span><br><span class="line">    <span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准库中的数组">标准库中的数组</h3><p>C++标准库还提供了一些更高级的数组数据结构，如<code>std::array</code>和<code>std::vector</code>，推荐使用这些标准库提供的容器而不是原始数组。</p><h4 id="std-array"><code>std::array</code></h4><p><code>std::array</code>是一个封装的固定大小的数组，定义在<code>&lt;array&gt;</code>头文件中。</p><p>声明：array&lt;类型，大小&gt; array对象名</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 0: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="std-vector"><code>std::vector</code></h4><p><code>std::vector</code>是一个动态数组，定义在<code>&lt;vector&gt;</code>头文件中。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 0: &quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; vec[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总之，C++中数组的使用既有基本的内置数组，也有标准库提供的更高级的数组容器，选择适合的数组类型有助于编写更高效和可维护的代码。</p></blockquote><p>size_t是一种无符号的整型类型，包含在<cstddef>中，它被其他各种头文件包括</p><p>常量在被声明时，注意需要被初始化：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x;</span><br><span class="line">x=<span class="number">7</span>;<span class="comment">//这是一个编译错误</span></span><br></pre></td></tr></table></figure><blockquote><p><code>array</code> 是 C++ 标准库中的一个模板类，封装了固定大小的数组。它提供了更方便和安全的接口来操作数组，并且与传统的 C 风格数组相比，具有更好的类型安全和功能。<code>std::array</code> 定义在 <code>&lt;array&gt;</code> 头文件中。<code>array</code>不提供边界检查</p><h3 id="std-array-的特点"><code>std::array</code> 的特点</h3><ol><li><strong>固定大小</strong>: <code>std::array</code> 的大小在编译时确定，不可改变。</li><li><strong>类型安全</strong>: <code>std::array</code> 使用模板，确保数组中所有元素类型相同。</li><li><strong>标准接口</strong>: 提供了一组标准化的接口，类似于 STL 容器，如 <code>begin()</code>, <code>end()</code>, <code>size()</code>, <code>at()</code> 等。</li><li><strong>性能</strong>: <code>std::array</code> 的性能与 C 风格数组相当，但提供了更多的功能。</li></ol><h3 id="声明和初始化-2">声明和初始化</h3><p>使用 <code>std::array</code> 需要包含头文件 <code>&lt;array&gt;</code>，并指定元素类型和数组大小。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个包含5个整数的数组，并初始化</span></span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//列表初始化器进行初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    也可以这样初始化，注意可以在读代码时更加清晰，理解用途</span></span><br><span class="line"><span class="comment">    const int size=5;</span></span><br><span class="line"><span class="comment">    std::array&lt;int,size&gt; arr=&#123;1,2,3,4,5&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问和修改元素">访问和修改元素</h3><p>可以使用索引、<code>at()</code> 方法、迭代器等方式访问和修改数组元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用索引访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 0: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 at() 方法访问元素，at() 会进行边界检查</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Element at index 1: &quot;</span> &lt;&lt; arr.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改元素</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified element at index 0: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历数组-2">遍历数组</h3><p>可以使用范围 <code>for</code> 循环或标准迭代器遍历数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围 for 循环遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法">常用方法</h3><ul><li><code>size()</code>: 返回数组的大小。</li><li><code>at(index)</code>: 访问指定索引的元素，带边界检查。</li><li><code>front()</code>: 返回第一个元素。</li><li><code>back()</code>: 返回最后一个元素。</li><li><code>begin()</code>: 返回指向数组起始位置的迭代器。</li><li><code>end()</code>: 返回指向数组末尾的迭代器。</li><li><code>data()</code>: 返回指向数组数据的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of array: &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; arr.<span class="built_in">front</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Last element: &quot;</span> &lt;&lt; arr.<span class="built_in">back</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始数组指针</span></span><br><span class="line">    <span class="type">int</span>* ptr = arr.<span class="built_in">data</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element using data(): &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="与传统数组的区别">与传统数组的区别</h3><ul><li><strong>类型安全</strong>: <code>std::array</code> 是一个模板类，确保所有元素类型相同。</li><li><strong>边界检查</strong>: <code>std::array</code> 的 <code>at()</code> 方法提供了边界检查，防止越界访问。</li><li><strong>标准接口</strong>: <code>std::array</code> 提供了 STL 容器的标准接口，使其与其他标准容器更一致。</li><li><strong>固定大小</strong>: <code>std::array</code> 的大小在编译时确定，不支持动态调整。</li></ul><h3 id="结论">结论</h3><p><code>std::array</code> 提供了一种更现代和安全的方式来使用固定大小的数组。它结合了 STL 容器的接口优势和 C 风格数组的性能，是 C++ 编程中处理固定大小数组的推荐选择。</p></blockquote><blockquote><p><code>default_random_engine</code> 是 C++11 标准库中定义的一个随机数生成器（RNG），位于 <code>&lt;random&gt;</code> 头文件中。它是标准库提供的多种随机数生成器之一，使用起来非常方便，适合于大多数一般用途的随机数生成需求。</p><h3 id="主要特性">主要特性</h3><ol><li><strong>易用性</strong>: <code>default_random_engine</code> 是一种通用的随机数生成器，提供了良好的默认行为，适合大多数应用。</li><li><strong>可移植性</strong>: 使用标准库提供的随机数生成器可以确保代码在不同平台上的一致性和可移植性。</li><li><strong>配置性</strong>: 可以与其他随机数分布（如均匀分布、正态分布等）结合使用，生成不同类型的随机数。</li></ol><h3 id="使用方法">使用方法</h3><ol><li><strong>包含头文件</strong>: 需要包含 <code>&lt;random&gt;</code> 头文件。</li><li><strong>创建随机数生成器</strong>: 使用 <code>default_random_engine</code> 创建一个随机数生成器对象。</li><li><strong>创建分布对象</strong>: 使用不同的分布类型（如 <code>uniform_int_distribution</code> 或 <code>uniform_real_distribution</code>）来生成不同类型的随机数。</li><li><strong>生成随机数</strong>: 使用生成器和分布对象生成随机数。</li></ol><h3 id="示例代码">示例代码</h3><p>以下是如何使用 <code>default_random_engine</code> 生成随机整数和浮点数的示例。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数生成器</span></span><br><span class="line">    std::default_random_engine generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布对象，用于生成范围在1到100之间的整数</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution_int</span><span class="params">(<span class="number">1</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印随机整数</span></span><br><span class="line">    <span class="type">int</span> random_int = <span class="built_in">distribution_int</span>(generator);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random integer: &quot;</span> &lt;&lt; random_int &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建均匀分布对象，用于生成范围在0.0到1.0之间的浮点数</span></span><br><span class="line">    <span class="function">std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution_real</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印随机浮点数</span></span><br><span class="line">    <span class="type">double</span> random_double = <span class="built_in">distribution_real</span>(generator);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random double: &quot;</span> &lt;&lt; random_double &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常见用途">常见用途</h3><ol><li><strong>随机抽样</strong>: 从一个数据集合中随机抽取元素。</li><li><strong>模拟和建模</strong>: 在蒙特卡罗模拟等应用中生成随机样本。</li><li><strong>游戏开发</strong>: 生成游戏中的随机事件或随机地图。</li><li><strong>测试和验证</strong>: 生成随机测试数据，进行软件测试和验证。</li></ol><h3 id="其他随机数生成器">其他随机数生成器</h3><p>虽然 <code>default_random_engine</code> 适合大多数一般用途，但 C++ 标准库还提供了其他几种随机数生成器，用于不同的需求：</p><ol><li><strong><code>std::mt19937</code></strong>: 梅森旋转算法，提供了高质量的随机数，适合高性能需求。</li><li><strong><code>std::ranlux24_base</code></strong> 和 <strong><code>std::ranlux48_base</code></strong>: 提供更高质量随机数，但速度较慢。</li><li><strong><code>std::minstd_rand0</code></strong> 和 <strong><code>std::minstd_rand</code></strong>: 线性同余生成器，适合快速生成随机数，但质量相对较低。</li></ol><p>选择哪种随机数生成器取决于具体的应用需求，<code>default_random_engine</code> 提供了一个很好的默认选择，可以满足大多数普通需求。</p></blockquote><blockquote><p>A program initializes static local arrays when their declarations are first encountered.</p><p>If a static array is not initialized explicitly by you, each element of that array is initialized to <em>zero</em> by the compiler when the array is created.</p><p>程序在第一次遇到静态局部数组声明时初始化它们。<br>如果静态数组没有由您显式初始化，则该数组的每个元素在创建数组时由编译器初始化为零。</p></blockquote><p>可以将static用于局部array的声明，这样就不会每次函数调用时被初始化，函数结束时被销毁，可以提高性能。</p><p>否则就会自动创建，自动销毁，每次的修改没有改变。</p><blockquote><p>在 C++11 中，<code>auto</code> 关键字和范围 <code>for</code> 循环（range-based for loop）为遍历数组提供了更加简洁和直观的方法。通过 <code>auto</code>，编译器可以自动推导变量的类型，这使得代码更加简洁，特别是在处理复杂类型时。此外，使用引用（reference）可以避免不必要的拷贝，提高性能。</p><h3 id="基本用法">基本用法</h3><h4 id="范围-for-循环">范围 <code>for</code> 循环</h4><p>范围 <code>for</code> 循环可以简化数组和其他容器的遍历过程。</p><p><strong>语法</strong>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : container) &#123;</span><br><span class="line"> <span class="comment">// 处理 element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-auto-和-引用">使用 <code>auto</code> 和 引用</h4><p>为了避免拷贝，通常可以使用引用遍历数组元素。</p><p><strong>语法</strong>:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : container) &#123;</span><br><span class="line"> <span class="comment">// 处理 element，通过引用修改原始数组中的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例代码-2">示例代码</h3><p>以下是使用 <code>auto</code> 和范围 <code>for</code> 循环遍历数组的示例代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 使用 std::array 声明并初始化一个包含5个整数的数组</span></span><br><span class="line"> std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用范围 for 循环和 auto 关键字遍历数组元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> element : arr) &#123;</span><br><span class="line">     std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出每个元素的值</span></span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用范围 for 循环和 auto&amp; 关键字遍历数组元素，通过引用修改元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">     element *= <span class="number">2</span>;  <span class="comment">// 将每个元素的值乘以2</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 再次遍历并输出修改后的数组</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> element : arr) &#123;</span><br><span class="line">     std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出每个元素的值</span></span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果">输出结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5 </span><br><span class="line">2 4 6 8 10 </span><br></pre></td></tr></table></figure><h3 id="解释">解释</h3><ol><li><strong>首次遍历</strong>: 使用 <code>auto</code> 自动推导元素类型，输出每个元素的值。</li><li><strong>通过引用修改元素</strong>: 使用 <code>auto&amp;</code> 遍历数组，直接修改原数组中的元素。</li><li><strong>再次遍历</strong>: 验证数组元素已被修改。</li></ol><h3 id="优点">优点</h3><ul><li><strong>简洁</strong>: 避免了显式声明变量类型，使代码更简洁。</li><li><strong>安全</strong>: 使用引用可以避免不必要的拷贝，提高性能，特别是对于复杂对象。</li><li><strong>直观</strong>: 范围 <code>for</code> 循环提供了更直观的遍历方式。</li></ul><h3 id="注意事项">注意事项</h3><ul><li><p>如果只需要读取数组元素而不修改，可以使用 <code>const auto&amp;</code> 遍历，确保元素不被修改。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">    std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出每个元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>auto</code> 和 <code>auto&amp;</code> 的使用需要在编译器支持 C++11 或更高版本时才能使用。</p></li></ul><p>通过结合 <code>auto</code> 和范围 <code>for</code> 循环，C++11 提供了一种简洁、高效的方式来遍历数组和其他容器，使代码更具可读性和可维护性。</p></blockquote><blockquote><p><strong>Using an Element’s Subscript</strong></p><p>The range-based for statement can be used in place of the counter-controlled for statement whenever code looping through an array does not require access to the element’s subscript.</p><p>However, if a program must use subscripts for some reason other than simply to loop through an array (e.g., to print a subscript number next to each array element value, as in the examples early in this chapter), you should use the counter-controlled for statement.</p><p>使用元素的下标<br>只要循环遍历数组的代码不需要访问元素的下标，就可以使用基于范围的for语句来代替反控制的for语句。<br>然而，如果程序不是为了循环数组而必须使用下标(例如，在本章前面的例子中，为了在每个数组元素值旁边打印一个下标数字)，则应该使用计数器控制的for语句。</p></blockquote><blockquote><p>在 C++ 标准库中，<code>sort</code> 和 <code>binary_search</code> 是两个常用的算法，定义在 <code>&lt;algorithm&gt;</code> 头文件中。<code>sort</code> 用于对容器中的元素进行排序，而 <code>binary_search</code> 用于在已排序的容器中进行二分查找。下面是这两个算法的详细介绍和示例。</p><h3 id="sort-算法"><code>sort</code> 算法</h3><p><code>sort</code> 算法用于对范围内的元素进行排序。它的时间复杂度平均为 (O(n \log n))，其中 (n) 是元素的数量。</p><h4 id="基本用法-2">基本用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用默认的升序排序</span></span><br><span class="line"> std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输出排序后的结果</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">     std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义比较函数">自定义比较函数</h3><p>可以传递一个自定义的比较函数来实现不同的排序规则，例如降序排序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b;  <span class="comment">// 实现降序排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用自定义的比较函数进行降序排序</span></span><br><span class="line"> std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), compare);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输出排序后的结果</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">     std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="binary-search-算法"><code>binary_search</code> 算法</h3><p><code>binary_search</code> 算法用于在已排序的范围内查找特定的值。它的时间复杂度为 (O(\log n))，其中 (n) 是元素的数量。</p><h4 id="基本用法-3">基本用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 在已排序的范围内进行二分查找</span></span><br><span class="line"> <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), value);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (found) &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; in the vector.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Did not find &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; in the vector.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义比较函数-2">自定义比较函数</h3><p><code>binary_search</code> 也可以使用自定义的比较函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b;  <span class="comment">// 用于降序排序的比较函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 在降序排序的范围内进行二分查找</span></span><br><span class="line"> <span class="type">bool</span> found = std::<span class="built_in">binary_search</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), value, compare);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (found) &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Found &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; in the vector.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Did not find &quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot; in the vector.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-2">注意事项</h3><ol><li><strong><code>sort</code> 算法</strong>：在使用 <code>sort</code> 前，确保包含 <code>&lt;algorithm&gt;</code> 头文件，并且传递的是有效的迭代器范围。<code>sort</code> 默认使用 <code>&lt;</code> 运算符进行比较。</li><li><strong><code>binary_search</code> 算法</strong>：在使用 <code>binary_search</code> 前，确保包含 <code>&lt;algorithm&gt;</code> 头文件，并且数据已经排序。否则，结果是未定义的。<code>binary_search</code> 默认使用 <code>&lt;</code> 运算符进行比较。</li><li><strong>效率</strong>：<code>sort</code> 的时间复杂度为 (O(n \log n))，<code>binary_search</code> 的时间复杂度为 (O(\log n))。对于较大的数据集，使用 <code>binary_search</code> 前务必先排序。</li></ol><p>通过结合使用 <code>sort</code> 和 <code>binary_search</code>，可以高效地对数据进行排序和搜索，适用于许多需要快速查询的大数据处理场景。</p></blockquote><blockquote><p>在 C++ 中，逗号运算符 (<code>,</code> operator) 是一个序列点，允许在一个语句中执行多个表达式，并保证从左到右的求值顺序。逗号运算符返回最后一个表达式的值。虽然它在代码中不常见，但在某些情况下非常有用。</p><h3 id="基本用法-4">基本用法</h3><p>逗号运算符将多个表达式串联起来，所有表达式会依次求值，但只返回最后一个表达式的结果。</p><h4 id="示例">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br><span class="line"></span><br><span class="line"> c = (a = a + <span class="number">1</span>, b = b + <span class="number">2</span>, a + b);  <span class="comment">// 使用逗号运算符</span></span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 a: 2</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;  <span class="comment">// 输出 b: 4</span></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;c: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;  <span class="comment">// 输出 c: 6</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述示例中，<code>c</code> 的值是由逗号运算符中最后一个表达式 <code>a + b</code> 的结果决定的，而 <code>a</code> 和 <code>b</code> 的值在之前的表达式中被修改。</p><h3 id="在循环中的使用">在循环中的使用</h3><p>逗号运算符在 <code>for</code> 循环中很有用，尤其是在需要初始化或更新多个变量的情况下。</p><h4 id="示例-2">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">10</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j: &quot;</span> &lt;&lt; j &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>for</code> 循环的初始化部分和更新部分都使用了逗号运算符，使得我们可以同时操作 <code>i</code> 和 <code>j</code> 两个变量。</p><h3 id="注意事项-3">注意事项</h3><ol><li><strong>优先级</strong>: 逗号运算符的优先级较低，因此在复杂表达式中使用时需要注意括号，以确保正确的求值顺序。</li><li><strong>副作用</strong>: 逗号运算符会依次求值其操作数，所有副作用都会按顺序发生。</li><li><strong>代码可读性</strong>: 虽然逗号运算符在某些情况下很有用，但过度使用可能会降低代码的可读性。因此，应谨慎使用，并确保代码的清晰性。</li></ol><h3 id="总结">总结</h3><p>逗号运算符在 C++ 中可以用来在一个语句中执行多个表达式，并按从左到右的顺序求值，返回最后一个表达式的结果。它在需要同时处理多个表达式或变量的初始化和更新时特别有用。尽管如此，由于它的低优先级和潜在的可读性问题，应该谨慎使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a[x,y]返回的是a[y]</span><br></pre></td></tr></table></figure><p>根据逗号运算符的规则，<code>x,y</code>最后得到的数值是<code>y</code></p><blockquote><p>在 C++ 中，多维数组是一种常见的数据结构，用于表示具有多个维度的数据。常见的多维数组包括二维数组（矩阵）和三维数组（立方体），它们可以扩展到更多维度。多维数组在数值计算、图像处理和科学计算等领域中广泛使用。</p><h3 id="多维数组的声明和初始化">多维数组的声明和初始化</h3><h4 id="二维数组">二维数组</h4><p>二维数组是最常见的多维数组，可以看作是一个数组的数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 声明一个 3x4 的二维数组</span></span><br><span class="line"> <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">     &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 访问和输出二维数组中的元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">         std::cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三维数组">三维数组</h4><p>三维数组是包含二维数组的数组，类似于立方体。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 声明一个 2x3x4 的三维数组</span></span><br><span class="line"> <span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">         &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">         &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">         &#123;<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>&#125;,</span><br><span class="line">         &#123;<span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>&#125;,</span><br><span class="line">         &#123;<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 访问和输出三维数组中的元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">             std::cout &lt;&lt; arr[i][j][k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         std::cout &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-std-array-创建多维数组">使用 <code>std::array</code> 创建多维数组</h3><p>C++11 引入了 <code>std::array</code>，可以用来创建更安全和灵活的多维数组。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 使用 std::array 声明一个 3x4 的二维数组</span></span><br><span class="line"> <span class="comment">// 这里的第一个参数是std::array&lt;int,4&gt; 表示arr的元素类型是array</span></span><br><span class="line"> std::array&lt;std::array&lt;<span class="type">int</span>, 4&gt;, 3&gt; arr = &#123;&#123;</span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">     &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">     &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line"> &#125;&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 访问和输出二维数组中的元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : arr) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : row) &#123;</span><br><span class="line">         std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态分配多维数组">动态分配多维数组</h3><p>对于需要在运行时确定大小的多维数组，可以使用动态内存分配。</p><h4 id="动态分配二维数组">动态分配二维数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> rows = <span class="number">3</span>;</span><br><span class="line"> <span class="type">int</span> cols = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 动态分配二维数组</span></span><br><span class="line"> <span class="type">int</span>** arr = <span class="keyword">new</span> <span class="type">int</span>*[rows];</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">     arr[i] = <span class="keyword">new</span> <span class="type">int</span>[cols];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 初始化数组</span></span><br><span class="line"> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">         arr[i][j] = value++;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 访问和输出二维数组中的元素</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">         std::cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     std::cout &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 释放动态分配的内存</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] arr[i];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><p>多维数组在 C++ 中提供了表示和操作多维数据的强大工具。根据需求，可以选择使用静态数组、<code>std::array</code> 或动态数组。静态数组适合大小固定的情况，<code>std::array</code> 提供了更安全和灵活的接口，而动态数组则适合需要在运行时确定大小的情况。通过合理选择和使用多维数组，可以有效地处理复杂的数据结构和计算任务。</p></blockquote><blockquote><p><code>std::vector</code> 是 C++ 标准模板库（STL）中的一个动态数组容器，定义在 <code>&lt;vector&gt;</code> 头文件中。它提供了一个灵活、动态调整大小的数组，可以存储任意类型的元素。<code>std::vector</code> 是常用的容器之一，因其高效的随机访问和动态调整大小能力而广受欢迎。</p><h3 id="特性">特性</h3><ol><li><strong>动态大小</strong>: <code>std::vector</code> 可以根据需要动态地增长或缩小大小。</li><li><strong>随机访问</strong>: 提供常数时间复杂度的随机访问（通过索引）。</li><li><strong>自动管理内存</strong>: 自动管理其存储的内存，避免手动内存管理带来的复杂性和错误。</li><li><strong>支持迭代器</strong>: 支持 STL 迭代器，可以与算法库无缝集成。</li><li><strong>自动扩展</strong>: 当向 <code>std::vector</code> 中添加元素超过其容量时，它会自动扩展容量。</li></ol><h3 id="基本用法-5">基本用法</h3><h4 id="引入头文件">引入头文件</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="声明和初始化-3">声明和初始化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个空的 vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用初始化列表初始化 vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用特定大小和初始值初始化 vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec3</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>;  <span class="comment">// 包含 5 个元素，每个元素的值为 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围初始化 vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">vec4</span><span class="params">(vec2.begin(), vec2.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="添加和删除元素">添加和删除元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; vec[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; vec.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 使用 at() 方法进行边界检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除元素</span></span><br><span class="line">    vec.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector size after pop_back: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历元素">遍历元素</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围 for 循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他常用操作">其他常用操作</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取大小和容量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Capacity: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vector is not empty&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空 vector</span></span><br><span class="line">    vec.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size after clear: &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新分配空间</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Capacity after reserve: &quot;</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), <span class="number">0</span>);  <span class="comment">// 在开头插入 0</span></span><br><span class="line">    vec.<span class="built_in">insert</span>(vec.<span class="built_in">end</span>(), <span class="number">6</span>);    <span class="comment">// 在结尾插入 6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除特定位置的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>());  <span class="comment">// 删除第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem : vec) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3">总结</h3><p><code>std::vector</code> 是 C++ 中功能强大的动态数组容器，提供了灵活的大小调整、高效的随机访问和自动内存管理。它适用于需要频繁插入、删除和随机访问元素的场景。通过掌握 <code>std::vector</code> 的使用，可以大大提高 C++ 程序的开发效率和代码的可维护性。</p></blockquote><blockquote><p>迭代器是 C++ 标准模板库（STL）中用于遍历容器元素的对象。迭代器提供了一种统一的方式来访问容器中的元素，无论容器的类型是什么，都可以使用相同的语法来进行遍历。迭代器的设计使得容器和算法可以解耦，提高了代码的灵活性和可复用性。</p><h3 id="基本用法-6">基本用法</h3><h4 id="迭代器类型">迭代器类型</h4><p>不同类型的容器有不同类型的迭代器，但它们通常具有相似的接口和用法。以下是常见的迭代器类型：</p><ul><li><strong>begin()</strong>: 返回指向容器第一个元素的迭代器。</li><li><strong>end()</strong>: 返回指向容器末尾的迭代器（不包含末尾元素的下一个位置）。</li></ul><h4 id="示例-3">示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用迭代器遍历 vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出当前迭代器指向的元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器操作">迭代器操作</h3><h4 id="解引用">解引用</h4><p>使用 <code>*</code> 运算符可以获取迭代器指向的元素的值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">std::cout &lt;&lt; *it &lt;&lt; std::endl;  <span class="comment">// 输出第一个元素的值</span></span><br></pre></td></tr></table></figure><h4 id="自增">自增</h4><p>使用 <code>++</code> 运算符可以将迭代器移动到容器中的下一个元素。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>();</span><br><span class="line">++it;  <span class="comment">// 将迭代器移动到第二个元素</span></span><br></pre></td></tr></table></figure><h4 id="比较">比较</h4><p>可以使用 <code>==</code> 或 <code>!=</code> 运算符来比较两个迭代器是否相等。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it1 = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = vec.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">if</span> (it1 == it2) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterators are equal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Iterators are not equal&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他操作">其他操作</h4><p>迭代器还支持许多其他操作，如算术运算、指针算术运算等，使得在容器中进行元素访问更加灵活。</p><h3 id="迭代器失效">迭代器失效</h3><p>在对容器进行修改时，可能会导致迭代器失效。迭代器失效意味着它们不再指向有效的元素或位置。通常情况下，插入和删除操作会导致迭代器失效。</p><h3 id="迭代器的类型">迭代器的类型</h3><p>不同容器类型（如 <code>vector</code>、<code>list</code>、<code>map</code> 等）的迭代器具有不同的特性和行为。例如，<code>vector</code> 和 <code>deque</code> 支持随机访问迭代器，而 <code>list</code> 支持双向迭代器。了解容器的迭代器类型对正确使用迭代器非常重要。</p><h3 id="总结-4">总结</h3><p>迭代器是 C++ 中一种强大的工具，用于遍历容器中的元素。它提供了一种统一的接口，使得容器和算法可以解耦，并且提供了一种灵活的方式来访问容器中的元素。通过掌握迭代器的基本用法和特性，可以编写更加灵活和高效的代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第六章</title>
      <link href="/posts/20c266a8.html"/>
      <url>/posts/20c266a8.html</url>
      
        <content type="html"><![CDATA[<h1 id="CPP复习-第六章">CPP复习 第六章</h1><p>函数原型的形参表中的每一个形参都应该显式地说明类型。</p><p>函数原型中、函数头以及函数调用时的在对应的实参和形参个数、类型型、顺序和返回类型必须一致。</p><p>函数原型（又称为 函数声明）提供了函数名、返回类型、函数预计接收的形参个数、以及形参的类型和顺序。</p><p>函数在调用前就已被定义，那么函数定义也可以作为函数原型，但是为了清晰易读，还是建议添加函数原型。</p><p>函数签名：函数名和实参部分，并未指定函数返回类型。</p><p>函数原型的一个特性是强制类型转换：将实参用合适的方式转换为形参指定的类型，从而正常执行。</p><p>函数被调用时实参个数与相应的函数形参个数或者类型不匹配，或者参数个数相同，但是无法隐式地转换为期望的类型，也会产生编译错误。</p><h2 id="随机数">随机数</h2><p><code>rand</code> 函数是 C++ 标准库中的一个函数，用于生成伪随机数。它在 <code>&lt;cstdlib&gt;</code> 头文件中定义。以下是 <code>rand</code> 函数的详细介绍及其使用方法：</p><h3 id="基本用法">基本用法</h3><p><code>rand</code> 函数返回一个范围在 <code>0</code> 到 <code>RAND_MAX</code> 之间的整数，其中 <code>RAND_MAX</code> 是一个常量，表示可生成的最大随机数值。不同的实现中，<code>RAND_MAX</code> 的值可能不同，但它至少为 32767。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 rand 和 srand</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> random_number = <span class="built_in">rand</span>(); <span class="comment">// 生成一个随机数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成特定范围内的随机数">生成特定范围内的随机数</h3><p>为了生成一个特定范围内的随机数，可以使用取模运算符 <code>%</code>。例如，要生成一个范围在 <code>0</code> 到 <code>99</code> 之间的随机数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 rand 和 srand</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> random_number = <span class="built_in">rand</span>() % <span class="number">100</span>; <span class="comment">// 生成 0 到 99 之间的随机数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random number (0-99): &quot;</span> &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要生成一个范围在 <code>min</code> 到 <code>max</code> 之间的随机数，可以使用以下公式：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 rand 和 srand</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> random_number = min + <span class="built_in">rand</span>() % (max - min + <span class="number">1</span>); <span class="comment">// 生成 min 到 max 之间的随机数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random number (&quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; max &lt;&lt; <span class="string">&quot;): &quot;</span> &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化随机数生成器">初始化随机数生成器</h3><p><code>rand</code> 函数生成的随机数是伪随机数，每次运行程序时都会生成相同的序列。为了避免这种情况，可以使用 <code>srand</code> 函数初始化随机数生成器的种子。通常使用当前时间作为种子，这样每次运行程序时都会生成不同的随机数序列。如果种子相同，那么产生的也是相同的随机数字序列。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 包含 rand 和 srand</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">// 包含 time 函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(<span class="built_in">time</span>(<span class="number">0</span>))); <span class="comment">// 使用当前时间作为随机数种子</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> random_number = <span class="built_in">rand</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random number with seed: &quot;</span> &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rand-函数的注意事项"><code>rand</code> 函数的注意事项</h3><ol><li><strong>伪随机性</strong>：<code>rand</code> 生成的数并不是真正的随机数，而是伪随机数，基于确定的算法。如果种子相同，生成的数列也会相同。</li><li><strong>线程安全</strong>：<code>rand</code> 函数不是线程安全的。如果在多线程环境中使用，需要进行适当的同步。</li><li><strong>更好的随机数生成器</strong>：对于需要更高质量随机数的应用，可以使用 C++11 提供的随机数库（<code>&lt;random&gt;</code> 头文件）。该库提供了更好的随机数生成器和更多的分布选项。</li></ol><h3 id="使用-C-11-随机数库">使用 C++11 随机数库</h3><p>C++11 提供了更强大的随机数生成器，可以生成更高质量的随机数。以下是一个简单的示例，使用 <code>std::mt19937</code> 生成器和 <code>std::uniform_int_distribution</code> 分布来生成随机数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span> <span class="comment">// 包含随机数库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数生成器</span></span><br><span class="line">    random_device rd; <span class="comment">// 随机设备，提供种子</span></span><br><span class="line">    <span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>; <span class="comment">// Mersenne Twister 随机数生成器</span></span><br><span class="line">    uniform_int_distribution&lt;&gt; <span class="built_in">dist</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 定义 10 到 20 之间的均匀分布</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成随机数</span></span><br><span class="line">    <span class="type">int</span> random_number = <span class="built_in">dist</span>(gen);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random number (10-20) using C++11 random library: &quot;</span> &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子展示了如何使用 C++11 的随机数库生成一个范围在 10 到 20 之间的随机数。相比 <code>rand</code> 函数，这种方法提供了更高质量的随机数和更多的控制选项。</p><h2 id="枚举类型">枚举类型</h2><p>枚举类型（<code>enum</code>）是 C++ 中一种用户自定义的数据类型，用于表示一组相关的常量。枚举类型使代码更具可读性和维护性，通过为常量赋予有意义的名字，取代了魔法数字（magic numbers）。</p><h3 id="基本用法-2">基本用法</h3><p>枚举类型通过 <code>enum</code> 关键字定义，语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">EnumName</span> &#123;</span><br><span class="line">    CONSTANT1,</span><br><span class="line">    CONSTANT2,</span><br><span class="line">    CONSTANT3,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个常量默认为一个整数值，从 <code>0</code> 开始递增。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,    <span class="comment">// 0</span></span><br><span class="line">    GREEN,  <span class="comment">// 1</span></span><br><span class="line">    BLUE    <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color color = RED;</span><br><span class="line">    <span class="keyword">if</span> (color == RED) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Color</code> 枚举包含三个常量：<code>RED</code>、<code>GREEN</code> 和 <code>BLUE</code>。默认情况下，它们分别对应整数值 <code>0</code>、<code>1</code> 和 <code>2</code>。</p><h3 id="指定枚举常量的值">指定枚举常量的值</h3><p>可以显式地为枚举常量指定整数值：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Weekday</span> &#123;</span><br><span class="line">    MONDAY = <span class="number">1</span>,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY = <span class="number">10</span>,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY,</span><br><span class="line">    SUNDAY</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MONDAY</code> 被显式指定为 <code>1</code>，<code>TUESDAY</code> 和 <code>WEDNESDAY</code> 分别是 <code>2</code> 和 <code>3</code>，<code>THURSDAY</code> 被指定为 <code>10</code>，其后的常量 <code>FRIDAY</code>、<code>SATURDAY</code> 和 <code>SUNDAY</code> 分别为 <code>11</code>、<code>12</code> 和 <code>13</code>。</p><h3 id="枚举类型的作用域">枚举类型的作用域</h3><p>在 C++11 及更高版本中，可以使用 <code>enum class</code> 或 <code>enum struct</code> 定义强类型枚举（scoped enum），避免与其他枚举或常量发生命名冲突。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color color = Color::RED;</span><br><span class="line">    <span class="keyword">if</span> (color == Color::RED) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The color is red.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Color::RED</code> 是强类型枚举的用法，枚举常量必须通过枚举类型名限定，这样可以避免命名冲突。</p><h3 id="枚举类型的底层类型">枚举类型的底层类型</h3><p>在 C++11 及更高版本中，可以指定枚举类型的底层类型：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">unsigned</span> <span class="type">char</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    GREEN,</span><br><span class="line">    BLUE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>Color</code> 的底层类型被指定为 <code>unsigned char</code>，这可以控制枚举类型的大小和表示范围。</p><h3 id="枚举类型的用法">枚举类型的用法</h3><p>枚举类型常用于状态机、选项标志、枚举集合等情景，以提高代码的可读性和维护性。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TrafficLight</span> &#123;</span><br><span class="line">    RED,</span><br><span class="line">    YELLOW,</span><br><span class="line">    GREEN</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTrafficLight</span><span class="params">(TrafficLight light)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (light) &#123;</span><br><span class="line">        <span class="keyword">case</span> TrafficLight::RED:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Red light&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TrafficLight::YELLOW:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Yellow light&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TrafficLight::GREEN:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Green light&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TrafficLight light = TrafficLight::GREEN;</span><br><span class="line">    <span class="built_in">printTrafficLight</span>(light);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>TrafficLight</code> 枚举用于表示交通信号灯的三种状态，通过 <code>switch</code> 语句处理每种状态的具体逻辑。</p><h3 id="总结">总结</h3><ul><li><strong>基本枚举</strong>：使用 <code>enum</code> 定义一组相关的常量，默认整数值从 <code>0</code> 开始递增。</li><li><strong>指定值</strong>：可以显式指定枚举常量的整数值。</li><li><strong>强类型枚举</strong>：使用 <code>enum class</code> 或 <code>enum struct</code> 定义强类型枚举，避免命名冲突。</li><li><strong>底层类型</strong>：在 C++11 及更高版本中，可以指定枚举类型的底层类型。</li></ul><p>通过使用枚举类型，可以使代码更具可读性和可维护性，尤其在处理一组相关常量时更加便利。</p><p>枚举类型中的常量代表的是整数。</p><p>默认情况下，作用域限定的枚举类型所隐含的整数类型是int，如果一个枚举常量的值超出了范围（也就是枚举类型所隐含的整数类型所表示的范围），则会编译错误。</p><p><code>default_random_engine</code> 是 C++11 标准库中的一个伪随机数生成器，定义在 <code>&lt;random&gt;</code> 头文件中。它提供了一种简单且标准化的方法来生成随机数。<code>default_random_engine</code> 是一种通用的随机数引擎，适用于大多数一般用途。</p><h3 id="基本用法-3">基本用法</h3><p>下面是一个简单的例子，演示如何使用 <code>default_random_engine</code> 生成随机数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span> <span class="comment">// 包含随机数库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建随机数生成器</span></span><br><span class="line">    default_random_engine generator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个均匀分布，范围是 [0, 99]</span></span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印10个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        cout &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化随机数生成器-2">初始化随机数生成器</h3><p>为了确保每次运行程序时生成不同的随机数序列，可以使用一个种子来初始化 <code>default_random_engine</code>。通常使用当前时间作为种子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">// 包含 time 函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用当前时间作为种子</span></span><br><span class="line">    <span class="type">unsigned</span> seed = <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="function">default_random_engine <span class="title">generator</span><span class="params">(seed)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, <span class="number">99</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        cout &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用不同的分布">使用不同的分布</h3><p>C++11 标准库提供了多种分布（distribution）用于生成不同类型的随机数，如均匀分布（<code>uniform_int_distribution</code>、<code>uniform_real_distribution</code>）、正态分布（<code>normal_distribution</code>）等。以下是一些示例：</p><p><strong>生成浮点数的均匀分布</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    default_random_engine generator;</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        cout &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生成正态分布的随机数</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    default_random_engine generator;</span><br><span class="line">    <span class="function">normal_distribution&lt;<span class="type">double</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">5.0</span>, <span class="number">2.0</span>)</span></span>; <span class="comment">// 平均值 5.0，标准差 2.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> random_number = <span class="built_in">distribution</span>(generator);</span><br><span class="line">        cout &lt;&lt; random_number &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><ul><li><strong><code>default_random_engine</code></strong>：C++11 提供的默认随机数生成器，适用于大多数通用用途。</li><li><strong>初始化种子</strong>：为了生成不同的随机数序列，可以使用当前时间或其他种子来初始化随机数生成器。</li><li><strong>不同的分布</strong>：C++11 提供了多种分布，可以生成不同类型和范围的随机数。</li></ul><p>使用 <code>default_random_engine</code> 及其相关的分布，可以方便地在 C++ 程序中生成高质量的随机数。</p><p>在 C++ 中，存储期和作用域是理解变量生命周期和可见性的两个重要概念。存储期描述了变量在内存中的存在时间，而作用域描述了变量在代码中的可访问区域。</p><h3 id="存储期">存储期</h3><p>存储期决定了变量在程序执行期间的生命周期。C++ 中有四种主要的存储期：</p><ol><li><p><strong>自动存储期（Automatic Storage Duration）</strong>：</p><ul><li>变量在块作用域内创建，当程序执行离开该块时销毁。</li><li>默认情况下，局部变量具有自动存储期。</li><li>存储在栈（stack）中。</li><li>变量类型包括：函数中声明的局部变量，函数形参，以及用register声明的局部变量或者函数形参。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// &#x27;a&#x27; 是一个自动存储期变量</span></span><br><span class="line">    <span class="comment">// &#x27;a&#x27; 存在于函数 foo() 的作用域内</span></span><br><span class="line">&#125; <span class="comment">// 当 foo() 结束时，&#x27;a&#x27; 被销毁</span></span><br></pre></td></tr></table></figure></li><li><p><strong>静态存储期（Static Storage Duration）</strong>：</p><ul><li>变量在程序开始时分配，在程序结束时销毁。静态存储类期的函数，就像其他函数一样，在程序开始时函数名就已经存在。</li><li>包括全局变量、静态局部变量和静态成员变量。</li><li>存储在全局/静态内存区。</li><li>extern与static为函数和具有静态存储期的变量声明标识符。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// &#x27;global_var&#x27; 是一个静态存储期变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">20</span>; <span class="comment">// &#x27;static_var&#x27; 也是静态存储期变量</span></span><br><span class="line">    <span class="comment">// &#x27;static_var&#x27; 只在第一次调用 foo() 时初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线程存储期（Thread Storage Duration）</strong>：</p><ul><li>变量在线程启动时创建，在线程结束时销毁。</li><li>使用 <code>thread_local</code> 关键字声明。</li><li>每个线程有自己独立的实例。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> thread_var = <span class="number">30</span>; <span class="comment">// &#x27;thread_var&#x27; 是一个线程存储期变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态存储期（Dynamic Storage Duration）</strong>：</p><ul><li>变量在运行时动态分配和释放内存，通常使用 <code>new</code> 和 <code>delete</code> 操作符。</li><li>存储在堆（heap）中。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* dynamic_var = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">40</span>); <span class="comment">// &#x27;dynamic_var&#x27; 是一个动态存储期变量</span></span><br><span class="line">    <span class="comment">// 使用动态内存分配</span></span><br><span class="line">    <span class="keyword">delete</span> dynamic_var; <span class="comment">// 手动释放动态内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="作用域">作用域</h3><p>作用域决定了变量在程序中的可见性和访问权限。C++ 中有几种主要的作用域：</p><ol><li><p><strong>块作用域（Block Scope）</strong>：</p><ul><li>变量在一对 <code>&#123;&#125;</code> 内声明，其作用域限于该块。</li><li>包括函数体、控制结构（如 if、for、while）和代码块。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">20</span>; <span class="comment">// &#x27;b&#x27; 具有块作用域</span></span><br><span class="line">        <span class="comment">// &#x27;b&#x27; 只在 if 语句块内可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &#x27;b&#x27; 在这里不可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>函数作用域（Function Scope）</strong>：</p><ul><li>标签的作用域，通常用于 <code>goto</code> 语句。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> label;</span><br><span class="line">label:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// &#x27;label&#x27; 具有函数作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>文件作用域（File Scope）</strong>：</p><ul><li>变量在文件级别声明，其作用域覆盖整个文件。</li><li>使用 <code>static</code> 关键字声明的文件范围内的静态变量。</li><li>全局变量默认具有文件作用域。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> file_static_var = <span class="number">50</span>; <span class="comment">// 文件作用域的静态变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">60</span>; <span class="comment">// 文件作用域的全局变量</span></span><br></pre></td></tr></table></figure></li><li><p><strong>命名空间作用域（Namespace Scope）</strong>：</p><ul><li>变量在命名空间内声明，其作用域限于该命名空间。</li><li>可以使用 <code>namespace</code> 关键字定义。</li><li>声明于任何的函数或者类之外的标识符</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MyNamespace &#123;</span><br><span class="line">    <span class="type">int</span> namespace_var = <span class="number">70</span>; <span class="comment">// 命名空间作用域的变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MyNamespace::namespace_var &lt;&lt; endl; <span class="comment">// 访问命名空间内的变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>类作用域（Class Scope）</strong>：</p><ul><li>变量或成员函数在类或结构体内声明，其作用域限于该类或结构体。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> class_var;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// &#x27;class_var&#x27; 在类作用域内可见</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>6.<strong>函数原型作用域（Class Scope）</strong>：</p><p>指的是那些用在函数形参列表中的标识符，不需要它们的名字，只需要类型。</p><h3 id="总结-3">总结</h3><ul><li><strong>存储期</strong>：描述变量在内存中的生命周期，包括自动存储期、静态存储期、线程存储期和动态存储期。</li><li><strong>作用域</strong>：描述变量在代码中的可见性和访问权限，包括块作用域、函数作用域、文件作用域、命名空间作用域和类作用域。</li></ul><p>理解存储期和作用域是编写高效、清晰和错误较少的 C++ 代码的关键。</p><blockquote><p>Each identifier in a program also has other attributes, including storage duration, scope and linkage.</p><p>C++ provides several storage-class specifiers that determine a variable’s storage duration:</p><p>◦register, extern, mutable and static.</p><p>程序中的每个标识符还具有其他属性，包括存储持续时间、作用域和链接。<br>c++提供了几个存储类说明符来确定变量的存储持续时间:<br>注册，外部，可变和静态。</p></blockquote><blockquote><p><strong>Storage Duration</strong></p><p>An identifier’s storage duration determines the period during which that identifier exists in memory.</p><p>◦Some exist briefly, some are repeatedly created and destroyed and others exist for a program’s entire execution.</p><p><strong>Scope</strong></p><p>An identifier’s <em>scope</em> is where <em>the identifier can be referenced</em> in a program.</p><p>◦Some identifiers can be referenced throughout a program; others can be referenced from only limited portions of a program.</p><p><strong>Linkage</strong></p><p>An identifier’s <em>linkage</em> determines whether it’s known only in the <em>source file where it’s declared</em> or <em>across multiple files that are compiled, then linked together.</em></p><p>存储时间<br>标识符的存储持续时间决定了该标识符在内存中存在的时间。<br>有些是短暂存在的，有些是反复创建和销毁的，还有一些是在程序的整个执行过程中存在的。</p><p>范围<br>标识符的作用域是标识符可以在程序中被引用的地方。<br>有些标识符可以在整个程序中引用;其他的只能从程序的有限部分引用。</p><p>链接<br>标识符的链接决定了它是只在声明它的源文件中已知，还是在编译后链接在一起的多个文件中已知。</p></blockquote><blockquote><p><strong>Storage Duration</strong></p><p>The storage-class specifiers can be split into four storage durations:</p><p>◦<em>automatic</em>, <em>static</em>, <em>dynamic</em> and <em>thread</em>.</p><p><strong>Local Variables and Automatic Storage Duration</strong></p><p>Variables with <em>automatic storage duration</em> include:</p><p>◦local variables declared in functions</p><p>◦function parameters</p><p>◦local variables or function parameters declared with register</p><p>存储时间<br>存储类说明符可以分为四个存储持续时间:<br>自动、静态、动态、螺纹。</p><p>局部变量和自动存储时间<br>具有自动保存期限的变量包括:<br>函数中声明的局部变量<br>函数参数<br>用寄存器声明的局部变量或函数参数</p></blockquote><blockquote><p><strong>Static Storage Duration</strong></p><p>Keywords extern and static declare identifiers for variables with <em>static storage duration</em> and for functions.</p><p>◦Exist from the point at which the program begins execution and until the program terminates.</p><p>Such a variable is initial<em>ized once when its declaration is encountered.</em></p><p>静态存储时长<br>关键字extern和static声明具有静态存储时间的变量和函数的标识符。<br>从程序开始执行到程序终止时存在。<br>这样的变量在遇到声明时初始化一次。</p></blockquote><blockquote><p><strong>Identifiers with Static Storage Duration</strong></p><p>There are two types of identifiers with <em>static storage duration</em></p><p>◦external identifiers (such as global variables and global function names)</p><p>◦local variables declared with the storage-class specifier static.</p><p><strong>具有静态存储时间的标识符</strong></p><p>有两种类型的标识符带有静态存储持续时间</p><p>◦外部标识符(如全局变量和全局函数名)</p><p>◦用存储类说明符static声明的局部变量。</p></blockquote><blockquote><p><strong>static</strong> <strong>Local Variables</strong></p><p>Local variables declared static are still known only in the function in which they’re declared, but, unlike automatic variables, <em>static</em> <em>local variables retain their values when the function returns to its caller</em>.</p><p>The next time the function is called, the static local variables contain the values they had when the function last completed execution.</p><p>静态局部变量<br>声明为静态的局部变量仍然只在声明它们的函数中是已知的，但是，与自动变量不同，静态局部变量在函数返回给调用者时保留其值。<br>下次调用函数时，静态局部变量包含函数上次完成执行时的值。</p></blockquote><h2 id="内联函数">内联函数</h2><blockquote><p>内联函数（inline function）是C++中的一种优化机制，通过减少函数调用的开销来提高程序性能。内联函数使用<code>inline</code>关键字声明，建议编译器在调用内联函数时将其展开，而不是进行常规的函数调用。</p><h3 id="内联函数的定义">内联函数的定义</h3><p>内联函数的定义通常放在头文件中，以便编译器在每个使用该函数的地方都能看到函数的定义。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数的特点和使用场景">内联函数的特点和使用场景</h3><ol><li><p><strong>减少函数调用开销</strong>：</p><ul><li>内联函数通过在调用点直接展开函数体，避免了常规函数调用的开销（如压栈、跳转和返回）。</li><li>适用于短小、频繁调用的函数，如简单的getter和setter函数。</li></ul></li><li><p><strong>编译器建议</strong>：</p><ul><li><code>inline</code> 关键字只是对编译器的建议，编译器可能会根据具体情况决定是否内联。</li><li>现代编译器会根据函数的复杂度和调用频率自动决定是否内联，无需显式使用<code>inline</code>关键字。</li></ul></li><li><p><strong>代码膨胀</strong>：</p><ul><li>过度使用内联函数会导致代码膨胀（code bloat），增加二进制文件的大小。</li><li>应避免将大型或复杂的函数声明为内联函数。</li></ul></li></ol><h3 id="定义和声明内联函数">定义和声明内联函数</h3><p>内联函数通常在类定义内定义，以确保编译器在使用该类时能够看到内联函数的定义。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于非类成员函数，可以在头文件中定义，也可以在头文件中声明，在实现文件中定义：</p><p><strong>头文件（math.h）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MATH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MATH_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MATH_H</span></span></span><br></pre></td></tr></table></figure><p><strong>实现文件（math.cpp）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和宏的对比">内联函数和宏的对比</h3><p>内联函数比宏（macro）更安全和灵活。宏使用预处理器展开，不进行类型检查，可能导致难以调试的错误。</p><p><strong>示例（使用宏定义）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(a, b) ((a) + (b))</span></span><br></pre></td></tr></table></figure><p><strong>示例（使用内联函数）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联函数在编译阶段进行类型检查，并且支持C++的各种功能（如模板、重载等），而宏只在预处理阶段简单文本替换。</p><h3 id="内联函数的使用限制">内联函数的使用限制</h3><ol><li><p><strong>递归函数</strong>：</p><ul><li>递归函数不能完全内联，因为递归调用在编译时无法确定展开次数。</li></ul></li><li><p><strong>复杂函数</strong>：</p><ul><li>大型或复杂的函数不适合作为内联函数，会导致代码膨胀，影响性能。</li></ul></li><li><p><strong>虚函数</strong>：</p><ul><li>虚函数不能在编译时确定调用目标，通常不会被内联。</li></ul></li></ol><h3 id="总结-4">总结</h3><p>内联函数是提高程序性能的一种手段，通过减少函数调用的开销来优化短小、频繁调用的函数。然而，应谨慎使用内联函数，避免导致代码膨胀和性能问题。编译器会根据具体情况自动决定是否内联函数，因此在现代C++编程中，显式使用<code>inline</code>关键字的需求相对较少。</p></blockquote><p>对内联函数的任意修改，都要求该函数重新该函数的所有用户都重新编译。</p><h2 id="引用与引用形参">引用与引用形参</h2><p>引用可以提高性能，但是安全性会降低，因为被调用函数可能会削弱调用者的数据。</p><p>引用形参是函数调用中实参的别名。</p><p>传递大型对象时建议使用引用传递。</p><p>如果一个引用不应当修改实参，那么在形参的说明符前面加上const限定符即可。</p><p>函数也可以返回引用，但是这是非常危险的，因为如果返回的是被调用函数中的局部变量时，如果没有声明为static，那么它会在函数执行结束时自动销毁。产生对一个未定义变量的引用。</p><p>对一个未定义变量的引用称为虚悬引用。</p><blockquote><p>在 C++ 中，引用（reference）是一种别名机制，允许一个变量作为另一个变量的别名。引用形参是函数参数的一种，通过引用传递参数，使得函数可以直接操作调用者传入的变量。</p><h3 id="引用">引用</h3><h4 id="基本语法">基本语法</h4><p>引用在定义时使用符号 <code>&amp;</code>，并且必须在定义时进行初始化。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a; <span class="comment">// &#x27;ref&#x27; 是 &#x27;a&#x27; 的引用</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ref</code> 是 <code>a</code> 的引用，任何对 <code>ref</code> 的操作实际上都是对 <code>a</code> 的操作。</p><h4 id="特点">特点</h4><ol><li><strong>引用必须初始化</strong>：<ul><li>引用在声明时必须被初始化。</li></ul></li><li><strong>引用不可改变引用对象</strong>：<ul><li>一旦引用被初始化为某个对象，就不能改变引用对象。</li></ul></li><li><strong>引用是别名</strong>：<ul><li>引用只是现有变量的另一个名字，不分配新的内存。</li></ul></li></ol><h3 id="引用形参">引用形参</h3><p>引用形参是函数参数的一种，通过引用传递参数，使得函数可以直接操作实参，而不是其副本。这样可以避免不必要的拷贝，提高效率。</p><h4 id="例子">例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">(<span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">    num++; <span class="comment">// 直接修改实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">increment</span>(a); <span class="comment">// 传递 &#x27;a&#x27; 的引用</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 输出 6</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>increment</code> 接受一个 <code>int</code> 类型的引用参数 <code>num</code>。在 <code>main</code> 函数中，<code>a</code> 的引用被传递给 <code>increment</code>，因此 <code>increment</code> 可以直接修改 <code>a</code> 的值。</p><h3 id="引用形参的优点">引用形参的优点</h3><ol><li><p><strong>避免拷贝</strong>：</p><ul><li>传递大对象时，通过引用传递避免了对象的拷贝，提高了性能。</li></ul></li><li><p><strong>允许修改实参</strong>：</p><ul><li>通过引用传递，可以在函数内部修改调用者传入的变量。</li></ul></li><li><p><strong>实现常量引用</strong>：</p><ul><li>使用 <code>const</code> 引用形参，既可以避免拷贝，又可以防止修改实参。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string&amp; str)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="常量引用">常量引用</h3><p>常量引用（<code>const reference</code>）允许引用一个常量或非常量对象，并且在引用的生命周期内不允许修改引用对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// num = 10; // 错误，不能修改</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">print</span>(a); <span class="comment">// 可以传递非常量对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>); <span class="comment">// 可以传递常量对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的应用场景">引用的应用场景</h3><ol><li><p><strong>函数返回值</strong>：</p><ul><li>函数可以返回一个引用，使得调用者可以直接操作函数内部的变量。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getElement</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">getElement</span>(arr, <span class="number">1</span>) = <span class="number">10</span>; <span class="comment">// 修改 arr[1] 的值为 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>避免拷贝大对象</strong>：</p><ul><li>传递大型对象时，通过引用传递避免了对象的拷贝，节省了时间和空间。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">processLargeObject</span><span class="params">(<span class="type">const</span> LargeObject&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理大对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现类成员函数链式调用</strong>：</p><ul><li>类成员函数可以返回对象本身的引用，实现链式调用。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">MyClass&amp; <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">10</span>).<span class="built_in">setValue</span>(<span class="number">20</span>); <span class="comment">// 链式调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-5">总结</h3><ul><li><strong>引用</strong>：引用是现有变量的别名，必须初始化，且不能改变引用对象。</li><li><strong>引用形参</strong>：函数参数通过引用传递，使得函数可以直接操作实参，提高效率。</li><li><strong>常量引用</strong>：通过 <code>const</code> 修饰引用，避免拷贝的同时防止修改引用对象。</li><li><strong>应用场景</strong>：引用在避免对象拷贝、函数返回值、链式调用等方面有广泛应用。</li></ul><p>理解引用和引用形参在 C++ 编程中的作用，对于编写高效、优雅的代码非常重要。</p></blockquote><h2 id="默认实参">默认实参</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">It isn’t uncommon <span class="keyword">for</span> a program to invoke a function repeatedly with the same argument value <span class="keyword">for</span> a particular parameter.</span><br><span class="line">Can specify that such a parameter has a <span class="keyword">default</span> argument, i.e., a <span class="keyword">default</span> value to be passed to that parameter.</span><br><span class="line">When a program omits an argument <span class="keyword">for</span> a parameter with a <span class="keyword">default</span> argument in a function call, the compiler rewrites the function call <span class="keyword">and</span> inserts the <span class="keyword">default</span> value of that argument.</span><br><span class="line"><span class="function">Default arguments must be the <span class="title">rightmost</span> <span class="params">(trailing)</span> arguments in a function’s parameter list.</span></span><br><span class="line"><span class="function">Figure 6.21 demonstrates <span class="keyword">using</span> <span class="keyword">default</span> arguments to calculate a box’s volume. </span></span><br><span class="line"><span class="function">程序对特定形参使用相同的实参值反复调用函数的情况并不少见。</span></span><br><span class="line"><span class="function">可以指定这样的形参有一个默认实参，即传递给该形参的默认值。</span></span><br><span class="line"><span class="function">当程序在函数调用中省略带有默认实参的形参的实参时，编译器会重写函数调用并插入该实参的默认值。</span></span><br><span class="line"><span class="function">默认参数必须是函数形参列表中最右边<span class="params">(末尾)</span>的参数。</span></span><br><span class="line"><span class="function">图6.21演示了使用默认参数来计算盒子的体积。</span></span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240609005608260.png" alt="image-20240609005608260"></p><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240609005617123.png" alt="image-20240609005617123"></p><p>显式地传递给函数地任何实参都按照从左到右的顺序赋值给了函数的形参。</p><p>默认实参简化了函数调用的书写。</p><h2 id="一元的作用域分辨运算符">一元的作用域分辨运算符</h2><blockquote><p>It’s possible to declare local and global variables of the same name.</p><p>C++ provides the unary scope resolution operator (::) to access a global variable when a local variable of the same name is in scope.</p><p>Using the unary scope resolution operator (::) with a given variable name is optional when the only variable with that name is a global variable.</p><p>Figure 6.22 shows the unary scope resolution operator with local and global variables of the same name.</p><p>可以声明同名的局部变量和全局变量。<br>c++提供一元作用域解析操作符(::)，当同名局部变量在作用域中时，它可以访问全局变量。<br>当唯一具有该名称的变量是全局变量时，对给定变量名使用一元范围解析运算符(::)是可选的。<br>图6.22显示了具有相同名称的局部变量和全局变量的一元作用域解析操作符。</p></blockquote><p><img src="C:%5CUsers%5C22635%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20240609005917218.png" alt="image-20240609005917218"></p><p>总是使用::来引用全局变量可以降低出错概率，可以知道访问的是一个局部变量还是全局变量。</p><h2 id="函数重载">函数重载</h2><blockquote><p>C++ enables several functions of the same name to be defined, as long as they have different signatures.</p><p>This is called function overloading.</p><p>The C++ compiler selects the proper function to call by examining the number, types and order of the arguments in the call.</p><p>Function overloading is used to create several functions of the <em>same</em> name that perform similar tasks, but on different data types.</p><p>c++允许定义多个同名函数，只要它们具有不同的签名即可。<br>这被称为函数重载。<br>c++编译器通过检查调用中参数的数量、类型和顺序来选择要调用的适当函数。<br>函数重载用于创建多个同名的函数，这些函数执行类似的任务，但使用不同的数据类型。</p></blockquote><p>重载的函数可以有不同的返回类型，但是必须有不同的形参列表。编译器通过形参列表来区分重载的函数。</p><blockquote><p>函数重载（Function Overloading）是C++中一种允许在同一个作用域内定义多个同名函数的特性，这些函数必须具有不同的参数列表（参数的数量、类型或顺序不同）。函数重载的主要目的是提高代码的可读性和可维护性，使得同一操作可以适用于不同类型的数据。</p><h3 id="函数重载的规则">函数重载的规则</h3><ol><li><p><strong>参数列表必须不同</strong>：</p><ul><li>函数的参数数量不同。</li><li>参数的类型不同。</li><li>参数的顺序不同（对于不同类型的参数）。</li></ul></li><li><p><strong>返回类型不参与重载</strong>：</p><ul><li>函数的返回类型不用于区分重载函数。</li></ul></li></ol><h3 id="示例">示例</h3><p>以下是函数重载的几个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数 &#x27;print&#x27;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Printing int: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Printing double: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Printing string: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">10</span>);        <span class="comment">// 调用 print(int)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">5.7</span>);       <span class="comment">// 调用 print(double)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>);   <span class="comment">// 调用 print(string)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数 <code>print</code> 被重载了三次，分别接受 <code>int</code>、<code>double</code> 和 <code>string</code> 类型的参数。根据传递的参数类型，编译器会选择调用相应的重载函数。</p><h3 id="注意事项">注意事项</h3><ol><li><p><strong>默认参数和函数重载</strong>：</p><ul><li>默认参数与函数重载结合使用时，可能会导致二义性问题。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>); <span class="comment">// 调用 func(int) 或 func(int, int) 都可以</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，编译器无法确定调用哪个函数，会产生二义性错误。</p></li><li><p><strong>函数重载与模板</strong>：</p><ul><li>模板函数也可以重载，但要注意模板函数和普通函数的匹配规则。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Template function: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Non-template function: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 调用非模板函数，因为它是一个更具体的匹配</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5.5</span>); <span class="comment">// 调用模板函数，因为没有更具体的匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>重载与类型转换</strong>：</p><ul><li>类型转换可能会导致意想不到的重载解析结果。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Int function: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Double function: &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 调用 func(int)，因为 &#x27;a&#x27; 可以转换为 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>char</code> 类型的 <code>'a'</code> 会被转换为 <code>int</code> 类型，调用 <code>func(int)</code>。</p></li></ol><h3 id="函数重载的实际应用">函数重载的实际应用</h3><p>函数重载在实际编程中非常有用，可以使代码更加简洁和易于维护。例如，标准库中的 <code>abs</code> 函数就有多个重载版本，用于处理不同类型的参数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">abs</span><span class="params">(<span class="type">long</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">abs</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">abs</span><span class="params">(<span class="type">float</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">double</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">abs</span><span class="params">(<span class="type">long</span> <span class="type">double</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>通过重载 <code>abs</code> 函数，标准库提供了一种统一的接口，可以计算不同类型数字的绝对值，而不需要用户记住不同的函数名称。</p><h3 id="总结-6">总结</h3><ul><li><strong>函数重载</strong>：允许在同一个作用域内定义多个同名函数，必须具有不同的参数列表。</li><li><strong>参数列表</strong>：可以通过参数数量、类型或顺序来区分。</li><li><strong>返回类型</strong>：不参与重载的区分。</li><li><strong>应用场景</strong>：提高代码可读性和维护性，统一接口处理不同类型的数据。</li></ul><p>函数重载是C++中的重要特性之一，掌握函数重载有助于编写更灵活、可维护的代码。</p></blockquote><h3 id="函数的尾随返回值类型">函数的尾随返回值类型</h3><blockquote><p>在C++11中，引入了一种新的函数返回值声明方式，称为尾随返回类型（trailing return type）。这种方式将返回类型写在函数签名的末尾，而不是像传统方法那样写在函数名前面。尾随返回类型在某些情况下特别有用，例如当返回类型依赖于参数类型时。</p><h3 id="基本语法-2">基本语法</h3><p>尾随返回类型使用箭头符号 <code>-&gt;</code>，并将返回类型写在函数签名的最后。下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> -&gt; <span class="type">int</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>add</code> 函数的返回类型是 <code>int</code>，写在函数签名的最后。</p><h3 id="使用场景">使用场景</h3><p>尾随返回类型在以下几个场景中特别有用：</p><ol><li><p><strong>返回类型依赖于模板参数</strong>：<br>当返回类型依赖于函数参数的类型时，使用尾随返回类型可以更清晰地表达类型关系。</p></li><li><p><strong>简化类型声明</strong>：<br>当返回类型是一个复杂的类型（如函数指针或带有多个模板参数的类型）时，使用尾随返回类型可以使代码更简洁和易读。</p></li></ol><h3 id="示例-2">示例</h3><h4 id="返回类型依赖于模板参数">返回类型依赖于模板参数</h4><p>假设有一个模板函数，返回类型依赖于模板参数类型的某些操作。在这种情况下，使用尾随返回类型可以很方便地表达这种依赖关系。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2.5</span>); <span class="comment">// result 的类型是 double</span></span><br><span class="line">    std::cout &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出 3.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>add</code> 函数的返回类型是 <code>decltype(t + u)</code>，表示 <code>t</code> 和 <code>u</code> 相加后的类型。使用尾随返回类型，可以让返回类型的定义依赖于参数类型。</p><h4 id="复杂类型声明">复杂类型声明</h4><p>对于一些复杂的返回类型（例如，返回一个函数指针），尾随返回类型可以使声明更简洁。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用传统方式声明返回函数指针的函数</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">function1</span>(<span class="type">int</span>)) (<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用尾随返回类型声明返回函数指针的函数</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">function2</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function1 = add;</span><br><span class="line">    function2 = add;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">function1</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">function2</span>(<span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">function1</span>(<span class="type">int</span>))(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">function2</span><span class="params">(<span class="type">int</span>)</span> -&gt; <span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>function1</code> 和 <code>function2</code> 都返回一个指向函数的指针。使用尾随返回类型，可以使返回类型的声明更加直观和易读。</p><h3 id="总结-7">总结</h3><ul><li><strong>尾随返回类型</strong>：在C++11引入的一种新的函数返回类型声明方式，将返回类型写在函数签名的末尾。</li><li><strong>语法</strong>：<code>auto 函数名(参数列表) -&gt; 返回类型</code></li><li><strong>适用场景</strong>：<ul><li>当返回类型依赖于函数参数类型时（特别是模板函数）。</li><li>当返回类型较复杂时，使代码更简洁和易读。</li></ul></li><li><strong>示例</strong>：模板函数、返回复杂类型（如函数指针）。</li></ul><p>尾随返回类型在现代C++编程中提供了更大的灵活性和可读性，特别是在处理模板和复杂类型时。</p></blockquote><blockquote><p><code>decltype</code> 是 C++11 引入的一种关键字，用于获取表达式的数据类型。它的主要作用是在编译时推导出表达式的类型，并且可以用于定义变量、函数返回类型以及模板参数等。</p><h3 id="基本语法-3">基本语法</h3><p><code>decltype</code> 关键字后面跟着一个表达式，用于推导该表达式的类型。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression) variable_name;</span><br></pre></td></tr></table></figure><p>在这个语法中，<code>expression</code> 是任何有效的表达式，可以是变量、函数调用、算术运算等。</p><h3 id="示例-3">示例</h3><h4 id="定义变量的类型与表达式相同">定义变量的类型与表达式相同</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x) y; <span class="comment">// &#x27;y&#x27; 的类型为 &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>decltype(x)</code> 返回的类型与变量 <code>x</code> 的类型相同，即 <code>int</code>。</p><h4 id="定义变量的类型与函数调用的返回类型相同">定义变量的类型与函数调用的返回类型相同</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func</span>()) result; <span class="comment">// &#x27;result&#x27; 的类型为 &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>decltype(func())</code> 返回的类型与函数 <code>func()</code> 的返回类型相同，即 <code>int</code>。</p><h4 id="获取数组元素类型">获取数组元素类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(arr[<span class="number">0</span>]) element; <span class="comment">// &#x27;element&#x27; 的类型为 &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>decltype(arr[0])</code> 返回的类型与数组 <code>arr</code> 的元素类型相同，即 <code>int</code>。</p><h4 id="函数返回类型推导">函数返回类型推导</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>add</code> 函数返回类型使用了 <code>decltype(t + u)</code>，表示该函数的返回类型与 <code>t + u</code> 表达式的类型相同。</p><h3 id="注意事项-2">注意事项</h3><ol><li><p><strong>表达式不执行</strong>：<code>decltype</code> 只会获取表达式的类型，而不会执行表达式。因此，即使表达式是不合法的或者不完整的，也不会引发编译错误，只有当 <code>decltype</code> 语句被使用时才会检查表达式的合法性。</p></li><li><p><strong>表达式中的括号</strong>：<code>decltype</code> 会保留表达式中的括号，以及可能的引用、常量性等。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">decltype</span>((x)) y = x; <span class="comment">// &#x27;y&#x27; 的类型为 &#x27;int&amp;&#x27;，而不是 &#x27;int&#x27;</span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>decltype((x))</code> 返回的类型是 <code>int&amp;</code>，因为表达式 <code>(x)</code> 是一个左值引用。</p><h3 id="总结-8">总结</h3><ul><li><strong><code>decltype</code> 关键字</strong>：用于获取表达式的类型。</li><li><strong>语法</strong>：<code>decltype(expression)</code></li><li><strong>适用场景</strong>：<ul><li>定义变量的类型与表达式的类型相同。</li><li>定义函数返回类型与表达式的类型相同。</li><li>获取数组元素类型。</li></ul></li><li><strong>注意事项</strong>：<ul><li>表达式不执行，只获取类型。</li><li>保留表达式中的括号和可能的引用、常量性。</li></ul></li></ul><p><code>decltype</code> 关键字在模板、泛型编程、自动类型推导等方面具有重要作用，使得 C++ 中的类型推导更加灵活和方便。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP复习 第四章 第五章</title>
      <link href="/posts/c5acb085.html"/>
      <url>/posts/c5acb085.html</url>
      
        <content type="html"><![CDATA[<h2 id="Cpp复习-第四章第五章">Cpp复习 第四章第五章</h2><p>在 C++ 编程中，控制流结构是指管理代码执行顺序的方式。主要有三种控制流结构：顺序结构、循环结构和选择结构。下面是对每种结构的详细介绍：</p><h3 id="顺序结构">顺序结构</h3><p>顺序结构是最基本的控制流结构，它按照代码编写的顺序逐行执行。所有的程序都至少包含一些顺序结构。每个语句按出现的顺序执行，直到程序结束或遇到其他控制流结构。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> sum = a + b; <span class="comment">// 按顺序执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sum: &quot;</span> &lt;&lt; sum &lt;&lt; endl; <span class="comment">// 按顺序执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，变量 <code>a</code> 和 <code>b</code> 被依次赋值，然后计算它们的和，最后输出结果。</p><h3 id="选择结构">选择结构</h3><p>选择结构允许程序根据条件选择不同的路径执行。主要有三种选择结构：<code>if</code> 语句、<code>if-else</code> 语句和 <code>switch</code> 语句。</p><ol><li><p><strong><code>if</code> 语句</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>if-else</code> 语句</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当条件为假时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>switch</code> 语句</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 当表达式等于 value1 时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 当表达式等于 value2 时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 当表达式不匹配任何 case 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The number is positive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The number is negative.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The number is zero.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;You entered one.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;You entered two.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;You entered a number other than one or two.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环结构">循环结构</h3><p>循环结构允许程序重复执行一段代码，直到满足特定条件。主要有三种循环结构：<code>for</code> 循环、<code>while</code> 循环和 <code>do-while</code> 循环。</p><ol><li><p><strong><code>for</code> 循环</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>while</code> 循环</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>do-while</code> 循环</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure></li></ol><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;For loop iteration: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while 循环</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;While loop iteration: &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do-while 循环</span></span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Do-while loop iteration: &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">        ++k;</span><br><span class="line">    &#125; <span class="keyword">while</span> (k &lt;= <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li><strong>顺序结构</strong>：代码按顺序逐行执行。</li><li><strong>选择结构</strong>：根据条件选择不同的路径执行（<code>if</code>、<code>if-else</code>、<code>switch</code>）。</li><li><strong>循环结构</strong>：重复执行代码块直到满足特定条件（<code>for</code>、<code>while</code>、<code>do-while</code>）。</li></ul><p>通过组合使用这三种控制流结构，可以编写出功能丰富且灵活的 C++ 程序。</p><p>存在两种组合方式：控制语句嵌套和控制语句堆叠</p><p>在 C++ 编程中，控制语句的嵌套和堆叠是常见的技术，用于实现复杂的控制逻辑。以下是对这两种技术的详细解释及示例：</p><h3 id="控制语句嵌套">控制语句嵌套</h3><p>控制语句嵌套是指一个控制语句（如 if、for、while 等）位于另一个控制语句的内部。这种结构允许更复杂的条件判断和循环执行。</p><h4 id="示例：">示例：</h4><p><strong>嵌套的 if 语句</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;a is positive and less than b.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;a is non-positive and less than b.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is not less than b.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>嵌套的 for 循环</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制语句堆叠">控制语句堆叠</h3><p>控制语句堆叠是指多个控制语句依次执行，没有相互嵌套。这种结构有助于实现一系列独立的条件判断或循环执行。</p><h4 id="示例：-2">示例：</h4><p><strong>堆叠的 if 语句</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is less than b.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a is positive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b is positive.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆叠的 for 循环</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First loop iteration: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Second loop iteration: j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="控制语句嵌套和堆叠的综合示例">控制语句嵌套和堆叠的综合示例</h3><p>在实际应用中，经常会同时使用嵌套和堆叠的控制语句来实现复杂的逻辑。</p><h4 id="综合示例：">综合示例：</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Nested loop: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First condition met.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">2</span>; ++k) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Stacked and nested loop: k = &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2">总结</h3><ul><li><strong>控制语句嵌套</strong>：一个控制语句内部包含另一个控制语句，用于实现更复杂的逻辑。</li><li><strong>控制语句堆叠</strong>：多个控制语句依次执行，用于处理一系列独立的条件或循环。</li></ul><p>通过合理地使用嵌套和堆叠的控制语句，可以编写出逻辑清晰、功能强大的程序。理解并掌握这两种技术对于编写复杂的 C++ 程序是非常重要的。</p><p>MAX与MIN存在于头文件<climits></p><p>列表初始化器：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val=&#123;<span class="number">1</span>&#125;<span class="keyword">or</span><span class="type">int</span> val&#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中，循环语句、<code>switch</code> 语句以及 <code>break</code> 和 <code>continue</code> 语句是控制程序执行流的重要工具。以下是对这些语句的详细介绍及示例：</p><h3 id="循环语句">循环语句</h3><p>循环语句用于重复执行一段代码，直到满足特定条件。C++ 中主要有三种循环语句：<code>for</code> 循环、<code>while</code> 循环和 <code>do-while</code> 循环。</p><ol><li><p><strong><code>for</code> 循环</strong>：<br><code>for</code> 循环通常用于知道循环次数的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; condition; increment) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>while</code> 循环</strong>：<br><code>while</code> 循环在执行循环体之前检查条件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>do-while</code> 循环</strong>：<br><code>do-while</code> 循环先执行一次循环体，然后检查条件。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="switch-语句"><code>switch</code> 语句</h3><p><code>switch</code> 语句用于根据一个表达式的值来执行不同的代码块。它是多重选择结构的一个实现。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 当 expression 等于 constant1 时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 当 expression 等于 constant2 时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 可以有多个 case 子句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 当 expression 不匹配任何 case 时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> day = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Monday&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Tuesday&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Wednesday&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Invalid day&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break-语句"><code>break</code> 语句</h3><p><code>break</code> 语句用于立即终止所在的循环或 <code>switch</code> 语句，跳出循环或 <code>switch</code> 块。</p><p><strong>示例（在循环中使用）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 终止循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例（在 <code>switch</code> 语句中使用）</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Number is 1&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Number is 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Number is neither 1 nor 2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue-语句"><code>continue</code> 语句</h3><p><code>continue</code> 语句用于跳过当前循环迭代中的剩余代码，并立即开始下一次迭代。它只能用于循环中。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过当前迭代的剩余代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3">总结</h3><ul><li><strong>循环语句</strong>：<code>for</code>、<code>while</code> 和 <code>do-while</code> 用于重复执行代码块。</li><li><strong><code>switch</code> 语句</strong>：用于根据表达式的值选择执行不同的代码块。</li><li><strong><code>break</code> 语句</strong>：用于终止循环或 <code>switch</code> 语句。</li><li><strong><code>continue</code> 语句</strong>：用于跳过当前循环迭代中的剩余代码，并立即开始下一次迭代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组模板题</title>
      <link href="/posts/e92aaefd.html"/>
      <url>/posts/e92aaefd.html</url>
      
        <content type="html"><![CDATA[<h1 id="树状数组模板题">树状数组模板题</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/3079#problems">树状数组模板题 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>可以先看这篇文章学习或者复习一下：</p><p><a href="https://zhuanlan.zhihu.com/p/344360991">【朝夕的ACM笔记】数据结构-树状数组 - 知乎 (zhihu.com)</a></p><hr><h4 id="P3374-【模板】树状数组-1-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="comment">//树状数组</span></span><br><span class="line"><span class="comment">//树状数组：数组的每个位置储存的应当是一个区间的信息</span></span><br><span class="line"><span class="comment">//这些区间应当包容而不相交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单点修改</span></span><br><span class="line"><span class="comment">//首先修改的是单个元素</span></span><br><span class="line"><span class="comment">//其次修改的是包含这个元素的区间</span></span><br><span class="line"><span class="comment">//需要修改的区间(y,x],(x,x+lowbit(x)]------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//区间查询</span></span><br><span class="line"><span class="comment">//查询的是从[1,x]区间的和</span></span><br><span class="line"><span class="comment">//[1,x]=(y,x]+(y&#x27;,y]+(y&#x27;&#x27;,y&#x27;]+------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树 O(n)建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=a[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)    t[j]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt,x,y;    std::cin&gt;&gt;opt&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">update</span>(x,y,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(y)-<span class="built_in">query</span>(x<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P5057-CQOI2006-简单题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P5057">P5057 [CQOI2006] 简单题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll d[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        t[x]=t[x]%<span class="number">2</span>;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        ans%=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[j]+=t[i];</span><br><span class="line">            t[j]=t[j]%<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;    std::cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="built_in">update</span>(l,<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">update</span>(r+<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(x,n)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3368-【模板】树状数组-2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> d[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN];</span><br><span class="line"><span class="comment">//树状数组</span></span><br><span class="line"><span class="comment">//这里要求实现的是单点查询 区间修改</span></span><br><span class="line"><span class="comment">//我们可以发现 我们进行求一个差分数组 然后在树状数组上维护即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建树 O(n)建树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)    t[j]+=t[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        d[i]=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y,k;  std::cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">            <span class="built_in">update</span>(x,k,n);</span><br><span class="line">            <span class="built_in">update</span>(y+<span class="number">1</span>,-k,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(x)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2068-统计和-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll d[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]+=d[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="built_in">lowbit</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[j]+=t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,w;    std::cin&gt;&gt;n&gt;&gt;w;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> opt;   std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;  std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">update</span>(a,b,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;  std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(b)-<span class="built_in">query</span>(a<span class="number">-1</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4939-Agent2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a,b;    std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">            <span class="built_in">update</span>(a,<span class="number">1</span>,n);</span><br><span class="line">            <span class="built_in">update</span>(b+<span class="number">1</span>,<span class="number">-1</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a;  std::cin&gt;&gt;a;</span><br><span class="line">            std::cout&lt;&lt;<span class="built_in">query</span>(a)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2880-USACO07JAN-Balanced-Lineup-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2880">P2880 [USACO07JAN] Balanced Lineup G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">ll t1[MAXN];</span><br><span class="line">ll t2[MAXN];</span><br><span class="line"><span class="comment">//学到了树状数组的新用法 维护区间max和区间min</span></span><br><span class="line"><span class="comment">//update函数还是差不多的 只不过t[i]+=k 改成了t[i]=max(t[i],k) 这里的k对应的就是a[i]</span></span><br><span class="line"><span class="comment">//但是query的时候需要考虑l和r 不像以前那样[1,r]-[1,l]</span></span><br><span class="line"><span class="comment">//我们知道 树状数组是将数组分为若干个区间 进而往上爬更新实现的 区间只包含而不相交</span></span><br><span class="line"><span class="comment">//那么我们可以按照熟悉的方法 一直从r-=lowbit(r)进行更新 只需要&gt;=l即可</span></span><br><span class="line"><span class="comment">//但是需要注意 可能最后的块不是完整的一块 所以我们需要在不满足的条件下从r-&gt;l 直接暴力即可</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t1[x]=std::<span class="built_in">max</span>(t1[x],k);</span><br><span class="line">        t2[x]=std::<span class="built_in">min</span>(t2[x],k);</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll maxn=<span class="number">0</span>;</span><br><span class="line">    ll minn=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(r-<span class="built_in">lowbit</span>(r)&gt;=l)</span><br><span class="line">        &#123;</span><br><span class="line">            maxn=std::<span class="built_in">max</span>(maxn,t1[r]);</span><br><span class="line">            minn=std::<span class="built_in">min</span>(minn,t2[r]);</span><br><span class="line">            r-=<span class="built_in">lowbit</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        maxn=std::<span class="built_in">max</span>(maxn,a[r]);</span><br><span class="line">        minn=std::<span class="built_in">min</span>(minn,a[r]);</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn-minn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(i,a[i],n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(t2,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(t2));</span><br><span class="line">    <span class="type">int</span> n,q;    std::cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(n);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;    std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        std::cout&lt;&lt;<span class="built_in">query</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6225-eJOI2019-异或橙子-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6225">P6225 [eJOI2019] 异或橙子 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//思路都想对了 可是不会写qwq</span></span><br><span class="line"><span class="comment">//这题求的是^</span></span><br><span class="line"><span class="comment">//不难发现 如果区间包含的元素个数是偶数 那么它们的区间异或和一定为0</span></span><br><span class="line"><span class="comment">//反之 只跟 a[i]^a[i+2]^...^a[j] 有关</span></span><br><span class="line"><span class="comment">//那么我们可以在此基础上分奇偶项建立树状数组维护</span></span><br><span class="line"><span class="comment">//注意将a[i]修改为j的时候 t[x]^=(a[i]^k) 这个是异或的性质 注意一下即可</span></span><br><span class="line"><span class="comment">//query时直接异或和即可 因为分了奇偶</span></span><br><span class="line"><span class="comment">//至于query时 是奇数项的树状数组还是偶数项的树状数组 我们对l&amp;1即可</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span></span><br><span class="line">&#123;</span><br><span class="line">    ll t[MAXN];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            t[x]^=k;</span><br><span class="line">            x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)</span><br><span class="line">        &#123;</span><br><span class="line">            ans^=t[x];</span><br><span class="line">            x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BIT tree[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,q;    std::cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        tree[i&amp;<span class="number">1</span>].<span class="built_in">update</span>(i,a[i],n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> opt;    std::cin&gt;&gt;opt;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i,j;  std::cin&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            tree[i&amp;<span class="number">1</span>].<span class="built_in">update</span>(i,a[i]^j,n),    a[i]=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l,r;    std::cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="keyword">if</span>((l+r)&amp;<span class="number">1</span>)     std::cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>    std::cout&lt;&lt;(tree[l&amp;<span class="number">1</span>].<span class="built_in">query</span>(r)^tree[l&amp;<span class="number">1</span>].<span class="built_in">query</span>(l<span class="number">-1</span>))&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1908-逆序对-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val!=b.val)    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//求解逆序对</span></span><br><span class="line"><span class="comment">//只需要从左往右遍历，寻找左侧比当前元素大的元素个数，叠加即可</span></span><br><span class="line"><span class="comment">//左侧比当前元素大的元素个数=左侧元素个数-左侧小于等于当前元素的元素个数</span></span><br><span class="line"><span class="comment">//后者可以使用桶排的方法</span></span><br><span class="line"><span class="comment">//需要涉及到离散化 暂时还不熟悉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);   <span class="comment">//相当于桶排中的t[b[i]]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans+=i-<span class="built_in">query</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1774-最接近神的人-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1774">P1774 最接近神的人 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.val!=b.val)    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line">ll b[MAXN];</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//求解逆序对</span></span><br><span class="line"><span class="comment">//只需要从左往右遍历，寻找左侧比当前元素大的元素个数，叠加即可</span></span><br><span class="line"><span class="comment">//左侧比当前元素大的元素个数=左侧元素个数-左侧小于等于当前元素的元素个数</span></span><br><span class="line"><span class="comment">//后者可以使用桶排的方法</span></span><br><span class="line"><span class="comment">//需要涉及到离散化 暂时还不熟悉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,<span class="type">int</span> k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);   <span class="comment">//相当于桶排中的t[b[i]]++;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans+=i-<span class="built_in">query</span>(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4378-USACO18OPEN-Out-of-Sorts-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4378">P4378 [USACO18OPEN] Out of Sorts S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;(-x))</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll t[MAXN];</span><br><span class="line"><span class="comment">//一道逆序对的变式题 但是题目有点意思 自己犯了一些小错误</span></span><br><span class="line"><span class="comment">//这道题其实求的还是逆序对 但是我们可以发现</span></span><br><span class="line"><span class="comment">//前面那些大的数肯定会被当前数的后面，且只有这些数会跑到当前数的后面，所以这个点肯定只会被更新有限次</span></span><br><span class="line"><span class="comment">//那么我们取最大的即可</span></span><br><span class="line"><span class="comment">//1 update时 是b[i]而不是i query也是一样</span></span><br><span class="line"><span class="comment">//2 需要边建树 边更新答案</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll val;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.val==b.val)  <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">        <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,ll k,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        t[x]+=k;</span><br><span class="line">        x+=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=t[x];</span><br><span class="line">        x-=<span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].val, a[i].id=i;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,node::cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b[a[i].id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">update</span>(b[i],<span class="number">1</span>,n);</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,i-<span class="built_in">query</span>(b[i],n));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> tt=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(tt--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树状数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换根DP</title>
      <link href="/posts/4286fd48.html"/>
      <url>/posts/4286fd48.html</url>
      
        <content type="html"><![CDATA[<h1 id="换根DP">换根DP</h1><p>复习或者学习可以参考以下两篇文章：</p><p><a href="https://zhuanlan.zhihu.com/p/348349531">【朝夕的ACM笔记】动态规划-换根DP - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com/article/c8ov8ekf">[学习笔记]换根dp - 洛谷专栏 (luogu.com)</a></p><p>下面是对应的一些练习题目：（题单链接）</p><p><a href="https://www.luogu.com.cn/training/513240#information">换根DP - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><p>有一些题实在是太板子了，所以我就没怎么写注释了。</p><h4 id="P3478-POI2008-STA-Station-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI2008] STA-Station - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line"><span class="comment">//遇到换根dp了 学习一下</span></span><br><span class="line"><span class="comment">//关键是有两个dfs</span></span><br><span class="line"><span class="comment">//dfs1负责统计每个节点u距离根节点1的深度 以及以u为根的子树的大小</span></span><br><span class="line"><span class="comment">//dfs2负责计算dp数组  dp[u]表示以u为根节点的深度和</span></span><br><span class="line"><span class="comment">//状态转移方程就是</span></span><br><span class="line"><span class="comment">//dp[v]=g[v]+(dp[u]-(g[v]+size[v]))+(size[1]-size[v])</span></span><br><span class="line"><span class="comment">//g[u] 表示子树里所有节点到u的深度和</span></span><br><span class="line"><span class="comment">//size[u] 表示的是以u为根节点的子树大小</span></span><br><span class="line"><span class="comment">//depth[u]表示从u到1的深度(以后有用)</span></span><br><span class="line"><span class="comment">//v是u的子节点</span></span><br><span class="line"><span class="comment">//那么当根从u-&gt;v时 我们就要更新dp数组 dp[v]=g[v]+dp[u]-(g[v]+size[v])+(size[1]-size[v])</span></span><br><span class="line"><span class="comment">//显然的 g[v]需要加上去 而原来的dp[u]就要减去v子树里的信息</span></span><br><span class="line"><span class="comment">//一开始我也认为为什么是减去g[v]+size[v] 而不是减去g[v]</span></span><br><span class="line"><span class="comment">//我们可以这样想 u是v的父节点 那么v的子树里的所有点到u的距离都要额外+1 全部的额外和就是size[v]</span></span><br><span class="line"><span class="comment">//总共算出来就是g[v]+size[v]</span></span><br><span class="line"><span class="comment">//后面的减去size[1]-size[v]也是依此类推</span></span><br><span class="line"><span class="comment">//其实化简后就可以发现是dp[to]=dp[x]-2*size[to]+size[1];</span></span><br><span class="line"><span class="comment">//根本用不到g数组</span></span><br><span class="line"><span class="comment">//原题中没有确定根节点 那么我们不妨假设根节点是1 需要预处理出dp[1]</span></span><br><span class="line"><span class="comment">//先dfs1 预处里出depth数组 全部累加就可以得到dp[1]</span></span><br><span class="line"><span class="comment">//后面dfs2就是正规的状态转移了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一个小细节 注意得开long long </span></span><br><span class="line"><span class="comment">//因为可能在计算的过程中溢出了 虽然数据范围1e6乍一看人畜无害的样子</span></span><br><span class="line"><span class="comment">//这个细节一定要留意</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;ans)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dp[i];</span><br><span class="line">            pos=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ABC348E-Minimize-Sum-of-Distances-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/AT_abc348_e">[ABC348E] Minimize Sum of Distances - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*a[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">min</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-Painting-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1187E">Tree Painting - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//这道题题意看上去很难 其实是绕 关键是弄清楚要求什么就好了</span></span><br><span class="line"><span class="comment">//题目要求的是数量的贡献值 所以不需要求边长</span></span><br><span class="line"><span class="comment">//题目要求进行n次操作 其实答案只跟第一次操作 也就是将哪个点染为黑色有关</span></span><br><span class="line"><span class="comment">//wsm？</span></span><br><span class="line"><span class="comment">//一个点的贡献来源于以它为根的子树和它的祖先中能达到的白点数。</span></span><br><span class="line"><span class="comment">//当这个点的父亲已被染成黑色，该点的祖先颜色已无法对该点贡献造成影响，只与子树有关，而子树不受顺序影响。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实预处理都是一样的</span></span><br><span class="line"><span class="comment">//dp[i] 表示以i为根节点的答案</span></span><br><span class="line"><span class="comment">//不妨还是以1为根开始预处理</span></span><br><span class="line"><span class="comment">//这里dp[1]+=size[i]</span></span><br><span class="line"><span class="comment">//其中size[i]表示的是以i为根的子树的大小</span></span><br><span class="line"><span class="comment">//显然的 以1为根节点时 答案就是dp[1]</span></span><br><span class="line"><span class="comment">//接下来就是换根dp的转移了</span></span><br><span class="line"><span class="comment">//具体的推导还是看之前的文章</span></span><br><span class="line"><span class="comment">//这里直接丢了：dp[to]=dp[x]+size[1]-2*size[to];</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=size[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Tree-with-Maximum-Cost-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1092F">Tree with Maximum Cost - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*a[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Centroids-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF708C">Centroids - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="P2986-USACO10MAR-Great-Cow-Gathering-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR] Great Cow Gathering G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll c[MAXN];</span><br><span class="line"><span class="comment">//其实就是加了权值 但是自己还是犯了不少低级错误</span></span><br><span class="line"><span class="comment">//size[x]改为以x为根的子树所拥有的奶牛数目</span></span><br><span class="line"><span class="comment">//depth 表示的是以1为根节点 x到1的深度</span></span><br><span class="line"><span class="comment">//问题如下</span></span><br><span class="line"><span class="comment">//1 dp[to]=dp[x]-(2*size[to]-size[1])*t.val;</span></span><br><span class="line"><span class="comment">//第一个就是把t.val写成了c[to] 其实应该很容易就明白是t.val才对</span></span><br><span class="line"><span class="comment">//因为算的是总距离 自然是数量*距离 结果却变成了数目*数目</span></span><br><span class="line"><span class="comment">//第二个就是 dp[1]+=depth[i]*c[i];</span></span><br><span class="line"><span class="comment">//这里dp的定义改为总距离 所以需要*c[i]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">    ll val;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=c[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+t.val;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>])*t.val;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,l;    std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">        edge[a].<span class="built_in">push_back</span>(&#123;a,b,l&#125;);</span><br><span class="line">        edge[b].<span class="built_in">push_back</span>(&#123;b,a,l&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i]*c[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">1e15</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">min</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3647-APIO2014-连珠线-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3647">P3647 [APIO2014] 连珠线 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="ABC220F-Distance-Sums-2-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/AT_abc220_f">[ABC220F] Distance Sums 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]-(<span class="number">2</span>*size[to]-size[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1395-会议-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1395">P1395 会议 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll depth[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        depth[to]=depth[x]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        size[x]+=size[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to]=dp[x]<span class="number">-2</span>*size[to]+size[<span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[<span class="number">1</span>]+=depth[i];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;dp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            ans=dp[i];</span><br><span class="line">            p=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3047-USACO12FEB-Nearby-Cows-G-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3047">P3047 [USACO12FEB] Nearby Cows G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">//一道略有变式的换根dp</span></span><br><span class="line"><span class="comment">//这里需要考虑距离根节点的距离 所以需要添加一个维度k 表示到根节点距离&lt;=k的节点数权值和</span></span><br><span class="line"><span class="comment">//我们还是进行一样的预处理 以1为根</span></span><br><span class="line"><span class="comment">//先预处理出size数组 size[u][i]表示以u为根节点的子树 距离其&lt;=i的节点数</span></span><br><span class="line"><span class="comment">//注意这里是先默认整棵树是以1为根节点的 需要与上面的dp数组区分开来</span></span><br><span class="line"><span class="comment">//size[x][i]+=size[to][i-1] 1&lt;=i&lt;=k 先预处理出size数组 这是dfs1的任务</span></span><br><span class="line"><span class="comment">//接下来考虑dfs2 我们开始进行换根的操作</span></span><br><span class="line"><span class="comment">//dp[to][i]+=dp[x][i-1]-size[to][i-2] 2&lt;=i&lt;=k</span></span><br><span class="line"><span class="comment">//还得考虑dp[to][1]+=size[x][0] 不然会RE并且少算情况</span></span><br><span class="line"><span class="comment">//为什么还要减去size[to][i-2]呢？ 因为dp[x][i-1]一开始是从1为根节点开始的</span></span><br><span class="line"><span class="comment">//所以我们要减去重复的部分 对应的也就是size[to][i-2]（注意这里还是以1为根哦，所以是size数组，而不是dp数组）</span></span><br><span class="line"><span class="comment">//然后我们再dfs2更新即可</span></span><br><span class="line"><span class="comment">//记得dp数组的预处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结</span></span><br><span class="line"><span class="comment">//1 dfs1是以1为根的总树进行预处理 size数组和dp数组本质上是一样的 只不过size数组加了一个以1为根作为总树的前提</span></span><br><span class="line"><span class="comment">//我们可以根据dp数组的设计 来得出size数组的设计（其实一模一样 只不过加了一个限制条件）</span></span><br><span class="line"><span class="comment">//2 在换根的时候需要考虑清楚各种细节 这道题就是算重的情况</span></span><br><span class="line">ll dp[MAXN][<span class="number">25</span>];</span><br><span class="line">ll size[MAXN][<span class="number">25</span>];</span><br><span class="line">ll c[MAXN];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)   size[x][i]=c[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            size[x][i]+=size[to][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        dp[to][<span class="number">1</span>]+=size[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[to][i]+=dp[x][i<span class="number">-1</span>]-size[to][i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;c[i];</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=size[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i][k]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6419-COCI2014-2015-1-Kamp-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6419">P6419 [COCI2014-2015#1] Kamp - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>后续补</p><h4 id="Maximum-White-Subtree-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1324F">Maximum White Subtree - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll size[MAXN];</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="comment">//做了这么多道题目 对换根dp也有了自己的体会</span></span><br><span class="line"><span class="comment">//1 size数组的定义和dp数组定义一样 所以可以根据dp数组的设计来推导出size数组的设计</span></span><br><span class="line"><span class="comment">//size数组多了一个限制条件 就是它是以为1整棵树的根节点的</span></span><br><span class="line"><span class="comment">//2 根据dp数组的定义 我们也可以对size数组进行预处理 不过偏简单暴力</span></span><br><span class="line"><span class="comment">//这里size的定义是最大化cnt1-cnt2 显然的 我们可以贪心</span></span><br><span class="line"><span class="comment">//if(size[to]&gt;0)    size[x]+=size[to];</span></span><br><span class="line"><span class="comment">//这一步是由dfs1完成的 换句话说dfs1是完成以1为根的整棵树的工作</span></span><br><span class="line"><span class="comment">//dfs2就是换根 建议在推导如何换根时 以x作为整棵树的根节点来进行推导 比较好理解</span></span><br><span class="line"><span class="comment">//那么 换根时 不难想到 可能是由x继承过来 也可能是直接继承自己的size</span></span><br><span class="line"><span class="comment">//但是可能 自己的size可能是负值 所以还得再分类讨论</span></span><br><span class="line"><span class="comment">// if(size[to]&gt;0)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //直接继承自己的size或者dp[x]（也就是父亲的dp）</span></span><br><span class="line"><span class="comment">//            //为什么是这样子？因为如果size[to]大于0 那么肯定包括了 </span></span><br><span class="line"><span class="comment">//            dp[to]=std::max(size[to],dp[x]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            //如果不大于0 父亲肯定不包括 但是儿子又必须包括 </span></span><br><span class="line"><span class="comment">//            //所以dp[to]就是max(dp[x]+size[to],size[to])</span></span><br><span class="line"><span class="comment">//            //注意size[to]是最优的情况（前提是以1为根）</span></span><br><span class="line"><span class="comment">//            dp[to]=std::max(size[to],dp[x]+size[to]);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[x]=a[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(to,x);</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            size[x]+=size[to];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(to==fa)  <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(size[to]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[to]=std::<span class="built_in">max</span>(size[to],dp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[to]=std::<span class="built_in">max</span>(size[to],dp[x]+size[to]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">0</span>) a[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].<span class="built_in">push_back</span>(&#123;u,v&#125;);</span><br><span class="line">        edge[v].<span class="built_in">push_back</span>(&#123;v,u&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(dp,-0x3f,sizeof(dp));</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    dp[<span class="number">1</span>]=size[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;dp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 换根DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划3】区间与环形动态规划</title>
      <link href="/posts/451ad5ee.html"/>
      <url>/posts/451ad5ee.html</url>
      
        <content type="html"><![CDATA[<h1 id="【动态规划3】区间与环形动态规划">【动态规划3】区间与环形动态规划</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/213#problems">【动态规划3】区间与环形动态规划 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><h4 id="P1435-IOI2000-回文字串-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1435">P1435 [IOI2000] 回文字串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>这道题还有另外一种做法，利用LCS求解，可以看另外一篇文章：<a href="https://www.heavenhold.cn/2024/05/06/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%922%E3%80%91%E7%BA%BF%E6%80%A7%E7%8A%B6%E6%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">【动态规划2】线性状态动态规划 | Heavenhold</a>。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//有两种做法 一种是最长上升子序列 在另外一篇文章讲了</span></span><br><span class="line"><span class="comment">//这里介绍区间dp的做法</span></span><br><span class="line"><span class="comment">//dp[i][j] 表示要把从i到j的字符串变成回文串需要插入的最少字符数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=dp[i+1][j-1] id(s[i]==s[j])</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=len;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])  dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span>    dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][len]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1775-石子合并（弱化版）-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1775">P1775 石子合并（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示将从第i堆到第j堆的所有石子合并需要的最小代价</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i][k]+dp[k+1][j]+sum[j]-sum[k]+sum[k]-sum[i-1],dp[i][j]);</span></span><br><span class="line"><span class="comment">//其中k表示的是分段点</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">310</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">310</span>];</span><br><span class="line"><span class="comment">//sum表示的前缀和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;=j &amp;&amp; j&lt;=n ;p++)    <span class="comment">//p表示分段点 注意j要&lt;=n 否则可能会越界</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Zuma-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF607B">Zuma - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示将从第i堆到第j堆的所有珠子取走需要的最小时间</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i+1][j-1],dp[i][j]) if(a[i]==a[j])</span></span><br><span class="line"><span class="comment">//dp[i][j]=min(dp[i][k]+dp[k+1][j],dp[i][j]);</span></span><br><span class="line"><span class="comment">//wsm会是下面的这个呢 我们分析一下区间DP的原理</span></span><br><span class="line"><span class="comment">//区间DP其实是以某一个区间为中心 往其两边不断添加点或者区间 从而扩展的</span></span><br><span class="line"><span class="comment">//也就是  &lt;---[====]---&gt;</span></span><br><span class="line"><span class="comment">//而通过枚举分段点 我们可以得到每一种情况 取min 从而得到最小的情况 也就是答案</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">510</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][i+<span class="number">1</span>]=<span class="number">1</span>+(a[i]!=a[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]==a[j] &amp;&amp; i+<span class="number">1</span>&lt;=j<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//注意这里需要取min 因为在两边添加不一定是最优的</span></span><br><span class="line">                    dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;dp[i][j]&lt;&lt;&quot; 1 \n&quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]);</span><br><span class="line">                    <span class="comment">//std::cout&lt;&lt;dp[i][j]&lt;&lt;&quot; 2 \n&quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3205-HNOI2010-合唱队-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3205">P3205 [HNOI2010] 合唱队 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[i][j][opt] 表示从第i个位置到第j个位置之间 最后一个人是从左边/右边插入的方案数</span></span><br><span class="line"><span class="comment">//0 表示从左边插入 1 表示从右边插入</span></span><br><span class="line"><span class="comment">//根据题意 我们不难得出状态转移方程</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[i+1])     dp[i][j][0]+=dp[i+1][j][0];</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[j])   dp[i][j][0]+=dp[i+1][j][1];</span></span><br><span class="line"><span class="comment">if(a[j]&gt;a[j-1])     dp[i][j][1]+=dp[i][j-1][1];</span></span><br><span class="line"><span class="comment">if(a[i]&lt;a[j])   dp[i][j][1]+=dp[i][j-1][0];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//考虑初始化 dp[i][i][0]=1 我们默认一开始是从左边插入</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[i+<span class="number">1</span>])     dp[i][j][<span class="number">0</span>]+=dp[i+<span class="number">1</span>][j][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[j])   dp[i][j][<span class="number">0</span>]+=dp[i+<span class="number">1</span>][j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[j]&gt;a[j<span class="number">-1</span>])     dp[i][j][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(a[i]&lt;a[j])   dp[i][j][<span class="number">1</span>]+=dp[i][j<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                dp[i][j][<span class="number">0</span>]%=mod;</span><br><span class="line">                dp[i][j][<span class="number">1</span>]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(dp[<span class="number">1</span>][n][<span class="number">0</span>]+dp[<span class="number">1</span>][n][<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4170-CQOI2007-涂色-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4170">P4170 [CQOI2007] 涂色 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示从第i个位置到第j个位置需要的操作次数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//if(s[i]==s[j])  dp[i][j]=std::min(dp[i+1][j],dp[i][j-1]);</span></span><br><span class="line"><span class="comment">//原来一开始还加了一个 dp[i+1][j-1] </span></span><br><span class="line"><span class="comment">//也就是：dp[i][j]=std::min(dp[i+1][j],dp[i][j-1],dp[i+1][j-1]);</span></span><br><span class="line"><span class="comment">//但是这个是不对的 其实很显然 如果需要添加一种新的颜色 那么就需要加1了</span></span><br><span class="line"><span class="comment">//但是如果这样问题就很麻烦了 我们还得记录出现的颜色种类 其实上面的状态转移方程已经一步步转移过来了</span></span><br><span class="line"><span class="comment">//不再需要考虑这种特别复杂的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   dp[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;n)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==s[j])  dp[i][j]=std::<span class="built_in">min</span>(dp[i+<span class="number">1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1063-NOIP2006-提高组-能量项链-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1063">P1063 [NOIP2006 提高组] 能量项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示从第i个位置到第j个位置 可以释放的最多能量</span></span><br><span class="line"><span class="comment">//区间dp 因为涉及到环 所以拆环成链 具体是a[i+n]=a[i]这一步操作</span></span><br><span class="line"><span class="comment">//注意最长的长度是n 所以k的枚举范围是2-n 并且j&lt;=2*n</span></span><br><span class="line"><span class="comment">//注意枚举分段点时 p是从i开始的 一开始我也是从i开始 后来改成从i+1开始 样例就错了</span></span><br><span class="line"><span class="comment">//确实是得从i开始 因为1个两珠子的串是可能从2个珠子合成的</span></span><br><span class="line"><span class="comment">//这里一开始是打算开一个结构体 记录头标记 尾标记 其实没必要 因为首位相连 所以直接取下一个珠子的头标记即可</span></span><br><span class="line"><span class="comment">//注意最后获取答案 长度是n</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],a[i+n]=a[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//if(j&gt;2*n)   std::cout&lt;&lt;j&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">max</span>(dp[i][j],dp[i][p]+dp[p+<span class="number">1</span>][j]+a[i]*a[p+<span class="number">1</span>]*a[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="comment">//if(p&gt;2*n)   std::cout&lt;&lt;p&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   ans=std::<span class="built_in">max</span>(ans,dp[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    std::cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1880-NOI1995-石子合并-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1880">P1880 [NOI1995] 石子合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">19650827</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp1[<span class="number">210</span>][<span class="number">210</span>];  <span class="comment">//最大得分</span></span><br><span class="line"><span class="type">int</span> dp2[<span class="number">210</span>][<span class="number">210</span>];  <span class="comment">//最小得分</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">210</span>];</span><br><span class="line"><span class="comment">//要被自己的sb错误笑死了 一直把k当作枚举点 这已经是第二次了</span></span><br><span class="line"><span class="comment">//还是相同的方法 环拆成链 枚举断点</span></span><br><span class="line"><span class="comment">//需要预处理出前缀和</span></span><br><span class="line"><span class="comment">//注意单独一个堆是不能合成的 所以它的得分是0</span></span><br><span class="line"><span class="comment">//最后答案取长度为n的区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        a[i+n]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)     dp2[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp1[i][j]=std::<span class="built_in">max</span>(dp1[i][j],dp1[i][p]+dp1[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+k<span class="number">-1</span>&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+k<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p=i;p&lt;j;p++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp2[i][j]=std::<span class="built_in">min</span>(dp2[i][j],dp2[i][p]+dp2[p+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxAns=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minAns=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        maxAns=std::<span class="built_in">max</span>(maxAns,dp1[i][i+n<span class="number">-1</span>]);</span><br><span class="line">        minAns=std::<span class="built_in">min</span>(minAns,dp2[i][i+n<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;minAns&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;maxAns;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数位DP学习（一）</title>
      <link href="/posts/ab7f3d5e.html"/>
      <url>/posts/ab7f3d5e.html</url>
      
        <content type="html"><![CDATA[<h1 id="数位DP学习">数位DP学习</h1><p>我是参考Pecco大佬的这篇文章学习的：<a href="https://zhuanlan.zhihu.com/p/348851463">算法学习笔记(68): 数位DP - 知乎 (zhihu.com)</a>，可以先看看，或者复习后再看看下面的题。</p><p>题单是这个：<a href="https://www.luogu.com.cn/training/82023#problems">（提高）『数位DP』从入门到入土 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a>，目前写了十多道，会慢慢补的。</p><p>也许以后会再补充一些其他OJ上的题目？</p><hr><h2 id="数位DP文章例题">数位DP文章例题</h2><p>先附上文章里的题目吧~~~</p><h4 id="不要62-HDU-2089-Virtual-Judge-vjudge-net"><a href="https://vjudge.net/problem/HDU-2089">不要62 - HDU 2089 - Virtual Judge (vjudge.net)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],dp[<span class="number">8</span>][<span class="number">12</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;    <span class="comment">//记录原来的数字中的位数</span></span><br><span class="line"><span class="comment">//dp[pos][last][limit]</span></span><br><span class="line"><span class="comment">//dp[pos][last][limit] 表示在第pos位时 所有符合要求的方案数</span></span><br><span class="line"><span class="comment">//limit是用来限制当前位最多可以枚举到哪一位</span></span><br><span class="line"><span class="comment">//true 说明只能枚举到原来的数字中这一位的值 否则就是0-9</span></span><br><span class="line"><span class="comment">//last是用来记录上一位的数字 判断当前解是否合法</span></span><br><span class="line"><span class="comment">//一般来说pos 和 limit是必要的 其他根据题目要求增加维度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> last,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)<span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">if</span>(dp[pos][last][limit]!=<span class="number">-1</span>)<span class="keyword">return</span> dp[pos][last][limit];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(last==<span class="number">6</span>&amp;&amp;i==<span class="number">2</span> || i==<span class="number">4</span>)   <span class="keyword">continue</span>;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,i,limit&amp;&amp;i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][last][limit]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">11</span>,<span class="literal">true</span>);  <span class="comment">//last设置为11 表示不存在上一位</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,(x||y))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2602-ZJOI2010-数字计数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digit=i;</span><br><span class="line">        ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Little-Girl-and-Maximum-XOR-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF276D">Little Girl and Maximum XOR - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],b[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//这里注意一下数组大小 因为是二进制 所以原本的20需要装换成对应的二进制数有几位</span></span><br><span class="line"><span class="comment">//dp[pos][limitl1][limitr1][limitl2][limitr2]</span></span><br><span class="line"><span class="comment">//pos含义一样 limitl1 表示当前位是否有下限制 limitr1 表示当前位是否有上限制</span></span><br><span class="line"><span class="comment">//limitl2 limitr2 同理</span></span><br><span class="line"><span class="comment">//因为是枚举2个数 并且不是计数 所以一个数需要设置上下限 总共4个limit</span></span><br><span class="line">ll cnt1,cnt2,cnt;</span><br><span class="line"><span class="comment">//cnt1 表示的是a数组的各位</span></span><br><span class="line"><span class="comment">//cnt2 表示的是b数组的各位</span></span><br><span class="line"><span class="comment">//cnt=max(cnt1,cnt2)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">bool</span> limitl1,<span class="type">bool</span> limitr1,<span class="type">bool</span> limitl2,<span class="type">bool</span> limitr2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//这里不太理解wsm是return 0;</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][limitl1][limitr1][limitl2][limitr2];</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=(limitl1?a[pos]:<span class="number">0</span>);i&lt;=(limitr1?b[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=(limitl2?a[pos]:<span class="number">0</span>);j&lt;=(limitr2?b[pos]:<span class="number">1</span>);j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=std::<span class="built_in">max</span>(ans,((i^j)&lt;&lt;(cnt-pos<span class="number">-1</span>))+<span class="built_in">dfs</span>(pos+<span class="number">1</span>,limitl1 &amp;&amp; i==a[pos],limitr1 &amp;&amp; i==b[pos],limitl2 &amp;&amp; j==a[pos], limitr2 &amp;&amp; j==b[pos]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt1=<span class="number">0</span>;</span><br><span class="line">    cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt1++]=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        b[cnt2++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt=std::<span class="built_in">max</span>(cnt1,cnt2);</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    std::<span class="built_in">reverse</span>(b,b+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    std::cout&lt;&lt;<span class="built_in">f</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的正解做法其实是贪心，后面会写一篇文章来介绍。</p><hr><h2 id="（提高）『数位DP』从入门到入土">（提高）『数位DP』从入门到入土</h2><h4 id="P4999-烦人的数学作业-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4999">P4999 烦人的数学作业 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">22</span>];</span><br><span class="line">ll dp[<span class="number">22</span>][<span class="number">200</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+i,limit &amp;&amp; i==a[pos]);</span><br><span class="line">        ans+=mod;</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    <span class="comment">//需要注意最后+mod 再%mod</span></span><br><span class="line">    std::cout&lt;&lt;(r-l+mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P6218-USACO06NOV-Round-Numbers-S-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P6218">P6218 [USACO06NOV] Round Numbers S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cnt0][cnt1][limit]</span></span><br><span class="line"><span class="comment">//pos limit 含义一样 cnt0记录当前有多少个0  cnt1同理 lead 考虑当前位之前是否全为0</span></span><br><span class="line"><span class="comment">//奇怪的问题 多加了一维就过了??? 原来一直WA</span></span><br><span class="line"><span class="comment">//大概明白什么原因了 如果是原来直接减 里面会包含前导0 所以就错了</span></span><br><span class="line">ll cnt;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos,ll cnt0,ll cnt1,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt0&gt;=cnt1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cnt0][cnt1][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)    <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0,cnt1,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(lead) ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0,cnt1+<span class="number">1</span>,limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt0+(i==<span class="number">0</span>),cnt1+(i==<span class="number">1</span>),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x&amp;<span class="number">1</span>;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y; std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2657-SCOI2009-windy-数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2657">P2657 [SCOI2009] windy 数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">12</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//数据出水了 这份码是有问题的</span></span><br><span class="line"><span class="comment">//加上特判应该就没问题了 可能是算重的问题</span></span><br><span class="line"><span class="comment">//有一个地方不太理解 1 200000 --&gt; 46859</span></span><br><span class="line"><span class="comment">//第二维度上限是10100</span></span><br><span class="line"><span class="comment">//大致明白了 ans+=----       d=ans</span></span><br><span class="line"><span class="comment">//得到的ans 和 sum 没有直接的关系 sum是一个底层的基本情况 ans是由底层dp来的</span></span><br><span class="line"><span class="comment">//因为其实只是0-9之间 所以底层实际上sum的数目只有0-9之间而已(也许有10)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">int</span> last,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][last][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发现了一件奇怪的事情 sum改成d 恰好是答案的负数</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-last)&gt;=<span class="number">2</span> || lead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//比较恶心的一点 一位数也是windy数</span></span><br><span class="line">            <span class="comment">//所以这里得讨论一下 如果abs(i-last)&gt;=2 或者 有前导0 都可能是windy数(个位数捣乱)</span></span><br><span class="line">            <span class="comment">//所以sum的更新需要判断 如果是个位数或者没有前导0 那么sum就+1 但是这样后面就得加上特判了</span></span><br><span class="line">            ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+((cnt==<span class="number">1</span>)) || (i || !lead),i,limit &amp;&amp; i==a[pos],lead &amp;&amp; i==<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">10</span>&amp;&amp;y&lt;<span class="number">10</span>)    std::cout&lt;&lt;r-l<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>        std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2602-ZJOI2010-数字计数-洛谷-计算机科学教育新生态-luogu-com-cn-2"><a href="https://www.luogu.com.cn/problem/P2602">P2602 [ZJOI2010] 数字计数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>看上面，这里不重复了。</p><h4 id="P1836-数页码-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1836">P1836 数页码 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">12</span>];</span><br><span class="line">ll dp[<span class="number">12</span>][<span class="number">90</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,ll sum,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,sum+i,limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    x=<span class="number">1</span>;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4317-花神的数论题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4317">P4317 花神的数论题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P=<span class="number">1e7</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll a[<span class="number">64</span>];</span><br><span class="line">ll dp[<span class="number">64</span>][<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>];</span><br><span class="line">ll ans[<span class="number">64</span>];</span><br><span class="line">ll dp2[<span class="number">64</span>][<span class="number">64</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//一开始没搞懂wsm要用快速幂</span></span><br><span class="line"><span class="comment">//大概明白了 求的是sum(1)*sum(2)*------*sum(n)</span></span><br><span class="line"><span class="comment">//可以转化成对应的二进制数中 1个1的个数 * 2个1的个数 * 3个1的个数 * 4个1的个数 * ...</span></span><br><span class="line"><span class="comment">//这个时候就可以使用快速幂了</span></span><br><span class="line"><span class="comment">//直接算应该也是可行的 但是dp方程就需要改变了</span></span><br><span class="line"><span class="comment">/*引用一下</span></span><br><span class="line"><span class="comment"> * 我们可以用数位DP求出二进制数中含有1的个数为k的数的数目sum，</span></span><br><span class="line"><span class="comment"> * 这样k的贡献就是sum个k连乘，也就是k的sum次方，</span></span><br><span class="line"><span class="comment"> * 这样我们枚举每一个二进制表示中可能含有的1的个数就可以得到最终的贡献</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//答案涉及到取模，但是需要注意的是我们仅仅能在加法减法或者乘法过程中随意取模，</span></span><br><span class="line"><span class="comment">//但是我们不能在求指数的过程中取模，否则会出现错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 又犯了一堆错误</span></span><br><span class="line"><span class="comment"> * 1 取模的时候只能在快速幂的时候取 否则ans[i]改变了</span></span><br><span class="line"><span class="comment"> * 2 又默认拆分成十进制了 数组也开小了 a[]开小了 dp[]却开对了------</span></span><br><span class="line"><span class="comment"> * 3 dfs中 ans赋值成1了</span></span><br><span class="line"><span class="comment"> * 4 P是 1e7+7 写成1e9+7 或者1e7+9了</span></span><br><span class="line"><span class="comment"> * 5 最后答案取模时又忘记+P 再%P了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cnt1,<span class="type">int</span> tot,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cnt1][tot][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt1==tot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cnt1+(i==<span class="number">1</span>),tot,limit &amp;&amp; i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=a*ans%P;</span><br><span class="line">        a=a*a%P;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        ans[i]=<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,i+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res=res*<span class="built_in">qpower</span>(i+<span class="number">1</span>,ans[i])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(res+P)%P&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还有第二种方法 第一种我们算的是含有k个1的数的个数，然后我们在函数外面进行求解k的贡献</span></span><br><span class="line"><span class="comment">//我们现在其实可以直接计算 就可以不用在外面再累乘计算了</span></span><br><span class="line"><span class="function">ll <span class="title">dfs2</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cnt1,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp2[pos][cnt1][limit];</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">max</span>(cnt1,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans*<span class="built_in">dfs2</span>(pos+<span class="number">1</span>,cnt1+(i==<span class="number">1</span>),limit &amp;&amp; i==a[pos])%P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;y;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(y)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=y&amp;<span class="number">1</span>;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp2,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp2));</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">dfs2</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>)+P)%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统计问题-The-Counting-Problem-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/UVA1640">统计问题 The Counting Problem - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,x||y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)     std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digit=i;</span><br><span class="line">            ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">            <span class="comment">//毒瘤问题 不能输出多余的空格</span></span><br><span class="line">            std::cout&lt;&lt;r-l&lt;&lt;(i&lt;<span class="number">9</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Salazar-Slytherin’s-Locket-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF855E">Salazar Slytherin’s Locket - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">64</span>],dp[<span class="number">64</span>][<span class="number">1024</span>][<span class="number">2</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//理解错题意了 题目要求得是这个数转化成b进制后 判断0---b-1得个数是否都为偶数 如果是 则统计</span></span><br><span class="line"><span class="comment">//其实有一个很莽的写法 因为b最大到10 所以直接开到13维度</span></span><br><span class="line"><span class="comment">//但是正解是状压+数位</span></span><br><span class="line"><span class="comment">//我们可以将每个数字出现的个数进行二进制状态压缩</span></span><br><span class="line"><span class="comment">//0 表示出现偶数次</span></span><br><span class="line"><span class="comment">//1 表示出现奇数次</span></span><br><span class="line"><span class="comment">//dp[pos][state][limit][lead]</span></span><br><span class="line"><span class="comment">//pos lead limit 分别表示位置 有无前导0 当前位有无限制</span></span><br><span class="line"><span class="comment">//state 状压表示集合</span></span><br><span class="line"><span class="comment">//状态转移 只需要state ^ (1&lt;&lt;i)即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后再加一个维度 表示进制 这样dp数组只要初始化一次即可 否则会TLE</span></span><br><span class="line"><span class="comment">//注意要加在最前面 否则数组访问到其他非法元素</span></span><br><span class="line"><span class="comment">//好吧 不是这个原因 已经卡了两个多小时了 bzd为什么 已经无语了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ok 大致理解原理了 非常好的题 使我“浪费”了三个小时时间(但是 数位dp也进化了)</span></span><br><span class="line"><span class="comment"> * 由于在不同数的limit是不同的 这会阻止我们复用dp数组</span></span><br><span class="line"><span class="comment"> * 注意到limit等于1的状态出现的频率远远小于limit等于0的状态，</span></span><br><span class="line"><span class="comment"> * 所以我们可以选择只记忆化limit为0的状态，</span></span><br><span class="line"><span class="comment"> * 这样每次dp数组的意义就完全相同了 (来自Pecco)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ll cnt;</span><br><span class="line">ll b;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos,<span class="type">int</span> state,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][state][lead][b];</span><br><span class="line">    <span class="keyword">if</span>(!pos)    <span class="keyword">return</span> state==<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span> &amp;&amp; !limit)  <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:b<span class="number">-1</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,<span class="literal">false</span>,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,state^(<span class="number">1</span>&lt;&lt;i),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%b;</span><br><span class="line">        x/=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;b&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MDIGITS-Counting-Digits-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/SP3928">MDIGITS - Counting Digits - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">10</span>],dp[<span class="number">15</span>][<span class="number">12</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][limit][lead]</span></span><br><span class="line"><span class="comment">//pos 和 limit就不介绍了 前面已经知道了</span></span><br><span class="line"><span class="comment">//cntd 表示的是到目前为止找到了多少个digit</span></span><br><span class="line"><span class="comment">//lead 表示记录在当前位之前所有位是否都是0</span></span><br><span class="line"><span class="comment">//除了for循环内容和pos==cnt 外 其他的基本上都是板子</span></span><br><span class="line">ll cnt,digit;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)    <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][cntd][limit][lead]!=<span class="number">-1</span>)  <span class="keyword">return</span> dp[pos][cntd][limit][lead];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[pos][cntd][limit][lead]=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//初始化dp数组为-1</span></span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(a,a+cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x&gt;&gt;y,x||y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;y)     std::<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            digit=i;</span><br><span class="line">            ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">            <span class="comment">//毒瘤问题 不能输出多余的空格</span></span><br><span class="line">            std::cout&lt;&lt;r-l&lt;&lt;(i&lt;<span class="number">9</span>?<span class="string">&quot; &quot;</span>:<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Classy-Numbers-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/CF1036C">Classy Numbers - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">22</span>],dp[<span class="number">22</span>][<span class="number">22</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> cntd&lt;=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd+(i!=<span class="number">0</span>),limit &amp;&amp; i==a[pos],lead &amp;&amp; i==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4127-AHOI2009-同类分布-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4127#submit">P4127 [AHOI2009] 同类分布 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">22</span>],dp[<span class="number">22</span>][<span class="number">180</span>][<span class="number">200</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> P;</span><br><span class="line"><span class="comment">//也是一道挺有意思的题目</span></span><br><span class="line"><span class="comment">//dp[pos][sum][num]表示pos是位，sum为和，num为原数</span></span><br><span class="line"><span class="comment">//但是由于范围太大 直接转移存在问题 所以不难想到取模</span></span><br><span class="line"><span class="comment">//但是取什么数 这是一个问题</span></span><br><span class="line"><span class="comment">//原来的要求就是sum%num==0 即可</span></span><br><span class="line"><span class="comment">//所以如果能够让num取模到最后为0 其实也就是sum为模数就好了</span></span><br><span class="line"><span class="comment">//这样其实看好像没啥区别(有一种废话做法的感觉，问题就在于范围太大了 可能会溢出 所以算的过程中取模)</span></span><br><span class="line"><span class="comment">//但是把又不知道是哪一个 所以可以暴力枚举(范围也很小 200内)</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,ll num,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][num];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> num==<span class="number">0</span> &amp;&amp; sum==P;    <span class="comment">//最后结果 需要num==0 并且 sum==P (P是枚举的模数)</span></span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意边算边取模</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,sum+i,(<span class="number">10ll</span>*num+i)%P,limit &amp;&amp; i==a[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//暴力枚举模数</span></span><br><span class="line">    <span class="keyword">for</span>(P=<span class="number">1</span>;P&lt;=<span class="number">9</span>*cnt;P++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));   <span class="comment">//这里还得memset一下</span></span><br><span class="line">        ans+=<span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    ll l=<span class="built_in">f</span>(x<span class="number">-1</span>);</span><br><span class="line">    ll r=<span class="built_in">f</span>(y);</span><br><span class="line">    std::cout&lt;&lt;r-l&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//memset(dp,-1,sizeof(dp));</span></span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PR003004-Digit-Sum-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/SP17247">PR003004 - Digit Sum - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> cnt,digit;</span><br><span class="line">ll a[<span class="number">20</span>];</span><br><span class="line">ll dp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][cntd][lead]</span></span><br><span class="line"><span class="comment">//pos 表示位置 cntd 表示 统计到的digit的个数 lead 表示是否有前导0</span></span><br><span class="line"><span class="comment">//一开始的想法是对其进行取模运算 记录余数和倍数 但是后来发现这样搞也会MLE</span></span><br><span class="line"><span class="comment">//发现都是由0-9数字构成的 所以我们可以统计下0-9的数目 在加起来即可</span></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> cntd,<span class="type">bool</span> limit,<span class="type">bool</span> lead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][cntd][lead];</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)      <span class="keyword">return</span> cntd;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span> &amp;&amp; !limit)      <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lead &amp;&amp; i==<span class="number">0</span>)    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd,limit &amp;&amp; i==a[pos],<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span>    ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,cntd+(i==digit),limit &amp;&amp; i==a[pos],<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit)  d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x%<span class="number">10</span>;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt,<span class="number">0</span>,<span class="literal">true</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ll x,y;     std::cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        digit=i;</span><br><span class="line">        ll l=<span class="built_in">f</span>(x<span class="number">-1</span>),r=<span class="built_in">f</span>(y);</span><br><span class="line">        ans+=i*(r-l);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    std::cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因为是保存在Typora上的，现在已经有5000多字了，已经开始卡了，所以会分多期。</p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP专题--数塔问题</title>
      <link href="/posts/df2e3138.html"/>
      <url>/posts/df2e3138.html</url>
      
        <content type="html"><![CDATA[<h1 id="DP专题——数塔问题">DP专题——数塔问题</h1><p>来源自这篇文章：<a href="https://zhuanlan.zhihu.com/p/111637733">【朝夕的ACM笔记】动态规划-数塔问题 - 知乎 (zhihu.com)</a></p><hr><h4 id="P1508-Likecloud-吃、吃、吃-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1508">P1508 Likecloud-吃、吃、吃 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到第i行 第j列可以得到的最大值</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=max(dp[i+1][j+1],dp[i+1][j-1],dp[i+1][j])+a[i][j]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里犯了一个错误 n是奇数 所以不需要n/2-1 直接n/2即可</span></span><br><span class="line">    dp[m][n/<span class="number">2</span>+<span class="number">1</span>]=a[m][n/<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    dp[m][n/<span class="number">2</span>+<span class="number">2</span>]=a[m][n/<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">    dp[m][n/<span class="number">2</span>]=a[m][n/<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(&#123;dp[i+<span class="number">1</span>][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j<span class="number">-1</span>]&#125;)+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[<span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1216-USACO1-5-IOI1994-数字三角形-Number-Triangles-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1216">P1216 [USACO1.5] [IOI1994]数字三角形 Number Triangles - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到第i行 第j列可以得到的最大值</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r;  std::cin&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j<span class="number">-1</span>])+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[r][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1004-NOIP2000-提高组-方格取数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k][l] 表示第一次走到(i,j) 第二次走到(k,l)可以获得的最大价值</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j][k][l]</span></span><br><span class="line"><span class="comment">//由于只能向下或者向右走</span></span><br><span class="line"><span class="comment">//所以一共有四种情况</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+num[i][j]+num[k][l]</span></span><br><span class="line"><span class="comment">//注意 走过了就num[i][j] 其数值变为0 所以需要判重</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//num数组表示迷宫</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c &amp;&amp; (a||b||c))</span><br><span class="line">    &#123;</span><br><span class="line">        num[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                    <span class="comment">//判重</span></span><br><span class="line">                    <span class="keyword">if</span>(i==k &amp;&amp; j==l)    dp[i][j][k][l]-=num[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n][n][n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1006-NOIP2008-提高组-传纸条-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1006">P1006 [NOIP2008 提高组] 传纸条 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> num[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="comment">//跟方格取数很像 但是不能走重复的路</span></span><br><span class="line"><span class="comment">//所以可以让l 从j+1开始 就可以避免重复了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=j+<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意终点是(m,n)哦 不用算(m,n)的热心值</span></span><br><span class="line">    std::cout&lt;&lt;dp[m][n<span class="number">-1</span>][m<span class="number">-1</span>][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化方法</span></span><br><span class="line"><span class="comment">//我们可以发现，由于走的过程中只允许向右或向下走，所以每走一步不是行数加一就是列数加一。</span></span><br><span class="line"><span class="comment">//故在两条路径的长度一样时（也就是走的步数一样多时） 也就是i+j=k+l=步数+2</span></span><br><span class="line"><span class="comment">//所以可以开一个三维数组dp[n+m-2][x1][x2]</span></span><br><span class="line"><span class="comment">//第一维度表示步数 m行n列的矩阵步数从0~n+m-2</span></span><br><span class="line"><span class="comment">//第二维和第三维分别表示两条路径的横坐标，只要知道了步数和横坐标，就可以通过计算得出纵坐标。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//再考虑优化 其实每次都是只多走了一步 考虑01背包的优化 我们其实也可以把步数这一维度删去</span></span><br><span class="line"><span class="comment">//一开始数组也是简单的只开了60*60 结果WA了 问题出在压缩维度这里</span></span><br><span class="line"><span class="comment">//因为m+n&lt;=100 而num[i][k-i] k:1~m+n-2 所以这个时候 而i的范围是从1-m 所以可以到时候最大到90多</span></span><br><span class="line"><span class="comment">//所以我们可以只开105即可</span></span><br><span class="line"><span class="comment">//dp2不用改 影响的只是num2数组</span></span><br><span class="line"><span class="type">int</span> dp2[<span class="number">60</span>][<span class="number">60</span>];</span><br><span class="line"><span class="type">int</span> num2[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;    std::cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;num2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意i+j=k+l=步数+2</span></span><br><span class="line">    <span class="comment">//k枚举的是步数 所以注意num2数组那里要加2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n+m<span class="number">-2</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//要处理不同的横坐标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;i;j--)    <span class="comment">//防止路径重复</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp2[i][j]=std::<span class="built_in">max</span>(&#123;dp2[i][j],dp2[i<span class="number">-1</span>][j],dp2[i][j<span class="number">-1</span>],dp2[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line">                dp2[i][j]+=num2[i][k-i+<span class="number">2</span>]+num2[j][k-j+<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp2[m<span class="number">-1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上一道强化版题目的链接：<a href="https://www.luogu.com.cn/problem/T35377">T35377 大教室中传纸条 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/posts/79666db.html"/>
      <url>/posts/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构">数据结构</h1><h2 id="单调队列">单调队列</h2><h4 id="P1886-滑动窗口-【模板】单调队列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1886">P1886 滑动窗口 /【模板】单调队列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN],b[MAXN];</span><br><span class="line">std::deque&lt;ll&gt; dqmax;</span><br><span class="line">std::deque&lt;ll&gt; dqmin;</span><br><span class="line"><span class="comment">//时间复杂度为O(n)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间的最小值 维护的是一个单调递增序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//超过滑动窗口的长度 直接弹出头部</span></span><br><span class="line">        <span class="keyword">if</span>(!dqmin.<span class="built_in">empty</span>() &amp;&amp; i-dqmin.<span class="built_in">front</span>()&gt;=k)    dqmin.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">//维护单调递增序列</span></span><br><span class="line">        <span class="keyword">while</span>(!dqmin.<span class="built_in">empty</span>() &amp;&amp; a[dqmin.<span class="built_in">back</span>()]&gt;a[i])   dqmin.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//都满足 则插入i 注意插入的是编号</span></span><br><span class="line">        dqmin.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//i超出k 开始输出</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)      std::cout&lt;&lt;a[dqmin.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求区间的最大值 维护的是一个单调递增的序列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//超过滑动窗口的长度 直接弹出头部</span></span><br><span class="line">        <span class="keyword">if</span>(!dqmax.<span class="built_in">empty</span>() &amp;&amp; i-dqmax.<span class="built_in">front</span>()&gt;=k)    dqmax.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">//维护单调递增序列</span></span><br><span class="line">        <span class="keyword">while</span>(!dqmax.<span class="built_in">empty</span>() &amp;&amp; a[dqmax.<span class="built_in">back</span>()]&lt;a[i])   dqmax.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="comment">//都满足 则插入</span></span><br><span class="line">        dqmax.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="comment">//i超出k 开始输出</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k)      std::cout&lt;&lt;a[dqmax.<span class="built_in">front</span>()]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【动态规划2】线性状态动态规划</title>
      <link href="/posts/b591163f.html"/>
      <url>/posts/b591163f.html</url>
      
        <content type="html"><![CDATA[<h1 id="【动态规划2】线性状态动态规划">【动态规划2】线性状态动态规划</h1><p>题单链接：<a href="https://www.luogu.com.cn/training/212#information">【动态规划2】线性状态动态规划 - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><hr><h4 id="P1020-NOIP1999-提高组-导弹拦截-洛谷-计算机科学教育新生态-luogu-com-cn">[P1020 <a href="https://www.luogu.com.cn/problem/P1020">NOIP1999 提高组] 导弹拦截 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示以i为长度时 最长不上升子序列的最后一项</span></span><br><span class="line"><span class="comment">//分为两种 可以直接插入在尾部 或者 插入在中间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt,x;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;x)</span><br><span class="line">    &#123;</span><br><span class="line">        a[++cnt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化为无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,MAXN,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=dp[len])    dp[++len]=a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//最长不上升子序列是插在最后一个 注意要加上greater&lt;int&gt;() 因为dp数组是递减的</span></span><br><span class="line">            <span class="comment">//注意解引用*</span></span><br><span class="line">            *std::<span class="built_in">upper_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,a[i],std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;())=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化 dp[1]=a[1]</span></span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    len=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dilworth定理</span></span><br><span class="line">    <span class="comment">//对于一个偏序集，最少链划分等于最长反链长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;dp[len])    dp[++len]=a[i];     <span class="comment">//直接插入在尾部</span></span><br><span class="line">        <span class="comment">//最长上升子序列是插在找到的第一个 dp数组是递增的</span></span><br><span class="line">        <span class="keyword">else</span>    *std::<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,a[i])=a[i];     <span class="comment">//直接插入在中间</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2285-HNOI2004-打鼹鼠-洛谷-计算机科学教育新生态-luogu-com-cn">[P2285 <a href="https://www.luogu.com.cn/problem/P2285">HNOI2004] 打鼹鼠 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> t[MAXN],x[MAXN],y[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i只鼠鼠时 机器人能够打死多少只鼠鼠</span></span><br><span class="line"><span class="comment">//鼠鼠出现的时间是递增的 所以按顺序枚举即可</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i]=dp[j]+1 if(dis[i-&gt;j]&lt;=t[i]-t[j])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)   std::cin&gt;&gt;t[i]&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;    <span class="comment">//一开始从这个位置开始可以直接打死一只鼠鼠</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j]+<span class="number">1</span>&gt;dp[i] &amp;&amp; std::<span class="built_in">abs</span>(x[i]-x[j])+std::<span class="built_in">abs</span>(y[i]-y[j])&lt;=t[i]-t[j])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1725-琪露诺-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[MAXN];</span><br><span class="line">std::deque&lt;ll&gt; dq;</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i]表示走到编号为i的格子时 最大冰冻之数 (因为原题中有i==0 也就是起点)</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[j]=max(dp[i])+a[j] (i+l&lt;=j&lt;=i+r)</span></span><br><span class="line"><span class="comment">//有点像一个滑动窗口 所以我们可以使用单调队列来解决</span></span><br><span class="line"><span class="comment">//根据自己的理解写了一下 挂了一些细节 RE啥的 hack暂时没通过(sb洛谷 我原来的答案是错的 居然能过)</span></span><br><span class="line"><span class="comment">//问题 1 没有注意到初始化dp数组 导致hack点没过</span></span><br><span class="line"><span class="comment">//    2 要输入的n+1个点 这个已经解决了</span></span><br><span class="line"><span class="comment">//    3 RE的问题:其实编号为0-&gt;l-1的点是没有dp值的 所以j得从l开始 对应的j编号也要减l</span></span><br><span class="line"><span class="comment">//    4 dp数组更新时没有条件需求 ans要赋值为无穷小</span></span><br><span class="line"><span class="comment">//    5 注意看清题意 j+r&gt;n就算到达 注意在这些范围内更新</span></span><br><span class="line"><span class="comment">//    6 dp[j]=-0x3f3f3f 但是bzd memset出错了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l,r;  std::cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],dp[i]=<span class="number">-0x3f3f3f</span>;</span><br><span class="line">    <span class="type">int</span> len=r-l+<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">-0x3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=l;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; j-dq.<span class="built_in">front</span>()&gt;=len)    dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dp[dq.<span class="built_in">back</span>()]&lt;=dp[j-l])   dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        dq.<span class="built_in">push_back</span>(j-l);</span><br><span class="line">        dp[j]=dp[dq.<span class="built_in">front</span>()]+a[j];</span><br><span class="line">        <span class="keyword">if</span>(j+r&gt;n)   ans=std::<span class="built_in">max</span>(ans,dp[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4933-大师-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4933">P4933 大师 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>];</span><br><span class="line">ll dp[<span class="number">1010</span>][N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//dp[i][d] 表示前i个塔中 高度差为d的方案数</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][h[i]-h[j]]+=dp[j][h[i]-h[j]]+1 注意取模 由于d可能为负数 所以d可以加上一个常数</span></span><br><span class="line"><span class="comment">//ans 就是所有可能情况的和</span></span><br><span class="line"><span class="comment">//方案数 是+= 不是=</span></span><br><span class="line"><span class="comment">//还有一个问题 就是d是+N的 所以可能太大 数组第二维度需要开成2*N</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][a[i]-a[j]+N]+=dp[j][a[i]-a[j]+N]+<span class="number">1</span>;</span><br><span class="line">            dp[i][a[i]-a[j]+N]%=mod;</span><br><span class="line">            <span class="comment">//这里先加原来的 再取模 否则会WA</span></span><br><span class="line">            ans+=dp[j][a[i]-a[j]+N]+<span class="number">1</span>;</span><br><span class="line">            ans%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记漏了一个也成立</span></span><br><span class="line">    std::cout&lt;&lt;(ans+n)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1439-【模板】最长公共子序列-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1439">P1439 【模板】最长公共子序列 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="comment">//dp[i] 表示以i为长度时 最长不上升子序列的最后一项</span></span><br><span class="line"><span class="comment">//分为两种 可以直接插入在尾部 或者 插入在中间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        mp[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;b[i];</span><br><span class="line">    dp[<span class="number">1</span>]=mp[b[<span class="number">1</span>]];</span><br><span class="line">    <span class="type">int</span> len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[b[i]]&gt;dp[len])    dp[++len]=mp[b[i]];</span><br><span class="line">        <span class="keyword">else</span>    *(std::<span class="built_in">lower_bound</span>(dp+<span class="number">1</span>,dp+<span class="number">1</span>+len,mp[b[i]]))=mp[b[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;len&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1435-IOI2000-回文字串-洛谷-计算机科学教育新生态-luogu-com-cn">[P1435 <a href="https://www.luogu.com.cn/problem/P1435">IOI2000] 回文字串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="comment">//一开始以为这道题可以使用nlogn的二分优化方法做 后来发现是不可行的</span></span><br><span class="line"><span class="comment">//以样例为例 ab3bd--&gt;db3ba</span></span><br><span class="line"><span class="comment">//原来记录编号 12345-&gt;54321</span></span><br><span class="line"><span class="comment">//这么做 其实不可能构造出一个LIS的</span></span><br><span class="line"><span class="comment">//问题就在于它们之中有相同的元素 但是它们的位置标记却没有改变</span></span><br><span class="line"><span class="comment">//采取优化方法的前提是：序列其中的元素互不相同</span></span><br><span class="line"><span class="comment">//所以这道题只能使用普通方法做了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    std::string t;  t=s;</span><br><span class="line">    std::<span class="built_in">reverse</span>(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>());</span><br><span class="line">    t=<span class="string">&#x27;@&#x27;</span>+t;</span><br><span class="line">    s=<span class="string">&#x27;@&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])  dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span>    dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减去它们的公共部分就是需要插入的字符数</span></span><br><span class="line">    std::cout&lt;&lt;n-dp[n][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1874-快速求和-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1874">P1874 快速求和 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>针对hack的一些看法：<a href="https://www.luogu.com/article/vr0vrkqs">P1874 快速求和 - 洛谷专栏 (luogu.com)</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int dp[45][MAXN];</span></span><br><span class="line"><span class="comment">int num[45][45];</span></span><br><span class="line"><span class="comment">std::string s;</span></span><br><span class="line"><span class="comment">int getNum(int l,int r)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int i=l;</span></span><br><span class="line"><span class="comment">    while(i&lt;=r &amp;&amp; s[i]==&#x27;0&#x27;)    i++;</span></span><br><span class="line"><span class="comment">    if(i&gt;r)return 0;</span></span><br><span class="line"><span class="comment">    if(r-i+1&gt;6) return INF;</span></span><br><span class="line"><span class="comment">    else return std::stoi(s.substr(i,r-i+1));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void solve()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    std::cin&gt;&gt;s;</span></span><br><span class="line"><span class="comment">    int n;  std::cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    s=&#x27;0&#x27;+s;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;s.length();i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=i;j&lt;s.length();j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            num[i][j]=getNum(i,j);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    memset(dp,0x3f,sizeof(dp));</span></span><br><span class="line"><span class="comment">    dp[0][0]=-1;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;s.length();i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;=n;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            for(int k=1;k&lt;=i;k++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                if(j&gt;=num[i-k+1][i])    dp[i][j]=std::min(dp[i-k][j-num[i-k+1][i]]+1,dp[i][j]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    if(dp[s.length()-1][n]&gt;=s.length()-1)   std::cout&lt;&lt;-1&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    else    std::cout&lt;&lt;dp[s.length()-1][n]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ll num[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line">ll dp[<span class="number">45</span>][MAXN];</span><br><span class="line"><span class="comment">//dp[i][j] 表示前i个数中 和为j所需要添加的+</span></span><br><span class="line"><span class="comment">//num[i][j]表示从编号为i的数到编号为j的数 构成的数字</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=min(dp[i][j],dp[i-k+1][j-num[i-k][i]]+1)  k表示的区间的长度</span></span><br><span class="line"><span class="comment">//在这道题上花了很长时间了</span></span><br><span class="line"><span class="comment">//一个方面就是没想到num数组的更新的问题 不过后来解决了</span></span><br><span class="line"><span class="comment">//其实状态需转移方程不难想 问题在于预处理 这个预处理真的是毒瘤</span></span><br><span class="line"><span class="comment">//第一个就是 dp[0][0]的初始化 如果长度为0和为 不需要加加号就可以使和为0 但第一次算会加1 因此初始状态dp[0][0]设为-1</span></span><br><span class="line"><span class="comment">//dp 数组初始化 memset只能0-255 所以不要乱用memset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也许找到了一种方法? 看看num是否超出范围 如果超出 就赋值为INF</span></span><br><span class="line"><span class="comment">//其实就是上面文章提供的写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    ll n;  std::cin&gt;&gt;n;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i][j]=num[i][j<span class="number">-1</span>]*<span class="number">10</span>+s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[1][num[1][1]]=0;</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num[i-k][i])    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i-k<span class="number">-1</span>][j-num[i-k][i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][n]&gt;=len)     std::cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    std::cout&lt;&lt;dp[len][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大佬师兄指点后的代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll num[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line">ll dp[<span class="number">45</span>][MAXN];</span><br><span class="line"><span class="comment">//dp[0][j]没初始化导致WA</span></span><br><span class="line"><span class="comment">//然后num数组因为有些值会爆long long从而可能变成负值 导致dp转移式子中会越界 导致RE</span></span><br><span class="line"><span class="comment">//终于解决了一个困扰已久的问题</span></span><br><span class="line"><span class="comment">//memset(dp,0x3f,sizeof(dp)) memset是取赋值的后八位(也就是一个字节填充全部的字节,int就是由0x3f的后8位赋值全部的字节)</span></span><br><span class="line"><span class="comment">//0x3f:00111111     dp-&gt;00111111 00111111 00111111 001111111</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s;  std::cin&gt;&gt;s;</span><br><span class="line">    ll n;  std::cin&gt;&gt;n;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    s=<span class="string">&#x27;0&#x27;</span>+s;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=i;j&lt;=len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i][j]=num[i][j<span class="number">-1</span>]*<span class="number">10</span>+s[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x6f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(ll k=<span class="number">0</span>;k&lt;i;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=num[i-k][i] &amp;&amp; num[i-k][i]&gt;=<span class="number">0</span>)    dp[i][j]=std::<span class="built_in">min</span>(dp[i][j],dp[i-k<span class="number">-1</span>][j-num[i-k][i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[len][n]&gt;=len)     std::cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    std::cout&lt;&lt;dp[len][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2758-编辑距离-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2758">P2758 编辑距离 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">2010</span>][<span class="number">2010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示到a的第i个字符 b的第j个字符 使得a==b 的操作次数</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=min(dp[i-1][j]+1,dp[i][j-1]+1,dp[i-1][j-1]+(a[i]!=b[j]))</span></span><br><span class="line"><span class="comment">//根据题意 初始化dp[i][0]=i,dp[0][j]=j 最基本的情况就是长度为0的情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string a,b;    std::cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    a=<span class="string">&quot;@&quot;</span>+a;</span><br><span class="line">    b=<span class="string">&quot;@&quot;</span>+b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b.<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;b.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j]+<span class="number">1</span>,dp[i][j<span class="number">-1</span>]+<span class="number">1</span>,dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(a[i]!=b[j])&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[a.<span class="built_in">size</span>()<span class="number">-1</span>][b.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1091-NOIP2004-提高组-合唱队形-洛谷-计算机科学教育新生态-luogu-com-cn">[P1091 <a href="https://www.luogu.com.cn/problem/P1091">NOIP2004 提高组] 合唱队形 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">110</span>],g[<span class="number">110</span>];</span><br><span class="line"><span class="comment">//思路不难想 从1-&gt;n 求一遍LIS 再从n-&gt;1 求一遍LIS 枚举位置 就可以求出来了</span></span><br><span class="line"><span class="comment">//dp: 1-&gt;n</span></span><br><span class="line"><span class="comment">//g: 1-&gt;n</span></span><br><span class="line"><span class="comment">//不要忘记单独一个点初始化为1</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])   dp[i]=std::<span class="built_in">max</span>(dp[j]+<span class="number">1</span>,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要使用reverse 否则编号乱了</span></span><br><span class="line">    <span class="comment">//std::reverse(a+1,a+1+n);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j])   g[i]=std::<span class="built_in">max</span>(g[j]+<span class="number">1</span>,g[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]+g[i]<span class="number">-1</span>);<span class="comment">//-1 否则会把自己算重复了</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;n-ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1854-花店橱窗布置-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1854">P1854 花店橱窗布置 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line">ll a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line">ll dp[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//dp[i][j]表示 以前i束花中 前j个花瓶中 可以获得的最大美学价值</span></span><br><span class="line"><span class="comment">//a[i][j]   花束i摆放在花瓶j中的美学值</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i][j],dp[i-1][j-1],dp[i-1][j-2].....dp[i-1][i-1])</span></span><br><span class="line"><span class="comment">void print(ll x,ll y)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(x)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ll p=x;</span></span><br><span class="line"><span class="comment">        while(dp[x][p]!=y)  p++;</span></span><br><span class="line"><span class="comment">        print(x-1,y-a[x][p]);</span></span><br><span class="line"><span class="comment">        std::cout&lt;&lt;p&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void solve()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int f,v;    std::cin&gt;&gt;f&gt;&gt;v;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=f;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=1;j&lt;=v;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            std::cin&gt;&gt;a[i][j];</span></span><br><span class="line"><span class="comment">            dp[i][j]=-2E9;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    dp[0][0]=0;</span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=f;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=i;j&lt;=v;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            //dp[i][j]=std::max(dp[i-1][j-1]+a[i][j],dp[i][j]);</span></span><br><span class="line"><span class="comment">            for(int k=1;k&lt;=j-i+1;k++)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                dp[i][j]=std::max(dp[i][j],dp[i-1][j-k]+a[i][j]);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ll ans=0;</span></span><br><span class="line"><span class="comment">    for(int i=f;i&lt;=v;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        ans=std::max(ans,dp[f][i]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;ans&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">    print(f,ans);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//上面的方法最后一个点WA了 下面的这种方法跟我一开始想的相似 但是有些地方又不太一样</span></span><br><span class="line"><span class="comment">//主要是学习一下如何用记录</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos[<span class="number">110</span>];       <span class="comment">//pos数组记录答案</span></span><br><span class="line">    <span class="type">int</span> p;      <span class="comment">//指针</span></span><br><span class="line">&#125;book[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> f,v;    std::cin&gt;&gt;f&gt;&gt;v;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-127</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=f;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=v;i++)   dp[<span class="number">0</span>][i]=<span class="number">0</span>;     <span class="comment">//最初一朵花都没插 所以是0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=f;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j]&gt;dp[i][j<span class="number">-1</span>])     <span class="comment">//这里的状态转移方程和上面不一样</span></span><br><span class="line">            <span class="comment">//这样理解 dp[i][j-1]表示 第i束花放在第j-1个花瓶可以获得的最大美学价值</span></span><br><span class="line">            <span class="comment">//原来这里可能有花并且摆法更好 也就是 dp[i-1][j-1]+a[i][j]&gt;dp[i][j-1] 那么就要让位了</span></span><br><span class="line">            <span class="comment">//注意下面更新的是dp[i][j]</span></span><br><span class="line">            &#123;</span><br><span class="line">                book[i][j]=book[i<span class="number">-1</span>][j<span class="number">-1</span>];  <span class="comment">//从前一个情况继承过来</span></span><br><span class="line">                book[i][j].pos[++book[i][j].p]=j;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                book[i][j]=book[i][j<span class="number">-1</span>];</span><br><span class="line">                dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[f][v]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=book[f][v].p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;book[f][v].pos[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1833-樱花-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1833">P1833 樱花 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,sth,stm,eth,etm,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    std::cin&gt;&gt;sth&gt;&gt;ch&gt;&gt;stm&gt;&gt;eth&gt;&gt;ch&gt;&gt;etm;</span><br><span class="line">    <span class="type">int</span> tot=eth*<span class="number">60</span>+etm-sth*<span class="number">60</span>-stm;</span><br><span class="line">    std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,c,p;  std::cin&gt;&gt;t&gt;&gt;c&gt;&gt;p;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>)    p=<span class="number">999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=p;j&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            w[++cnt]=j*t;</span><br><span class="line">            v[cnt]=j*c;</span><br><span class="line">            p-=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p)   w[++cnt]=p*t,v[cnt]=p*c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=tot;j&gt;=w[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j-w[i]]+v[i],dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[tot]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2340-USACO03FALL-Cow-Exhibition-G-洛谷-计算机科学教育新生态-luogu-com-cn">[P2340 <a href="https://www.luogu.com.cn/problem/P2340">USACO03FALL] Cow Exhibition G - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="comment">//ll dp[410][410];</span></span><br><span class="line"><span class="type">int</span> s[<span class="number">410</span>],f[<span class="number">410</span>];</span><br><span class="line"><span class="comment">//两个限制条件的背包问题</span></span><br><span class="line"><span class="comment">//一开始的思路是dp[i][j] 表示情商和为i 智商和为j的 所取得的最大值</span></span><br><span class="line"><span class="comment">//但是发现数据范围有负数 并且是1&lt;=n&lt;=400 -1000&lt;=s(f)&lt;=1000</span></span><br><span class="line"><span class="comment">//为了处理这个问题数组会爆炸 所以不行</span></span><br><span class="line"><span class="comment">//换个思路 背包一般是求最大体积下的最大值</span></span><br><span class="line"><span class="comment">//那么我们可以类似设计出 最大智商和下的最大情商和</span></span><br><span class="line"><span class="comment">//dp[i] 表示智商和为i的情况下 可以获得的最大情商和</span></span><br><span class="line"><span class="comment">//为了处理负数的问题 我们可以一开始把智商都加上1000</span></span><br><span class="line"><span class="comment">//所以数组的范围是 400*1000*2=800000</span></span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> cnt[MAXN];</span><br><span class="line"><span class="comment">//状态转移方程 dp[j]=max(dp[j-s[i]]+f[i],dp[j])</span></span><br><span class="line"><span class="comment">//一开始想的是能否把s[i]都加上1000 再转移 但是这样需要记录路径 我自己写挂了</span></span><br><span class="line"><span class="comment">//所以采用题解的方法 干脆把整个数组进行偏移400 * 1000</span></span><br><span class="line"><span class="comment">//还需要注意一点 如果s[i]是负的 那么j-s[i]&gt;j了 这时就得改变for的顺序 改为正序枚举</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;s[i]&gt;&gt;f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-0x3f</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">400000</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">800000</span>;j&gt;=s[i];j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-s[i]]+f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在这里时 傻乎乎的犯了一个错误 这里需要从0开始 不能从400000开始</span></span><br><span class="line">            <span class="comment">//因为智商是有负的 我们只是进行了偏移而已 不能不更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">800000</span>+s[i];j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-s[i]]+f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">400000</span>;i&lt;=<span class="number">800000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=std::<span class="built_in">max</span>(ans,dp[i]+i<span class="number">-400000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4310-绝世好题-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P4310">P4310 绝世好题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示以第i个数为结尾 能够得到的子序列b的最长长度</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i]=dp[j]+1  if(dp[i]&lt;dp[j]+1 &amp;&amp; i&gt;j &amp;&amp; a[i]&amp;a[j]!=0)</span></span><br><span class="line"><span class="comment">// ok TLE一个点 果然还是太侥幸了 修改一下方法</span></span><br><span class="line"><span class="comment">// 其实可以发现 一直更新是非常耗时的 而且每次查询的区间是从1-&gt;i 1-&gt;i+1 1-&gt;i+2 长度 加一</span></span><br><span class="line"><span class="comment">//那么其实我们可以记录当前区间的最大值 然后再i++后 判断新的是否大于原来的dp[i]即可</span></span><br><span class="line"><span class="comment">//不用开数组 直接ans记录 更新即可</span></span><br><span class="line"><span class="comment">//其实这种方法不是正解 明天再补吧 太晚了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i],     dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&gt;ans)   <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]&lt;dp[j]+<span class="number">1</span> &amp;&amp; (a[i]&amp;a[j])!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1004-NOIP2000-提高组-方格取数-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1004">P1004 [NOIP2000 提高组] 方格取数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//dp[i][j][k][l] 表示第一次走到(i,j) 第二次走到(k,l)可以获得的最大价值</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j][k][l]</span></span><br><span class="line"><span class="comment">//由于只能向下或者向右走</span></span><br><span class="line"><span class="comment">//所以一共有四种情况</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j][k][l]=max(dp[i-1][j][k-1][l],dp[i][j-1][k][l-1],dp[i-1][j][k][l-1],dp[i][j-1][k-1][l])+num[i][j]+num[k][l]</span></span><br><span class="line"><span class="comment">//注意 走过了就num[i][j] 其数值变为0 所以需要判重</span></span><br><span class="line"><span class="type">int</span> num[<span class="number">12</span>][<span class="number">12</span>];</span><br><span class="line"><span class="comment">//num数组表示迷宫</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="keyword">while</span>(std::cin&gt;&gt;a&gt;&gt;b&gt;&gt;c &amp;&amp; (a||b||c))</span><br><span class="line">    &#123;</span><br><span class="line">        num[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k][l]=std::<span class="built_in">max</span>(&#123;dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l],dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>],dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>],dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l]&#125;)+num[i][j]+num[k][l];</span><br><span class="line">                    <span class="comment">//判重</span></span><br><span class="line">                    <span class="keyword">if</span>(i==k &amp;&amp; j==l)    dp[i][j][k][l]-=num[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n][n][n][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1541-NOIP2010-提高组-乌龟棋-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P1541">P1541 [NOIP2010 提高组] 乌龟棋 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">360</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i个格子可以获得的最多分数</span></span><br><span class="line"><span class="comment">//dp[i]=max(dp[i],dp[i-1]+a[i],dp[i-2]+a[i],dp[i-3]+a[i],dp[i-4]+a[i])</span></span><br><span class="line"><span class="comment">//发现这个思路是错误的 因为题目中没有将其和方格中的分数绑定在一起</span></span><br><span class="line"><span class="comment">//因为需要考虑牌的数目 所以不妨设dp[a][b][c][d] 依次表示第一种牌 第二种牌 第三第四</span></span><br><span class="line"><span class="comment">//通过枚举牌的数量 可以进行状态转移</span></span><br><span class="line"><span class="type">int</span> mp[<span class="number">6</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        mp[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意一开始的分数就是a[1]</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=4;i++)   std::cout&lt;&lt;mp[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">//std::cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mp[<span class="number">1</span>];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=mp[<span class="number">2</span>];j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=mp[<span class="number">3</span>];k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;=mp[<span class="number">4</span>];l++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> &amp;d=dp[i][j][k][l];</span><br><span class="line">                    <span class="comment">//这里要特别注意加1 因为是从1开始的 要算上1这个开始的格子</span></span><br><span class="line">                    <span class="type">int</span> dis=<span class="number">1</span>*i+<span class="number">2</span>*j+<span class="number">3</span>*k+<span class="number">4</span>*l+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i)   d=std::<span class="built_in">max</span>(d,dp[i<span class="number">-1</span>][j][k][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(j)   d=std::<span class="built_in">max</span>(d,dp[i][j<span class="number">-1</span>][k][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(k)   d=std::<span class="built_in">max</span>(d,dp[i][j][k<span class="number">-1</span>][l]+a[dis]);</span><br><span class="line">                    <span class="keyword">if</span>(l)   d=std::<span class="built_in">max</span>(d,dp[i][j][k][l<span class="number">-1</span>]+a[dis]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[mp[<span class="number">1</span>]][mp[<span class="number">2</span>]][mp[<span class="number">3</span>]][mp[<span class="number">4</span>]];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3147-USACO16OPEN-262144-P-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P3147">P3147 [USACO16OPEN] 262144 P - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4><p>题解链接：<a href="https://www.luogu.com.cn/article/pq62uvcs">题解 P3147 【[USACO16OPEN]262144】</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX=<span class="number">270007</span>;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> std::pair&lt;<span class="type">double</span>,<span class="type">int</span>&gt; pdi;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">61</span>][MAX];</span><br><span class="line"><span class="comment">//真难 这个dp真想不出来</span></span><br><span class="line"><span class="comment">//直接看题解吧</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        dp[x][i]=i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">58</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][dp[i<span class="number">-1</span>][j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j])    ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve3</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2679-NOIP2015-提高组-子串-洛谷-计算机科学教育新生态-luogu-com-cn"><a href="https://www.luogu.com.cn/problem/P2679">P2679 [NOIP2015 提高组] 子串 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></h4>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder DP Contest</title>
      <link href="/posts/a40a9815.html"/>
      <url>/posts/a40a9815.html</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder-DP-Contest">Atcoder DP Contest</h1><p>这里是题单的链接：<a href="https://www.luogu.com.cn/training/244301#problems">AtCoder DP Contest - 题单 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>目前还有些题目没写 后续学完相关知识再补</p><h2 id="A">A</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;h[i];</span><br><span class="line">    <span class="comment">//dp[1]=h[1],不需要初始化dp[1]，本身就是0</span></span><br><span class="line">    dp[<span class="number">2</span>]=<span class="built_in">abs</span>(h[<span class="number">2</span>]-h[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=std::<span class="built_in">min</span>(dp[i<span class="number">-1</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-1</span>]),dp[i<span class="number">-2</span>]+<span class="built_in">abs</span>(h[i]-h[i<span class="number">-2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="B">B</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> h[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//dp[i]记作跳到第i块石头所花费的最小体力</span></span><br><span class="line"><span class="comment">//状态转移方程：</span></span><br><span class="line"><span class="comment">//dp[i]=min(dp[i-1]+abs(h[i]-h[i-1]) dp[i-2]+abs(h[i]-h[i-2])------)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> k;  std::cin&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;h[i],dp[i]=<span class="number">1e15</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dp[2]=abs(h[2]-h[1]);</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=std::<span class="built_in">min</span>(k,i<span class="number">-1</span>);j++)</span><br><span class="line">        dp[i]=std::<span class="built_in">min</span>(dp[i-j]+<span class="built_in">abs</span>(h[i]-h[i-j]),dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C">C</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line">ll dp[MAXN][<span class="number">5</span>];</span><br><span class="line"><span class="comment">//dp[i][j]表示第i天，以第j种活动结束</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//假设j=1</span></span><br><span class="line"><span class="comment">// 1-a 2-b 3-c</span></span><br><span class="line"><span class="comment">//dp[i][1]=max(dp[i-1][2]+a[i],dp[i-1][3]+a[i])</span></span><br><span class="line"><span class="comment">//其他的同理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)std::cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+a[i],dp[i<span class="number">-1</span>][j+<span class="number">2</span>]+a[i]);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">2</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+b[i],dp[i<span class="number">-1</span>][j+<span class="number">1</span>]+b[i]);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">3</span>)dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+c[i],dp[i<span class="number">-1</span>][j<span class="number">-2</span>]+c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;std::<span class="built_in">max</span>(&#123;dp[n][<span class="number">1</span>],dp[n][<span class="number">2</span>],dp[n][<span class="number">3</span>]&#125;)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="D">D</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//最初的想法是三个维度：容量，取到了第i个物品，以及是否取</span></span><br><span class="line"><span class="comment">//是否取对后面的状态转移没有任何影响，所以可以删去</span></span><br><span class="line"><span class="comment">//取到第i个物品的状态转移似乎也没有影响，所以可以删去</span></span><br><span class="line"><span class="comment">//保留容量维度</span></span><br><span class="line"><span class="comment">//dp[i]表示容量为i时，最大价值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> W;  std::cin&gt;&gt;W;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=W;j&gt;=w[i];j--)<span class="comment">//注意要倒序枚举 否则是从更新后的状态转移过来的</span></span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[W]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="E">E</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//一道很有趣的题目</span></span><br><span class="line"><span class="comment">//这道题的范围很大 看了一眼题解区 以为题目修改过 或者 翻译有误</span></span><br><span class="line"><span class="comment">//仔细一想 这道题是从一个新奇的角度分析背包问题</span></span><br><span class="line"><span class="comment">//注意到范围是1e9 即使是一维也无法解决</span></span><br><span class="line"><span class="comment">//要求的还是同样的问题 从另外一个角度入手</span></span><br><span class="line"><span class="comment">//仍然是一维</span></span><br><span class="line"><span class="comment">//dp[i] 表示的是总价值为i时 最小的体积 有点倒反天罡的趣味</span></span><br><span class="line"><span class="comment">//这里取最小值 是因为体积越小 越能容纳更多的物品 总价值也就越大 这是一种贪心的想法</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i]=min(dp[i],dp[i-v[j]]+w[i])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> W;  std::cin&gt;&gt;W;</span><br><span class="line">    <span class="type">int</span> V=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;w[i]&gt;&gt;v[i],V+=v[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=v[i];j--)</span><br><span class="line">            dp[j]=std::<span class="built_in">min</span>(dp[j],dp[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=V;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&lt;=W)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout&lt;&lt;i&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="F">F</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//dp[i][j]表示以s[i] t[j]结尾的最长公共子序列长度</span></span><br><span class="line"><span class="comment">//状态转移方程：dp[i][j]=dp[i-1][j-1]+1 if s[i]==t[j] else max(dp[i-1][j],dp[i][j-1])</span></span><br><span class="line"><span class="comment">//这里注意需要先把字符串加上@，这样才避免预处理时候的麻烦</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string s,t;    std::cin&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>(),m=t.<span class="built_in">length</span>();</span><br><span class="line">    std::string ans=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    s=<span class="string">&quot;@&quot;</span>+s,t=<span class="string">&quot;@&quot;</span>+t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==t[j])  dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用双指针实现</span></span><br><span class="line">    <span class="comment">//如果是正序 无法保证一定是最长的 需要倒序(因为已经知道了最长的长度，可以保证一定是最优的)</span></span><br><span class="line">    <span class="type">int</span> sp=n,tp=m;</span><br><span class="line">    <span class="keyword">while</span>(sp&gt;<span class="number">0</span>&amp;&amp;tp&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[sp]==t[tp])</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=s[sp];</span><br><span class="line">            sp--;tp--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[sp<span class="number">-1</span>][tp]&gt;dp[sp][tp<span class="number">-1</span>])   sp--;</span><br><span class="line">            <span class="keyword">else</span> tp--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(),ans.<span class="built_in">end</span>());</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="G">G</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[MAXN],in[MAXN];</span><br><span class="line"><span class="comment">//dp[i] 表示到第i个节点的最长路径</span></span><br><span class="line"><span class="comment">//状态转移方称 dp[i]=max(dp[j]+1,dp[i]); j为i的父节点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="comment">//记得搜索的顺序和dp是相反的</span></span><br><span class="line"><span class="comment">//dp是由起点-&gt;终点 而dfs是从终点-&gt;起点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for(auto t:edge[x])</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        if(dp[t.to]&lt;dp[t.from]+1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            dp[t.to]=dp[t.from]+1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        dfs(t.to);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//这里写挂了，导致重复dfs了很多次</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新问题</span></span><br><span class="line">    <span class="comment">//这里需要判断一下dp[x]是否为0 否则搜索太多次 也会TLE</span></span><br><span class="line">    <span class="keyword">if</span>(dp[x]==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> t: edge[x]) &#123;</span><br><span class="line">            dp[x] = std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(t.to) + <span class="number">1</span>, dp[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;    std::cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="comment">//in[v]++;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(<span class="built_in">dfs</span>(i),ans);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="H">H</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">char</span> mp[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> h,w;    std::cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)std::cin&gt;&gt;mp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[i][<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mp[<span class="number">1</span>][i]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> dp[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=w;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i<span class="number">-1</span>][j]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=(dp[i<span class="number">-1</span>][j]+dp[i][j<span class="number">-1</span>])%mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j<span class="number">-1</span>]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i<span class="number">-1</span>][j]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=dp[i<span class="number">-1</span>][j]%mod;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mp[i<span class="number">-1</span>][j]==<span class="string">&#x27;#&#x27;</span>&amp;&amp;mp[i][j<span class="number">-1</span>]!=<span class="string">&#x27;#&#x27;</span>)dp[i][j]=dp[i][j<span class="number">-1</span>]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[h][w]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="I">I</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> dp[<span class="number">3010</span>][<span class="number">3010</span>];</span><br><span class="line"><span class="type">double</span> p[<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//dp[i][j] 表示前i枚硬币中 有j枚正面朝上的概率</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=dp[i-1][j-1]*p[i]+dp[i-1][j]*(1-p[i]);</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[0][0]初始化 其他非法状态不考虑</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]*(<span class="number">1</span>-p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]*p[i]+dp[i<span class="number">-1</span>][j]*(<span class="number">1</span>-p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//题目要求的是正&gt;负 看清楚题目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i+i&gt;n;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=dp[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意输出保留10位精度</span></span><br><span class="line">    std::cout&lt;&lt;std::fixed&lt;&lt;std::<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="J">J</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">double</span> dp[<span class="number">310</span>][<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//dp[i][j][k] 表示共有i个盘子中有1个寿司 j个盘子中有2个寿司 k个盘子中有3个寿司</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j][k]=n/(i+j+k)+i/(i+j+k)*dp[i-1][j][k]+j/(i+j+k)*dp[i+1][j-1][k]</span></span><br><span class="line"><span class="comment">//+k/(i+j+k)*dp[i][j+1][k-1]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> all=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;  std::cin&gt;&gt;x;</span><br><span class="line">        m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里需要注意以下枚举的顺序</span></span><br><span class="line">    <span class="comment">//先枚举有3个寿司的盘子 再枚举有2个寿司的盘子 再枚举有一个寿司的盘子</span></span><br><span class="line">    <span class="comment">//因为寿司多的盘子 其寿司数目会减少 影响寿司少的盘子的情况</span></span><br><span class="line">    <span class="comment">//如果是1-&gt;2-&gt;3的顺序枚举 有一些更新的状态就没有参与到dp中了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i||j||k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j][k]=(<span class="type">double</span>)n/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(i)dp[i][j][k]+=i*dp[i<span class="number">-1</span>][j][k]/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(j)dp[i][j][k]+=j*dp[i+<span class="number">1</span>][j<span class="number">-1</span>][k]/(i+j+k);</span><br><span class="line">                    <span class="keyword">if</span>(k)dp[i][j][k]+=k*dp[i][j+<span class="number">1</span>][k<span class="number">-1</span>]/(i+j+k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全部盘子都收集完了</span></span><br><span class="line">    std::cout&lt;&lt;std::fixed&lt;&lt;std::<span class="built_in">setprecision</span>(<span class="number">10</span>)&lt;&lt;dp[m[<span class="number">1</span>]][m[<span class="number">2</span>]][m[<span class="number">3</span>]]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="K">K</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//属于博弈论的dp</span></span><br><span class="line"><span class="comment">//dp[i] 表示到第i个石子的时候 当前者的胜负</span></span><br><span class="line"><span class="comment">//当i==0 f[0]=0;</span></span><br><span class="line"><span class="comment">//顺序推导 求出f[n]即可判断胜负</span></span><br><span class="line"><span class="comment">//认识到一个点 如果当前是必败态 那么它必然是从必胜态转移过来的</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i]+=!dp[i-a[j]] 注意这里是|或者+运算 因为可能是从多个状态转移过来的 只要有一种胜利即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//很有Nim博弈的味道 DAG推导</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;    std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]|=!dp[i-a[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;(dp[k]?<span class="string">&quot;First&quot;</span>:<span class="string">&quot;Second&quot;</span>)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="L">L</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">3010</span>];</span><br><span class="line">ll dp[<span class="number">3010</span>][<span class="number">3010</span>],sum[<span class="number">3010</span>];</span><br><span class="line"><span class="comment">//这道题目有合并的性质 所以我们可以考虑使用区间dp</span></span><br><span class="line"><span class="comment">//dp[i][j]表示 从i到j区间内 first的最大分数</span></span><br><span class="line"><span class="comment">//由于这是一道博弈论问题 所以需要从对手的状态转移过来</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(sum[i+1][j]-dp[i+1][j]+a[i],sum[i][j-1]-dp[i][j-1]+a[j])</span></span><br><span class="line"><span class="comment">//sum[i][j] 表示从i到j之间的区间和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        dp[i][i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=std::<span class="built_in">max</span>(sum[j]-sum[i]-dp[i+<span class="number">1</span>][j]+a[i],sum[j<span class="number">-1</span>]-sum[i<span class="number">-1</span>]-dp[i][j<span class="number">-1</span>]+a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;-(sum[n]<span class="number">-2</span>*dp[<span class="number">1</span>][n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="M">M</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">ll dp[MAXN],sum[MAXN];</span><br><span class="line"><span class="comment">//dp[i]表示前i颗糖分完的方案数</span></span><br><span class="line"><span class="comment">//dp[i]+=dp[i-(1,2,---a[j])]</span></span><br><span class="line"><span class="comment">//sum[i]是dp[i] dp[i-1] dp[i-2]-----的前缀和 否则会TLE</span></span><br><span class="line"><span class="comment">//所以就优化为dp[i]=sum[i]-sum[i-a[j]-1]</span></span><br><span class="line"><span class="comment">//需要注意的是i可能&lt;=a[j] 所以dp[i]=sum[i]了 注意分类讨论</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其实直接比较好想的是dp[i][j] 表示前i个人分了j个糖果的情况 但是自己当时脑回路清奇 直接把第一维压缩了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;  std::cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[<span class="number">0</span>]=dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[j]=(sum[j<span class="number">-1</span>]+dp[j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;a[i])dp[j]=(sum[j]-sum[j-a[i]<span class="number">-1</span>]+mod)%mod;</span><br><span class="line">            <span class="keyword">else</span> dp[j]=sum[j]%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[k]%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="N">N</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">4010</span>];</span><br><span class="line">ll dp[<span class="number">4010</span>][<span class="number">4010</span>],sum[<span class="number">4010</span>];</span><br><span class="line"><span class="comment">//一道经典的区间dp题目</span></span><br><span class="line"><span class="comment">//dp[i][j]表示合并成区间[i,j]所需要的最大代价</span></span><br><span class="line"><span class="comment">//状态转移方程</span></span><br><span class="line"><span class="comment">//[i,j]可以由[i,k],[k,j]合并得到 所以需要枚举k</span></span><br><span class="line"><span class="comment">//除了本身的代价外 还有[i,j]的区间和</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i][k]+dp[k][j]+sum[j]-sum[i-1],dp[i][j])</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        dp[i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//区间dp三个步骤</span></span><br><span class="line">    <span class="comment">//枚举长度</span></span><br><span class="line">    <span class="comment">//枚举起点</span></span><br><span class="line">    <span class="comment">//枚举分段点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+l<span class="number">-1</span>&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i+l<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">//注意枚举的分段点是从i开始 但是要小于j,否则有可能k+1&gt;j越界</span></span><br><span class="line">            <span class="comment">//原来一开始是写k=i+1 但是实际上可以是由一个数加上一个区间的合并</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=std::<span class="built_in">min</span>(dp[i][k]+dp[k+<span class="number">1</span>][j]+sum[j]-sum[i<span class="number">-1</span>],dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[<span class="number">1</span>][n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="O">O</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//ll dp[25][MAXN];</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="comment">//一道状态压缩dp 涉及到二分图匹配</span></span><br><span class="line"><span class="comment">//为什么会用到状压呢? 这是个二分图匹配问题 涉及集合 所以可能想到用状压 另一方面就是n比较小</span></span><br><span class="line"><span class="comment">//dp[i][j]表示前i个男生 到由若干个女生构成的集合j中 一一匹配的方案数</span></span><br><span class="line"><span class="comment">//状态转移方程 dp[i][j]=dp[i][j]+dp[i-1][j-k]  (j-k)表示j中去掉元素k</span></span><br><span class="line"><span class="comment">//状压dp一般下标从0开始 方便位运算(这里就是a[i][j]中i j下标从0开始)</span></span><br><span class="line"><span class="comment">//遇到一个奇怪的问题 第二维度开太小了 应该是RE才对 结果却是WA</span></span><br><span class="line"><span class="comment">//猜测越位哪些被忽略了 从而导致答案错误</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[MAXN];</span><br><span class="line"><span class="comment">//考虑优化 第一维可以省略</span></span><br><span class="line"><span class="comment">//优化后 dp[i]=dp[i]+dp[i-k] 含义一样</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void solve1()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    int n;  std::cin&gt;&gt;n;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;n;j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            std::cin&gt;&gt;a[i][j];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    dp[0][0]=1;</span></span><br><span class="line"><span class="comment">    for(int i=0;i&lt;n;i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        for(int j=0;j&lt;(1&lt;&lt;n);j++)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            if(__builtin_popcount(j)==i)</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                for(int k=0;k&lt;n;k++)</span></span><br><span class="line"><span class="comment">                &#123;</span></span><br><span class="line"><span class="comment">                    if(a[i][k]&amp;&amp;(j&amp;(1&lt;&lt;k))==0)</span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        dp[i+1][j|(1&lt;&lt;k)]=(dp[i][j]+dp[i+1][j|(1&lt;&lt;k)])%mod;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    std::cout&lt;&lt;dp[n][(1&lt;&lt;n)-1]&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt=__builtin_popcount(i);</span><br><span class="line">        <span class="comment">//原来是__builtin_popcount(j)==i 枚举i 看i与j是否完全配对</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[cnt][j]&amp;&amp;(i&amp;(<span class="number">1</span>&lt;&lt;j))==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i|(<span class="number">1</span>&lt;&lt;j)]=(dp[i|(<span class="number">1</span>&lt;&lt;j)]+dp[i])%mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P">P</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">std::vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">ll dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//vis 其实跟记忆化搜索差不多</span></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="comment">//dp[i][0] 表示以第i号节点为根节点且第i号节点为白色时的方案数</span></span><br><span class="line"><span class="comment">//dp[i][1] 表示以第i号节点为根节点且第i号节点为黑色时的方案数</span></span><br><span class="line"><span class="comment">//dp[i][0]*=dp[j][0]+dp[j][1] 其中j指的是i的子节点</span></span><br><span class="line"><span class="comment">//dp[i][1]*=dp[j][0]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e.to;</span><br><span class="line">        <span class="keyword">if</span>(vis[y])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//注意的先vis标记 否则有些情况会重复计算</span></span><br><span class="line">        vis[y]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        dp[x][<span class="number">0</span>]*=(dp[y][<span class="number">0</span>]+dp[y][<span class="number">1</span>]);</span><br><span class="line">        dp[x][<span class="number">0</span>]%=mod;</span><br><span class="line">        dp[x][<span class="number">1</span>]*=dp[y][<span class="number">0</span>];</span><br><span class="line">        dp[x][<span class="number">1</span>]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//没有确定根节点 所以建立双向边 首先遍历到的就是父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;    std::cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line">        <span class="built_in">add</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这样 我们就可以默认1为根节点 直接dfs即可</span></span><br><span class="line">    vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(dp[<span class="number">1</span>][<span class="number">0</span>]+dp[<span class="number">1</span>][<span class="number">1</span>])%mod;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Q">Q</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll dp[MAXN];</span><br><span class="line">ll be[<span class="number">1010</span>];   <span class="comment">//表示区间i的最大值</span></span><br><span class="line">ll b[MAXN];    <span class="comment">//单个元素dp[i]的max</span></span><br><span class="line"><span class="comment">//dp[i] 表示以第i个元素为结尾 可以得到的最大权值</span></span><br><span class="line"><span class="comment">//dp[i]=max(dp[j])+a[i] (1&lt;h[j]&lt;h[i])</span></span><br><span class="line"><span class="comment">//由于区间范围较大 所以需要优化一下 这里用分块</span></span><br><span class="line"><span class="comment">//因为是从1开始 所以前面直接枚举块 后面枚举零散的元素即可</span></span><br><span class="line"><span class="comment">//更新的时候 因为是单点更新 所以对应的点更新(记作A) 块也要更新(后面的元素寻找max时 A是在块中)</span></span><br><span class="line"><span class="comment">//总结一点 点要更新 所在的块也要更新</span></span><br><span class="line"><span class="type">int</span> h[MAXN],a[MAXN];</span><br><span class="line"><span class="type">int</span> block;  <span class="comment">//块长</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x]=std::<span class="built_in">max</span>(b[x],y);</span><br><span class="line">    be[x/block+<span class="number">1</span>]=std::<span class="built_in">max</span>(be[x/block+<span class="number">1</span>],y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r/block;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,be[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r/block*block;i&lt;=r;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    block=std::<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;h[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="built_in">query</span>(h[i]<span class="number">-1</span>)+a[i];</span><br><span class="line">        <span class="built_in">update</span>(h[i],dp[i]);</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="R">R</h2><p>没写</p><h2 id="S">S</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> a[<span class="number">10010</span>],dp[<span class="number">10010</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//dp[pos][sum][limit][lead]</span></span><br><span class="line"><span class="comment">//pos limit lead 含义不变</span></span><br><span class="line"><span class="comment">//sum 表示到当前位时的各位数字之和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原来一开始MLE了 最先优化 考虑删除掉 lead维度 但是还是有2个点WA了</span></span><br><span class="line"><span class="comment">//应该是出现了负数 最后结果加上mod 再取模即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以再进一步优化</span></span><br><span class="line"><span class="comment">//dp[pos][sum][limit]</span></span><br><span class="line"><span class="comment">//pos limit 含义不变</span></span><br><span class="line"><span class="comment">//sum 表示到当前位时的各位数字之和 </span></span><br><span class="line"><span class="comment">//考虑到D的范围是从0-100 所以其实sum的范围最大到100多即可 这里110</span></span><br><span class="line"><span class="type">int</span> cnt,D;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> sum,<span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;d=dp[pos][sum][limit];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos==cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum%D==<span class="number">0</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d!=<span class="number">-1</span>)   <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=(limit?a[pos]:<span class="number">9</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">dfs</span>(pos+<span class="number">1</span>,(sum+i)%D,limit &amp;&amp; i==a[pos]);</span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    d=ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string k;</span><br><span class="line">    std::cin&gt;&gt;k&gt;&gt;D;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[cnt++]=k[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for(int i=0;i&lt;cnt;i++)  std::cout&lt;&lt;a[i];</span></span><br><span class="line">    std::cout&lt;&lt;(<span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>)<span class="number">-1</span>+mod)%mod&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="T">T</h2><p>没写</p><h2 id="U">U</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line">ll a[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//这是一道状压dp问题</span></span><br><span class="line"><span class="comment">//怎么看出来 1 n范围小 2 涉及到集合处理的问题</span></span><br><span class="line"><span class="comment">//但我对状压还是不太熟悉 所以还是看题解了 关键还是怎么枚举集合 进行位运算</span></span><br><span class="line"><span class="comment">//不难想到状态转移方为 dp[i]=max(dp[i],dp[j]+dp[k])   这里的i j k就表示集合</span></span><br><span class="line"><span class="comment">//j 和 k 是i的子集 其实有点像之前的二分图dp 感觉处理方式都是一样的 分成不同的集合来进行处理</span></span><br><span class="line"><span class="comment">// 难点是进行位运算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cin&gt;&gt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预处理</span></span><br><span class="line">    <span class="comment">// i枚举集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举 存在两边的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=j+<span class="number">1</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//判断是否存在连边</span></span><br><span class="line">                <span class="keyword">if</span>((i&gt;&gt;j)&amp;<span class="number">1</span> &amp;&amp; (i&gt;&gt;k)&amp;<span class="number">1</span>)    dp[i]+=a[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父集合</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//枚举子集和</span></span><br><span class="line">        <span class="comment">//j=(j-1)&amp;i 这样可以保证j是越来越小的 且是i的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j;j=(j<span class="number">-1</span>)&amp;i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=std::<span class="built_in">max</span>(dp[i],dp[j]+dp[i^j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="V">V</h2><p>没写</p><h2 id="W">W</h2><p>没写</p><h2 id="X">X</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    ll w,s,v;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp;b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w+s&lt;b.w+b.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">1010</span>];</span><br><span class="line">ll dp[MAXN];</span><br><span class="line"><span class="comment">//01背包 + 贪心</span></span><br><span class="line"><span class="comment">//对背包有了新的理解 限重可以抽象为当前背包的某个限制条件</span></span><br><span class="line"><span class="comment">//一开始在考虑怎么处理 限重的问题</span></span><br><span class="line"><span class="comment">//采用的是贪心的思路 如果两个货物i j 在题它们上面 想要堆叠更多的物品 不难想到 si-wj&lt;sj-wi</span></span><br><span class="line"><span class="comment">//这样可以保证可以堆叠更多的物品 转换得到 si+wi&lt;sj+wj</span></span><br><span class="line"><span class="comment">//那么可以这样处理</span></span><br><span class="line"><span class="comment">//原本的dp[i][j]方程表示的是 dp[i][j]表示前i个物品中 s+w为j时能得到的最大价值</span></span><br><span class="line"><span class="comment">//考虑优化 那么i维度就可以删去 --&gt; dp[j]</span></span><br><span class="line"><span class="comment">//状态转移方程基本一致 dp[j]=max(dp[j],dp[j-a[i].s]+a[i].v) 注意倒序枚举</span></span><br><span class="line"><span class="comment">//还需要注意j 不是枚举最大的MAX 而是当前箱子的w+s 并不是一开始能够容纳的上限就是最大的 而是所枚举的箱子的MAX</span></span><br><span class="line"><span class="comment">//之前的背包的上限是一个固定值 是唯一且确定的 但这个不是 根据箱子的枚举而改变MAX</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  std::cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)   std::cin&gt;&gt;a[i].w&gt;&gt;a[i].s&gt;&gt;a[i].v;</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line">    <span class="comment">//memset(dp,-0x3f3f3f3f,sizeof(dp));</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    ll MAX=a[n].s+a[n].w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(ll j=a[i].w+a[i].s;j&gt;=a[i].w;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=std::<span class="built_in">max</span>(dp[j-a[i].w]+a[i].v,dp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//补充一点 这里还需要取max</span></span><br><span class="line">    <span class="comment">//原本的普通背包是不用的</span></span><br><span class="line">    <span class="comment">//这里wsm需要? </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=MAX;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//std::cin&gt;&gt;t;</span></span><br><span class="line">    <span class="keyword">while</span>(t--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Y">Y</h2><p>没写</p><h2 id="Z">Z</h2><p>没写</p>]]></content>
      
      
      <categories>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博弈论研究</title>
      <link href="/posts/802170ef.html"/>
      <url>/posts/802170ef.html</url>
      
        <content type="html"><![CDATA[<h1 id="博弈论研究">博弈论研究</h1><p>前置知识这里不会细讲，可以看看这几位大佬的博客和文章，感觉讲得很好。</p><p>记住这句话，“<strong>每个必胜的状态都是从对手的上个必败状态推来的，必败也是同理。</strong>”。</p><p><a href="https://zhuanlan.zhihu.com/p/257013159">算法学习笔记(51): SG函数 - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/flashhu/p/8665204.html">博弈论总结（只会打表，永不证明）（博弈论） - Flash_Hu - 博客园 (cnblogs.com)</a></p><p><a href="https://www.luogu.com.cn/article/zvs3dsbt">题解 P2197 【【模板】nim游戏】 - 洛谷专栏 (luogu.com.cn)</a></p><p><a href="https://blog.csdn.net/A_Comme_Amour/article/details/79347291">[学习笔记]（博弈论）Nim游戏和SG函数_nim博弈-CSDN博客</a></p><p><a href="https://www.luogu.com.cn/article/shyocttb">浅谈SG函数和博弈论 - 洛谷专栏 (luogu.com.cn)</a></p><p><a href="https://blog.csdn.net/strangedbly/article/details/51137432">博弈论 SG函数_a1 ^ a2 ^ … ^ an != 0-CSDN博客</a></p><hr><p>这里先用$Nim$博弈引入：<a href="https://www.luogu.com.cn/problem/P2197">P2197 【模板】Nim 游戏 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>我们设计当$SG(x)=0$时，$x$为必败态，相反，$x$为必胜态。</p><p>对于单堆的$Nim$游戏，我们可以计算出$SG$值，$SG(x)$表示剩余石子数为$x$的状态值。</p><p>根据$SG$函数的定义：$SG(x)=mex((SG(y)|x-&gt;y))$,$mex$表示一个集合中未出现的最小自然数。</p><p>不难得到，我们可以得到：$SG(1)=1、SG(2)=2、SG(3)=3······SG(n)=n$。(从$SG(0)=0$递推过来)。</p><p>利用$SG$定理，我们可以将多个堆的状态转移到一个堆的状态，直接异或起来就行了。</p><p>参考代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 22635 on 2024/2/9.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        ans^=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题计划</title>
      <link href="/posts/2a942d0f.html"/>
      <url>/posts/2a942d0f.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ABC070</title>
      <link href="/posts/4ce1f198.html"/>
      <url>/posts/4ce1f198.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC070">ABC070</h1><blockquote><h1 id="ABC070B-Two-Switches">[ABC070B] Two Switches</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>Alice和Bob都有一个开关用来控制机器人。<br>Alice在A秒按下开关，移动机器人，并在B秒后释放开关。</p><p>Bob在C秒按下开关，移动机器人，并在D秒后释放开关。</p><p>求Alice和Bob都按下开关的秒数。</p><h2 id="输入格式">输入格式</h2><p>一行，有四个正整数A，B，C，D。分别代表Alice在第A秒按下开关，在第B秒释放开关。Bob在第C秒按下开关，在第D秒释放开关。</p><h2 id="输出格式">输出格式</h2><p>输出Alice和Bob都按下开关的秒数</p><h2 id="题目描述-2">题目描述</h2><p>Alice と Bob は、ロボットを制御するためのスイッチを1つずつ持っており、ロボットを動かしています。<br>Alice はロボットを動かし始めて $ A $ 秒後にスイッチを押し始め、ロボットを動かし始めて $ B $ 秒後にスイッチを離しました。<br>Bob はロボットを動かし始めて $ C $ 秒後にスイッチを押し始め、ロボットを動かし始めて $ D $ 秒後にスイッチを離しました。<br>Alice と Bob が、二人ともスイッチを押していた秒数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $ $ D $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>Alice と Bob が二人ともスイッチを押していた秒数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 75 25 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 33 66 99</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 90 20 80</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 0≦A\ &lt;\ B≦100 $</li><li>$ 0≦C\ &lt;\ D≦100 $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>ロボットを動し始めて $ 0 $ 秒後から $ 75 $ 秒後までの間、Alice はスイッチを押していました。 一方、ロボットを動し始めて $ 25 $ 秒後から $ 100 $ 秒後までの間、Bob はスイッチを押していました。 したがって、二人が同時にスイッチを押していた時間は、ロボットを動し始めて $ 25 $ 秒後から $ 75 $ 秒後までの $ 50 $ 秒です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>Alice と Bob が同時にスイッチを押していないので、答えは $ 0 $ 秒です。</p></blockquote><h2 id="思路">思路</h2><p>计算重合部分即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="type">int</span> x=<span class="built_in">max</span>(a,c);</span><br><span class="line">    <span class="type">int</span> y=<span class="built_in">min</span>(b,d);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">max</span>(y-x,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC070C-Multiple-Clocks">[ABC070C] Multiple Clocks</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>有N台钟表，第i个钟表的秒针经过T[i]秒绕表盘一周。最初，所有的钟表的秒针都指向上方。某人开始同时顺时针拨动所有时钟的秒针。下一次所有的时钟的秒针都向上是在几秒后？</p><h2 id="输入">输入</h2><p>第一行：N；</p><p>以下N行：每行一个T[i]。</p><h2 id="输出">输出</h2><p>一行，最少的拨动次数。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 台の時計があり、$ i(1≦i≦N) $ 番目の時計の針はちょうど $ T_i $ 秒で時計盤を $ 1 $ 周します。<br>最初、全ての時計の針は真っ直ぐ上に向いており、止まっています。<br>イルカは、全ての時計の針を同時に動かし始めました。<br>再び、全ての時計の針が真っ直ぐ上に向くのは何秒後でしょうか?</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ : $ $ T_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>時計の針を動かし始めてから、再び全ての時計の針が真っ直ぐ上に向くまでの秒数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">1000000000000000000</span><br><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦100 $</li><li>$ 1≦T_i≦10^{18} $</li><li>入力は全て整数である。</li><li>答えは $ 10^{18} $ 秒以内である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 2 $ つの時計があり、各時計の針が真っ直ぐ上に向くのは以下の時刻です。 - $ 1 $ 番目の時計の針: 時計の針を動かし始めてから、$ 2 $ 秒後、$ 4 $ 秒後、$ 6 $ 秒後、$ … $ - $ 2 $ 番目の時計の針: 時計の針を動かし始めてから、$ 3 $ 秒後、$ 6 $ 秒後、$ 9 $ 秒後、$ … $ したがって、$ 2 $ つの時計の針が真っ直ぐ上に向くのにかかる秒数は $ 6 $ 秒となります。</p></blockquote><h2 id="思路-2">思路</h2><p>比较容易发现，其实要求的是所有$t$的最小公倍数。</p><p>直接利用$lcm(n,m)=\frac{n*m}{gcd(n,m)}$即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ull t[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ull ans=t[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans=(ans/__gcd(ans,t[i]))*t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC070D-Transit-Tree-Path">[ABC070D] Transit Tree Path</h1><h2 id="题面翻译-3">题面翻译</h2><p>给出一棵有N个结点的树，给出Q个询问，求结点xj过结点K到节点yj的最短距离</p><h2 id="题目描述-5">题目描述</h2><p>$ N $ 頂点の木が与えられます。<br>木とはグラフの一種であり、頂点の数を $ N $ とすると、辺の数が $ N-1 $ 本である閉路のない連結グラフです。<br>$ i(1≦i≦N-1) $ 番目の辺は 頂点 $ a_i $ と 頂点 $ b_i $ を距離 $ c_i $ で結びます。</p><p>また、$ Q $ 個の質問クエリと整数 $ K $ が与えられます。</p><ul><li>$ j(1≦j≦Q) $ 番目の質問クエリでは、頂点 $ x_j $ から 頂点 $ K $ を経由しつつ、頂点 $ y_j $ まで移動する場合の最短経路の距離を求めてください。</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ b_1 $ $ c_1 $ $ : $ $ a_{N-1} $ $ b_{N-1} $ $ c_{N-1} $ $ Q $ $ K $ $ x_1 $ $ y_1 $ $ : $ $ x_{Q} $ $ y_{Q} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>質問クエリの解答を $ Q $ 行出力せよ。<br>$ j(1≦j≦Q) $ 行目には、$ j $ 番目のクエリの答えを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 4 1</span><br><span class="line">3 5 1</span><br><span class="line">3 1</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3</span><br><span class="line">1 4 5</span><br><span class="line">1 5 7</span><br><span class="line">1 6 9</span><br><span class="line">1 7 11</span><br><span class="line">3 2</span><br><span class="line">1 3</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">14</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 1000000000</span><br><span class="line">2 3 1000000000</span><br><span class="line">3 4 1000000000</span><br><span class="line">4 5 1000000000</span><br><span class="line">5 6 1000000000</span><br><span class="line">6 7 1000000000</span><br><span class="line">7 8 1000000000</span><br><span class="line">8 9 1000000000</span><br><span class="line">9 10 1000000000</span><br><span class="line">1 1</span><br><span class="line">9 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17000000000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 3≦N≦10^5 $</li><li>$ 1≦a_i,b_i≦N\ (1≦i≦N-1) $</li><li>$ 1≦c_i≦10^9\ (1≦i≦N-1) $</li><li>与えられるグラフは木である。</li><li>$ 1≦Q≦10^5 $</li><li>$ 1≦K≦N $</li><li>$ 1≦x_j,y_j≦N\ (1≦j≦Q) $</li><li>$ x_j≠y_j\ (1≦j≦Q) $</li><li>$ x_j≠K,y_j≠K\ (1≦j≦Q) $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>与えられた $ 3 $ つの質問クエリに対する最短経路は以下の通りです。 - $ 1 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 4 $ : 距離 $ 1+1+1=3 $ - $ 2 $ つ目の質問クエリ: 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ : 距離 $ 1+1=2 $ - $ 3 $ つ目の質問クエリ: 頂点 $ 4 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ → 頂点 $ 5 $ : 距離 $ 1+1+1+1=4 $</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>質問クエリに対する最短経路は、必ず頂点 $ K=2 $ を通過する必要があります。</p></blockquote><h2 id="思路-3">思路</h2><p>从$x$节点经过$k$节点到$y$节点的方法分为两步：</p><p>1、从$x$节点走到$k$节点。</p><p>2、从$k$节点走到$y$节点。</p><p>只需要从$k$出发，跑一遍最短路即可，答案就是$dis[x]+dis[y]$。</p><p>涉及$m$次询问，直接离线处理。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll n,m,k;</span><br><span class="line">ll dis[MAXN],inq[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll from,to,val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ll from,ll to,ll val)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to,val&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用spfa求最短路</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        dis[i]=<span class="number">1e18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[k]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;ll&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(k);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> from=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[from]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[from])&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[t.to]&gt;dis[from]+t.val)&#123;</span><br><span class="line">                dis[t.to]=dis[from]+t.val;</span><br><span class="line">                <span class="keyword">if</span>(inq[t.to]==<span class="number">0</span>)&#123;</span><br><span class="line">                    inq[t.to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t.to);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ll x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">        <span class="built_in">add</span>(y,x,z);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        ll x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;dis[x]+dis[y]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC067</title>
      <link href="/posts/cb9e557a.html"/>
      <url>/posts/cb9e557a.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC067">ABC067</h1><blockquote><h1 id="ABC067B-Snake-Toy">[ABC067B] Snake Toy</h1><h2 id="题面翻译">题面翻译</h2><p>输入n个数，输出前k大的数的总和</p><h2 id="题目描述">题目描述</h2><p>すぬけくんは $ N $ 本の棒を持っています。 $ i $ 番目の棒の長さは $ l_i $ です。</p><p>すぬけくんは $ K $ 本の棒を選んでつなげて、ヘビのおもちゃを作りたいです。</p><p>ヘビのおもちゃの長さは選んだ棒たちの長さの総和で表されます。 ヘビのおもちゃの長さとしてありうる長さのうち、最大値を求めなさい。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ l_1 $ $ l_2 $ $ l_3 $ $ … $ $ l_{N} $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 14</span><br><span class="line">50 26 27 21 41 7 42 35 7 5 5 36 39 1 45</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">386</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ K\ \leq\ N\ \leq\ 50 $</li><li>$ 1\ \leq\ l_i\ \leq\ 50 $</li><li>$ l_i $ は整数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>長さ $ 3,4,5 $ の棒を選んでつなげると、長さ $ 12 $ のヘビのおもちゃを作ることが可能で、これがありうる長さのうち最大の値です。</p></blockquote><h2 id="思路">思路</h2><p>直接用优先队列即可解决。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll l[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;&gt; q;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;l[i];</span><br><span class="line">        q.<span class="built_in">push</span>(l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        ans+=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC067C-Splitting-Pile">[ABC067C] Splitting Pile</h1><h2 id="题面翻译-2">题面翻译</h2><p>小狸和浣熊制作了 $N$ 张卡，并堆积成山。卡片山上第 $i$ 张卡片上写着整数 $a_i$。<br>小狸和浣熊决定分享 $N$ 张卡。小狸从卡片山上取了几张卡片后，浣熊会把剩下的全部卡片都取出来。此时，无论是小狸还是浣熊都必须取得 $1$ 张以上的卡。<br>如果小狸和浣熊所持有的卡片上写着的数的总和分别为 $x, y$。求出 $|x - y|$ 中可能值的最小值。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんとアライグマは $ N $ 枚のカードの山を作りました。カードの山の上から $ i $ 番目のカードには整数 $ a_i $ が書かれています。</p><p>$ N $ 枚のカードを分け合うことにしました。 すぬけくんがカードの山の上から何枚かのカードを取ったあと、アライグマは残ったカード全てを取ります。 このとき、すぬけくんもアライグマも $ 1 $ 枚以上のカードを取る必要があります。</p><p>すぬけくんとアライグマが持っているカードに書かれた数の総和をそれぞれ $ x,y $ として、$ |x-y| $ を最小化したいです。 $ |x-y| $ としてありうる値の最小値を求めなさい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_{N} $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">10 -10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ \leq\ N\ \leq\ 2\ \times\ 10^5 $</li><li>$ -10^{9}\ \leq\ a_i\ \leq\ 10^{9} $</li><li>$ a_i $ は整数</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>すぬけくんが上から $ 4 $ 枚のカードを、アライグマが残った $ 2 $ 枚のカードを取ったとき、$ x=10,y=11 $ となって、$ |x-y| $ は $ 1 $ となり、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>すぬけくんは上から $ 1 $ 枚のカードを、アライグマは残った $ 1 $ 枚を取るしかありえません。このとき $ x=10,y=-10 $ となって、$ |x-y| $ は $ 20 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>直接用前缀和即可解决。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum[n]<span class="number">-2</span>*sum[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC067D-Fennec-VS-Snuke">[ABC067D] Fennec VS. Snuke</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>$Fennec$ 和 $Snuke$ 正在玩棋盘游戏。</p><p>在这个游戏中，有 $n$ 个格子和 $n-1$ 条道路， 编号为 $a_i$ 和 $b_i$ 的格子通过第 $i$ 条边相连。这些格子和边组成了一棵树。</p><p>第 $1$ 个格子是黑色，第 $n$ 个格子是白色，其他格子没有颜色。先手 $Fennec$ 和后手 $Snuke$ 交替给格子涂色，两人依次执行以下操作：</p><p>$Fennec$：将一个与黑色格子相邻且未被涂色的格子涂成黑色。</p><p>$Snuke$：将一个与白色格子相邻且未被涂色的格子涂成白色。</p><p>如果当前行动的玩家无法涂色，他将输掉游戏。请你写一个程序，判断当 $Fennec$ 和 $Snuke$ 都采取最佳策略时，谁能获胜。</p><h2 id="输入格式-3">输入格式</h2><p>第一行一个整数 $n\ \ (2 ≤n≤1e5)$</p><p>接下来 $n-1$行，每行两个整数 $a_i$ 和 $b_i$，表示 $a_i$ 和 $b_i$ 间有一条边 $(1≤a_i ,b_i ≤n)$</p><h2 id="输出格式-3">输出格式</h2><p>若 Fennec 获胜，输出“Fennec”，否则输出“Snuke”（不包含引号）</p><h2 id="题目描述-4">题目描述</h2><p>フェネックとすぬけくんがボードゲームで遊んでいます。</p><p>このボードゲームには $ 1 $ 番から $ N $ 番までの番号がついた $ N $ 個のマスと、マスどうしをつなぐ $ N-1 $ 本の道が存在しています。 $ a_i $ 番のマスと $ b_i $ 番のマスは $ i $ 番目の道を介して隣り合っています。どの $ 2 $ つのマスも隣接するマスをいくつか辿って必ず辿り着くことが可能です。すなわち、グラフ理論の言葉を用いると、マスと道から構成されるグラフは木です。</p><p>はじめに $ 1 $ 番のマスは黒く、$ N $ 番のマスは白く塗られています。その他のマスはまだ色が塗られていません。 先手のフェネックと後手のすぬけくんは残りのマスに交互に色を塗ります。 自分の手番において、$ 2 $ 人はそれぞれ以下のような行動を行います。</p><ul><li>フェネック：<strong>黒く</strong> 塗られたマスに隣接したマスであって、色が塗られていないマスを $ 1 $ つ選んで <strong>黒く</strong> 塗る。</li><li>すぬけくん：<strong>白く</strong> 塗られたマスに隣接したマスであって、色が塗られていないマスを $ 1 $ つ選んで <strong>白く</strong> 塗る。</li></ul><p>手番のプレイヤーがマスに色を塗ることができなかったとき、敗者となります。フェネックとすぬけくんが最適に行動したとき勝者はどちらか判定してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ b_1 $ $ : $ $ a_{N-1} $ $ b_{N-1} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>勝者がフェネックならば <code>Fennec</code> と、すぬけくんならば <code>Snuke</code> と出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">3 6</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">7 4</span><br><span class="line">5 7</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fennec</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 4</span><br><span class="line">4 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Snuke</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ \leq\ N\ \leq\ 10^5 $</li><li>$ 1\ \leq\ a_i,\ b_i\ \leq\ N $</li><li>与えられるグラフは木</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>例えばフェネックがはじめに $ 2 $ 番のマスを黒く塗ると、すぬけくんがどのようにマスを白く塗ったとしてもフェネックが勝者となります。</p></blockquote><h2 id="思路-3">思路</h2><p>$dfs$。</p><p>不难想到最优的策略，就是围追堵截对方的路。</p><p>对于某一个点，我们可以统计黑棋和白棋到该点所需要的步数，如果黑棋距离更近，那么黑棋可以先占领，否则，则白棋占领，注意到黑棋具有先手优势，如果两者到该点的点数相等，还是黑棋先占领。</p><p>我们只需要$dfs$算出两者到每一个点的步数即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">ll dis[<span class="number">5</span>][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll to,ll from,ll id)</span></span>&#123;</span><br><span class="line">    dis[id][to]=dis[id][from]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[to])&#123;</span><br><span class="line">        <span class="comment">//注意可能遇到父节点 需要跳过</span></span><br><span class="line">        <span class="keyword">if</span>(t.to==from)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(t.to,to,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//黑棋开始dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//白棋开始dfs</span></span><br><span class="line">    <span class="built_in">dfs</span>(n,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//id为0是黑棋，1为白棋</span></span><br><span class="line">    <span class="comment">//ans1统计的是黑棋占领的个数，ans2统计的是白棋占领的个数</span></span><br><span class="line">    ll ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[<span class="number">0</span>][i]&lt;=dis[<span class="number">1</span>][i])&#123;</span><br><span class="line">            ans1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans1&gt;ans2)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Fennec&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Snuke&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC066</title>
      <link href="/posts/bc9965ec.html"/>
      <url>/posts/bc9965ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC066">ABC066</h1><blockquote><h1 id="ABC066B-ss">[ABC066B] ss</h1><h2 id="题面翻译">题面翻译</h2><p>如果某个串可以由两个一样的串前后连接得到，我们就称之为“偶串”。比如说“xyzxyz”和“aaaaaa”是偶串，而“ababab”和“xyzxy”则不是偶串。</p><p>输入一个字符串S，查找可以通过从S的末尾删除一个或多个字符获得的最长偶数字符串的长度。确保给定输入存在这样的非空字符串。</p><p>输出这个非空字符串的长度</p><h2 id="题目描述">题目描述</h2><p>同じ文字列を $ 2 $ つ並べてできる文字列のことを偶文字列と呼ぶことにします。 例えば、 <code>xyzxyz</code> や <code>aaaaaa</code> は偶文字列ですが、<code>ababab</code> や <code>xyzxy</code> は偶文字列ではありません。</p><p>アルファベットの小文字からなる偶文字列 $ S $ が与えられます。 $ S $ の末尾の文字を $ 1 $ 文字以上消して作れる偶文字列のうち、最も長い偶文字列の長さを求めて下さい。 与えられる入力では、条件を満たす $ 1 $ 文字以上の文字列が存在することが保証されています。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えとなる文字列の長さを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abaababaab</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xxxx</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcabcabcabc</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">akasakaakasakasakaakas</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ \leq\ |S|\ \leq\ 200 $</li><li>$ S $ は小文字のアルファベットのみからなる偶文字列である。</li><li>$ S $ に対して、条件を満たす $ 1 $ 文字以上の文字列が存在する。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>abaababaab</code> は偶文字列ですが、 $ 1 $ 文字も消していないので条件を満たしません。 <code>abaababaa</code> は偶文字列ではありません。 <code>abaababa</code> は偶文字列ではありません。 <code>abaabab</code> は偶文字列ではありません。 <code>abaaba</code> は偶文字列です。よって、答えは <code>abaaba</code> の長さである $ 6 $ です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p><code>xxx</code> は偶文字列ではありません。 <code>xx</code> は偶文字列です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>条件を満たす文字列は <code>abcabc</code> なので、答えは $ 6 $ です。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>条件を満たす文字列は <code>akasakaakasaka</code> なので、答えは $ 14 $ です。</p></blockquote><h2 id="思路">思路</h2><p>我们直接每次删去一个字符，暴力判断是否是偶字符串即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        n--;</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;s[<span class="number">0</span>]==s[<span class="number">1</span>])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=n/<span class="number">2</span>;i&lt;=n/<span class="number">2</span><span class="number">-1</span>,j&lt;=n<span class="number">-1</span>;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i]==s[j])&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                    <span class="keyword">if</span>(i==n/<span class="number">2</span><span class="number">-1</span>)&#123;</span><br><span class="line">                        flag=n;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            cout&lt;&lt;flag;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用STL的写法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll maxn=<span class="number">14e4</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">length</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i-=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>,i&gt;&gt;<span class="number">1</span>)==s.<span class="built_in">substr</span>(i&gt;&gt;<span class="number">1</span>,i&gt;&gt;<span class="number">1</span>))<span class="comment">//STL大法</span></span><br><span class="line">        &#123;</span><br><span class="line">            num=i;<span class="comment">//满足直接退出循环并输出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC066C-pushpush">[ABC066C] pushpush</h1><h2 id="题面翻译-2">题面翻译</h2><p>输入N，后面有N个数，代表:$a1,a2,a3, … ,aN$，我们将会对$b$这个空序列进行N个操作</p><p>第i个操作进行如下处理：</p><ul><li><p>在b序列的末尾加入a[i]</p></li><li><p>翻转b序列</p></li></ul><p>感谢@RioBlu的翻译</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ n $ の数列 $ a_1,\ …\ ,\ a_n $ が与えられます。 空の数列 $ b $ に対して、以下の操作を $ n $ 回行うことを考えます。</p><p>$ i $ 回目には</p><ol><li>数列の $ i $ 番目の要素 $ a_i $ を $ b $ の末尾に追加する。</li><li>$ b $ を逆向きに並び替える。</li></ol><p>この操作をしてできる数列 $ b $ を求めて下さい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ $ … $ $ a_n $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ n $ 個の整数を空白区切りで $ 1 $ 行に出力せよ。 $ i $ 番目には、 $ b_i $ を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 1 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 2</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0 6 7 6 7 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 6 6 0 7 7</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 2\times\ 10^5 $</li><li>$ 0\ \leq\ a_i\ \leq\ 10^9 $</li><li>$ n,a_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 1 $ となります。 $ 1 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 1 $ となります。 $ 2 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 1,\ 2 $ となります。 $ 2 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 2,\ 1 $ となります。 $ 3 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 2,\ 1,\ 3 $ となります。 $ 3 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 3,\ 1,\ 2 $ となります。 $ 4 $ 回目の操作 $ 1 $ の後、 $ b $ は $ 3,\ 1,\ 2,\ 4 $ となります。 $ 4 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 4,\ 2,\ 1,\ 3 $ となります。 よって、答えは <code>4 2 1 3</code> です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>出力例 1 の説明の通り、 $ 3 $ 回目の操作 $ 2 $ の後、 $ b $ は $ 3,\ 1,\ 2 $ となるので、 答えは <code>3 1 2</code> です。</p></blockquote><h2 id="思路-2">思路</h2><p>可以利用deque来实现。</p><p>反转本质上可以转化为数字的前后插入问题</p><p>比如说，第一次是向最后插入，反转后第二次就是在最前插入</p><p>所以用deque来存储数字（特别好用）,需要注意考虑最后是奇数串还是偶数串，注意输出顺序。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],q1[MAXN],q2[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    deque&lt;ll&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//判断是前还是后输入</span></span><br><span class="line">        <span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> d.<span class="built_in">push_front</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;<span class="comment">//从后输出</span></span><br><span class="line">        <span class="keyword">while</span>(d.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout&lt;&lt;d.<span class="built_in">back</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            d.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//从前输出</span></span><br><span class="line">        <span class="keyword">while</span>(d.<span class="built_in">size</span>())&#123;</span><br><span class="line">            cout&lt;&lt;d.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            d.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC066D-11">[ABC066D] 11</h1><h2 id="题面翻译-3">题面翻译</h2><p>长度为n+1的序列a.其中[1…n]每个数都至少出现一次.<br>（n&lt;=1e5）,对每个k从1到n，询问长度为k的不同的子序列有多少个?</p><h2 id="题目描述-3">题目描述</h2><p>$ 1,…,n $ の $ n $ 個の整数からなる長さ $ n+1 $ の数列 $ a_1,a_2,…,a_{n+1} $ が与えられます。 この数列には $ 1,…,n $ のどの整数もかならず $ 1 $ 回以上出現することが分かっています。</p><p>$ k=1,…,n+1 $ のそれぞれについて、与えられた数列の長さ $ k $ の（連続とは限らない）部分列の個数を求め、 $ 10^9+7 $ で割ったあまりを出力して下さい。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ … $ a_{n+1} $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>答えを $ n+1 $ 行に出力せよ。 $ k $ 行目には、長さ $ k $ の部分列の個数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">29 19 7 10 26 32 27 4 11 20 2 8 16 23 5 14 6 12 17 22 18 30 28 24 15 1 25 3 13 21 19 31 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">525</span><br><span class="line">5453</span><br><span class="line">40919</span><br><span class="line">237336</span><br><span class="line">1107568</span><br><span class="line">4272048</span><br><span class="line">13884156</span><br><span class="line">38567100</span><br><span class="line">92561040</span><br><span class="line">193536720</span><br><span class="line">354817320</span><br><span class="line">573166440</span><br><span class="line">818809200</span><br><span class="line">37158313</span><br><span class="line">166803103</span><br><span class="line">166803103</span><br><span class="line">37158313</span><br><span class="line">818809200</span><br><span class="line">573166440</span><br><span class="line">354817320</span><br><span class="line">193536720</span><br><span class="line">92561040</span><br><span class="line">38567100</span><br><span class="line">13884156</span><br><span class="line">4272048</span><br><span class="line">1107568</span><br><span class="line">237336</span><br><span class="line">40920</span><br><span class="line">5456</span><br><span class="line">528</span><br><span class="line">33</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="注意">注意</h3><ul><li>$ 2 $ つの部分列が数列として同じであれば、元の数列での位置が異なっていたとしても、$ 1 $ 通りと数えます。</li><li>数列 $ a $ の長さ $ k $ の部分列とは、$ a $ の要素のうち $ k $ 個を選んで、 それらを順番を変えずに取り出して並べた数列のことを指します。 例えば、数列 $ 1,2,3,4,5 $ の長さ $ 3 $ の部分列には、 $ 1,3,5 $ や $ 1,2,3 $ などがあります。 一方で、$ 3,1,2 $ や $ 1,10,100 $ はこの数列の部分列ではありません。</li></ul><h3 id="制約-3">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 10^5 $</li><li>$ 1\ \leq\ a_i\ \leq\ n $</li><li>$ 1,…,n $ のどの整数も必ず数列に出現する。</li><li>$ n,a_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>長さ $ 1 $ の部分列は $ 1 $、$ 2 $、$ 3 $ の $ 3 $ 通りです。 長さ $ 2 $ の部分列は $ 1,1 $、$ 1,2 $、$ 1,3 $、$ 2,1 $、$ 2,3 $ の $ 5 $ 通りです。 長さ $ 3 $ の部分列は $ 1,1,3 $、$ 1,2,1 $、$ 1,2,3 $、$ 2,1,3 $ の $ 4 $ 通りです。 長さ $ 4 $ の部分列は $ 1,2,1,3 $ の $ 1 $ 通りです。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>長さ $ 1 $ の部分列は $ 1 $ の $ 1 $ 通りです。 長さ $ 2 $ の部分列は $ 1,1 $ の $ 1 $ 通りです。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>$ 10^9+7 $ で割ったあまりを出力することに注意して下さい。</p></blockquote><h2 id="思路-3">思路</h2><p>这是一道排列组合的问题。</p><p>可以发现只有一个数会出现两次，其他数都只会出现一次。</p><p>先考虑不重复的情况，那么就是$C_{n+1}^{k}$即可。</p><p>但是得除掉重复的情况，思考一下，假设出现两次的数字，出现的位置分别记作$left,right$。</p><p>如果交换它们两个的位置，那么得到的序列还是一样的，也就是说，位于它们两者之间的数字是对可能的序列情况是没有任何影响的。</p><p>那么我们只需要考虑在$left$左边，$right$右边的序列情况即可，可以得到是$C_{(l-1)+(n-r+1)}^{k}$。</p><p>那么两者相减就是答案。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll fac[MAXN],vis[MAXN];</span><br><span class="line"><span class="comment">//费马小定理求组合数</span></span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>||m&lt;=<span class="number">0</span>||n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*<span class="built_in">qpower</span>(fac[n-m]*fac[m]%mod,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    n++;</span><br><span class="line">    ll start=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//得到重复出现的数字</span></span><br><span class="line">        <span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line">            start=vis[x];</span><br><span class="line">            last=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vis数组记录数字出现的位置</span></span><br><span class="line">        vis[x]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;n<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fac[i]=fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll ans=<span class="built_in">C</span>(n,i)-<span class="built_in">C</span>(start+n-last<span class="number">-1</span>,i<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//这里+mod，防止结果为负数</span></span><br><span class="line">        ans=(ans+mod)%mod;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC065</title>
      <link href="/posts/25903456.html"/>
      <url>/posts/25903456.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC065">ABC065</h1><blockquote><h1 id="ABC065A-Expired">[ABC065A] Expired?</h1><h2 id="题面翻译">题面翻译</h2><p>高桥君在保质期前 $a$ 天买了食物，$b$ 天后吃了，但是高桥君吃了过期 $x$ 天的食物不会胃痛，如果过了 $x$ 天吃，他就会胃痛。</p><p>给定 $x,a,b$，如果食物没有过期，输出 <code>delicious</code>。</p><p>如果食物过期了但吃了不会胃痛，输出 <code>safe</code>。</p><p>如果吃了会胃痛，输出 <code>dangerous</code>。</p><h2 id="题目描述">题目描述</h2><p>高橋君は胃が強いので、賞味期限を $ X $ 日まで過ぎた食品を食べてもお腹を壊しません。 賞味期限を $ X+1 $ 日以上過ぎた食品を食べると、お腹を壊します。</p><p>また、賞味期限を過ぎずに食べると、おいしく感じます。そうでない場合、おいしく感じません。</p><p>高橋君は、賞味期限の $ A $ 日前に食品を買ってきて、買ってから $ B $ 日後に食べました。</p><p>高橋君が食品をおいしく感じた場合 <code>delicious</code> を、おいしくは感じなかったがお腹は壊さなかった場合 <code>safe</code> を、お腹を壊した場合 <code>dangerous</code> を出力するプログラムを作成してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $ $ A $ $ B $</p></blockquote><h2 id="输出格式">输出格式</h2><p>高橋君が食品をおいしく感じた場合 <code>delicious</code> を、おいしくは感じなかったがお腹は壊さなかった場合 <code>safe</code> を、お腹を壊した場合 <code>dangerous</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">safe</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delicious</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 7 12</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dangerous</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ X,A,B\ ≦\ 10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>賞味期限を $ 3 $ 日過ぎて食べるので、おいしくは感じませんが、お腹も壊しません。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>賞味期限を過ぎていないので、おいしく感じます。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>賞味期限を $ 5 $ 日過ぎて食べるので、お腹を壊します。</p></blockquote><h2 id="思路">思路</h2><p>这题完全败在了理解上qwq。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= b) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;delicious&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((b - a) &lt;= x) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;safe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;dangerous&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065B-Trained">[ABC065B] Trained?</h1><h2 id="题面翻译-2">题面翻译</h2><p>有一堆按钮，按钮的编号是从 $1$ 到 $n$ 。第 $i$ 个按钮对应第 $i$ 个灯。</p><p>你按下第 $i$ 个按钮时，如果你按下的按钮对应的灯是关闭的,那么灯 $a_i$ 会开启，灯 $i$ 会关闭； 如果按钮对应的灯是开启的,那么按下它就什么都不会发生。</p><p>最初，灯 $1$ 是关闭的，其他的灯都开着。 高桥君希望最后灯 $2$ 是关闭的。</p><p>输出他最少按下按钮的次数，如果不能则输出 $-1$ 。</p><h2 id="题目描述-2">题目描述</h2><p>筋力をつけたい高橋君は、AtCoder 社のトレーニング設備で、トレーニングをすることにしました。</p><p>AtCoder 社のトレーニング設備には $ N $ 個のボタンがついており、ちょうど $ 1 $ 個のボタンが光っています。 ボタンには、$ 1 $ から $ N $ までの番号がついています。 ボタン $ i $ が光っているときにそのボタンを押すと、ボタン $ i $ の明かりが消え、その後ボタン $ a_i $ が光ります。$ i=a_i $ であることもあります。 光っていないボタンを押しても、何も起こりません。</p><p>最初、ボタン $ 1 $ が光っています。高橋君は、ボタン $ 2 $ が光っている状態で、トレーニングをやめたいと思っています。</p><p>そのようなことは可能かどうか判定し、もし可能なら最低で何回ボタンを押す必要があるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ : $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>ボタン $ 2 $ を光らせることが不可能な場合、$ -1 $ を出力せよ。 そうでない場合、ボタン $ 2 $ を光らせるために必要なボタンを押す回数の最小値を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 10^5 $</li><li>$ 1\ ≦\ a_i\ ≦\ N $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ボタン $ 1,3 $ の順に押せばよいです。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>ボタン $ 1 $ を押すとボタン $ 3 $ 、ボタン $ 3 $ を押すとボタン $ 1 $ が光るので、ボタン $ 2 $ が光ることはありません。</p></blockquote><h2 id="思路-2">思路</h2><p>算是一个简单的链表？直接模拟即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="comment">//如果到达2点，直接输出操作次数</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;cnt;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i=a[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065C-Reconciled">[ABC065C] Reconciled?</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>すぬけ君养了 $ N $ 只狗和 $M$ 只猴。すぬけ君想把这 $N+M$ 只动物排成一列。</p><p>すぬけ君希望狗与狗不能互相挨着，猴与猴不能互相挨着。</p><p>这样的排列方式有多少种？请输出答案对 $10^9+7$ 取模的结果。不过，狗与狗间，猴与猴间相互区别。</p><h2 id="数据范围">数据范围</h2><ul><li>$1 \leq N,M \leq 10^5 $</li></ul><h2 id="输入">输入</h2><p>输入按以下标准：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N M</span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><p>输出方案数对 $10^9+7$ 取模的结果</p><h2 id="样例1解释">样例1解释</h2><p>将每只狗分别记为<code>A</code>,<code>B</code>，将每只猴分别记为<code>C</code>,<code>D</code>，则共有<code>ACBD</code>,<code>ADBC</code>,<code>BCAD</code>,<code>BDAC</code>,<code>CADB</code>,<code>CBDA</code>,<code>DACB</code>,<code>DBCA</code> $8$ 种排列方法。</p><p>感谢@ミク 提供的翻译</p><h2 id="题目描述-4">题目描述</h2><p>すぬけ君は、犬を $ N $ 匹と猿を $ M $ 匹飼っています。すぬけ君は、この $ N+M $ 匹を一列に並べようと思っています。</p><p>文字通り犬猿の仲の犬たちと猿たちを仲直りさせたいすぬけ君は、犬同士、または猿同士が隣り合うところができないように並べようと思っています。</p><p>このような並べ方は何通りあるでしょうか。犬と猿は $ 10^9+7 $ 以上の数を理解できないので、並べ方の個数を $ 10^9+7 $ で割ったあまりを求めてください。 ただし、犬同士、また猿同士は互いに区別します。また、左右が反転しただけの列も異なる列とみなします。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>並べ方の個数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">530123477</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N,M\ ≦\ 10^5 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>犬をそれぞれ <code>A</code>,<code>B</code> とし、猿をそれぞれ <code>C</code>,<code>D</code> とすると、<code>ACBD</code>,<code>ADBC</code>,<code>BCAD</code>,<code>BDAC</code>,<code>CADB</code>,<code>CBDA</code>,<code>DACB</code>,<code>DBCA</code> の $ 8 $ 通りの並べ方があります。</p></blockquote><h2 id="思路-3">思路</h2><p>数学题。</p><p>如果猴子和狗的数目之差大于1，肯定不行，直接输出0即可。</p><p>如果小于或者等于1，需要分类讨论。</p><p>如果相等，那么狗和猴子的顺序可以颠倒，需要乘以2，不等则不行。</p><p>那么问题就变成了简单的排列组合问题，注意猴子和狗子是有区分的，那么答案就是狗子数目的阶乘和猴子数目阶乘的乘积。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll fac[MAXN];</span><br><span class="line"><span class="comment">//预处理出阶乘</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1e5</span>;i++)&#123;</span><br><span class="line">        fac[i]=(fac[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//之差大于1，直接输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(n-m)&gt;<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果相等，则可以交换位置，注意*2</span></span><br><span class="line">        <span class="keyword">if</span>(n==m)&#123;</span><br><span class="line">            ans=(fac[n]*fac[m]%mod)*<span class="number">2</span>%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不等则不行</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans=(fac[n]*fac[m]%mod);</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC065D-Built">[ABC065D] Built?</h1><h2 id="题面翻译-4">题面翻译</h2><h2 id="题目描述-5">题目描述</h2><p>平面上有 $N$ 个城市。第 $i$ 个城市的坐标为 $(x_i,y_i)$ 。同一个坐标上可能有多个城市。在坐标为 $(a,b)$ 的城市和坐标为 $(c,d)$ 的城市间建造一条道路需要 $min(|a-c|,|b-d|)$ 円。只能在城市与城市间建造道路。<br>要使任意两个城市之间有直接或间接道路相连，最少需要多少円？</p><h2 id="数据范围-2">数据范围</h2><ul><li>$2 \leq N \leq 10^5$</li><li>$0 \leq x_i,y_i \leq 10^9$</li><li>输入全为整数</li></ul><h2 id="输入-2">输入</h2><p>输入按以下形式：<br>$$ N $$<br>$$ x_1 \space y_1 $$<br>$$ x_2 \space y_2 $$<br>$$ : $$<br>$$ x_N \space y_N $$</p><h2 id="输出-2">输出</h2><p>请输出使任意两城市间有直接或间接道路连接所需最少钱数。</p><h2 id="样例1解释-2">样例1解释</h2><p>在城市 $1$ 与城市 $2$ 间建造一条道路，在城市 $2$ 与城市 $3$ 间建造一条道路，花费 $2+1=3$ 円。</p><p>感谢@ミク 提供的翻译</p><h2 id="题目描述-6">题目描述</h2><p>平面上に、$ N $ 個の街があります。$ i $ 個目の街は、座標 $ (x_i,y_i) $ にあります。同じ座標に、複数の街があるかもしれません。</p><p>座標 $ (a,b) $ にある街と座標 $ (c,d) $ にある街の間に道を造るのには、$ min(|a-c|,|b-d|) $ 円かかります。街と街の間以外に、道を造ることはできません。</p><p>任意の $ 2 $ つの街の間を、道を何本か通って行き来できるようにするためは、最低で何円必要でしょうか。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ x_1 $ $ y_1 $ $ x_2 $ $ y_2 $ : $ x_N $ $ y_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>任意の $ 2 $ つの街の間を道を何本か通って行き来できるようにするためにかかるお金の最小値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 5</span><br><span class="line">3 9</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">8 3</span><br><span class="line">4 9</span><br><span class="line">12 19</span><br><span class="line">18 1</span><br><span class="line">13 5</span><br><span class="line">7 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 10^5 $</li><li>$ 0\ ≦\ x_i,y_i\ ≦\ 10^9 $</li><li>入力は全て整数である</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>街 $ 1 $ と $ 2 $ 、街 $ 2 $ と $ 3 $ の間に道を造ると、かかるお金は $ 2+1=3 $ 円になります。</p></blockquote><h2 id="思路-4">思路</h2><p>比较容易地发现可以使用最小生成树。</p><p>但是如果直接建图的话，肯定会TLE。</p><p>不妨采取以下思路：题目要求的是$min(x_i-x_j,y_i-y_j)$。那么我们可以先对所有点的$x$坐标进行排序，得到的相邻两个差是最小的，所以我们只需要建$n-1$条边，每条边的权值为$x_i-x_{i-1}$。</p><p>同理，$y$也是进行一样的处理。</p><p>最后再在其中选择最小值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll n;</span><br><span class="line">ll fa[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll id;</span><br><span class="line">    ll x,y;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    ll from,to,val;</span><br><span class="line">&#125;b[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.x&lt;y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp2</span><span class="params">(node x,node y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.y&lt;y.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp3</span><span class="params">(Edge x,Edge y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.val&lt;y.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">        a[i].id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据x坐标进行建边</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp1);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[++cnt].from=a[i<span class="number">-1</span>].id;</span><br><span class="line">        b[cnt].to=a[i].id;</span><br><span class="line">        b[cnt].val=a[i].x-a[i<span class="number">-1</span>].x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据y坐标进行建边</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[++cnt].from=a[i<span class="number">-1</span>].id;</span><br><span class="line">        b[cnt].to=a[i].id;</span><br><span class="line">        b[cnt].val=a[i].y-a[i<span class="number">-1</span>].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b+<span class="number">1</span>,b+<span class="number">1</span>+cnt,cmp3);</span><br><span class="line"></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//联通操作</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ll from=<span class="built_in">find</span>(b[i].from);</span><br><span class="line">        ll to=<span class="built_in">find</span>(b[i].to);</span><br><span class="line">        <span class="keyword">if</span>(from!=to)&#123;</span><br><span class="line">            fa[from]=to;</span><br><span class="line">            n--;</span><br><span class="line">            ans+=b[i].val;</span><br><span class="line">            <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC064</title>
      <link href="/posts/529704c0.html"/>
      <url>/posts/529704c0.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC069</title>
      <link href="/posts/2c26787d.html"/>
      <url>/posts/2c26787d.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC069">ABC069</h1><blockquote><h1 id="ABC069C-4-adjacent">[ABC069C] 4-adjacent</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>一个数列长为n。你的任务是将数列进行排列，使得当1 ≤ i ≤ N − 1 时，a[i]与a[i+1]的积是4的倍数。<br>请判断你是否能完成这个任务。</p><h2 id="输入格式">输入格式</h2><p>第一行包含一个正整数n，为数列的长度。<br>第二行包含n个正整数，为数列内的数。</p><h2 id="输出格式">输出格式</h2><p>如果你能完成这个任务，输出Yes，否则输出No。</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ N $ の数列 $ a\ =\ (a_1,\ a_2,\ …,\ a_N) $ があります。 各 $ a_i $ は正の整数です。</p><p>すぬけ君の目標は、$ a $ の要素を自由に並べ替え、次の条件が成り立つようにすることです。</p><ul><li>各 $ 1\ &lt;\ =\ i\ &lt;\ =\ N\ -\ 1 $ について、$ a_i $ と $ a_{i\ +\ 1} $ の積は $ 4 $ の倍数である。</li></ul><p>すぬけ君が目標を達成できるか判定してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>すぬけ君が目標を達成できるならば <code>Yes</code> を、できないならば <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 10 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 7 1 8 2 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ a_i $ は整数である。</li><li>$ 1\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>例えば、$ (1,\ 100,\ 10) $ と並べ替えればよいです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>どのように並べ替えても、条件が成り立つようにできません。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>最初から条件が成り立っています。</p></blockquote><h2 id="思路">思路</h2><p>不难想到有两种情况：</p><p>1、$a_n$为4的倍数。</p><p>2、$a_n$与$a_{n+1}$为2的倍数。</p><p>如果$a_n$为4的倍数，$a_{n+1}$没有任何要求，反之，如果$a_n$是2的倍数，那么$a_{n+1}$也需要是2的倍数。</p><p>需要计算一下贡献，判断是否大于$\frac{n}{2}$。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> cnt1=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">4</span>==<span class="number">0</span>)cnt1++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[i]%<span class="number">2</span>==<span class="number">0</span>)cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意cnt2需要除以2</span></span><br><span class="line">    <span class="keyword">if</span>(cnt1+cnt2/<span class="number">2</span>&gt;=n/<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC069D-Grid-Coloring">[ABC069D] Grid Coloring</h1><h2 id="题面翻译-2">题面翻译</h2><p>给你一个序列$a$,满足$\sum\limits^{n}_{i=1}a_i=WH$<br>请你够构造一个$W*H$的矩阵,满足:</p><ul><li>每一中颜色$i$,满足矩阵中出现了$a_i$次</li><li>要保证每一种颜色$i$都是相互联通的,即为一个联通块</li></ul><p>可以证明一定可以构造出这样的矩阵</p><h2 id="题目描述-3">题目描述</h2><p>縦 $ H $ 行、横 $ W $ 列のマス目があります。 すぬけ君は、このマス目を色 $ 1 $, $ 2 $, $ … $, $ N $ で塗り分けようとしています。 このとき、次の条件が成り立つようにします。</p><ul><li>各 $ i $ ($ 1\ &lt;\ =\ i\ &lt;\ =\ N $) について、色 $ i $ のマスはちょうど $ a_i $ 個存在する。 ただし、$ a_1\ +\ a_2\ +\ …\ +\ a_N\ =\ H\ W $ である。</li><li>各 $ i $ ($ 1\ &lt;\ =\ i\ &lt;\ =\ N $) について、色 $ i $ のマスは上下左右に連結である。 すなわち、どの色 $ i $ のマスからどの色 $ i $ のマスへも、上下左右に隣り合う色 $ i $ のマスのみを辿って行き来できる。</li></ul><p>条件を満たす塗り分け方をひとつ求めてください。 解は必ず存在することが示せます。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ N $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>条件を満たす塗り分け方をひとつ出力せよ。 塗り分け方は次のフォーマットで出力せよ。 ただし、$ c_{i\ j} $ は、上から $ i $ 行目、左から $ j $ 列目のマスの色である。</p><blockquote><p>$ c_{1\ 1} $ $ … $ $ c_{1\ W} $ $ : $ $ c_{H\ 1} $ $ … $ $ c_{H\ W} $</p></blockquote><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">3</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4 4 4 3</span><br><span class="line">2 5 4 5 3</span><br><span class="line">2 5 5 5 3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ &lt;\ =\ H,\ W\ &lt;\ =\ 100 $</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ H\ W $</li><li>$ a_i\ &gt;\ =\ 1 $</li><li>$ a_1\ +\ a_2\ +\ …\ +\ a_N\ =\ H\ W $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>例えば、次の塗り分け方は条件を満たしません。 色 $ 1 $ のマスが上下左右に連結でないからです。 <code>1 2 3 1</code></p></blockquote><h2 id="思路-2">思路</h2><p>不难想到蛇形构造，但是细节需要注意。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> h,w,n;</span><br><span class="line"><span class="type">int</span> g[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//将所有需要的数字存在数组a中，可以理解为每一块拼图都存入其中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;x;j++)</span><br><span class="line">            a.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">                g[i][j]=a[w*i+j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//注意反向</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)</span><br><span class="line">                g[i][w-j<span class="number">-1</span>]=a[w*i+j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;w;j++)&#123;</span><br><span class="line">            cout&lt;&lt;g[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC068</title>
      <link href="/posts/5b2148eb.html"/>
      <url>/posts/5b2148eb.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC068">ABC068</h1><blockquote><h1 id="ABC068B-Break-Number">[ABC068B] Break Number</h1><h2 id="题面翻译">题面翻译</h2><p>输入一个不大于100的正整数，输出小于等于它且最大的二的幂</p><h2 id="题目描述">题目描述</h2><p>高橋君は $ 2 $ で割れる数が好きです。</p><p>正整数 $ N $ が与えられるので、$ 1 $ 以上 $ N $ 以下の整数のうち、最も $ 2 $ で割れる回数が多いものを求めてください。答えは必ず $ 1 $ つに定まります。</p><p>なお、$ 2 $ で割っていき、何回あまりが出ずに割れるかを、$ 2 $ で割れる回数と呼ぶことにします。</p><p>例えば</p><ul><li>$ 6 $ ならば、$ 6 $ -&gt; $ 3 $で、$ 1 $ 回 $ 2 $ で割れます。</li><li>$ 8 $ ならば、$ 8 $ -&gt; $ 4 $ -&gt; $ 2 $ -&gt; $ 1 $で、$ 3 $ 回 $ 2 $ で割れます。</li><li>$ 3 $ ならば、$ 0 $ 回 $ 2 $ で割れます。</li></ul><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>問題の答えを出力する。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 4 $ は $ 2 $ 回 $ 2 $ で割ることができ、これは $ 1 $, $ 2 $, …, $ 7 $ の中で最も多いです。</p></blockquote><h2 id="思路">思路</h2><p>直接暴力计算，并且更新即可。</p><p>注意考虑特判。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">double</span> r[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                k/=<span class="number">2</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;tot)&#123;</span><br><span class="line">            ans=i;</span><br><span class="line">            tot=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC068C-Cat-Snuke-and-a-Voyage">[ABC068C] Cat Snuke and a Voyage</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题意">题意</h3><p>有很多小岛，编号$1$到$n$，某两个岛之间有船可以到达，每次从$1$号小岛出发，要到$n$号岛屿。规定只能做两次船，问是否能到达目标岛屿。</p><h3 id="输入">输入</h3><p>第一行第一个数字是要到达的岛屿$n$，第二行一个数字是$m$，表示有$m$个岛之间有船可以连通，接下来$m$行每行两个数（岛的编号 ），表示某两个岛连通。</p><h3 id="输出">输出</h3><p>如果能到达，输出<code>POSSIBLE</code>，否则输出<code>IMPOSSIBLE</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 题意</span><br><span class="line"></span><br><span class="line">有很多小岛，编号$1$到$n$，某两个岛之间有船可以到达，每次从$1$号小岛出发，要到$n$号岛屿。规定只能做两次船，问是否能到达目标岛屿。</span><br><span class="line"></span><br><span class="line">### 输入</span><br><span class="line"></span><br><span class="line">第一行第一个数字是要到达的岛屿$n$，第二行一个数字是$m$，表示有$m$个岛之间有船可以连通，接下来$m$行每行两个数（岛的编号 ），表示某两个岛连通。</span><br><span class="line"></span><br><span class="line">### 输出</span><br><span class="line"></span><br><span class="line">如果能到达，输出```POSSIBLE```，否则输出```IMPOSSIBLE```</span><br><span class="line"></span><br><span class="line">### 数据范围</span><br><span class="line"></span><br><span class="line">$3≤N≤200000$</span><br><span class="line"></span><br><span class="line">$1≤M≤200000$</span><br><span class="line"></span><br><span class="line">$1≤ai&lt;bi≤N$</span><br><span class="line"></span><br><span class="line">$(ai,bi)≠(1,N)$</span><br><span class="line"></span><br><span class="line">如果$i≠j$则$(ai,bi)≠(aj,bj).$</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数据范围">数据范围</h3><p>$3≤N≤200000$</p><p>$1≤M≤200000$</p><p>$1≤ai&lt;bi≤N$</p><p>$(ai,bi)≠(1,N)$</p><p>如果$i≠j$则$(ai,bi)≠(aj,bj).$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">[problemUrl]: https://atcoder.jp/contests/abc068/tasks/arc079_a</span><br><span class="line"></span><br><span class="line">高橋キングダムには、高橋諸島という、$ N $ 個の島からなる諸島があります。 便宜上、これらの島を島 $ 1 $、島 $ 2 $、 ...、島 $ N $ と呼ぶことにします。</span><br><span class="line"></span><br><span class="line">これらの諸島の間では、船の定期便が $ M $ 種類運行されています。 定期便はそれぞれ $ 2 $ つの島の間を行き来しており、$ i $ 種類目の定期便を使うと、 島 $ a_i $ と島 $ b_i $ の間を行き来する事ができます。</span><br><span class="line"></span><br><span class="line">すぬけくんは今島 $ 1 $ にいて、島 $ N $ に行きたいと思っています。 しかし、島 $ 1 $ から島 $ N $ への定期便は存在しないことがわかりました。 なので、定期便を $ 2 $ つ使うことで、島 $ N $ に行けるか調べたいと思っています。</span><br><span class="line"></span><br><span class="line">これを代わりに調べてあげてください。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">入力は以下の形式で標準入力から与えられる。</span><br><span class="line"></span><br><span class="line">&gt; $ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ : $ a_M $ $ b_M $</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">定期便を $ 2 $ つ使いたどり着けるならば `POSSIBLE`、たどり着けないならば `IMPOSSIBLE` と出力する。</span><br><span class="line"></span><br><span class="line">## 样例 #1</span><br><span class="line"></span><br><span class="line">### 样例输入 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3 2<br>1 2<br>2 3</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #2</span><br><span class="line"></span><br><span class="line">### 样例输入 #2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4 3<br>1 2<br>2 3<br>3 4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IMPOSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #3</span><br><span class="line"></span><br><span class="line">### 样例输入 #3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>100000 1<br>1 99999</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>IMPOSSIBLE</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 样例 #4</span><br><span class="line"></span><br><span class="line">### 样例输入 #4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5 5<br>1 3<br>4 5<br>2 3<br>2 4<br>1 4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 样例输出 #4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>POSSIBLE</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">## 提示</span><br><span class="line"></span><br><span class="line">### 制約</span><br><span class="line"></span><br><span class="line">- $ <span class="number">3</span>\ ≦\ N\ ≦\ <span class="number">200</span>,<span class="number">000</span> $</span><br><span class="line">- $ <span class="number">1</span>\ ≦\ M\ ≦\ <span class="number">200</span>,<span class="number">000</span> $</span><br><span class="line">- $ <span class="number">1</span>\ ≦\ a_i\ &lt;\ b_i\ ≦\ N $</span><br><span class="line">- $ (a_i,\ b_i)\ \neq\ (<span class="number">1</span>,\ N) $</span><br><span class="line">- $ i\ \neq\ j $ ならば $ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $</span><br><span class="line"></span><br><span class="line">### Sample Explanation <span class="number">2</span></span><br><span class="line"></span><br><span class="line">島 $ <span class="number">4</span> $ へ行くには、定期便を $ <span class="number">3</span> $ つ使う必要があります。</span><br><span class="line"></span><br><span class="line">### Sample Explanation <span class="number">4</span></span><br><span class="line"></span><br><span class="line">島 $ <span class="number">1</span> $、島 $ <span class="number">4</span> $、島 $ <span class="number">5</span> $ と移動すれば $ <span class="number">2</span> $ つの定期便で移動可能です。</span><br></pre></td></tr></table></figure></blockquote><h2 id="思路-2">思路</h2><p>注意到是要通过两条船到达，那么可以考虑：统计有那些点是从1到y，有哪些点是从x到n。</p><p>如果都满足的话，就可以到达。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)a[y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y==n)b[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举所有的点，看看能否从1到i，又从i到n</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&amp;&amp;b[i])&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;POSSIBLE&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;IMPOSSIBLE&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC068D-Decrease-Contestant-ver">[ABC068D] Decrease (Contestant ver.)</h1><h2 id="题面翻译-3">题面翻译</h2><p>对于一个长度为N的序列$a$,我们有这样的操作:</p><ul><li>从序列$a$中选出一个最大值,将其减$N$,对于剩下的$N-1$个元素,将其全部加$1$</li><li>可以证明操作$K$次之后，存在序列的最大值将小于或等于N-1。</li></ul><p>现在,给定一个正整数$K$,请构造出一个长度为$N$的序列$a$<br>使得满足操作$K$次之后满足序列的最大值将小于或等于N-1。</p><h2 id="题目描述-2">题目描述</h2><p>長さ $ N $ の非負整数列 $ a_i $ に対し、数列の最大値が $ N-1 $ 以下になるまで以下の操作を繰り返し行うことを考えます。</p><ul><li>数列のうち最も大きい要素を求める、複数ある場合はどれか $ 1 $ つ選ぶ。この要素の値を $ N $ 減らす。これ以外の要素の値を $ 1 $ 増やす。</li></ul><p>なお、この操作を行い続けると、いつかは数列の最大値が $ N-1 $ 以下になることが証明できます。</p><p>ここで、整数 $ K $ が与えられるので、この操作を行う回数がちょうど $ K $ 回になるような数列 $ a_i $ を $ 1 $ つ求めてください。なお、この問題の入出力の制約下では、かならず $ 1 $ つは条件を満たすような数列が存在することが示せます。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ K $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>以下の形式で数列を出力する。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><p>ここで、$ 2\ ≦\ N\ ≦\ 50, $ $ 0\ ≦\ a_i\ ≦\ 10^{16}\ +\ 1000 $ でなければならない。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3 3 3 3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 0 3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">27 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567894848</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1000 193 256 777 0 1 1192 1234567891011 48 425</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 0\ ≦\ K\ ≦\ 50\ \times\ 10^{16} $</li></ul><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>\[2, 2\] -&gt; \[0, 3\] -&gt; \[1, 1\] と、$ 2 $ 回操作を行います。</p></blockquote><h2 id="思路-3">思路</h2><p>直接看这里：[<a href="https://www.luogu.com.cn/article/zxtp5vur">ABC068D] Decrease (Contestant ver.) - 洛谷专栏 (luogu.com.cn)</a></p><p>一道有趣的构造题。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll k;cin&gt;&gt;k;</span><br><span class="line">    cout&lt;&lt;<span class="number">50</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i+(k+i)/<span class="number">50</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC063</title>
      <link href="/posts/ccf39163.html"/>
      <url>/posts/ccf39163.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC063">ABC063</h1><blockquote><h1 id="ABC063C-Bugged">[ABC063C] Bugged</h1><h2 id="题面翻译">题面翻译</h2><p>有 $N$ 道题，答对一道获得 $A_i$ 分，答错不得分。但是如果现在分数为 $10$ 的倍数将会显示 $0$ 分，问最高可以获得多少分？</p><h2 id="题目描述">题目描述</h2><p>あなたはコンピュータで試験を受けています。試験は $ N $ 問の問題からなり、$ i $ 問目の問題の配点は $ s_i $ です。それぞれの問題に対するあなたの解答は「正解」または「不正解」のいずれかとして判定され、正解した問題の配点の合計があなたの成績となります。あなたが解答を終えると、解答がその場で採点されて成績が表示される…はずでした。</p><p>ところが、試験システムに欠陥があり、成績が $ 10 $ の倍数の場合は、画面上で成績が $ 0 $ と表示されてしまいます。それ以外の場合は、画面に正しい成績が表示されます。この状況で、成績として画面に表示されうる最大の値はいくつでしょうか？</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ s_1 $ $ s_2 $ $ : $ $ s_N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>成績として画面に表示されうる最大の値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>入力値はすべて整数である。</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 100 $</li><li>$ 1\ &lt;\ =\ s_i\ &lt;\ =\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 10 $ 点の問題と $ 15 $ 点の問題に正解し、$ 5 $ 点の問題には正解しないことで成績が $ 25 $ となり、この成績は画面に正しく表示されます。$ 5 $ 点の問題にも正解すると成績が $ 30 $ となりますが、この成績は画面上では $ 0 $ と表示されてしまいます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>すべての問題に正解すると成績が $ 35 $ となり、この成績は画面に正しく表示されます。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>どのような解答状況でも成績は $ 10 $ の倍数となり、画面上では $ 0 $ と表示されてしまいます。</p></blockquote><h2 id="思路">思路</h2><p>比较容易想到的就是贪心：如果所有数字的和不是10的倍数，那么直接输出即可。但如果是10的整数倍，我们只有减去一个某一个数即可。</p><p>那么要减去谁呢？如果这个数是10的倍数，那么所有数之和减去该数后，还是10的整数倍，没有任何效果。</p><p>那么为了使得结果最大化，我们应该减去最小的、且不是10的整数倍的数。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> MIN=MAXN;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="comment">//选出符合情况的最小值</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%<span class="number">10</span>)&#123;</span><br><span class="line">            MIN=<span class="built_in">min</span>(MIN,a[i]);</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意 可能选不出满足情况的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(!flag)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本身和不是10的整数倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">10</span>)cout&lt;&lt;sum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//本身和是10的整数倍</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;sum-MIN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC063D-Widespread">[ABC063D] Widespread</h1><h2 id="题面翻译-2">题面翻译</h2><p>你散步的时候，突然$N$个魔物出现了。</p><p>各个魔物都有体力这个值，第$i$个魔物出现时的体力是$h_i$,而体力$0$以下的魔物立即消失。</p><p>幸运的是，你是一个熟练的魔法师，可以发动爆炸来攻击魔物。一次爆炸可以减少魔物的体力，如下所示。</p><p>选择生存的魔物，以魔物为中心引起爆炸。成为爆炸中心的魔物的体力$A$减少，其他魔物的体力$B$分别减少。</p><p>这里需要说明的是，$A$和$B$是预先确定的值，且$A&gt;B$。</p><p>为了消灭所有的魔物，你最少需要引起几次爆炸呢?</p><h2 id="题目描述-2">题目描述</h2><p>あなたが散歩していると、突然 $ N $ 体の魔物が出現しました。それぞれの魔物は <em>体力</em> という値を持ち、$ i $ 体目の魔物の出現時の体力は $ h_i $ です。体力が $ 0 $ 以下となった魔物は直ちに消滅します。</p><p>幸い、あなたは熟練の魔法使いであり、爆発を引き起こして魔物を攻撃できます。一回の爆発では、以下のように魔物の体力を減らすことができます。</p><ul><li>生存している魔物を一体選び、その魔物を中心に爆発を引き起こす。爆発の中心となる魔物の体力は $ A $ 減り、その他の魔物の体力はそれぞれ $ B $ 減る。ここで、$ A $ と $ B $ はあらかじめ定まった値であり、$ A\ &gt;\ B $ である。</li></ul><p>すべての魔物を消し去るためには、最小で何回の爆発を引き起こす必要があるでしょうか？</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ h_1 $ $ h_2 $ $ : $ $ h_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>すべての魔物を消し去るために必要な最小の爆発の回数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 3</span><br><span class="line">8</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 10 4</span><br><span class="line">20</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2 1</span><br><span class="line">900000000</span><br><span class="line">900000000</span><br><span class="line">1000000000</span><br><span class="line">1000000000</span><br><span class="line">1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">800000000</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力値はすべて整数である。</li><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ 1\ &lt;\ =\ B\ &lt;\ A\ &lt;\ =\ 10^9 $</li><li>$ 1\ &lt;\ =\ h_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>以下のようにして、$ 2 $ 回の爆発ですべての魔物を消し去ることができます。 - まず、体力が $ 8 $ の魔物を中心に爆発を引き起こす。$ 4 $ 体の魔物の体力はそれぞれ $ 3 $, $ 4 $, $ 1 $, $ -1 $ となり、最後の魔物は消滅する。 - 次に、残りの体力が $ 4 $ の魔物を中心に爆発を引き起こす。残っていた $ 3 $ 体の魔物の体力はそれぞれ $ 0 $, $ -1 $, $ -2 $ となり、すべての魔物が消滅する。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>それぞれの魔物を中心に $ 2 $ 回ずつ、合計で $ 4 $ 回の爆発を引き起こす必要があります。</p></blockquote><h2 id="思路-2">思路</h2><p>思考，可以发现存在明显的分界点情况，在某一个临界次数值下，可以消灭全部怪物，具有单调性，所以可以考虑二分。</p><p>这里根据题目要求，二分的是次数。重心放在check函数怎么写。</p><p>不难想到使用贪心的思想，对于一个怪物来说，如果你能使用伤害为b的攻击，将其消灭，则使用b。</p><p>否则就只能使用爆炸了，统计一下爆炸的次数，然后和mid比较即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll h[MAXN],n,a,b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来解决取整问题</span></span><br><span class="line"><span class="function">ll <span class="title">Ceil</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x%y==<span class="number">0</span>)<span class="keyword">return</span> x/y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x/y+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll mid)</span></span>&#123;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(h[i]&lt;=mid*b)<span class="keyword">continue</span>;</span><br><span class="line">        cnt+=<span class="built_in">Ceil</span>(h[i]-mid*b,a-b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较爆炸次数cnt和mid的值</span></span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll MAX=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;h[i],MAX=<span class="built_in">max</span>(MAX,h[i]);</span><br><span class="line">    ll l=<span class="number">0</span>,r=<span class="built_in">Ceil</span>(MAX,b);</span><br><span class="line">    <span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)&#123;</span><br><span class="line">        ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            r=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(l))cout&lt;&lt;l;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块入门by hzwer</title>
      <link href="/posts/cbd2a72.html"/>
      <url>/posts/cbd2a72.html</url>
      
        <content type="html"><![CDATA[<h1 id="分块入门-by-hzwer">分块入门 by hzwer</h1><p>文章内容来自于<a href="http://hzwer.com/8053.html">「分块」数列分块入门1 – 9 by hzwer - 分块 - hzwer.com</a>，如有侵权，请联系作者删除</p><hr><h2 id="入门1">入门1</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，单点查值。</strong></p><p>这是一道能用许多数据结构优化的经典题，可以用于不同数据结构训练。</p><p>数列分块就是把数列中每m个元素打包起来，达到优化算法的目的。</p><p>以此题为例，如果我们把每m个元素分为一块，共有$O(\frac{n}{m})$块，每次<strong>区间加的操作会涉及$O(\frac{n}{m})$个整块，以及区间两侧两个不完整的块中至多2m个元素。</strong></p><p>我们给每个块设置一个加法标记（就是记录这个块中元素一起加了多少），每次操作对每个整块直接O(1)标记，而不完整的块由于元素比较少，暴力修改元素的值。</p><p>每次询问时返回元素的值加上其所在块的加法标记。</p><p>这样每次操作的复杂度是$O(\frac{n}{m})+O(m)$，根据均值不等式，当$m$取$\sqrt{n}$时总复杂度最低，为了方便，我们都默认下文的分块大小为$\sqrt{n}$</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,blo;</span><br><span class="line"><span class="type">int</span> v[<span class="number">50005</span>],bl[<span class="number">50005</span>],atag[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//修改每个元素的值</span></span><br><span class="line">    <span class="comment">//从a开始</span></span><br><span class="line">    <span class="comment">//如果a与b属于同一块，那么直接修改即可</span></span><br><span class="line">    <span class="comment">//不属于同一块，修改从a开始，到a所在块的右边界的区间元素，暴力修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">        v[i]+=c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断a与b是否处于同一块中</span></span><br><span class="line">    <span class="comment">//不属于同一块</span></span><br><span class="line">    <span class="comment">//修改从b所在块的左边界开始，到b的区间元素，暴力修改</span></span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">            v[i]+=c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a到b之间的元素块整块加值</span></span><br><span class="line">    <span class="comment">//如果a与b位于同一个块内，则不会进入循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">        atag[i]+=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//n表示有多少个元素，blo表示的分块的大小</span></span><br><span class="line">    n=<span class="built_in">read</span>();blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读入n个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将每个元素分配到对应的块中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)bl[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n表示n次操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//f表示操作的类型，a表示区间的左端点，b表示区间的右端点，c表示加上的值</span></span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//区间修改</span></span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)<span class="built_in">add</span>(a,b,c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//单点查询，这里的b表示查询的单点值</span></span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,v[b]+atag[bl[b]]);</span><br><span class="line">            cout&lt;&lt;v[b]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;atag[bl[b]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="入门2">入门2</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的元素个数。</strong></p><p>有了上一题的经验，我们可以发现，数列简单分块问题实际上有三项东西要我们思考：</p><p>对于每次区间操作：</p><p>1.<strong>不完整的块</strong> 的$O(\sqrt{n})$个元素怎么处理？</p><p>2.$O(\sqrt{n})$个 <strong>整块</strong> 怎么处理？</p><p>3.要预处理什么信息（复杂度不能超过后面的操作）？</p><p>我们先来思考只有询问操作的情况，不完整的块枚举统计即可；而要在每个整块内寻找小于一个值的元素数，于是我们不得不要求块内元素是有序的，这样就能使用二分法对块内查询，需要预处理时每块做一遍排序，复杂度$O(nlog\ n)$，每次查询在$\sqrt{n}$个块内二分，以及暴力$2\sqrt{n}$个元素，总复杂度$O(nlog\ n+n\sqrt{n}log\sqrt{n})$。</p><p><strong>可以通过均值不等式计算出更优的分块大小，就不展开讨论了</strong></p><p>那么区间加怎么办呢？</p><p>套用第一题的方法，维护一个加法标记，略有区别的地方在于，不完整的块修改后可能会使得该块内数字乱序，所以头尾两个不完整块需要重新排序，复杂度分析略。</p><p>在加法标记下的询问操作，块外还是暴力，查询小于（x – 加法标记）的元素个数，块内用（x – 加法标记）作为二分的值即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> aa[MAXN],be[MAXN],tag[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[MAXN];</span><br><span class="line"><span class="type">int</span> n,block;</span><br><span class="line"><span class="comment">//重构</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先清空数组</span></span><br><span class="line">    v[x].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对该块内的元素进行重构</span></span><br><span class="line">    <span class="comment">//注意最后一块可能不是完整的一块 所以需要取min(n,x*block)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(x<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(n,x*block);i++)&#123;</span><br><span class="line">        v[x].<span class="built_in">push_back</span>(aa[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对块中的元素进行重构 排序 方便后续的二分查找</span></span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(),v[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//修改从a到b的区间内的元素</span></span><br><span class="line">    <span class="comment">//可能从a到b会跨块 所以取min(be[a]*block,b)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(b,be[a]*block);i++)&#123;</span><br><span class="line">        aa[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重构块</span></span><br><span class="line">    <span class="built_in">reset</span>(be[a]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 那么需要重构b所在的块</span></span><br><span class="line">    <span class="comment">//注意是从b所在块的左边开始重构</span></span><br><span class="line">    <span class="keyword">if</span>(be[a]!=be[b])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(be[b]<span class="number">-1</span>)*block+<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">            aa[i]+=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//别忘了重构块</span></span><br><span class="line">        <span class="built_in">reset</span>(be[b]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对从a到b之间的块进行重构</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 则需要将位于它们之间的块打上标记</span></span><br><span class="line">    <span class="comment">//注意不需要重构块 因为块中的元素值都加上了c</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=be[a]+<span class="number">1</span>;i&lt;=be[b]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        tag[i]+=c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//查询从a到b的区间内大于c的元素</span></span><br><span class="line">    <span class="comment">//可能从a到b会跨块 所以取min(be[a]*block,b)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(be[a]*block,b);i++)&#123;</span><br><span class="line">        <span class="comment">//be[a]改成be[i]可行吗</span></span><br><span class="line">        <span class="comment">//可行</span></span><br><span class="line">        <span class="keyword">if</span>(aa[i]+tag[be[i]]&lt;c)ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断a与b是否位于同一块</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 那么需要重构b所在的块</span></span><br><span class="line">    <span class="comment">//注意这里只是询问，不需要重构</span></span><br><span class="line">    <span class="keyword">if</span>(be[a]!=be[b])&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=block*(be[b]<span class="number">-1</span>)+<span class="number">1</span>;i&lt;=b;i++)&#123;</span><br><span class="line">            <span class="comment">//be[b]改成be[i]也可行</span></span><br><span class="line">            <span class="keyword">if</span>(aa[i]+tag[be[i]]&lt;c)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对从a到b之间的块进行重构</span></span><br><span class="line">    <span class="comment">//如果a与b不属于同一块 则需要将位于它们之间的块中的元素进行二分查找</span></span><br><span class="line">    <span class="comment">//注意不需要重构块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=be[a]+<span class="number">1</span>;i&lt;=be[b]<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x=c-tag[i];</span><br><span class="line">        ans+=<span class="built_in">lower_bound</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>(),x)-v[i].<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回答案</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>),cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">// 输入n个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;aa[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分块大小确定</span></span><br><span class="line">    block=<span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个数确定其对应的块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        be[i]=(i<span class="number">-1</span>)/block+<span class="number">1</span>;</span><br><span class="line">        v[be[i]].<span class="built_in">push_back</span>(aa[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每个块内的元素进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=be[n];i++)&#123;</span><br><span class="line">        <span class="comment">//wsm要重构</span></span><br><span class="line">        <span class="comment">//为了后面询问的需要，我们使用的是二分查找，但是不一定所有的块都会被重构</span></span><br><span class="line">        <span class="comment">// 所有我们需要提前对每个块进行重构 也就是对块中的元素进行排序</span></span><br><span class="line">        <span class="built_in">sort</span>(v[i].<span class="built_in">begin</span>(),v[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n此询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> f,a,b,c;cin&gt;&gt;f&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)<span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)cout&lt;&lt;<span class="built_in">query</span>(a,b,c*c)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="入门3">入门3</h2><p><strong>给出一个长为n的数列，以及n个操作，操作涉及区间加法，询问区间内小于某个值x的前驱（比其小的最大元素）。</strong></p><p>n&lt;=100000其实是为了区分暴力和一些常数较大的写法。</p><p>接着第二题的解法，其实只要把块内查询的二分稍作修改即可。</p><p>不过这题其实想表达：可以在块内维护其它结构使其更具有拓展性，比如放一个 <strong>set</strong> ，这样如果还有插入、删除元素的操作，会更加的方便。</p><p><strong>分块的调试检测技巧：</strong></p><p>可以生成一些大数据，然后用两份分块大小不同的代码来对拍，还可以根据运行时间尝试调整分块大小，减小常数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN], be[MAXN], tag[MAXN];</span><br><span class="line"><span class="type">int</span> n, block;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s[<span class="number">1050</span>];</span><br><span class="line"><span class="comment">//修改加值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= <span class="built_in">min</span>(y, be[x]*block); i++) &#123;</span><br><span class="line">        <span class="comment">//需要先删除 再修改元素 再存入块中</span></span><br><span class="line">        s[be[i]].<span class="built_in">erase</span>(a[i]);</span><br><span class="line">        a[i] += z;</span><br><span class="line">        s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">if</span> (be[x] != be[y]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = block * (be[y] - <span class="number">1</span>) + <span class="number">1</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            s[be[i]].<span class="built_in">erase</span>(a[i]);</span><br><span class="line">            a[i] += z;</span><br><span class="line">            s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跨块 整块加上标记</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = be[x] + <span class="number">1</span>; i &lt;= be[y] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        tag[i] += z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//询问</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="comment">//注意这里的val是值+标记</span></span><br><span class="line">    <span class="comment">//a[i]如果被修改了 则一定不会被加上tag</span></span><br><span class="line">    <span class="comment">//若加上tag 则不会被加上值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= <span class="built_in">min</span>(y, be[x]*block); i++) &#123;</span><br><span class="line">        <span class="type">int</span> val = a[i] + tag[be[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val &lt; z)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一样的情况</span></span><br><span class="line">    <span class="keyword">if</span> (be[x] != be[y]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = block * (be[y] - <span class="number">1</span>) + <span class="number">1</span>; i &lt;= y; i++) &#123;</span><br><span class="line">            <span class="type">int</span> val = a[i] + tag[be[i]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (val &lt; z)</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//跨块</span></span><br><span class="line">    <span class="comment">//注意num得改为z-tag[i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = be[x] + <span class="number">1</span>; i &lt;= be[y] - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> num = z - tag[i];</span><br><span class="line">        <span class="comment">//找到第一个值为num的元素 因为set是自动排序的</span></span><br><span class="line">        set&lt;<span class="type">int</span>&gt;::iterator it = s[i].<span class="built_in">lower_bound</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找不到则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (it == s[i].<span class="built_in">begin</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记得要找比它小的 所以要减1</span></span><br><span class="line">        --it;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, *it + tag[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>), cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//获取分块大小</span></span><br><span class="line">    block = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分块 将元素加到对应的块中</span></span><br><span class="line">    <span class="comment">// 这里的块用堆实现</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        be[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>;</span><br><span class="line">        s[be[i]].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n次操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> f, x, y, z;</span><br><span class="line">        cin &gt;&gt; f &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">query</span>(x, y, z) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始Qt</title>
      <link href="/posts/9d331126.html"/>
      <url>/posts/9d331126.html</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-初识Qt">第1章 初识Qt</h2><h3 id="1-1-Qt简介">1.1 Qt简介</h3><p>这一部分跳过</p><h3 id="1-2-Qt的安装">1.2 Qt的安装</h3><p>这一部分跳过</p><h3 id="1-3-Qt的编写一个Hello-World程序">1.3 Qt的编写一个Hello World程序</h3><p>这里涉及到了很多专业知识，打算写一下，但是内容太多了，后续找找看有没有比较好的电子书可以下载的。</p><p>只找到了Qt5.9的电子书，先凑合吧。</p><p>前面涉及到的基本是Qt的页面介绍，以及如何创建一个新项目。</p><p>具体看看这里：<a href="https://github.com/BomLook/QT-1/blob/master/QT%E7%AC%94%E8%AE%B0%E5%90%88%E9%9B%86.md">Qt快速入门</a>。</p><p>接下来就是按照书上的要求一步一步操作了，如下：（其实就是简单的贴上一些东西）</p><p><img src="https://img2.imgtp.com/2024/04/07/OamnrBHC.png" alt=""></p><p>效果如下：</p><p><img src="https://img2.imgtp.com/2024/04/07/Ig3bXmob.png" alt=""></p><p>但是在Run时遇到一点小问题，我一开始在给项目设置开发套件的时候，点得太快，可能导致全部的开发套件都选上了。</p><p>一开始用的是MSVC2019，但是这个时候就提示not exist。尝试改成用Min-GW开发套件就可以了。</p><p><img src="https://img2.imgtp.com/2024/04/07/ZknftNPF.png" alt=""></p><p>补充一点，由于一开始的时候是中文版本，由于翻译的问题，中文的内容可能不够准确，所以建议使用英文页面。</p><p>这里书上给的是点击Tool-Option进行修改。但在新版本中，需要点击Edit-Preference-Environment来进行修改。</p><p>基本就这样，没了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt6 C++开发指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载：string类</title>
      <link href="/posts/6c3ccb6a.html"/>
      <url>/posts/6c3ccb6a.html</url>
      
        <content type="html"><![CDATA[<h1 id="C-How-to-Program">C++ How to Program</h1><h2 id="运算符重载：string类">运算符重载：string类</h2><p>主要包含string类的一些函数，具体可以看黑马的STL部分，这里不重复了。</p><p>主要注意以下部分：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s1)</span></span>;</span><br><span class="line"><span class="comment">//这是调用string类的拷贝构造函数，并s1的副本对其进行初始化。</span></span><br><span class="line"></span><br><span class="line">s4=s2;</span><br><span class="line"><span class="comment">//这是string类重载的&quot;=&quot;运算符，可以进行正确的赋值操作，正确处理自我赋值的情况，详情以后补充。</span></span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">cout&lt;&lt;s[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;s[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//这里是重载[]来访问string中的元素，注意这不会进行任何越界检查（也就是有越界的风险）</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s.<span class="built_in">at</span>(<span class="number">0</span>)&lt;&lt;s.<span class="built_in">at</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//at函数与上述[]一样，但是会检查是否在有效范围之内（越界会抛出error）</span></span><br></pre></td></tr></table></figure><h3 id="运算符重载的基本知识">运算符重载的基本知识</h3><p>通过像往常编写非静态成员函数或者非成员函数定义就可以实现运算符的重载，只不过现在的名字是operator加上重载的运算符。这些函数必须由类的对象来调用，并作用到这个对象上。</p><p>有如下的三个例外：<br>1、绝大多数类可以使用=对其数据成员进行逐个赋值操作，但是我们前面说到，如果数据成员包含指针，这将带来严重的问题。</p><p>因此，我们将显式地重载赋值运算符。</p><p>2、取址（&amp;）运算符返回对象的地址，这个运算符也能被重载。</p><p>3、逗号（，）运算符从左到右对表达式进行求值，并返回表达式的值，也可以重载。</p><h4 id="不能被重载的运算符">不能被重载的运算符</h4><p>以下四个</p><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>.</td><td>.*</td><td>::</td><td>?:</td></tr></tbody></table><p>第二个是pointer to member。</p><h4 id="重载运算符的规则和限制">重载运算符的规则和限制</h4><p>1、优先级不变。（当然圆括号可以改变表达式中重载运算符的求值顺序）</p><p>2、结合性不变。（如果是从左到右结合，那么它的重载版本仍是这样）</p><p>3、元数不变。（也就是一元运算符，还是二元运算符保持不变，特别的是&amp;，+，-，*即可作为一元、也可以作为二元，这些一元和二元的版本都可以被单独重载）。</p><p>4、不能创造新的运算符，只能重载现有运算符。</p><p>5、运算符作用在基本类型上的方法不可以被重载改变（比方说+不可以称之为两个int相减）。</p><p>运算符重载仅限于用户定义类型或者用户定义类型和基本类型的混合。</p><p>6、关系运算符必须被单独重载。</p><p>7、重载（）、[]、-&gt;或者任何赋值运算符时，重载函数都必须声明为类成员，其他无所谓。</p><p>建议：</p><p>对类类型进行运算符重载，应该使得重载的运算符尽可能仿效内置运算符对基本类型的作用方式。</p><h3 id="二元运算符的重载">二元运算符的重载</h3><p>有两种：<br>1、带有一个参数的非静态成员函数。</p><p>2、带有两个参数的非成员函数（需要被声明为类的友元）。</p><h4 id="作为成员函数的二元重载运算符">作为成员函数的二元重载运算符</h4><p>仅当左操作数是该类的对象，且重载函数是一个成员时，二元运算符的重载函数才能作为成员函数。</p><p>注意左操作数是调用该成员函数的对象。</p><h4 id="作为非成员函数的二元重载运算符">作为非成员函数的二元重载运算符</h4><p>必须带有两个参数，其中一个必须是与重载运算符有关系的类对象或者是类对象的引用，例子如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> String&amp;,<span class="type">const</span> String&amp;);</span><br></pre></td></tr></table></figure><h3 id="重载二元流插入运算符和流提取运算符">重载二元流插入运算符和流提取运算符</h3><p>可以实现用户自定义的输入和输出。</p><p>这里通过例子简单见到介绍一下注意事项：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;output,<span class="type">const</span> PhoneNumber &amp;number)</span><br><span class="line">&#123;</span><br><span class="line">    output&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;number.areaCode&lt;&lt;<span class="string">&quot;)&quot;</span></span><br><span class="line">        &lt;&lt;number.exchange&lt;&lt;<span class="string">&quot;-&quot;</span>&lt;&lt;number.line;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;input,PhoneNumber &amp;number)</span><br><span class="line">&#123;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">4</span>)&gt;&gt;number.areaCode;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">5</span>)&gt;&gt;number.exchange;</span><br><span class="line">    input&gt;&gt;<span class="built_in">setw</span>(<span class="number">6</span>)&gt;&gt;number.line;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到函数的返回值都是引用，这样才可以实现级联调用（这和前面的串联调用很像）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PhoneNumber t1,t2; </span><br><span class="line">cin&gt;&gt;t1&gt;&gt;t2;</span><br></pre></td></tr></table></figure><p>因为该类的对象在全局中只能有一个，所以参数列表中的第一个参数都是以引用的形式传递的（流对象不能复制，只能引用）。</p><p>ostream也是同理，注意只能用非成员函数实现，因为如果用非静态成员函数实现：那么调用该成员函数的对象将位于重载运算符的左边，与实际要求矛盾。</p><p>这里的setw限制了读到每个字符数组的字符个数，如setw(n)设置允许读入n个字符。</p><p>istream还有一个ignore函数：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream &amp;input;</span><br><span class="line">input.<span class="built_in">ignore</span>()</span><br><span class="line"><span class="comment">//将圆括号、空格、破折号等字符全部跳过。</span></span><br><span class="line"><span class="comment">//ignore丢弃输入流中指定个数的字符（默认为一个字符）。</span></span><br></pre></td></tr></table></figure><h4 id="重载流插入-运算符">重载流插入(&lt;&lt;)运算符</h4><p>和上面基本一致。</p><h4 id="作为非成员友元函数的重载运算符">作为非成员友元函数的重载运算符</h4><p>这个已经在前面解释过了，不再多解释。</p><h4 id="为什么流插入和流提取运算符必须被重载为非成员函数">为什么流插入和流提取运算符必须被重载为非成员函数</h4><p>这个已经在前面解释过了，不再多解释。</p><p>假设一定要用成员函数，那么得修改C++标准库中的数据类型，这是非常危险的（也不允许）。</p><h3 id="重载一元运算符">重载一元运算符</h3><p>有两种（就是上面说的两种）。</p><h5 id="作为成员函数的一元重载运算符">作为成员函数的一元重载运算符</h5><p>以重载!为例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!()<span class="type">const</span>;</span><br></pre></td></tr></table></figure><p>这样，当编译器遇到表达式!s时，将会生成函数调用s.operator!()。</p><h4 id="作为非成员函数的一元重载运算符">作为非成员函数的一元重载运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!(<span class="type">const</span> String &amp;)</span><br></pre></td></tr></table></figure><p>!s将被处理为operator!()。</p><h3 id="重载一元前置和后置运算符：-和–">重载一元前置和后置运算符：++和–</h3><p>自增自减运算符的前置和后置形式都可以进行重载，下面以自增为例介绍如何区分前置和后置形式。</p><p>为了使得编译器能够正确地识别要使用的是哪一种++模式，每个重载地运算符函数都必须有各自明显的特征。</p><p>假设前置的自增运算符为我们Date对象d1的天数+1。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line">Date &amp;<span class="keyword">operator</span>++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非静态成员函数</span></span><br><span class="line"><span class="comment">//当编译器遇到：++d1时，等价于</span></span><br><span class="line">d1.<span class="keyword">operator</span>++()。</span><br><span class="line"></span><br><span class="line"><span class="comment">//非成员函数类型</span></span><br><span class="line"><span class="comment">//编译器遇到++d1，等价于</span></span><br><span class="line"><span class="keyword">operator</span>++(d1)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在类中的声明为</span></span><br><span class="line">Date &amp;<span class="keyword">operator</span>++(Date &amp;);</span><br></pre></td></tr></table></figure><h4 id="重载后置的自增运算符">重载后置的自增运算符</h4><h5 id="非静态成员函数类型">非静态成员函数类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//编译器遇到表达式d1++时。</span><br><span class="line">//调用如下：</span><br><span class="line">d1.operator++(0)</span><br><span class="line"></span><br><span class="line">//对应的函数原型为</span><br><span class="line">Date operator++(int)</span><br></pre></td></tr></table></figure><p>这里的0其实是个哑巴，只是为了让编译器能够区分前置和后置而已。</p><h5 id="非成员函数类型">非成员函数类型</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数调用</span><br><span class="line">operator++(d1,0);</span><br><span class="line"></span><br><span class="line">//函数原型</span><br><span class="line">Date operator(Date &amp;,int);</span><br></pre></td></tr></table></figure><p>这里的0作用和上面一样。</p><p>注意：后置的运算符按值返回对象，而前置的运算符按引用返回对象。这是因为在自增前，后置的运算符通常先返回一个包含对象原始数据的临时对象，C++将其作为右值，不能用在赋值运算符的左侧。前置的自增运算符返回实际自增后的具有新值的对象，可以放在赋值运算符的左侧。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        num=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="function">node <span class="title">tmp</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">        num=num+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    node a;</span><br><span class="line">    node b;</span><br><span class="line">    b=a++;</span><br><span class="line">    b.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">//输出为1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议：使用前置的自增或者自减运算符，后置会对性能造成更大的影响。</p><h3 id="实例研究：Date类">实例研究：Date类</h3><p>（跳过）</p><p>注意不能返回局部变量的引用，否则会编译错误（因为可能该对象被析构了）。</p><h3 id="动态内存管理">动态内存管理</h3><p>通过运算符new和delete实现。</p><p>可以使用new运算符在执行期间为对象或者数组动态分配所需要的内存，对象和数组被存储在堆中（这是一个专门用来存储动态分配对象的内存区域）。一旦内存中的自由存储区被分配，那么就可以通过new运算符返回的指针进行访问。当不再需要内存时，则可以使用delete来释放内存，从而内存返回给堆区，以便供将来的new操作复用。</p><h4 id="使用new来动态获取内存">使用new来动态获取内存</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time *timePtr=<span class="keyword">new</span> <span class="built_in">Time</span>();</span><br></pre></td></tr></table></figure><p>上面的new运算符为一个Time类型的对象分配大小合适的内存空间，调用默认的构造函数来初始化这个对象并返回一个指向new运算符右侧类型的指针（也即是Time*）。</p><p>如果new无法在内存中为该对象找到足够的空间，则会抛出异常（一般会抛出一个bad_alloc异常）。</p><h4 id="使用delete动态释放内存">使用delete动态释放内存</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> timePtr;</span><br></pre></td></tr></table></figure><p>这将先调用timePtr指向对象的析构函数，早收回对象所占用的内存空间，把内存返回给自由存储区。</p><p>注意：</p><p>1、当动态内存分配的空间不再使用时，要及时释放。</p><p>2、不要删除不是new分配的内存。</p><p>3、delete一个动态分配的内存块后确保不要对同一块内存再次delete，一个建议是：立即将delete过的指针的值设置为nullptr，delete一个nullptr是没有影响的。</p><p>补充：可以重载new和delete运算符，两者必须在同一作用域内重载。（以后再详细补充）</p><h4 id="动态内存的初始化">动态内存的初始化</h4><p>可以为新建立的基本类型变量提供初始化值：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> *ptr=<span class="keyword">new</span> <span class="built_in">double</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure><p>同样的语法也可以用来将由逗号分隔开的参数列表指定给对象的构造函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time *timePtr=<span class="keyword">new</span> <span class="built_in">Time</span>(<span class="number">12</span>,<span class="number">45</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="使用new-动态分配内置数组">使用new[]动态分配内置数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *Array=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();</span><br></pre></td></tr></table></figure><p>这声明了一个指针Array，并将指向一个动态分配的10元素的整数数组第一个元素的指针赋给它。</p><p>new int[10]值后面的括号初始化数组元素——基本数据类型设置为0，bool为flase，指针为nullptr，对象则通过其默认构造函数进行初始化，注意：在编译时确定数组的大小时必须用常量整数表达式确定，动态分配数组的大小可以用在执行期间求值的任何非负整数表达式来指定。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ld long double</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;cin&gt;&gt;a;</span><br><span class="line">    <span class="type">int</span> *ptr=<span class="keyword">new</span> <span class="type">int</span>[a];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        cin&gt;&gt;*(ptr+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a;i++)&#123;</span><br><span class="line">        cout&lt;&lt;*(ptr+i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//样例</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h4 id="C-11使用列表初始化动态分配内存的数组">C++11使用列表初始化动态分配内存的数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>默认初始化列表——对基本类型来说，就是将每个元素置为0。</p><h4 id="使用delete-动态释放内置数组">使用delete[]动态释放内置数组</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> []Array;</span><br></pre></td></tr></table></figure><p>注意：如果上面语句中的指针指向一个内置数组，则语句先调用数组中每个对象的析构函数，后回收空间。</p><p>如果不包含[]，且指针指向一个对象的数组，则结果是未知的，可能会只为数组的首对象调用析构函数。</p><p>对空指针进行delete，或者delete[]操作并无任何效果。</p><h4 id="C-11使用unique-ptr管理动态分配的内存">C++11使用unique_ptr管理动态分配的内存</h4><p>unique_ptr是一个智能指针，当一个unique_ptr超出范围时，它的析构函数将自动把其管理的内存返还到自由存储区中。</p><h3 id="实例研究：Array类">实例研究：Array类</h3><p>（跳过）</p><h3 id="运算符作为成员函数或非成员函数的比较">运算符作为成员函数或非成员函数的比较</h3><p>一个特定类的运算符成员函数仅在以下两种情形中被调用，当二元运算符的左操作数是该类的对象时，或者一元运算符唯一的操作数是该类的对象时。</p><h4 id="可交换的运算符">可交换的运算符</h4><p>一般由非成员函数实现，这样可以使得运算符具有交换性。</p><h3 id="类型转换">类型转换</h3><p>程序员必须指出如何转换，编译器才能执行。</p><h4 id="转换运算符">转换运算符</h4><p>又称为强制类型转换运算符，可用于将某一类的对象转换为另外一个类的对象，这种转换运算符必须是非static成员函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass::<span class="keyword">operator</span> <span class="type">char</span> *()<span class="type">const</span></span><br></pre></td></tr></table></figure><p>可以将用户自定义吧类型Myclass的对象转换为一个临时的char*对象，这个运算符函数声明为const，因为不修改原始的对象。</p><p>不需要指定转换类型，因为返回类型就时目标类型。</p><p>当编译器遇到：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(s);</span><br></pre></td></tr></table></figure><p>会产生函数调用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="keyword">operator</span> <span class="type">char</span>*();</span><br></pre></td></tr></table></figure><p>这将把操作数转换为char*类型。</p><h4 id="重载强制类型转换运算符">重载强制类型转换运算符</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span><span class="type">const</span></span>;</span><br><span class="line"><span class="function">MyClass::<span class="keyword">operator</span> <span class="title">OtherClass</span><span class="params">()</span><span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h4 id="强制类型转换运算符和转换构造函数的隐式调用">强制类型转换运算符和转换构造函数的隐式调用</h4><p>两者优点之一是：必要时，编译器可以隐式地调用这些函数来创建临时的对象。</p><p>如：String类的对象s出现在本来一个应该出现字符数组char*的位置上，那么</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;s</span><br></pre></td></tr></table></figure><p>编译器可以使用重载的强制类型转换运算符operator char*将对象转换为char *,并在表达式中使用这个转换结果char *。</p><p>这样就可以不必重载&lt;&lt;运算符了。</p><h3 id="explicit构造函数与转换运算符">explicit构造函数与转换运算符</h3><p>任何单参数且不被声明为explict的构造函数可以被编译器识别用来进行隐式类型转换，除了拷贝构造函数。</p><p>构造函数中的实参被转换为函数中定义的类对象，这种转换是自动进行的。</p><p>但某种情况下，这样会带来麻烦和问题。从而产生歧义。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Array <span class="title">integers</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="built_in">outArray</span>(integers);</span><br><span class="line"><span class="built_in">outArray</span>(<span class="number">3</span>);<span class="comment">//发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outArray</span><span class="params">(<span class="type">const</span> Array &amp;arrayOutPut)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下数组中的元素都为0。</p><p>本来，第一行是创建了一个integers的Array类对象（有7个元素，默认为0），然后输出。</p><p>但是由于没有提供接受一个int作为参数的outArray函数，所以编译器先确定Array类是否提供了一个将int转换为Array的转换构造函数，由于任何接受单参数的构造函数都可以被认为是转换构造函数，所以编译器认为接受单个int参数的Array构造函数是一个转换构造函数，并将参数3转换为一个包含了3个元素的临时Array对象，然后再将它传递给函数outArray，输出内容。乌龙就这么产生了。</p><p>为了解决这个问题，所以有了关键字explicit。</p><h4 id="防止无意中调用将单参数的构造函数作为转换构造函数">防止无意中调用将单参数的构造函数作为转换构造函数</h4><p>我们在声明每个单参数的构造函数时，前面加上explicit关键字，目的是禁止不应该允许的由转换构造函数完成的隐式转换。</p><p>这样上面的程序应该修改为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Array <span class="title">integers</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line"><span class="built_in">outArray</span>(integers);</span><br><span class="line"><span class="built_in">outArray</span>(<span class="number">3</span>);<span class="comment">//不会发生隐式类型转换，会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">outArray</span>(<span class="built_in">Array</span>(<span class="number">3</span>))<span class="comment">//显式转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">outArray</span><span class="params">(<span class="type">const</span> Array &amp;arrayOutPut)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了问题。</p><p>建议在单参数的构造函数中总是使用explicit关键字，除非打算将它们用作转换构造函数。</p><h4 id="C-11：explicit转换运算符">C++11：explicit转换运算符</h4><p>同样，也可以声明explicit的转换运算符来防止编译器使用它们进行隐式转换。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explicit</span> MyClass::<span class="keyword">operator</span> <span class="type">char</span>*()<span class="type">const</span> </span><br></pre></td></tr></table></figure><h3 id="重载函数调用运算符">重载函数调用运算符</h3><p>这个非常灵活多变，也非常重要，因为函数能够接受任意数量的逗号分隔参数。</p><p>举个例子：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">String::operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> index,<span class="type">size_t</span> length)</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure><p>这里想要的是检查起始位置越界或者负长度的功能，注意必须是一个const成员变量，不应该修改原始的String对象。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String s1=<span class="string">&quot;AEIOU&quot;</span>;</span><br><span class="line">s1.<span class="built_in">operator</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这将会得到字串&quot;IOU&quot;。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类的深入剖析：抛出异常</title>
      <link href="/posts/2e0f1faa.html"/>
      <url>/posts/2e0f1faa.html</url>
      
        <content type="html"><![CDATA[<h2 id="类的深入剖析：抛出异常">类的深入剖析：抛出异常</h2><h3 id="Time类实例研究">Time类实例研究</h3><h4 id="Time类的定义">Time类的定义</h4><p>这里涉及到一个C++软件工程的概念：在头文件中使用“包含防护”，从而避免头文件中的代码被多次包含到同一个源代码文件中的情况，具体写法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_H</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这里详细解释一下：</p><p>在构建大型程序时，头文件中还会放入其他的定义和声明。</p><p>当前述的“包含防护”在TIME_H已被定义时，可以阻止将#ifndef和#endif之间的代码包含到文件中。</p><p>如果在这些指令之间的代码先前没有包含到应用程序中，那么TIME_H这个名字将会被#define定义，并且包含该头文件的语句。</p><p>如果已经包含，那么TIME_H已经有定义，将不会包含该头文件。</p><p>建议：<br>1、使用预处理器指令#ifndef、#define、#endif等构成包含防护，从而避免头文件在一个程序中被多次包含。</p><p>2、按照惯例，在#ifndef和#define中，应该使用大写的头文件名，并且用下划线代替圆点。</p><h3 id="Time类的成员函数">Time类的成员函数</h3><p>可以使用类内初始化器，在类定义中声明为任何数据成员之处对此数据成员进行初始化。</p><p>其实就是{}：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(): a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; &#123;<span class="comment">//具体的实现逻辑&#123;&#125; //C++11, 初始化数组成员  </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Time类的成员函数setTime和异常的抛出">Time类的成员函数setTime和异常的抛出</h4><p>看以下这条语句：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;error&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里，throw语句创建了一个类型为invalid_argument的新对象，而跟在类名称后面的圆括号表示对该invalid_argument对象构造函数的一个调用，这里需要加入头文件#include<stdexcept>。</p><h4 id="Time类的成员函数printUniversal">Time类的成员函数printUniversal</h4><p>这里注意一个setfill流操作符。可以用于指定当输出域宽大于输出整数值中的数字个数时所需要的显示的填充字符。</p><p>默认情况下，数的输出是右对齐的，那么填充字符出现在数中数字的左边，如果是左对齐，则出现在右边。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>)&lt;&lt;<span class="built_in">setw</span>(<span class="number">3</span>)&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>输出结果为001。</p><p>如果将要输出的数填满了指定的域宽，则不显示填充字符。</p><p>注意：一旦使用了setfill指定了填充字符，则该字符将应用在后续的显示中，只要显示的域宽大于要被显示数所需要的的实际宽度。（实际上setfill是一个黏性设置，当每个黏性设置不再需要使用时，则应当将它恢复到以前的模式，否则在后续中输出可能会存在问题）。</p><h4 id="Time类的成员函数printStandard">Time类的成员函数printStandard</h4><p>还是上面一样的问题，跳过。</p><h4 id="在类定义外部定义成员函数与类的作用域">在类定义外部定义成员函数与类的作用域</h4><p>即使声明在类定义中的成员函数可以在类定义的外部定义（并且通过二元作用域分辨运算符“绑定”到该类），这样的成员函数仍在该类的作用域中。（二元作用域分辨运算符就是::）</p><h4 id="成员函数与全局函数（又称自由函数）">成员函数与全局函数（又称自由函数）</h4><p>跳过，讲的是成员函数的优点。</p><h4 id="使用Time类">使用Time类</h4><p>定义了一个类，即可将他用于对象，数组，指针，引用中：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time sunset;</span><br><span class="line">array&lt;Time,5&gt;arrayOfTimes;</span><br><span class="line">Time &amp;dinnerTime=sunset;</span><br><span class="line">Time *timePtr=&amp;dinnerTime;</span><br></pre></td></tr></table></figure><h4 id="用无效值调用setTime">用无效值调用setTime</h4><p>主要涉及try…catch语句。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try语句块是用来判断是否有异常；</p><p>catch语句块捕捉异常，并进行处理；</p><p>throw是抛出异常；</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">fuc</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>                        <span class="comment">//定义函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> y;                                    <span class="comment">//除数为0，抛出异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x/y;                                    <span class="comment">//否则返回两个数的商</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> res;</span><br><span class="line">    <span class="keyword">try</span>                                            <span class="comment">//定义异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        res=<span class="built_in">fuc</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;The result of x/y is : &quot;</span>&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">        res=<span class="built_in">fuc</span>(<span class="number">4</span>,<span class="number">0</span>);                                <span class="comment">//出现异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span>(<span class="type">double</span>)                                    <span class="comment">//捕获并处理异常</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;error of dividing zero.\n&quot;</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);                                    <span class="comment">//异常退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里转载自：[C++：try catch语句用法_c++ try catch用法-CSDN博客](<a href="https://blog.csdn.net/sss_369/article/details/92179738?ops_request_misc=%7B%22request%5Fid%22%3A%22171225794616800188521498%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=171225794616800188521498&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-92179738-null-null.142%5Ev100%5Epc_search_result_base6&amp;utm_term=c%2B%2B">https://blog.csdn.net/sss_369/article/details/92179738?ops_request_misc={&quot;request_id&quot;%3A&quot;171225794616800188521498&quot;%2C&quot;scm&quot;%3A&quot;20140713.130102334..&quot;}&amp;request_id=171225794616800188521498&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-92179738-null-null.142^v100^pc_search_result_base6&amp;utm_term=c%2B%2B</a> try catch用法&amp;spm=1018.2226.3001.4187)</p><p>一般格式如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="keyword">try</span></span><br><span class="line">　　&#123;</span><br><span class="line">　　　　<span class="comment">// 这里的程序代码完成真正复杂的计算工作，这些代码在执行过程中</span></span><br><span class="line">　　　　<span class="comment">// 有可能抛出DataType1、DataType2和DataType3类型的异常对象。</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType1&amp; d1)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType2&amp; d2)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">catch</span>(DataType3&amp; d3)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="comment">/*********************************************************</span></span><br><span class="line"><span class="comment">　　注意上面try block中可能抛出的DataType1、DataType2和DataType3三</span></span><br><span class="line"><span class="comment">　　种类型的异常对象在前面都已经有对应的catch block来处理。但为什么</span></span><br><span class="line"><span class="comment">　　还要在最后再定义一个catch(…) block呢？这就是为了有更好的安全性和</span></span><br><span class="line"><span class="comment">　　可靠性，避免上面的try block抛出了其它未考虑到的异常对象时导致的程</span></span><br><span class="line"><span class="comment">　　序出现意外崩溃的严重后果，而且这在用VC开发的系统上更特别有效，因</span></span><br><span class="line"><span class="comment">　　为catch(…)能捕获系统出现的异常，而系统异常往往令程序员头痛了，现</span></span><br><span class="line"><span class="comment">　　在系统一般都比较复杂，而且由很多人共同开发，一不小心就会导致一个</span></span><br><span class="line"><span class="comment">　　指针变量指向了其它非法区域，结果意外灾难不幸发生了。catch(…)为这种</span></span><br><span class="line"><span class="comment">　　潜在的隐患提供了一种有效的补救措施。</span></span><br><span class="line"><span class="comment">　　*********************************************************/</span></span><br><span class="line"> </span><br><span class="line">　　<span class="built_in">catch</span>(…)</span><br><span class="line">　　&#123;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以再看看这篇文章深究：<a href="https://www.cnblogs.com/MrYuan/p/4800257.html">c++中try catch的用法 - 超酷小子 - 博客园 (cnblogs.com)</a>。</p><h4 id="组成和继承概念介绍">组成和继承概念介绍</h4><p>组成：包含类对象作为其他类的成员。</p><p>继承：从已有的类派生出来的新的类。</p><h4 id="对象大小">对象大小</h4><p>实际上，对象只包含数据。编译器只创建独立于类的所有对象的一份成员函数的副本，该类的所有对象都共享这份副本。</p><h3 id="类的作用域和类成员的访问">类的作用域和类成员的访问</h3><p>类的数据成员和成员函数都属于该类的作用域。默认情况下，非成员函数在全局命名空间作用域中定义。</p><h4 id="类作用域和块作用域">类作用域和块作用域</h4><p>成员函数中声明的变量具有块作用域，只有该函数知道他们。如果成员函数定义了与类作用域内变量同名的另外一个变量，则函数中块作用域中的变量将隐藏在类作用域中的变量，需要使用类名+::进行访问。</p><h4 id="圆点成员选择运算符-和箭头成员选择运算符">圆点成员选择运算符(.)和箭头成员选择运算符(-&gt;)</h4><p>(.)前面+对象名、对象引用，则可以直接访问该对象的成员。</p><p>(-&gt;)前面+对象指针，则可以访问该对象的成员。</p><p>示例如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Account account;</span><br><span class="line">Account &amp;accountRef;</span><br><span class="line">Account *accountPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用如下</span></span><br><span class="line">account.<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br><span class="line">accountRef.<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br><span class="line">accountPtr-&gt;<span class="built_in">setBalance</span>(<span class="number">12345</span>);</span><br></pre></td></tr></table></figure><h3 id="访问函数与工具函数">访问函数与工具函数</h3><p>访问函数：可以读取和显示数据。</p><p>工具函数：一个用来支持类的其他成员函数操作的private成员函数。</p><h4 id="Time类实例研究：具有默认实参的构造函数">Time类实例研究：具有默认实参的构造函数</h4><p>一个默认所有实参的构造函数也是一个默认的构造函数，即一个调用时不需要带任何实参的构造函数，每个类最多只有一个默认构造函数。</p><p>注意：对默认实参值的任何修改都要求重新编译用户代码（保证程序正常运行）。</p><h4 id="关于Time类的设置函数、获取函数、构造函数的补充说明">关于Time类的设置函数、获取函数、构造函数的补充说明</h4><p>类内的一些成员函数的实现可由设置函数和获取函数构成，这样，当private数据成员发生改变时（如数据成员减少），只需要修改哪些直接访问private数据的函数体（尤其是设置函数和获取函数），而其他没有直接访问的函数则不需要修改。这样可以降低因改变类的实现方法而造成编程错误的可能性。</p><p>建议：<br>1、如果成员函数已经实现了类的构造函数所需要的部分或全部功能，则可以在构造函数中调用这样的成员函数。既可以简化代码的维护，也可以减少由修改代码实现方法所引起出差的可能性。</p><p>2、构造函数应当适当地初始化后，再调用其他成员函数。</p><h4 id="C-11：使用列表初始化器调用构造函数">C++11：使用列表初始化器调用构造函数</h4><p>格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time t2&#123;<span class="number">2</span>&#125;;</span><br><span class="line">Time t3&#123;<span class="number">21</span>,<span class="number">34</span>&#125;;</span><br><span class="line">Time t4&#123;<span class="number">12</span>,<span class="number">25</span>,<span class="number">42</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="C-11：重载的构造函数和委托构造函数">C++11：重载的构造函数和委托构造函数</h4><p>构造函数也可以重载：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Time</span>();</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span>);</span><br><span class="line"><span class="built_in">Time</span>(<span class="type">int</span>,<span class="type">int</span> <span class="type">int</span>);</span><br></pre></td></tr></table></figure><p>构造函数也可以使用同一个类中的其他构造函数，这称为委托构造函数。</p><p>例子如下：使用Time(int,int,int)来构造其他三个构造函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">:<span class="built_in">Time</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> hour)</span><br><span class="line">:<span class="built_in">Time</span>(hour,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> hour,<span class="type">int</span> minute)</span><br><span class="line">:<span class="built_in">Time</span>(hour,minute,<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="析构函数">析构函数</h3><p>析构函数不接受任何参数，也不返回任何值。</p><p>本身不释放对象占用的内存空间，它只是再系统回收对象的内存空间之前执行扫尾工作，这样内存可以用于重新保存新的对象。</p><h3 id="何时调用构造和析构">何时调用构造和析构</h3><p>（需要再复习）</p><p>编译器隐式地调用构造和析构函数，一般两者的调用顺序相反，但是，对象的存储类别也可以该改变调用析构函数的顺序。</p><p>取决于程序进入和离开实例化对象所在作用域的顺序。</p><h3 id="返回private数据成员的引用或者指针">返回private数据成员的引用或者指针</h3><p>如果让类的public成员函数返回对该类private数据成员的引用，注意函数返回的如果是一个const引用，则这个引用不可以作为可供修改的左值（读起来好绕口）。</p><p>换句话说，这么做是非常不合理的，因为这样，我们可以直接访问private数据成员，并且进行修改，（返回一个private类型的数据成员的引用或指针破坏了类的封装性），当然在某些情况下是合理的。</p><h3 id="默认的逐个赋值">默认的逐个赋值</h3><p>赋值运算符可以将一个对象赋给另外一个相同类型的对象。默认情况下是逐个成员进行赋值。</p><p>但是，当类的数据成员包含指向动态分配内存的指针时，将会引发严重的问题。以后会提到怎么解决。</p><p>复制构造函数由编译器默认提供，功能和赋值运算符基本一致，但是也存在相同的问题。</p><h3 id="const对象和const成员函数">const对象和const成员函数</h3><p>对于const对象，编译器不允许进行成员函数的调用，除非成员函数也声明为const。</p><p>一个const成员函数需要在两处同时指明const限定符：</p><p>1、函数原型的参数列表后面插入关键字const</p><p>2、在函数定义时在函数体开始时的左括号之前。</p><p>注意：</p><p>1、将修改对象的数据成员的成员函数定义为const将导致编译错误。</p><p>2、定义为const的成员函数如果又调用同一类的同一实例的非const成员函数，将导致编译错误。</p><p>3、在const对象上调用非const成员函数将导致编译错误。</p><p>4、一个const对象的常量性是从构造函数完成初始化到析构函数被调用为止。</p><h4 id="使用const和非const成员函数">使用const和非const成员函数</h4><p>尽管构造函数必须是非const函数，但是它仍可以用来初始化const对象。</p><p>有趣的是，在构造函数中，调用非const成员函数来完成const对象的初始化是允许的，与上面的内容不谋而合。</p><h3 id="组成：对象作为类的成员">组成：对象作为类的成员</h3><p>（后续补充）</p><h3 id="friend函数和friend类">friend函数和friend类</h3><p>类的friend函数在类的作用域外被定义，却具有访问类的非public成员的权限。</p><p>单独的函数、整个类、或其他类的成员函数都可以被声明为另一个类的友元。</p><h4 id="friend的声明">friend的声明</h4><p>友元声明可以出现在类的任何地方。</p><p>如果要让ClassTwo的所有成员函数都作为ClassOne的友元，则在ClassOne的定义中加入以下这句话：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ClassTwo</span>;</span><br></pre></td></tr></table></figure><p>注意，若使B成为A的友元，则A必须显式地声明为B是它的友元。并且友元关系不是对称的、传递的。</p><h4 id="重载友元函数">重载友元函数</h4><p>可以指定重载函数为类的友元，每个打算成为友元的重载函数都必须在类的定义里面显式地声明为类地一个友元。</p><p>注意：</p><p>1、友元不是成员函数</p><p>2、public、private、protected这些成员访问说明符标志与友元声明无关。</p><p>3、把所有的友元关系放在最前面，并且不要添加任何成员访问说明符。</p><h3 id="使用this指针">使用this指针</h3><p>每个对象都可以使用一个称为this的指针来访问自己的地址，对象的this指针不是对象本身的一部分，也就是this指针占用的内存大小不会反映在对对象进行sizeof运算得到的结果中。</p><p>并且，this指针作为一个隐式的参数传递给对象的每个非静态成员函数。</p><h4 id="使用this指针来避免名字冲突">使用this指针来避免名字冲突</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::setHour</span><span class="params">(<span class="type">int</span> hour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hour&gt;=<span class="number">0</span>&amp;&amp;hour&lt;<span class="number">24</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour=hour;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在该函数定义中，参数名和数据成员hour名字相同。在setHour的作用域内，参数hour将隐藏数据成员，所以我们可以使用this指针访问该数据成员hour，并且赋值。</p><h4 id="this指针的类型">this指针的类型</h4><p>一般情况下，this指针的类型为classtype *const，如果对象的类型及使用this的成员函数被声明为const时，this指针的类型为const classtype *const。</p><h4 id="隐式和显式地使用this指针来访问对象的数据成员">隐式和显式地使用this指针来访问对象的数据成员</h4><p>分为两种：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用this指针和-&gt;进行访问修改</span></span><br><span class="line"><span class="keyword">this</span>-&gt;x=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用*this和.进行访问修改</span></span><br><span class="line">(*<span class="keyword">this</span>).x=<span class="number">12</span>;</span><br><span class="line"><span class="comment">//注意这对圆括号是必须的，因为*的优先级高于.,不加圆括号，将被识别为*(this.x);</span></span><br></pre></td></tr></table></figure><p>this指针的一个有趣的用法是防止对象自我赋值，后续补充。</p><h4 id="使用this指针使得串联函数成为可能">使用this指针使得串联函数成为可能</h4><p>this指针的另一个用法是串联的成员函数调用成为可能，也就是多个函数在一条语句中被重复调用。</p><p>关键是这些调用函数的返回值是*this（这一点在重载运算符中有所体现）。</p><h3 id="static类成员">static类成员</h3><p>static类成员属于类（所有对象共享一份数据），不属于某个具体的对象，某个对象修改static的类成员，也会影响其他对象。</p><p>这样的优点是：所有对象都只需要一份数据副本即可，使用static数据成员可以节省存储空间。</p><h4 id="静态数据成员的作用域和初始化">静态数据成员的作用域和初始化</h4><p>类的static数据成员只在类的作用域内起作用，且必须被精确地初始化。</p><p>基本类型的static数据成员默认情况下将被初始化为0。</p><p>注意如果有静态成员函数，则不需要初始化，因为它们的默认构造函数将被调用。</p><h4 id="访问静态数据成员">访问静态数据成员</h4><p>即使在没有任何类的对象时，类的static成员仍然存在。</p><p>private，protected：通常使用类的public成员函数或者类的友元访问。</p><p>没有类的对象存在时，只需在静态数据成员前加上类名和::即可。</p><p>当没有类的对象时而需要访问private或protected的static类成员时，应该提供public static成员函数，并且在函数名前加上类名和::来调用该函数。</p><p>因为类的static成员需要被任何访问文件的客户代码使用时，所以不能在.cpp文件中将它们声明为static，而只在.h文件中将它们声明为static。</p><p>如果成员函数不访问类的非static的数据成员或非static的成员函数，则应该将其声明为static。</p><p>static函数不具有this指针，因为static数据成员和成员函数独立于类的任何对象而存在，而this指针必须指向具体的对象。</p><p>注意：<br>1、static成员函数中不能使用this指针</p><p>2、static成员函数不能声明为const，const限定符指示函数不能修改它操作的对象的内容，但是static成员函数独立于类的任何对象而存在并且进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针</title>
      <link href="/posts/73608288.html"/>
      <url>/posts/73608288.html</url>
      
        <content type="html"><![CDATA[<h2 id="指针">指针</h2><h3 id="指针变量的声明和初始化">指针变量的声明和初始化</h3><h4 id="间接引用">间接引用</h4><p>指针变量存储的是内存的地址，间接引用一个值。</p><h4 id="指针的声明">指针的声明</h4><p>指针的声明如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type *countptr，count    <span class="comment">//type指的是类型，说明countptr是一个指向类型为type的指针，而count是一个类型为type的变量</span></span><br></pre></td></tr></table></figure><p>注意每一个指针变量名前面都必须有前缀的星号，建议每个声明只声明一个变量。</p><h4 id="指针的初始化">指针的初始化</h4><p>应该初始化为nullptr，或者为一个相应类型的地址。nullptr指的是空指针。</p><h3 id="指针运算符">指针运算符</h3><h4 id="地址运算符">地址运算符&amp;</h4><p>&amp;是一个一元运算符，它获得操作数的内存地址。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *yPtr=<span class="literal">nullptr</span>;</span><br><span class="line">yPtr=&amp;<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>这样，yPtr将获得y的地址，yPtr间接引用变量y的值。</p><p>注意这里与引用变量声明中的&amp;用法不同，后者的前面总是有一个type，在声明一个引用时，&amp;是变量的一部分。</p><h4 id="间接运算符">间接运算符*</h4><p>又称为间接引用运算符，返回的当前指针指向的变量。借助上例</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;*yPtr&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>两者的显示结果都是5。</p><p>也可以在赋值时使用：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*yPtr=<span class="number">9</span>;</span><br><span class="line">cin&gt;&gt;*yPtr;</span><br></pre></td></tr></table></figure><p>这将把输入的值存放到y中。</p><p>注意不要间接引用一个未初始化的指针，否则可能会产生严重后果（不小心修改重要的数据），也不要间接引用一个空指针。</p><h3 id="使用指针的按引用传递方式">使用指针的按引用传递方式</h3><p>指针也可以像引用传递一样，将指向大型数据的对象的指针传递给函数，减少值传递对象所需要的开销。</p><p>注意：传递的是指向这个变量的指针（以值传递的方式，被复制到了函数对应的指针形参中），然后被调用的函数就可以通过间接引用这个指针来访问这个变量，从而完成了按引用传递。</p><h3 id="内置数组">内置数组</h3><h4 id="声明内置数组">声明内置数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type name [size]</span><br><span class="line"><span class="comment">//类型 数组名 [数组大小]</span></span><br></pre></td></tr></table></figure><h4 id="访问内置数组的元素">访问内置数组的元素</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用[]来访问内置数组中的单个元素</span><br><span class="line">int a[10]=&#123;0,1,2,3,4,5,6,7,8,9&#125;;</span><br><span class="line">cout&lt;&lt;a[0]&lt;&lt;a[1];</span><br></pre></td></tr></table></figure><h4 id="初始化内置数组">初始化内置数组</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用初始化列表中的值初始化这些元素，若提供的初始化值数目少于元素的个数，则剩下的元素是有值的初始化</span></span><br><span class="line"><span class="comment">//bool:false</span></span><br><span class="line"><span class="comment">//指针：nullptr</span></span><br><span class="line"><span class="comment">//基本的数值类型：0</span></span><br><span class="line"><span class="comment">//类：根据默认构造函数初始化</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组的大小也可以忽略，前提是声明时有初始化列表</span></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">//创建了包含5个元素的数组</span></span><br></pre></td></tr></table></figure><h4 id="将内置数组传递给函数">将内置数组传递给函数</h4><p>注意：内置数组的名字可以隐式地转换为这个内置数组第一个元素的内存地址。</p><p>若数组名为arrayName，则它可以隐式地转换为&amp;arrayName[0]。</p><p>所以将其传递到函数时，只需要将简单地传递其数组名即可，这样，函数就可以修改数组中的任意一个元素，除非在数组名前面加上const，表明这些元素不可以被修改。（这样可以防止在函数体中修改原始的内置数组）</p><h4 id="声明内置数组形参">声明内置数组形参</h4><p>格式如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> values[])</span></span></span><br></pre></td></tr></table></figure><p>这将表明这个数组不应该被这个函数修改。</p><p>还可以写成：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *values)</span></span></span><br></pre></td></tr></table></figure><p>注意：编译器是无法区分接受一个指针的函数和接受一个内置数组的函数，因为当编译器遇到const int values[]的一维内置数组的函数形参时，它将转换为指针表示形式的const int *values。</p><p>这两种形式是可以互换的，但建议：当实参是一个内置数组时，还是使用[]。</p><h4 id="C-11：标准库函数begin和end">C++11：标准库函数begin和end</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>())</span><br></pre></td></tr></table></figure><p>这表明a的整个数组都应该被排序（vector类或者array类）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(<span class="built_in">begin</span>(n),<span class="built_in">end</span>(n));</span><br></pre></td></tr></table></figure><p>也可以对内置数组进行排序，注意n是内置数组名。</p><h4 id="内置数组的局限性">内置数组的局限性</h4><p>1、无法使用关系运算符和相等运算符进行比较</p><p>2、不能相互赋值</p><p>3、不知道自己的大小</p><p>4、不提供自动边界检查的功能，可能会越界。</p><p>所以推荐使用array和vector。</p><h3 id="使用const修饰指针">使用const修饰指针</h3><p>考虑一个情况，打印一个数组，所以其中的元素和数组的大小不应该改变。</p><p>注意内置数组很容易按引用的方式被传递，很容易在被调函数中被修改，所以需要const关键字修饰。</p><p>建议：</p><p>1、如果一个值在它被传递到的函数中没有（或不应该）改变，那么这个参数应该被声明为从const。</p><p>2、在使用一个函数前，确定哪些值需要被修改，哪些值则不需要。</p><p>将指针传递给函数的方式有4种：</p><p>1、指向非const数据的非const指针</p><p>2、指向const数据的非const指针</p><p>3、指向非const数据的const指针</p><p>4、指向const数据的const指针</p><h4 id="指向非const数据的非const指针">指向非const数据的非const指针</h4><p>访问权限最高，可以通过指针间接修改数据，也可以修改指针，使其指向其他数据。</p><p>声明一般为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">type *ptr;</span><br></pre></td></tr></table></figure><h4 id="指向const数据的非const指针">指向const数据的非const指针</h4><p>可以被修改以指向任何适当类型的其他数据项，但是不能通过该指针来修改它所指向的数据</p><p>声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr</span><br></pre></td></tr></table></figure><p>其实很好理解，const修饰的是int，所以它不能修改它所指向的数据。</p><p>当一个函数被调用时，其实参为内置数组，则实参的内容将被有效地按引用传递给函数。当传递的是指向对象的指针时，只会复制对象的地址，然而对象本身并没有被复制。</p><p>建议：</p><p>1、如果大型对象不需要在被调用函数中修改，则使用指向const数据的指针或者const数据的引用来传递它们，避免按值传递的复制开销</p><p>2、使用指向const数据的指针或者const数据的引用来传递大型对象，可以获得按值传递的安全性</p><p>3、应该采用按值传递的方式向函数传递基本类型的实参（如int、double等），除非调用者明确要求被调函数可以直接修改调用者中的值</p><h4 id="指向非const数据的const指针">指向非const数据的const指针</h4><p>它始终指向同一个内存位置，通过该指针可以修改这个位置上的数据。</p><p>注意：声明为const的指针必须在它们被声明时被初始化，但如果这样的指针是函数的形参，那么就可以用传递给函数的指针来初始化它</p><p>声明如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">const</span> *ptr</span><br></pre></td></tr></table></figure><p>const修饰的是*</p><h4 id="指向const数据的const指针">指向const数据的const指针</h4><p>它具有最小的访问权限：总是指向内存中的相同位置，并且不能用指针修改这个内存位置的数据。</p><p>建议：如果一个内置数组作为实参，并且该实参只是作为可读，那么就应该使用该类型的指针。</p><h3 id="sizeof运算符">sizeof运算符</h3><p>可以用于在编译期间确定内置数组或者其他任意数据类型、变量或者常量的字节大小。</p><p>当用于一个内置数组时，将返回该内置数组的字节大小，返回值是size_t类型。</p><p>注意：在一个函数中，使用sizeof关键字来获得一个内置数组形参的字节数，结果会得到一个指针的字节数，而不是该内置数组的字节数</p><p>可以使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> numbers/<span class="built_in">sizeof</span>(numbers[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>来获得一个内置数组的元素个数。</p><h4 id="确定基本类型、内置数组和指针字节大小">确定基本类型、内置数组和指针字节大小</h4><p>使用sizeof运算符，可以计算用于大部分标准数据类型的字节数。</p><p>sizeof运算符可以用于任何表达式或者任何类型名。</p><p>当sizeof用于一个变量名时（不是一个内置数组时）或其他表达式时，返回的用于存储该表达式的特定类型的字节数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只有在类型名作为sizeof的操作数时，才需要使用圆括号</span></span><br><span class="line"><span class="built_in">sizeof</span>(<span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//当操作数是表达式时，则不用圆括号</span></span><br><span class="line"><span class="type">int</span> a</span><br><span class="line"><span class="keyword">sizeof</span> a</span><br></pre></td></tr></table></figure><p>注意，sizeof是一个编译时的运算符，不会对操作数进行求值，其所得的值是一个size_t类型的常量表达式。</p><p>建议：在不同的系统中，用来存储一个特定数据类型的字节数可能不同，如果编写的程序依赖于数据类型的字节大小，则需要总是使用sizeof来确定存储数据类型所需要的字节数。</p><h3 id="指针表达式和指针算术运算">指针表达式和指针算术运算</h3><p>指针算术运算只适用于指向内置数组元素的指针。</p><p>一个指针可以++、–、+=（+）一个整数、-=(-)一个整数、或者一个指针可以减去另外一个同类型指针（注意只适用于指向同一内置数组元素的两个指针）。</p><p>注意：指针算术运算的结果取决于指针所指向的对象的大小，所以指针算术运算是与机器有关的。</p><p>以下两种写法是等效的：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *vPtr=v;</span><br><span class="line"><span class="type">int</span> *vPtr=&amp;v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="指针加上与减去整数">指针加上与减去整数</h4><p>当指针加上或者减去一个整数时，它是加上或者减去这个整数与该指针指向对象的字节大小的乘积，字节数取决于对象的数据类型。</p><p>如下所示：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *vPtr=&amp;v[<span class="number">0</span>];</span><br><span class="line">vPtr+=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>此时vPtr指针指向的是v[2]。</p><p>假设vPtr原本指向的v[0]的内存地址为3000，因为一个int数据占据4字节内存，所以vPtr现在指向的地址为3008，也就是v[2]的地址。</p><p>如果vPtr增加到了3016，则指向的是v[4]。</p><p>也可以进行回退，只需要vPtr-=4即可，此时指针指向的是v[0]，也就是这个数组的开始地址。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vPtr-=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>如果指针+1或者-1，则可以使用自增或者自减运算符。++指向下一个元素，–指向前一个元素。</p><p>注意：指针的算术运算符是没有边界检查功能的，所以必须确保在指针指向的元素在内置数组的范围内。</p><h4 id="指针相减">指针相减</h4><p>指向同一个内置数组的指针变量可以相减，如：</p><p>vPtr包含地址3000(v[0])，vPtr2包含地址3008(v[2])，则：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x=vPtr2-vPtr;</span><br></pre></td></tr></table></figure><p>恰好对应的就是这段区间内有几个元素（注意是v[0]、v[1]）。</p><p>指针算术运算只有在指向内置数组的指针上进行时才有意义，否则这是一个逻辑错误。</p><h4 id="指针赋值">指针赋值</h4><p>两个指针为同一类型时，则可以将一个指针赋值给另外一个指针，否则必须使用强制类型转换（通常是reinterpret_cast），这将把赋值运算符右侧的指针值转换为左侧的指针类型。</p><p>但是存在例外，即void指针（void*）,这是一种通用指针，可以表示任何类型的指针。</p><p>任何指向基本类型或者类类型的指针都可以被赋值给void*类型的指针，而不需要强制类型转换。</p><p>但是，void*类型的指针是不能直接赋值给其他类型的指针的，必须先把void * 类型的指针强制转换为合适的指针类型。</p><h4 id="不能间接引用void-指针">不能间接引用void*指针</h4><p>因为void指针只是一个包含未知数据类型的内存地址，编译器不知道该指针所指向的确切字节数和数据类型（编译器必须知道这两个才能正常编译，否则无法确定特定指针的数据类型，对于void指针来说，无法确定字节数），所以会报错。</p><p>注意：将一个类型的指针赋值给另外一个类型的指针时，需要将前者强制类型转换。</p><p>对于void*指针的合法操如下：</p><p>1、将void*指针与其他指针进行比较。</p><p>2、将void*指针强制类型转换为其他类型的指针和将地址赋值给void *指针。</p><p>除上述外，其他均是非法操作。</p><h4 id="指针比较">指针比较</h4><p>可以使用相等和关系运算符进行比较。</p><p>只有在指针指向同一数组的元素时，使用关系运算符才是有意义的。</p><p>指针比较的是存储在内存中的地址。在一个数组中，指向内置数组中下表编号大一些的元素的指针比指向内置数组中下表编号小一些的元素的指针大。</p><p>一个常用的指针比较是判定其是否为0、nullptr或者NULL。</p><h3 id="指针和内置数组的关系">指针和内置数组的关系</h3><p>用以下的声明进行介绍：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *bPtr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下两者是等价的</span></span><br><span class="line">bPtr=b;</span><br><span class="line">bPtr=&amp;b[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h4 id="指针-偏移量表示法">指针/偏移量表示法</h4><p>b[i]可等价表示为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(b+i);</span><br></pre></td></tr></table></figure><p>这里的i指的是偏移量，联系前面的指针加法、减法运算可以很好理解，注意*优先级大于+，所以需要加上圆括号。</p><p>当然，&amp;b[i]也可以写成</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b+i;</span><br></pre></td></tr></table></figure><h4 id="以内置数组名作为指针的指针-偏移量表示法">以内置数组名作为指针的指针/偏移量表示法</h4><p>其实本质跟上面是一样的，这里我们就直接用数组名即可，因为数组名就是执行数组首元素的指针。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*(b+i)</span><br></pre></td></tr></table></figure><p>等价于b[i]。</p><h4 id="指针-下标表示法">指针/下标表示法</h4><p>和内置数组一样，指针也可以带下标，如</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bPtr[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这和b[1]是等价的。</p><h4 id="内置数组名不可以修改">内置数组名不可以修改</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">b+=<span class="number">3</span>；</span><br></pre></td></tr></table></figure><p>上述是一个非法操作，试图用算术运算来修该内置数组名的值。</p><p>这也说明，数组名是一个指向非const数据的const指针。</p><p>建议：使用内置数组表示法，不要使用指针表示法。</p><h3 id="基于指针的字符串">基于指针的字符串</h3><h4 id="字符与字符常量">字符与字符常量</h4><p>字符是C++源程序的基本构建块。</p><p>一个字符常量是一个整数，表示为用一对单引号引起来的一个字符。</p><h4 id="字符串">字符串</h4><p>一个字符串可以看作一个被视为整体的字符序列，包含字母、数字、特殊字符。</p><h4 id="基于指针的字符串-2">基于指针的字符串</h4><p>是一个以’\0’结尾的内置字符数组，'\0’标记了字符串在内存中结束的位置。</p><p>可以通过指向字符串第一个字符的指针来访问该字符串，对其进行sizeof运算得到的是包括空字符在内的这个字符串的长度。</p><p>数组名也是指向该内置数组第一个元素的指针。</p><h4 id="字符串文字作为初始化值">字符串文字作为初始化值</h4><p>以下两者等效：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> color[]=<span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *colorPtr=<span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure><p>注意两者都包含以’\0’作为结尾。</p><p>注意字符串文字是static存储类别的，在程序执行时一致存在，可以被共享，也可以不被共享。</p><p>建议：如果要修改字符串文字的内容，先将它存储到一个内置数组中。</p><h4 id="字符常量作为初始化值">字符常量作为初始化值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> color[]=&#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这是初始化列表的形式，编译器会根据初始化列表中的初始化值的个数，来决定上述内置数组的大小。</p><p>建议：</p><p>1、需要分配好足够的空间，来存储结束字符串的空字符。</p><p>2、要时刻记得包含结束的空字符。</p><h4 id="访问C字符串的字符">访问C字符串的字符</h4><p>可以使用内置数组的下标表示法直接访问字符串中单个的字符。</p><h4 id="使用cin读取字符串到char类型的内置数据中">使用cin读取字符串到char类型的内置数据中</h4><p>可以使用cin通过流提取读取一个字符串到一个内置字符数组中，例子如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;word</span><br></pre></td></tr></table></figure><p>这将读取一个字符串到名为word的内置字符数组中，该数组有20个元素。</p><p>用户输入的字符串存储到word中，直到遇到空白字符或者文件结束符为止，注意，该字符数组的长度不能超过19个字符，以便为结束空字符流出空间。</p><p>可以使用setw流操纵符来保证不超过读入word的字符串不会超过内置字符数组的长度</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;<span class="built_in">setw</span>(<span class="number">20</span>)&gt;&gt;word;</span><br></pre></td></tr></table></figure><p>这样将指定最多只有19个字符到word中，留下一个用于存储结束空字符。</p><p>注意setw只作用于下一个要输入的值，如果输入多了，那么剩下的字符不会被存储到word中。</p><h4 id="使用cin-getline-读取文本行到char类型的内置数据中">使用cin.getline()读取文本行到char类型的内置数据中</h4><p>getline（）函数有三个参数：一个存储该行文本的内置字符数组，一个长度，一个定界字符。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> sentence[<span class="number">80</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(sentence,<span class="number">80</span>,<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这将读取一行文本到内置数组中。</p><p>当遇到定界字符’\n’，或者输入了文件结束符，或者已经读入的字符数比长度参数小1时，函数将停止读取。</p><p>第三个参数的默认值时’\n’，并且内置数组的最后一个字符是留给结束空字符的，如果遇到定界字符，则会读取并丢弃它（这个时候将会结束继续输入字符到内置数组中，不管是否继续输入字符串）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">50</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(a,<span class="number">50</span>,<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="number">12345678</span> \\ <span class="number">666</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><h4 id="显示字符串">显示字符串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;sentence;</span><br><span class="line"><span class="comment">//这样即可直接输出</span></span><br></pre></td></tr></table></figure><p>cout不关心字符数组的大小，直到遇到终止符为止，空字符不会输出。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ How to Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Way to Practice Competitive Programming</title>
      <link href="/posts/a7d34c04.html"/>
      <url>/posts/a7d34c04.html</url>
      
        <content type="html"><![CDATA[<h1 id="一种程序设计竞赛的训练方法（译）">一种程序设计竞赛的训练方法（译）</h1><p>文章转载自：<a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html">一种程序设计竞赛的训练方法（译） - wawcac - 博客园 (cnblogs.com)</a>，如有侵权，请联系作者删除。</p><hr><p><a href="https://codeforces.com/blog/entry/66909">原文</a></p><p>[PDF]([<a href="https://drive.google.com/file/d/1J2x8pIYQ3MXANgvzOgBciWd3d79j_Exa/view">Tutorial] A Way to Practice Competitive Programming.pdf - Google 云端硬盘</a>)</p><blockquote><p>Rating从1000到2400+</p><p>2019年5月7日</p><p>Masataka Yoneda/E869120</p></blockquote><p>目录</p><ul><li><ol><li>自我介绍</li></ol><ul><li><a href="http://codeforces.com/">2-1. Codeforces </a></li><li><a href="https://atcoder.jp/">2-2. AtCoder </a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#2-3-topcoder">2-3. TopCoder</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#2-4-%E8%BF%99%E9%83%A8%E5%88%86%E7%9A%84%E6%80%BB%E7%BB%93">2-4. 这部分的总结</a></li></ul></li><li><ol start="3"><li>训练方法介绍</li></ol><ul><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-1-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-10001400">3-1. 训练技巧 rating 1000~1400</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-2-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-14001900">3-2. 训练技巧 rating 1400~1900</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-3-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-19002200">3-3. 训练技巧 rating 1900~2200</a></li><li><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#3-4-%E8%AE%AD%E7%BB%83%E6%8A%80%E5%B7%A7-rating-22002400">3-4. 训练技巧 rating 2200~2400</a></li></ul></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#4%E8%AE%AD%E7%BB%83%E5%BF%83%E7%90%86">4.训练心理</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#5-%E8%99%9A%E6%8B%9F%E8%B5%9B%E6%8E%A8%E8%8D%90">5. 虚拟赛推荐</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#6-%E6%9C%AA%E6%9D%A5%E6%84%BF%E6%99%AF">6. 未来愿景</a></p></li><li><p><a href="https://www.cnblogs.com/wawcac-blog/articles/12245307.html#7-%E6%80%BB%E7%BB%93">7. 总结</a></p></li></ul><h2 id="1-自我介绍">1. 自我介绍</h2><p>亲爱的CF社区：</p><p>2019年4月20日，在14场比赛后，我终于达到了grandmaster，rating 2426。在最后一场比赛之前，我很遗憾rating是2399，距离成为粉名只差1分。所以上一场比赛(Forethought Future Cup Elimination Round) 是我印象最深的比赛之一。感谢CF举办这些比赛，感谢友善、出色且给人留下深刻印象的CF社区接受我的博客。</p><p>如今，我也想给CF社区做一点贡献，因为我之前在CF社区收获了很多，心里十分感激。我思考了很长时间“如何给CF做贡献”，或者说以一种合适的方式给CF做贡献。我想到了：介绍一种从灰名到粉名的练习方法。</p><p>现在，我要解释如何成为一个红名大佬。</p><p>2017年7月，我写了一篇博客解释如何到紫名<a href="http://codeforces.com/blog/entry/53341">紫名秘籍</a> 。凭借这篇博客，我得到了181个赞，但那里面有很多语法错误，而且还有几个地方没有解释清楚。我很抱歉自己不擅长英语，也不是一个很好的作者。这次的博客可能还是有一些错误，但我努力使它更易读易懂。感谢你的合作、陪伴。</p><p>这次，我要分几个步骤进行讲解，因为rating范围有好几个，大部分人并不能一步就从灰名到达粉名，我也不能。所以这次我要分成下面的四个步骤：</p><ul><li>Rating 1000→1400，从灰名到青名</li><li>Rating 1400→1900，从青名到前10%的选手</li><li>Rating 1900→2200，从前10%选手到表现优异的Div1选手</li><li>Rating 2200→2400，从表现优异的Div1选手到粉名</li></ul><p>另外，在解释如何练习之前，因为CF用户很多，其中一些并不知道其他的OJ，所以我想介绍一下其他的在线比赛网站（AtCoder、TopCoder等）。</p><p>还有，很高兴你们阅读我的博客。非常感谢CF。</p><p>永田正彦</p><p>## 2. 常识介绍——一些打比赛的网站</p><p>世界上有很多OJ。为了成为粉名，我切了很多OJ上的很多题目。这次，为了 explain the post sections，我想先介绍一些比赛。</p><h3 id="2-1-Codeforces">2-1. <a href="http://codeforces.com/">Codeforces</a></h3><p>Codeforces是世界上最有名的OJ之一，目前有五千多题。</p><p>利用CF的最好方式之一是“题目Rating”。例如，1146H Satanic Panic 的Rating是2800，这意味着，如果你的rating大于等于2800，那么你应该<strong>在比赛中</strong>切掉这个题。</p><p>另外，CF分成三个部分（Div1、Div2、Div3）。</p><p>再往后，我会使用下面两种简称：</p><ul><li>Div1A, Div2E等等：代表Div1的A题、Div2的E题。通常，第一题是最简单的，最后一题是最难的。</li><li>难度R2800什么的：“难度R2800”代表这题难度被标成2800。例如，1146G Zoning Restriction 难度R2600，1146A Love &quot;A&quot;难度R600。</li></ul><h3 id="2-2-AtCoder">2-2. <a href="https://atcoder.jp/">AtCoder</a></h3><p>AtCoder是一个“拥有很多好题”的比赛网站。这只是个人意见，但如果你想变强，就要刷AtCoder。</p><p>AtCoder有三种类型的比赛：</p><ul><li>AtCoder Beginner Contest (ABC) : 有4道题。<ul><li>ABC难度一般为R500-R700-R900-R1400。</li></ul></li><li>AtCoder Regular Contest (ARC) : 有4道题。通常ARC的前两题和ABC的后两题是相同的。<ul><li>ARC难度一般为R900-R1400-R2100-R2600，因比赛而异。</li></ul></li><li>AtCoder Grand Contest (AGC) : 有6道题。<ul><li>AGC难度一般是 R1200- R1900- R2200- R2500-R3000-R3300</li></ul></li></ul><p>还有个很方便的网站——<a href="https://kenkoooo.com/atcoder#/table//">AtCoder problems</a>。</p><p>在这个网站，你可以看到自己AtCoder的切题列表，知道自己哪些题还没做，哪些题做了。AC的被标成绿色，尝试过但没AC的被标成黄色。</p><h3 id="2-3-TopCoder">2-3. TopCoder</h3><p>TopCoder也是一个著名的比赛网站。Single Round Match (SRM) 有两个部分：</p><ul><li>Division 2：有三道题，R600-R1300-R2100，被称为Div2简单、Div2中等、Div2困难。</li><li>Division 1：有三道题，R1800-R2400-R3000，被称为Div1简单、Div1中等、Div1困难。</li></ul><p>我为了到粉名，也用TopCoder训练。尽管主要是数学题，但都是好题（我尤其喜欢SRM600-699）。</p><h3 id="2-4-这部分的总结">2-4. 这部分的总结</h3><p>我主要用3个OJ训练：Codeforces、AtCoder、TopCoder。如果你了解了这3个OJ，就可以去阅读下一个部分了。在这些比赛网站训练是很重要也很有效的，而且我觉得这是最快的进步方式。</p><hr><p>在第3部分，我会写很多要点，但都只是我的个人观点，不信任我也是可以的。很多人遵循我的方法，取得了很大的进步，但也有很多人没遵循我的方法依然取得很大进步。用我的方法训练是挺好，但不一定对所有人都有效。</p><hr><h2 id="3-训练方法介绍">3. 训练方法介绍</h2><p>可能有很多人读过我上一篇教程博客，但现在和两年前不一样了。这两年我有很多遗憾。很多事情我没做，但我在想，如果我做了，是不是可以进步更快？因此，这篇博客和我之前那篇有很多不同之处。</p><p><strong>此外，在rating到达2200前和到达2200后，我的训练方式完全不同。</strong></p><p>还有一件事，这篇博客只是我的个人观点，训练方法因人而异，所以我认为你不一定按照我的方法训练。但我觉得我的方法对一些人来说是最有效的。</p><p>如果你理解了这一点，就可以继续往下读了。进入正题……3、2、1，走起！</p><h3 id="3-1-训练技巧-rating-1000-1400">3-1. 训练技巧 rating 1000~1400</h3><p>CF上有很多灰名、绿名，他们很想成为青名、蓝名，但依然在苦苦挣扎中。</p><p>尽管如此，到达青名（1400）只需要做到三点。</p><ul><li>能够快速写出模拟题（5到10分钟内）</li><li>能够快速写出暴力（5到10分钟内）</li><li>能够在脑子里或草稿纸上把问题分情况讨论（例如，N=2、N=3、N&gt;=4）</li></ul><p>举个例子，在Codeforces Round #556中，如果你可以做到以上三点，就可以很惊喜地在Div2中达到200名，这是一个很夸张的例子。但在Codeforces Round #554 (Div. 2)中，你只能达到3400名，rating1250及以下的参赛者可以上分。</p><p>平均来说，如果你可以做到以上三点，rating就可以达到1400。</p><p><strong>[[如何训练]]</strong></p><p>首先，我建议你打ABC。</p><p>尽管CF上有很多好题，但如果你想更容易地练习编程，最好去刷AtCoder。</p><p>特别地，我推荐做ABC中的B题和C题。做B题可以学到如何更快地写模拟和暴力，做C题可以学到如何想题、如何用草稿纸更快地想出解决方案。</p><p>从ABC 042开始，出题人加入了英文题面。目前最新的一场是ABC 125，所以共有84场可做的ABC。如果你切了所有的B题和C题，就会学到很多，变得更强。</p><p>可以借助<a href="https://kenkoooo.com/atcoder#/table//">AtCoder problems</a>的帮助刷AtCoder，你能从这个网站知道自己做了哪些题。</p><p>当你刷AtCoder时，有几点很重要：</p><ul><li>当你想不出解决方案时，应该在思考B题15分钟、思考C题30分钟后再看题解。可悲的是，最近几场ABC没有英文题解，但你可以读标程（题解中很可能包含标程的链接）。</li><li>即使你AC了某道题，在习惯快速写代码前，还是可以通过阅读大佬的源代码学到一些东西。所以我建议看一些简单的源代码。</li><li>特别是当你做C题时，我推荐你用草稿纸辅助思考。不用纸的话，用白板打草稿也可以。</li></ul><p>我是高中一个计算机社团的社长，有很多社员用这样的方法获得了进步。</p><h3 id="3-2-训练技巧-rating-1400-1900">3-2. 训练技巧 rating 1400~1900</h3><p>CF上人数最多的rating区间是[1400, 1500]。他们都很想上分，但从1500开始上分比较困难，很多人放弃了。但也有很多人坚持训练，成功上分。</p><p>要达到1900，需要下面的技巧：</p><ul><li><p>掌握并能够使用以下主要算法：</p><ul><li>暴力</li><li>动态规划</li><li>深度优先搜索</li><li>广度优先搜索</li><li>迪杰斯特拉</li><li>树状数组</li><li>排列数、组合数</li><li>乘法逆元</li><li>位掩码</li><li>二分查找</li></ul><p>注意：我认为在rating 1800前，线段树不是必须的。我上紫以后才学的线段树。</p></li><li><p>提高手速（例如，R1100的题目5分钟写好，R1400的题目10分钟写好）。手速在CF很重要，因为一般来说，如果题目难度范围很大，手速会在很大程度上影响rating。</p></li></ul><p><strong>[[如何训练]]</strong></p><p>**如果你不擅长快速写代码、快速调试，**就应该刷AtCoder。事实上，从统计学上讲，很多日本选手手速很快，但不擅长解决难题，我觉得是AtCoder的锅。</p><p>我推荐做ABC的C题和D题。<strong>平均来说</strong>，如果能在10分钟内解决C题，在20分钟内解决D题，你就是手速场中的Div1 😃</p><p><strong>如果你不擅长解难度高于R1400的题</strong>，就应该学一些上面提到的算法，做做CF上的板题。举个例子，如果你觉得自己不擅长DP，就刷CF上R1200到R1400的DP标签的题。让人惊讶的是，只有约50道难度小于等于R1400的DP标签的题。</p><p>有趣的是，板题都集中在只有Div2的那些比赛中。如果你不擅长只有Div2的比赛，那么很可能是你不擅长使用典型算法，尤其是上面提到的10种算法。</p><p><strong>如果你能做板题，但不擅长做难度高于R1500的题</strong>，就要开始在TopCoder刷题。这类练习对擅长只有Div2的比赛但不擅长Div1+Div2一体的、分开的比赛的人十分有效。</p><p>有时候，尤其是在Div1+Div2的比赛中，一些题目需要数学概念或者思考。因为TopCoder上有很多题用到这些（另外还有简便的实现！），所以你应该刷TopCoder。</p><p>我推荐刷最近100场SRM的Div1简单。但有些题真的太难了（甚至粉名都切不掉），所以刷之前，你应该看一下题目的通过率。你可以利用<a href="https://competitiveprogramming.info/">奇怪的插件？</a>来获取一些信息。</p><p>不幸的是，我不知道有没有像AtCoder Problems那样，能够看自己在TopCoder SRM中做过哪些题的网站。所以，如果你想记录自己刷过那些题，应该做一个电子表格或者表格。</p><p>当我还是个蓝名时，数学思维也很糟糕。在切了50题Div1简单以后，我在TopCoder成了蓝名，在CF成了紫名。</p><p><strong>如果你擅长切题，但在比赛中发挥不好</strong>，就应该多打虚拟赛。你知道CF的虚拟赛系统吗？你可以虚拟参赛！</p><h3 id="3-3-训练技巧-rating-1900-2200">3-3. 训练技巧 rating 1900~2200</h3><p>如果你想达到2200，首先，你应该是Div1，并且参加Div1的比赛。这意味着你应该刷很多难题（R1900或更高）。</p><p>即使你手速快或者十分擅长切板题，打Div1比赛也是很难的。可悲的是，有很多选手在蓝名和紫名之间摇摆</p><p>要达到2200，需要以下技巧：</p><ul><li>知道并且会用上面提到的10种算法，还要加个线段树（包括懒标记）</li><li>非常快的手速：R1100 5分钟，R1500 10分钟，R1800 15分钟，R2000 40分钟。</li><li>相当好的数学思维和思考问题的能力。</li><li>强大的思维，可以支持超过1小时的思考，即使在Div1比赛中途落后了也不放弃。</li></ul><p><strong>[[如何训练]]</strong></p><p>这只是我的训练方式：在rating2000时打了很多虚拟比赛。在这里，虚拟比赛并不意味着“虚拟参与”，而是选择4到5道难度在自己rating附近的题目（举个例子，目前rating是2000，那么选择CF中R2000的题目），并且在2小时内切掉。</p><p>你可以利用<a href="https://vjudge.net/">vjudge</a>。在这个网站，你可以从很多OJ上（AtCoder、CF、Hackerrank、Codechef、POJ……）拉题组一场虚拟赛。</p><p>如果你在虚拟赛中不能切掉这些题，而且没有想出解决方案，就应该去谷歌查题解（举个例子，如果你想找Codeforces Round #556 (Div. 1)的题解，就去谷歌搜“Codeforces Round #556 editorial”）。</p><p>在CF上分还有一件重要的事。为了更快的手速，你应该准备一些板子。例如，我认为线段树板子、懒标记线段树板子、CRT的板子、FFT的板子、计算几何板子等等都是很有效的。</p><h3 id="3-4-训练技巧-rating-2200-2400">3-4. 训练技巧 rating 2200~2400</h3><p>这是本博客关于训练技巧的最后一部分。事实上，我卡在橙名很久了，就连在虚拟赛中，我的平均表现也是橙名。这是因为我之前的训练方法在橙名遇到了障碍。</p><p>Rating 2200到2400事实上非常难——如果你平均表现2200，如果你练习赛打得更多，上粉（到2400）看上去也没那么难。但是平均表现2400比你想象的要难得多。如果你的rating正好是2400，那么在Div1的比赛上，你一般要打进前20%（例如，如果有525人参加，那么你应该最差在105名）才能上分。</p><p>要达到2400，需要以下技巧：</p><ul><li>Rating达到2200</li><li>在Div1比赛中切掉AC少于100人的<strong>难题</strong></li></ul><p>如果你想切难题和用ad-hoc临时方法的题，根据TozanSoutherPacks在我上一篇博客下的评论<a href="http://codeforces.com/blog/entry/53341?#comment-373965">大佬的文章</a>，“要达到2600分乃至更高，你应该切Boss题，所有这些都是临时问题或者步骤很多的问题。”我觉得那是对的，但是对我来说，我觉得即使你只想达到2400分，切步骤很多的临时问题也是有必要的。</p><p><strong>[[如何训练]]</strong></p><p>达到2400分最安全的方法是“切4000道题”。我就在TopCoder、AtCoder、CF和一些日本OJ上切了超过4000题。</p><p>事实上，有一个传说（或者说是事实）是，最NB的选手tourist在他这辈子切了一万多题。</p><p>但是可能很多人觉得自己没时间。所以我会给你一些更高效的途径。</p><p>首先，AtCoder上有很多教育题。我推荐你做<strong>ARC尤其是ARC058到ARC090</strong>的E题和F题（尤其是AtCoder中700到900点的题目）。尽管以前的ARC在“思维”和“模板”之间是平衡的，但可悲的是，我认为AGC和最近的ARC实际上太偏向思维了，所以如果你的目标是在CF上分，我不推荐它们（尽管如果你想达到2600乃至更高，还是要刷AGC）。</p><p>对我来说，实际上，刷了ARC以后，我在CF虚拟赛的平均表现从2100提高到了2300（I could not reach 2400 because start was early）。</p><p>如果你切不动题，我推荐你放弃思考并且看题解的时间如下：</p><table><thead><tr><th>AtCoder点值</th><th>CF难度</th><th>思考时间</th></tr></thead><tbody><tr><td>600</td><td>R2000</td><td>40分钟</td></tr><tr><td>700</td><td>R2200</td><td>50分钟</td></tr><tr><td>800</td><td>R2400</td><td>60分钟</td></tr><tr><td>900</td><td>R2600</td><td>70分钟</td></tr><tr><td>1000</td><td>R2800</td><td>80分钟</td></tr></tbody></table><p>如果你切了AtCoder上的教育题，你编程比赛的技能将会有所提高。但还有另一个问题，没有付诸实践，你没办法上分。</p><p>所以，你应该至少在CF上打50场虚拟赛（尤其是Div1）。在虚拟赛中，你可以学到，紫名、橙名应该如何打比赛（比如比赛策略），以及如何在CF比赛中利用在AtCoder学到的技巧。<strong>我强烈推荐在虚拟赛后看看所有题的题解，除了太难的题</strong>（比如在比赛中AC人数少于30的题）。我还建议，在打完比赛看完题解后在笔记本上写一些对于比赛策略、教训和可以改进的地方的反思。</p><p>此外，我建议你每周一次，花点时间思考一些难题（比如CF上R2800的题）。如果你想了很久也想不出来，我建议你去读题解，因为那样你可以学到很多。解决难题可能会给你一场上分100+的机会，也会给你更快解决简单题的机会。</p><p>最后，我猜这个方法对于超过30%的人奏效，因为我用这个方法在CF上粉，我的孪生兄弟square1001用这个方法在TopCoder上红。希望我的方法可以产生新的粉名:)</p><h2 id="4-训练心理">4.训练心理</h2><p>心理问题是选手中最常见的问题之一。即使对我，直到最近两个月前，出于对一场掉分100+的恐惧，我超过9个月没打过CF上rated的比赛。另外，还有几场比赛我甚至都做不到看下一个题，因为我做不出来更简单的题，心态崩了。</p><p>我最近发现一种锻炼心态的办法。</p><ul><li>制定一个比赛前的常规程序。这能让我们在比赛期间集中注意力。<ul><li>事实上，就我而言，我的常规程序是在比赛快开始时看着倒计时减少到0。黑红大佬yutaka1999实际上在IOI开始前就在修禅。</li></ul></li><li>如果你比赛中没发挥好（比如20分钟内切不掉B题），不去看榜也是个好主意。</li><li>还有一件重要的事：“比赛过程中不要管rating”。<ul><li>我觉得，即使这场要掉分，下一场上分的可能性也提高了。这就是为什么我在比赛过程中不管rating。</li></ul></li><li>不要过于在意之前犯过的错误。错误也是一次好的学习机会，每个人都会犯错。即使是tourist也曾经在AtCoder World Tour Finals上翻车。<ul><li>我觉得吧，“rating”和“你犯过多少错、做过多少<strong>反思</strong>”之间存在关联。</li></ul></li></ul><p>以上这些方法不仅在正式比赛中适用，还在虚拟赛中适用。注意：比赛中不要有太大的压力，开心就好！</p><h2 id="5-虚拟赛推荐">5. 虚拟赛推荐</h2><p>在写关于虚拟赛的建议之前，我认为虚拟赛有以下两种类型：</p><ul><li>虚拟参与：选择一场比赛，就像真实参赛那样做题。和CF的虚拟赛系统一样。</li><li>虚拟比赛：使用VJ或者其他的评测系统。从CF上挑几题难度在自己rating附近的题，并在2到3小时内解决它们。</li></ul><p>首先，以上这两种方式我都推荐。</p><p>对于虚拟参与，我觉得你可以学到比赛策略、心态和其他一些比赛技巧。对于虚拟比赛，我觉得你可以集中精力卡一道题，因此解题、复习效率会得到提高。</p><p>这就是为什么当我在刷CF上的难题时，总是用VJ进行虚拟比赛。</p><p>如果你想在AtCoder打虚拟赛，用<a href="https://not-522.appspot.com/%EF%BC%88%E9%81%97%E6%86%BE%E7%9A%84%E6%98%AF%E8%BF%99%E4%B8%AA%E7%BD%91%E7%AB%99%E6%98%AF%E6%97%A5%E6%96%87%E7%9A%84%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%B8%8D%E6%98%AF%E6%97%A5%E6%9C%AC%E4%BA%BA%EF%BC%8C%E5%8F%AA%E5%A5%BD%E5%A7%94%E5%B1%88%E4%BD%A0%E7%94%A8%E4%B8%80%E4%B8%8B%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91%E4%BA%86%E3%80%82%E3%80%82%E3%80%82%EF%BC%89%E3%80%82%EF%BC%88%E7%8E%B0%E5%9C%A8%E5%B7%B2%E7%BB%8F%E4%B8%8D%E7%94%A8%E4%BA%86%EF%BC%8C%E5%AE%98%E6%96%B9%E5%B7%B2%E7%BB%8F%E6%8F%90%E4%BE%9B%E4%BA%86vp%EF%BC%89">https://not-522.appspot.com/（遗憾的是这个网站是日文的，如果你不是日本人，只好委屈你用一下谷歌翻译了。。。）。（现在已经不用了，官方已经提供了vp）</a></p><h2 id="6-未来愿景">6. 未来愿景</h2><p>幸运的是，在2019年4月29日，我CF的rating达到了2585，非常接近红名了。我很高兴，也真的很感激CF管理员和CF社区。</p><p>我实际上已经定下了未来的目标：黑红！</p><p>实际上，我最近在CF打了很多比赛或者虚拟赛。我在CF上最近10场比赛的表现是： 2865, 2661, 3029, 2890, 2858, 2875, 2318, 2717, 2506, 2891（平均2761.0）。</p><p>所以，我大概还差250分到达黑红。我为了实现梦想正在做的努力如下：</p><p><strong>[[如何训练]]</strong></p><ul><li>几乎每天都打2到3小时虚拟赛。赛后看题解、看黑红大佬的代码，写一个小时反思。</li><li>有时候（大约一周一次）从CF上选大概5题左右（难度从R2200到R2800），在2到4小时内解决。</li><li>即使打比赛三年了，我还是觉得有很多黑科技（实际上和算法板子不同）是我不知道的。所以比赛中如果有超过20人做出来的题目我没做出来，我就会去看题解。<ul><li>我觉得，如果我能在比赛中把几乎所有20个AC以上的题目做出来，早就是黑红了。</li></ul></li></ul><h2 id="7-总结">7. 总结</h2><p>这就是我要给CF社区说的所有训练方法。真心感谢你的阅读。</p><p>我使用CF很久了，也在社区中得到了成长。所以，我想我应该给CF社区做点什么贡献。做贡献有很多方式，我选择讲述在CF上分的实用技巧。我认为这是给CF做有实际意义贡献的最好方式之一。</p><p>最后，我建议一步步用一定的训练方法提高你打比赛的能力。但是训练方法因人而异，我不觉得我的方法总是最高效的，同样，我也不认为你必须按照的我方法训练。</p><p>但我觉得，这对某些人来说是最高效的方法。希望这篇博客有用，即使只有一小点儿。</p><p>因为我只是日本的一个高二学生，文中可能有很多语法错误，我英语也确实不好。我必须表示歉意，但相反，我必须感谢读者。谢谢你的阅读。</p><p>最后，祝你好运，祝你在CF上分，祝你在程序设计竞赛玩得开心。这就是我这篇博客的总结。再次感谢。</p><p>​                                                                                                                                                                                                                        永田正彦</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Plan</title>
      <link href="/posts/7d68f443.html"/>
      <url>/posts/7d68f443.html</url>
      
        <content type="html"><![CDATA[<h1 id="学习计划">学习计划</h1><p>上了大学，发现怎么比高三过得还<s>出生</s>。</p><hr><p>感觉得列个计划，不然越学状态越糟糕。</p><h2 id="学业">学业</h2><h3 id="1、工分">1、工分</h3><p>2023-04-02</p><p>目前来说没什么问题，领先进度。希望能一直保持</p><h3 id="2、概率论">2、概率论</h3><p>2024-04-02</p><p>也没啥问题，希望4月底能学完。</p><h3 id="3、学术英语">3、学术英语</h3><p>不能像上学期那样开摆了，不然绩点就蹭蹭往下掉了。</p><p>两次PBL要认真搞，而且上课的小作文也要认真写，争取回答两三问题吧（一直懒又社恐，不敢上去)。</p><p>期末的英语考试至少要提前一周背答案咯，注意笔试和听力都得背。（听力具体是哪一部分？）</p><p>还有六级考试，不然大二就更没时间了。</p><h3 id="4、大物实验">4、大物实验</h3><p>一学分，但是还要认真准备，老师要求有点高。</p><h3 id="5、军事理论">5、军事理论</h3><p>记得一直挂网课，不知道有没有线下期末考试。</p><h3 id="6、大学物理">6、大学物理</h3><p>目前落后两章，赶紧补。（4学分的重点课）</p><p>期末考试重点看往年试卷（神中神）。</p><h3 id="7、中国文学与文化">7、中国文学与文化</h3><p>还差期末考试（但是没有答案！！！）</p><h3 id="8、思想道德与法制">8、思想道德与法制</h3><p>还是要重视，毕竟是2.5学分。</p><h3 id="9、数字逻辑">9、数字逻辑</h3><p>不知道到底有没有算入绩点，目前赶上进度，难度还行，感觉重点还是放在期末复习月。</p><h3 id="10、C">10、C++</h3><p>大Boss压轴登场。</p><p>接下来还有两个实验，一个实训。</p><p>实验三已经基本完成了，实验四还没动，感觉实验四慢慢写得花一周。</p><p>实训才是最难熬的，感觉自己的设计思路还是很混乱，打算看看相关的书籍。</p><p>打算搞可视化，接下来还得学习Qt，任务艰巨。</p><h2 id="课外">课外</h2><p>其实要是不打ACM，时间也许绰绰有余？</p><p>可惜没有如果。</p><p>从去年10月份正式开始学算法，到现在已经过去半年多了，虽然有进步，但是缓慢。。。</p><p>感觉自己也走了很多弯路，虽然学习了很多算法，但是都没有好好消化吸收，不知道怎么用（情况现在有些改观）。</p><p>还是得多多答题，多多思考，少看题解，下面附上几篇学习思路：</p><p>[A Way to Practice Competitive Programming | Heavenhold](<a href="https://www.heavenhold.cn/2024/04/03/A">https://www.heavenhold.cn/2024/04/03/A</a> Way to Practice Competitive Programming/)</p><p>以后在慢慢补充训练题单，先睡觉了。</p><hr><p>校赛告一段落，打得很糟糕，第一次打这种三人合作的比赛。</p><p>接下来先集中精力专注课内吧，这周的PBL，还有C++实训，大学物理，概率论等等。</p><p>感觉不能说按照之前的专注于某一方向了，必须都得会，CF得早日上绿了（好久没打实时赛了，应该问题不大）。</p><p>实训只是在黑框框中实现了原理，当前的重要任务还是得先学好图形化，不然就没办法继续进展。</p>]]></content>
      
      
      <categories>
          
          <category> Plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诸子百家</title>
      <link href="/posts/f39cb498.html"/>
      <url>/posts/f39cb498.html</url>
      
        <content type="html"><![CDATA[<h1 id="诸子百家">诸子百家</h1><p>受某位大佬启发，打算整理一份算法的<s>百科全书</s>。</p><p>来源千奇百怪：包括个人博客，知乎文章，CSDN等等。</p><h2 id="杂项">杂项</h2><p>洛谷日报：<a href="https://www.luogu.com.cn/discuss/755848">2024 年洛谷日报索引创建</a></p><h2 id="大佬的博客">大佬的博客</h2><p>DPCC：<a href="https://www.totorocatcat.top/2024/03/31/WhatToDo/">What To Do | Totoro の旅 (totorocatcat.top)</a></p><p>秋钧：<a href="https://www.zhihu.com/column/c_1668286831920697344">算法学习笔记 - 知乎 (zhihu.com)</a></p><p>Pecco：<a href="https://www.zhihu.com/column/c_1182444932760125440">算法学习笔记 - 知乎 (zhihu.com)</a></p><p>严格鸽：<a href="https://www.zhihu.com/column/c_1548406061400498176">数据结构学习笔记 - 知乎 (zhihu.com)</a></p><p>hzwer：<a href="http://hzwer.com/">hzwer-blog</a></p><p>天才少女 珈百璃：<a href="https://www.zhihu.com/column/c_1447314601347649536">珈百璃的算法学习笔记</a></p><p>Matrix67: The Aha Moments：<a href="http://www.matrix67.com/blog/">某位大佬前辈的博客</a>;</p><p>K8he：<a href="https://www.cnblogs.com/K8He">K8he-blog</a></p><p>朝夕：<a href="https://zhuanlan.zhihu.com/p/112564411">【朝夕的ACM笔记】目录与索引</a></p><p>bhbjzyh：<a href="https://www.zhihu.com/column/c_1695477369492799488">算法</a></p><p>凉笙：<a href="https://www.cnblogs.com/Liang-sheng">东风夜放花千树，更吹落，星如雨</a></p><p>菠萝头：<a href="https://www.zhihu.com/column/c_1191379407951208448">算法竞赛</a></p><p>子谦：<a href="https://www.cnblogs.com/hanruyun">子谦。愿得忘忧水千觞，尽饮却愁再轻狂</a></p><p>_Lancy：<a href="https://www.cnblogs.com/ifmyt">nonxiaobai</a></p><p>xishanmeigao：<a href="https://www.cnblogs.com/xishanmeigao">xishanmeigao：每个问题里都藏着一个机会。Inside of every problem lies an opportunity.</a></p><p>hqztrue：<a href="https://www.zhihu.com/column/interestingalgorithms">算法随笔</a></p><p>北纬：<a href="https://www.zhihu.com/column/c_1550926641895014400">算法板子：收录一些常用的板子</a></p><p>北纬：<a href="https://www.zhihu.com/column/c_1574548636243001344">数据结构学习笔记</a></p><p>AnderL：<a href="https://www.zhihu.com/column/c_1510026670371643392">算法：Just for fun! 有趣的算法，不止竞赛</a></p><p>YangHan：<a href="https://www.zhihu.com/people/hans-55-17/posts">YangHan</a></p><p>sunhhhhh：<a href="https://www.zhihu.com/column/c_1698733541767307264">算法学习与复习笔记</a></p><h2 id="数据结构">数据结构</h2><p><a href="https://zhuanlan.zhihu.com/p/656702623">HelenXYZ：线段树，从入门到入坑</a></p><p><a href="https://zhuanlan.zhihu.com/p/246255556">Pecco：算法学习笔记(49): 线段树的拓展</a></p><p><a href="https://zhuanlan.zhihu.com/p/250565583">Pecco：算法学习笔记(50): 可持久化线段树</a></p><p><a href="https://zhuanlan.zhihu.com/p/575513452">Pecco：算法学习笔记(88): 线段树合并</a></p><p><a href="https://zhuanlan.zhihu.com/p/650874844">秋钧：笛卡尔树</a></p><p><a href="https://zhuanlan.zhihu.com/p/664621324">江南西路转运使：算法杂记 | 珂朵莉树</a></p><p><a href="https://zhuanlan.zhihu.com/p/657693348">HelenXYZ：FHQtreap，从入门到入坑</a></p><p><a href="https://zhuanlan.zhihu.com/p/556896902">严格鸽：数据结构学习笔记(1) Splay树 （splay实现区间操作</a></p><p><a href="https://zhuanlan.zhihu.com/p/558263140">严格鸽：数据结构学习笔记(1.1) splay树实现区间移动</a></p><p><a href="https://www.luogu.com/article/xrx28e6s">Sweetlemon：朝花中学OI队的奋斗历程——浅谈单调队列</a></p><p><a href="https://blog.csdn.net/FSAHFGSADHSAKNDAS/article/details/52825227">*ACoder*：单调队列优化的多重背包</a></p><p><a href="https://www.cnblogs.com/OIerShawnZhou">退役的Shawn Zhou的博客</a></p><p><a href="https://www.luogu.com/article/8g0pcl0w">Chanis：可以代替线段树的树状数组?——树状数组进阶(1)</a></p><p><a href="https://www.luogu.com/article/zohv6lup">Chanis：可以代替平衡树的树状数组?——树状数组进阶(2)</a></p><p><a href="https://www.luogu.com/article/0fo8ebvb">westernhan：树状数组的新构想</a></p><h2 id="动态规划">动态规划</h2><p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com.cn/article/63y3zs3d">_Watcher：数位DP模板</a></p><p><a href="https://zhuanlan.zhihu.com/p/659651268">秋钧：斜率优化动态规划</a></p><p><a href="https://zhuanlan.zhihu.com/p/663944537">bhbjzyh：动态规划的各种常见优化</a></p><p><a href="https://zhuanlan.zhihu.com/p/665082087">bhbjzyh：动态 DP 详讲</a></p><p><a href="https://web.archive.org/web/20111007185146/http://www.notonlysuccess.com/?p=931">NotOnlySuccess：【完全版】插头DP</a></p><p><a href="https://zhuanlan.zhihu.com/p/125145772">utobe：ACM动态规划总结</a></p><p><a href="https://www.luogu.com/article/vx7a76on">command_block：DP的决策单调性优化总结</a></p><h2 id="字符串">字符串</h2><p><a href="https://zhuanlan.zhihu.com/p/105629613">Pecco：算法学习笔记(13): KMP算法</a></p><p><a href="https://zhuanlan.zhihu.com/p/669489914">bhbjzyh：exKMP/Z 函数 学习笔记</a></p><p><a href="https://zhuanlan.zhihu.com/p/672592136">江南西路转运使：算法杂记 | AC自动机</a></p><p><a href="https://zhuanlan.zhihu.com/p/649662771">秋钧：后缀数组（SA）</a></p><p><a href="https://zhuanlan.zhihu.com/p/665086302">bhbjzyh：SAM 后缀自动机详讲</a></p><h2 id="图论">图论</h2><p><a href="https://zhuanlan.zhihu.com/p/651688492">秋钧：单源（全源）最短路及其应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/349530425">Pecco：算法学习笔记(69): 强连通分量</a></p><p><a href="https://zhuanlan.zhihu.com/p/660554775">秋钧：Tarjan 算法相关（超详细！！！）</a></p><p><a href="https://zhuanlan.zhihu.com/p/567569277">严格鸽：ACM教程之 Kruskal重构树</a></p><p><a href="https://zhuanlan.zhihu.com/p/96229700">Pecco：算法学习笔记(5)：匈牙利算法</a></p><p><a href="https://zhuanlan.zhihu.com/p/648735863">秋钧：网络最大流</a></p><p><a href="https://zhuanlan.zhihu.com/p/671008388">bhbjzyh：最小费用最大流</a></p><p><a href="https://zhuanlan.zhihu.com/p/42102528">Dispwnl：【洛谷日报#23】点分治略解</a></p><p><a href="https://zhuanlan.zhihu.com/p/50211772">后缀自动机·张：2-SAT</a></p><p><a href="https://www.zhihu.com/question/292283275/answer/484871888">如何看待SPFA已死这种说法？</a></p><p><a href="https://www.zhihu.com/question/268382638/answer/337778164">如何卡spfa？</a></p><h2 id="数学">数学</h2><p><a href="https://zhuanlan.zhihu.com/p/646535621">秋钧：整体二分</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581142.html">素数筛 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581101.html">乘法逆元 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581035.html">拓展欧几里得 - Horb7 - 博客园</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581137.html">龟速乘（防止爆long long）</a></p><p><a href="https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Horb7/p/15581097.html">拓展中国剩余定理 - Horb7 - 博客园</a></p><p><a href="https://zhuanlan.zhihu.com/p/108422764">Pecco：算法学习笔记(18): 欧拉函数</a></p><p><a href="https://zhuanlan.zhihu.com/p/645333706">秋钧：数论入门</a></p><p><a href="https://zhuanlan.zhihu.com/p/682429893">秋钧：线性代数在OI中的基础应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/330669300">ShineEternal：数论小白都能看懂的数学期望讲解</a></p><p><a href="https://zhuanlan.zhihu.com/p/671870244">bhbjzyh：快速傅里叶变化（FFT）入门</a></p><p><a href="https://www.luogu.com.cn/article/dz62cu5t">ShineEternal：数论小白都能看懂的线性方程组及其解法</a></p><p><a href="https://www.luogu.com.cn/article/td3ah746">ShineEternal：数论小白都能看懂的平面凸包详解</a></p><h2 id="计算几何">计算几何</h2><p><a href="https://link.zhihu.com/?target=https%3A//www.luogu.com/article/a9lmcppw">辰星凌：计算几何全家桶</a></p><h2 id="技巧">技巧</h2><p><a href="https://zhuanlan.zhihu.com/p/33080292">CFhM-R：ACM比赛常用技巧</a><br>以后还会再添加，不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC062</title>
      <link href="/posts/bbf4a1f5.html"/>
      <url>/posts/bbf4a1f5.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC062">ABC062</h1><blockquote><h1 id="ABC062A-Grouping">[ABC062A] Grouping</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题目描述"><strong>题目描述</strong></h3><h4 id="现在有两个序（如下图）">现在有两个序（如下图）</h4><p><img src="https://img2.imgtp.com/2024/03/27/YuR2EpRL.png" alt=""></p><h4 id="给你两个数，问你这两个数是不是在同一个序列里面的。">给你两个数，问你这两个数是不是在同一个序列里面的。</h4><h3 id="输入格式"><strong>输入格式</strong></h3><h4 id="一行，两个整数x-y-1≤x-y≤12-。">一行，两个整数x,y(1≤x,y≤12)。</h4><h3 id="输出格式"><strong>输出格式</strong></h3><p>一行如果x和y在同一个序列里，就输出Yes，否则输出No。</p><h3 id="输入样例1"><strong>输入样例1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><strong>输出样例1</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2"><strong>输入样例2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><strong>输出样例2</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="题目描述-2">题目描述</h2><p>すぬけ君は、$ 1 $ から $ 12 $ までの整数を下図のようにグループ分けしました。 整数 $ x $, $ y $ ($ 1\ &lt;\ =\ x\ &lt;\ y\ &lt;\ =\ 12 $) が与えられるので、$ x $, $ y $ が同一のグループに属しているか判定してください。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc062_a/b9e356d3a5d032bf49839a35a0ca16b703d349f5.png" alt="b4ab979900ed647703389d4349eb84ee.png"></p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ x $ $ y $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ x $, $ y $ が同一のグループに属しているならば <code>Yes</code> を、そうでなければ <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ x $, $ y $ は整数である。</li><li>$ 1\ &lt;\ =\ x\ &lt;\ y\ &lt;\ =\ 12 $</li></ul></blockquote><h2 id="思路">思路</h2><p>有趣的事情，这些数对应的恰好是对应月份的天数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">12</span>]=&#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> b,c;</span><br><span class="line">    cin&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a[b<span class="number">-1</span>]==a[c<span class="number">-1</span>]) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;<span class="comment">//判断</span></span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//比赛时不可少</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062B-Picture-Frame">[ABC062B] Picture Frame</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>给出一个长H，宽W的图像，用小写字母表示。第i行第j个字母是a(i,j)。</p><p>输出该图像最外层用一个’#'包围后的图像</p><h2 id="输入格式-3">输入格式</h2><p>输入将会按照以下格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H W</span><br><span class="line">a(1,1) ... a(1,W)</span><br><span class="line">...</span><br><span class="line">a(H,1) ... a(H,W)</span><br></pre></td></tr></table></figure><h2 id="输出格式-3">输出格式</h2><p>输出该图像最外层用一个’#'包围后的图像</p><h2 id="说明-提示">说明/提示</h2><p>1 $\le$ H,W $\le$ 100</p><p>a(i,j)是一个小写字母</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ ピクセル、横 $ W $ ピクセルの画像があります。 各ピクセルは英小文字で表されます。 上から $ i $ 番目、左から $ j $ 番目のピクセルは $ a_{ij} $ です。</p><p>この画像の周囲 $ 1 $ ピクセルを <code>#</code> で囲んだものを出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ a_{11} $ $ … $ $ a_{1W} $ $ : $ $ a_{H1} $ $ … $ $ a_{HW} $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>画像の周囲 $ 1 $ ピクセルを <code>#</code> で囲んだものを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">abc</span><br><span class="line">arc</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#####</span><br><span class="line">#abc#</span><br><span class="line">#arc#</span><br><span class="line">#####</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">z</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">###</span><br><span class="line">#z#</span><br><span class="line">###</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ &lt;\ =\ H,\ W\ &lt;\ =\ 100 $</li><li>$ a_{ij} $ は英小文字である。</li></ul></blockquote><h2 id="思路-2">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> h,w;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=w;j++)&#123;</span><br><span class="line">            cout&lt;&lt;a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=w+<span class="number">2</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062C-Chocolate-Bar">[ABC062C] Chocolate Bar</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个大小为 $H \times W$ 的矩形，由 $H \times W$ 个小矩形组成。</p><p>你需要将这个大矩形切成三个部分，要求只能沿着小矩形的边切且且出来的三个部分必须均为矩形。</p><p>请最小化切出来的三个矩形中最大矩形与最小矩形的差，并输出这个差值。</p><h2 id="题目描述-5">题目描述</h2><p>縦 $ H $ ブロック、横 $ W $ ブロックの板チョコがあります。 すぬけ君は、この板チョコをちょうど $ 3 $ つのピースに分割しようとしています。 ただし、各ピースはブロックの境目に沿った長方形でなければなりません。</p><p>すぬけ君は、$ 3 $ つのピースの面積 (ブロック数) をできるだけ均等にしようとしています。 具体的には、$ 3 $ つのピースの面積の最大値を $ S_{max} $、最小値を $ S_{min} $ としたとき、$ S_{max}\ -\ S_{min} $ を最小化しようとしています。 $ S_{max}\ -\ S_{min} $ の最小値を求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>$ S_{max}\ -\ S_{min} $ の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ &lt;\ =\ H,\ W\ &lt;\ =\ 10^5 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 5\ -\ 5\ =\ 0 $ となります。 ![2a9b2ef47b750c0b7ba3e865d4fb4203.png](<a href="https://atcoder.jp/img/arc074/2a9b2ef47b750c0b7ba3e865d4fb4203.png">https://atcoder.jp/img/arc074/2a9b2ef47b750c0b7ba3e865d4fb4203.png</a>)</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 8\ -\ 6\ =\ 2 $ となります。 ![a42aae7aaaadc4640ac5cdf88684d913.png](<a href="https://atcoder.jp/img/arc074/a42aae7aaaadc4640ac5cdf88684d913.png">https://atcoder.jp/img/arc074/a42aae7aaaadc4640ac5cdf88684d913.png</a>)</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>次図のように分割すると、$ S_{max}\ -\ S_{min}\ =\ 10\ -\ 6\ =\ 4 $ となります。 ![eb0ad0cb3185b7ae418e21c472ff7f26.png](<a href="https://atcoder.jp/img/arc074/eb0ad0cb3185b7ae418e21c472ff7f26.png">https://atcoder.jp/img/arc074/eb0ad0cb3185b7ae418e21c472ff7f26.png</a>)</p></blockquote><h2 id="思路-3">思路</h2><p>其实很好想：暴力枚举。先横切一刀，再竖切一刀。</p><p>可以先枚举横切的一块，再将剩下的一块一分为二，尽可能均分。</p><p>注意有两个横切的方向，并且要比较横切块与竖切块的大小关系。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll h,w;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//特判，如果为三的倍数，直接为0</span></span><br><span class="line">    <span class="keyword">if</span>(h%<span class="number">3</span>==<span class="number">0</span>||w%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll cnt=<span class="number">0</span>;</span><br><span class="line">        ll ans=<span class="number">1e15</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举横切，这是其中一个方向</span></span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=h;i++)&#123;</span><br><span class="line">            cnt+=w;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切能均分</span></span><br><span class="line">            <span class="keyword">if</span>((h*w-cnt)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>((h*w-cnt)/<span class="number">2</span>-cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切不能均分，需要选出最大最小</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll MAX=<span class="built_in">max</span>(cnt,(h*w-cnt+h-i)/<span class="number">2</span>);</span><br><span class="line">                ll MIN=<span class="built_in">min</span>(cnt,(h*w-cnt-h+i)/<span class="number">2</span>);</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,MAX-MIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        ll ans2=<span class="number">1e15</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//另外一个方向</span></span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=w;i++)&#123;</span><br><span class="line">            cnt+=h;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切能均分</span></span><br><span class="line">            <span class="keyword">if</span>((h*w-cnt)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                ans2=<span class="built_in">min</span>(ans2,<span class="built_in">abs</span>((h*w-cnt)/<span class="number">2</span>-cnt));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//竖切不能均分</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ll MAX=<span class="built_in">max</span>(cnt,(h*w-cnt+w-i)/<span class="number">2</span>);</span><br><span class="line">                ll MIN=<span class="built_in">min</span>(cnt,(h*w-cnt-w+i)/<span class="number">2</span>);</span><br><span class="line">                ans2=<span class="built_in">min</span>(ans2,MAX-MIN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">min</span>(ans,ans2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC062D-3N-Numbers">[ABC062D] 3N Numbers</h1><h2 id="题面翻译-4">题面翻译</h2><p>给一个长度为 $3N$ 的数组 $a=(a_1,a_2,…,a_n)$，要求删去其中 $N$ 个数使得剩余的 $2N$ 个数中前 $N$ 个数之和与后 $N$ 个数之和的差最大。</p><h2 id="题目描述-6">题目描述</h2><p>$ N $ を $ 1 $ 以上の整数とします。</p><p>長さ $ 3N $ の数列 $ a\ =\ (a_1,\ a_2,\ …,\ a_{3N}) $ があります。 すぬけ君は、$ a $ からちょうど $ N $ 個の要素を取り除き、残った $ 2N $ 個の要素を元の順序で並べ、長さ $ 2N $ の数列 $ a’ $ を作ろうとしています。 このとき、$ a’ $ のスコアを $ (a’\ の前半\ N\ 要素の総和)\ -\ (a’\ の後半\ N\ 要素の総和) $ と定義します。</p><p>$ a’ $ のスコアの最大値を求めてください。</p><h2 id="输入格式-6">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ $ … $ $ a_{3N} $</p></blockquote><h2 id="输出格式-6">输出格式</h2><p>$ a’ $ のスコアの最大値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 1 4 1 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">8 2 2 7 4 6 5 3 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ a_i $ は整数である。</li><li>$ 1\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 300 $ 点分のテストケースでは、$ N\ &lt;\ =\ 1,000 $ が成り立つ。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ a_2 $, $ a_6 $ を取り除くと、$ a’\ =\ (3,\ 4,\ 1,\ 5) $ となり、スコアは $ (3\ +\ 4)\ -\ (1\ +\ 5)\ =\ 1 $ となります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>例えば、$ a_1 $ を取り除くと、$ a’\ =\ (2,\ 3) $ となり、スコアは $ 2\ -\ 3\ =\ -1 $ となります。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>例えば、$ a_2 $, $ a_3 $, $ a_9 $ を取り除くと、$ a’\ =\ (8,\ 7,\ 4,\ 6,\ 5,\ 3) $ となり、スコアは $ (8\ +\ 7\ +\ 4)\ -\ (6\ +\ 5\ +\ 3)\ =\ 5 $ となります。</p></blockquote><h2 id="思路-4">思路</h2><p>一开始想的是单调队列？结果发现是优先队列</p><p>思路来自：[<a href="https://www.luogu.com.cn/article/zhsnt0hm">ABC062D] 3N Numbers - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>本体我们可以把整个数列划分成两部分，取第一部分（前一段）前$n$大的值，第二部分（后一段）前$n$小的值。这样对两段分别加和，然后将两端的和作差即可。</p><p>很容易想到枚举分界线，对分界线两边的数字分别取最大值，时间复杂度$O(n^2log\ n)$，不可取。</p><p>枚举分界线的操作没有二分的性质，二分也不可取。</p><p>那么如果我们能够与处理好每个分界线所对应的前后两短的最大最小值，那么问题就迎刃而解了。</p><p>很显而易见，我们可以维护一个优先队列，最大值即为整个优先队列里前$n$大的值，维护最小值亦然，便于处理完成了。</p><p>代码整体时间复杂度：$O(nlog\ n)$。</p><p>注意：<strong>不开 long long 见祖宗！</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line">ll a[MAXN],q[MAXN],p[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;ll,vector&lt;ll&gt;,greater&lt;ll&gt;&gt;pq;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">while</span>(pq.<span class="built_in">size</span>()&gt;n)sum-=pq.<span class="built_in">top</span>(),pq.<span class="built_in">pop</span>();</span><br><span class="line">        q[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ll&gt;qp;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">3</span>*n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        qp.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        <span class="keyword">while</span>(qp.<span class="built_in">size</span>()&gt;n)sum-=qp.<span class="built_in">top</span>(),qp.<span class="built_in">pop</span>();</span><br><span class="line">        p[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">-1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=n;i&lt;=<span class="number">2</span>*n;i++)ans=<span class="built_in">max</span>(ans,q[i]-p[i+<span class="number">1</span>]);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC061</title>
      <link href="/posts/22fdf04f.html"/>
      <url>/posts/22fdf04f.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC061">ABC061</h1><blockquote><h1 id="ABC061B-Counting-Roads">[ABC061B] Counting Roads</h1><h2 id="题面翻译">题面翻译</h2><p>题意简述：</p><p>有N个城市和M条道路。</p><p>第i条道路（1 &lt;= i &lt;= M）双向连接两个城市ai和bi（1 &lt;= ai，bi &lt;= N），</p><p>可能有多条道路连接同一对的两个城市。</p><p>对于每个城市，有多少条道路连接到它？</p><p>输入：N，M，每条道路的情况；</p><p>输出：连接到每个城市的道路条数。</p><p>样例输入：</p><p>4 3</p><p>1 2</p><p>2 3</p><p>1 4</p><p>样例输出：</p><p>2</p><p>2</p><p>1</p><p>1</p><p>样例解释：</p><p>共有4个城市，3条道路</p><p>1号——2号</p><p>2号——3号</p><p>1号——4号</p><p>有2条道路连接到1号，2条连接到2号，1条连接到3号，1条连接到4号。</p><p>注意：</p><p>所有道路都是双向的。</p><h2 id="题目描述">题目描述</h2><p>$ N $ 個の都市があり、$ M $ 本の道路があります。<br>$ i(1≦i≦M) $ 番目の道路は、都市 $ a_i $ と 都市 $ b_i $ $ (1≦a_i,b_i≦N) $ を双方向に結んでいます。<br>同じ $ 2 $ つの都市を結ぶ道路は、$ 1 $ 本とは限りません。<br>各都市から他の都市に向けて、何本の道路が伸びているか求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ : $ $ a_M $ $ b_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを $ N $ 行に出力せよ。<br>$ i(1≦i≦N) $ 行目には、都市 $ i $ から他の都市に向けて、何本の道路が伸びているかを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 8</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">1 5</span><br><span class="line">2 8</span><br><span class="line">3 7</span><br><span class="line">5 2</span><br><span class="line">4 1</span><br><span class="line">6 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2≦N,M≦50 $</li><li>$ 1≦a_i,b_i≦N $</li><li>$ a_i\ ≠\ b_i $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>- 都市 $ 1 $ からは $ 1 $ 番目と $ 3 $ 番目の道路が伸びています。 - 都市 $ 2 $ からは $ 1 $ 番目と $ 2 $ 番目の道路が伸びています。 - 都市 $ 3 $ からは $ 2 $ 番目の道路が伸びています。 - 都市 $ 4 $ からは $ 3 $ 番目の道路が伸びています。</p></blockquote><h2 id="思路">思路</h2><p>直接用邻接表模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> edge[<span class="number">55</span>][<span class="number">55</span>],ans[<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        edge[a][b]++;</span><br><span class="line">        edge[b][a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            ans[i]+=edge[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC061C-Big-Array">[ABC061C] Big Array</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目翻译">题目翻译</h2><h3 id="题目描述-2">题目描述</h3><p>有一个数组S，一开始是空的。接下来对这个数组进行N次插入操作.<br>第ii次操作会向数组中加入$b_i$<br>个整数$a_i$<br>，然后将整个数组从小到大排一次序。<br>求N次操作后, 数组中的第K个数。<br>例如S={1,2,2,3,3,3}时, 从小到大排序后第4个数是3。</p><h3 id="输入格式-2">输入格式</h3><p>第1行, 包含两个整数N,K用空格分隔.</p><p>第2行到第N+1行, 每行包含两个整数<br>$a_i$,$b_i$</p><h3 id="输出格式-2">输出格式</h3><p>输出N次操作后集合中第K小的数.</p><h3 id="说明-提示">说明/提示</h3><h4 id="数据范围">数据范围</h4><ul><li><pre><code>1≦N≦$10^5$ </code></pre></li><li><pre><code>1≦$a_i$ ,$b_i$ ≦$10^5$ </code></pre></li><li><pre><code>1≦K≦$b_1$+...+$b_n$</code></pre></li><li><pre><code>所有输入值都是整数。</code></pre></li></ul><hr><p>题目翻译者UID：370640</p><h2 id="题目描述-3">题目描述</h2><p>空の配列が $ 1 $ つあります。<br>この配列に、整数を配列に挿入する操作を $ N $ 回行います。<br>$ i(1≦i≦N) $ 回目の操作では、配列に整数 $ a_i $ を $ b_i $ 個挿入します。<br>$ N $ 回の挿入操作後の配列の中で、$ K $ 番目に小さい数を求めてください。<br>例えば、配列が $ {1,2,2,3,3,3} $ の時、$ 4 $ 番目に小さい数は $ 3 $ となります。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ a_1 $ $ b_1 $ $ : $ $ a_N $ $ b_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ N $ 回の挿入操作後の配列の中で、$ K $ 番目に小さい数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 500000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">1 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br><span class="line">100000 100000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ 1≦a_i,b_i≦10^5 $</li><li>$ 1≦K≦b_1…+…b_n $</li><li>入力は全て整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>操作後の配列は、問題文に書かれている例と同じです。</p></blockquote><h2 id="思路-2">思路</h2><p>不开long long见祖宗。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">&#125;x[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a&lt;b.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;x[i].a&gt;&gt;x[i].b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+n,cmp);</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cnt+=x[i].b;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=k)&#123;</span><br><span class="line">            cout&lt;&lt;x[i].a;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC061D-Score-Attack">[ABC061D] Score Attack</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个有 $n$ 个点和 $m$ 条边的简单有向图。其中第 $i$ 条边从点 $a_i$ 连向点 $b_i$ ，且具有权值 $c_i$。</p><p>我们在图上进行以下游戏。一开始，一个棋子被放置在点 $1$ 。玩家可以进行如下操作：</p><ul><li>当棋子位于点 $a_i$ 时，可以通过边 $i$ 将棋子移动到点 $b_i$ ，且让分数增加 $c_i$。</li></ul><p>当棋子位于点 $n$ 时，玩家可以选择让游戏结束。假设玩家一直按最优策略操作，求出游戏结束后可以增加分数的最大值。如果分数可以无限增加，输出 <code>inf</code> 。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 頂点 $ M $ 辺の重み付き有向グラフがあります。<br>$ i(1≦i≦M) $ 番目の辺は 頂点 $ a_i $ から 頂点 $ b_i $ を重み $ c_i $ で結びます。<br>このグラフと駒を利用して、次の1人ゲームを行います。</p><p>最初、駒を頂点 $ 1 $ に置いて、プレイヤーのスコアを $ 0 $ とします。<br>プレイヤーは、次の条件で駒を繰り返し移動させることができます。</p><ul><li>頂点 $ a_i $ に駒があるとき、$ i $ 番目の辺を利用して頂点 $ b_i $ に移動する。移動後にプレイヤーのスコアが $ c_i $ 加算される。</li></ul><p>頂点 $ N $ に駒があるときのみ、ゲームを終了できます。<br>なお、与えられる有向グラフの上で頂点 $ 1 $ から頂点 $ N $ に移動できることは保障されています。</p><p>プレイヤーがゲーム終了時のスコアを出来るだけ大きくするような行動を取ったとき、ゲーム終了時のスコアはいくつになるでしょうか?<br>ゲーム終了時のスコアをいくらでも大きくできる場合は <code>inf</code> と出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_M $ $ b_M $ $ c_M $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>もし、ゲーム終了時のスコアをいくらでも大きくできる場合は <code>inf</code>、そうでない場合はゲーム終了時のスコアの最大値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">1 3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">1 2 1</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inf</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">1 2 -1000000000</span><br><span class="line">2 3 -1000000000</span><br><span class="line">3 4 -1000000000</span><br><span class="line">4 5 -1000000000</span><br><span class="line">5 6 -1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-5000000000</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦N≦1000 $</li><li>$ 1≦M≦min(N(N-1),2000) $</li><li>$ 1≦a_i,b_i≦N\ (1≦i≦M) $</li><li>$ a_i≠b_i\ (1≦i≦M) $</li><li>$ a_i≠a_j $ または $ b_i≠b_j\ (1≦i\ &lt;\ j≦M) $</li><li>$ -10^9≦c_i≦10^9\ (1≦i≦M) $</li><li>$ c_i $ は整数である。</li><li>与えられるグラフには、頂点 $ 1 $ から頂点 $ N $ への経路が存在する。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>駒を頂点 $ N=3 $ に移動できる経路は以下の $ 2 $ 通りです。 - 頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 3 $ : スコア $ 4+3=7 $ - 頂点 $ 1 $ → 頂点 $ 3 $ : スコア $ 5 $ したがって、ゲーム終了時のスコアの最大値は $ 7 $ となります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>頂点 $ 1 $ → 頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 2 $ … と移動することで、ゲーム終了時のスコアをいくらでも増やせます。</p></blockquote><h2 id="思路-3">思路</h2><p>思路参考自：<a href="https://www.luogu.com.cn/article/3u32mbew">题解 ABC 061 D - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>很显然，题目让我们找最长路或者找正环</p><p>可以边权转负，所以就变成了找最短路+找负环。用SPFA即可。</p><p>然后你会发现 WA 了，我们的思路好像并没有问题，再读一遍题：</p><blockquote><p>If it is possible to increase the score indefinitely, print <code>inf</code>.</p><p>如果分数可以无限增加，输出 <code>inf</code> 。</p></blockquote><p>分数无限增加一定是有正环，但有正环分数就一定会无限增加么？</p><p>如果有一个正环，但从$1$到$n$的路径上并不会经过，那么他对答案是没有影响的，</p><p>所以开始时说的“找正环”是不对的，应该是 <strong>找最长路径上是否经过正环</strong>，</p><p>这样我们只需要判断$n$是否在正环上就可以了。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//思路：找最长路径、判断是否成环</span></span><br><span class="line"><span class="comment">//然后边权转负就成了最短路+找负环，用SPFA跑一遍即可</span></span><br><span class="line"><span class="comment">//分数无限增加一定是有正环，但有正环分数就一定会无限增加么？</span></span><br><span class="line"><span class="comment">//如果有一个正环，但从1到n的路径上并不会经过，那么他对答案是没有影响的</span></span><br><span class="line">ll dis[MAXN],vis[MAXN],inq[MAXN],cnt[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to,val;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to,val&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)dis[i]=LONG_LONG_MAX&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>,vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e:edge[u])&#123;</span><br><span class="line">            <span class="type">int</span> to=e.to;</span><br><span class="line">            <span class="keyword">if</span>(inq[to])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[to]&gt;dis[u]+e.val)&#123;</span><br><span class="line">                dis[to]=dis[u]+e.val;</span><br><span class="line">                <span class="keyword">if</span>(!vis[to])&#123;</span><br><span class="line">                    vis[to]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(to);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//这个我已经忘了</span></span><br><span class="line">                    <span class="keyword">if</span>(++cnt[to]&gt;=n)&#123;</span><br><span class="line">                        inq[to]=<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inq[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        <span class="built_in">add</span>(u,v,-w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;inf\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;-dis[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC060</title>
      <link href="/posts/55fac0d9.html"/>
      <url>/posts/55fac0d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC060">ABC060</h1><blockquote><h1 id="ABC060B-Choose-Integers">[ABC060B] Choose Integers</h1><h2 id="题面翻译">题面翻译</h2><p>问在A的倍数里有没有除B余C的，如果有输出&quot;YES&quot;(双引号不输出)，否则输出&quot;NO&quot;(双引号不输出)</p><h2 id="题目描述">题目描述</h2><p>あなたは、正の整数をいくつか選び、それらの総和を求めます。</p><p>選ぶ数の上限や、選ぶ整数の個数に制限はありません。 どんなに大きな整数を選んでもよいですし、整数を $ 5000 $ 兆個選んでもよいです。 ただし、選ぶ数はすべて $ A $ の倍数でなくてはいけません。 また、少なくとも $ 1 $ つは整数を選ばなくてはいけません。</p><p>そして総和を $ B $ で割ったあまりが $ C $ となるようにしたいです。 こうなるように整数を選ぶことが出来るか判定してください。</p><p>出来るならば <code>YES</code>、そうでないならば <code>NO</code> を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $</p></blockquote><h2 id="输出格式">输出格式</h2><p><code>YES</code> か <code>NO</code> を出力する。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 100 97</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40 98 58</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">77 42 36</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ A\ ≦\ 100 $</li><li>$ 1\ ≦\ B\ ≦\ 100 $</li><li>$ 0\ ≦\ C $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>たとえば $ 7,\ 14 $ を選ぶと総和は $ 21 $ となり、これを $ 5 $ で割ったあまりは $ 1 $ となります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>偶数をいくつ足したとしても、けっして奇数になることはありません。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>$ 1 $ の倍数、つまりすべての整数が選べるので、$ 97 $ を選べば良いです。</p></blockquote><h2 id="思路">思路</h2><p>比较常见的解法就是从1开始枚举，直到b。因为$a*(b+k)\ mod\ b=0$一定成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span><span class="comment">//万能头文件可好 </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//主函数 </span></span><br><span class="line"><span class="type">int</span> a,b,c;<span class="comment">//定义 </span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<span class="comment">//输入 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=b;i++)&#123;<span class="comment">//开始循环判断，前文有解释 </span></span><br><span class="line"><span class="keyword">if</span>((a*i)%b==c)&#123;<span class="comment">//若符合题意 </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);<span class="comment">//输出，换行是个好习惯 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//提前结束程序 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);<span class="comment">//如果一直没有符合题意的倍速，则输出NO </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//over~</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种比较有趣的解法（来自：<a href="https://www.luogu.com.cn/article/t62zzh3p">题解 AT2554 【Choose Integers】 - 洛谷专栏 (luogu.com.cn)</a>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int gcd(int x , int y)&#123;//最大公约数函数</span><br><span class="line">while(x % y)&#123;//更相减损法进阶：辗转相除法</span><br><span class="line">int r = x % y;//取余</span><br><span class="line">x = y;</span><br><span class="line">y = r;//迭代</span><br><span class="line">&#125;</span><br><span class="line">return y;//最大公约数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">int a , b , c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;//被除数，除数，余数</span><br><span class="line"></span><br><span class="line">if(c % gcd(a , b) == 0)&#123;//这条式子下面会给出证明</span><br><span class="line">cout &lt;&lt; &quot;YES&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">cout &lt;&lt; &quot;NO&quot;;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="证明">证明</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//证明：</span></span><br><span class="line"><span class="comment">//原题可表示为 </span></span><br><span class="line"><span class="comment">//k * a - p * b = c</span></span><br><span class="line"><span class="comment">//原式 = gcd(a , b) * [k * a / gcd(a , b) - p * b / gcd(a , b)]</span></span><br><span class="line"><span class="comment">//因为 k , p为任意整数</span></span><br><span class="line"><span class="comment">//所以 [k * a / gcd(a , b) - p * b / gcd(a , b)] 可以取任意整数值</span></span><br><span class="line"><span class="comment">//所以当 c 能整除 gcd(a , b)时 , 可以满足题目条件</span></span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC060C-Sentou">[ABC060C] Sentou</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>在一个公共澡堂里，有一个淋浴器。在按下开关时，淋浴器将会开始运作，在 $T$ 秒内一直流出热水。</p><p>如果你在淋浴器运作的情况下时按下开关，水就会从当前时间开始继续运作 $T$ 秒，而不是让淋浴器多运作 $T$ 秒。</p><p>在这个淋浴间前，有 $N$ 个人按下开关。第 $i$ 个人在第 $1$ 个人按下开关后的第 $t_i$ 个秒按下开关。请求出淋浴器运作的总时间。</p><h2 id="输入格式-2">输入格式</h2><p>第一行两个整数 $N$ 和 $T$，分别表示人数和淋浴器连续工作时间。</p><p>第二行共 $N$ 个整数，第 $i$ 个整数代表 $t_i$，含义见题目描述。</p><h2 id="输出格式-2">输出格式</h2><p>一行一个整数，淋浴器运作的总时间。</p><h2 id="数据范围">数据范围</h2><ul><li>$ 1\ \leq\ N\ \leq\ 200,000 $</li><li>$ 1\ \leq\ T\ \leq\ 10^9 $</li><li>$ 0\ =\ t_1\ &lt;\ t_2\ &lt;\ t_3\ &lt;\ ,\ …,\ &lt;\ t_{N-1}\ &lt;\ t_N\ \leq\ 10^9 $</li><li>$ T $ 和 $ t_i $ 都是整数。</li></ul><h2 id="题目描述-3">题目描述</h2><p>とある銭湯には、スイッチを押すと $ T $ 秒間お湯が出るシャワーがあります。</p><p>なお、お湯が出ているときにスイッチを押すと、そのタイミングから $ T $ 秒間お湯が出つづけます。 お湯の出る時間が $ T $ 秒間延長されるわけではないことに注意してください。</p><p>このシャワーの前を、$ N $ 人の人がスイッチを押して通り過ぎていきます。 $ i $ 人目の人は、$ 1 $ 人目の人がスイッチを押した $ t_i $ 秒後にスイッチを押します。</p><p>お湯が出る時間の総和は何秒かを求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T $ $ t_1 $ $ t_2 $ … $ t_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>お湯が出る時間の総和を $ X $ 秒として、$ X $ を出力する。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 4</span><br><span class="line">0 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1000000000</span><br><span class="line">0 1000 1000000 1000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000000000</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-5-2">样例 #5</h2><h3 id="样例输入-5-2">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 10</span><br><span class="line">0 3 5 7 100 110 200 300 311</span><br></pre></td></tr></table></figure><h3 id="样例输出-5-2">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">67</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 200,000 $</li><li>$ 1\ ≦\ T\ ≦\ 10^9 $</li><li>$ 0\ =\ t_1\ &lt;\ t_2\ &lt;\ t_3\ &lt;\ ,\ …,\ &lt;\ t_{N-1}\ &lt;\ t_N\ ≦\ 10^9 $</li><li>$ T,\ t_i $ はすべて整数である</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1 $ 人目の人がスイッチを押し、お湯が $ 3 $ 秒出た後にもう一度スイッチが押され、$ 4 $ 秒間お湯が出続けます。 よって合計で $ 7 $ 秒間お湯が出ます。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>$ 1 $ 人目の人がスイッチを押して、お湯が出終わった $ 1 $ 秒後にもう一度スイッチが押されます。</p></blockquote><h2 id="思路-2">思路</h2><p>只要判断这段时间段内是否重合即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,t;cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    ll ans=t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//重合了，更新加上差值</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]+t&gt;a[i+<span class="number">1</span>])&#123;</span><br><span class="line">            ans+=a[i+<span class="number">1</span>]-a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有重合，加上t</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ans+=t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC060D-Simple-Knapsack">[ABC060D] Simple Knapsack</h1><h2 id="题面翻译-3">题面翻译</h2><p>你有 $N$ 个物品和容量为 $W$ 的背包，每个物品要么选要么不选,它们的体积为 $w_i$，价值为 $v_i$，求总体积至多为 $W$ 情况下能拿走物品价值的最大值。</p><p><strong>【数据范围】</strong></p><p>$1\le N \le 100$，$1\le W \le 10^9$，$1 \le w_i \le 10^9$<br>$w_1 \le w_i \le w_1+3 (i=2,3,\cdots N)$<br>$1 \le v_i \le 10^7$<br>$W,w_i,v_i$ 都是整数</p><p>翻译：<a href="https://www.luogu.org/space/show?uid=68706">So_what</a></p><h2 id="题目描述-4">题目描述</h2><p>あなたは $ N $ 個の物と、強度 $ W $ のバッグを持っています。 $ i $ 個目の物は、重さが $ w_i $ で価値が $ v_i $ です。</p><p>あなたは、物のうちいくつかを選び、バッグに入れます。 ただし、選んだ物の重さの和は $ W $ 以下でなくてはいけません。</p><p>あなたは、バッグに入れた物の価値の総和を最大化したいです。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ W $ $ w_1 $ $ v_1 $ $ w_2 $ $ v_2 $ : $ w_N $ $ v_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>価値の総和の最大値を出力する。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">2 1</span><br><span class="line">3 4</span><br><span class="line">4 10</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">2 1</span><br><span class="line">3 7</span><br><span class="line">4 10</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 10</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">400</span><br></pre></td></tr></table></figure><h2 id="样例-4-3">样例 #4</h2><h3 id="样例输入-4-3">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br><span class="line">10 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-3">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 100 $</li><li>$ 1\ ≦\ W\ ≦\ 10^9 $</li><li>$ 1\ ≦\ w_i\ ≦\ 10^9 $</li><li>すべての $ i\ =\ 2,3,…,N $ について、$ w_1\ ≦\ w_i\ ≦\ w_1\ +\ 3 $</li><li>$ 1\ ≦\ v_i\ ≦\ 10^7 $</li><li>$ W,\ w_i,\ v_i $ はすべて整数である</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ 1,\ 3 $ 個目の物を選ぶと良いです。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>$ 2,\ 4 $ 個目の物を選ぶと良いです。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>すべての物が選べます。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>$ 1 $ 個も物が選べません。</p></blockquote><h2 id="思路-3">思路</h2><p>一开始，一眼01背包，交上去RE了qwq。</p><p>仔细一看，才发现范围竟然是$10^9$,然后自己又眼瞎，没看到$w_1\leq w_i \leq w_1+3$~~~~。</p><p>所以看题解喽。</p><blockquote><h3 id="前言">前言</h3><p>为什么我现在才发现这道题洛谷里面有……</p><p><a href="https://www.luogu.com.cn/problem/AT2556">题目链接</a></p><p><strong>正解：01 背包</strong></p><p>一道比较简单的创新 01 背包。</p><hr><h3 id="正解">正解</h3><p>如果按照背包的板子做，那么一定会 TLE 和 MLE。那如何优化呢？</p><p>我们注意到数据范围里有一句十分特殊的话：</p><blockquote><p>对于每个$i=2,3,···n$，满足$W_1\leq W_i\leq W_1+3$</p></blockquote><p>那么我们完全可以把每个物品的重量以$W_1$为基准，转化为一个不超过3的数。这么可以极大地优化空间复杂度。</p><p>用$h$代表$W_1$的真实数字。</p><p>但是这样的话，我们就无法得知我们现在装的东西到底有没有超过背包的容量，因为我们并不知道我们选了多少个东西。所以$dp$数组还需要开一维代表选择物品的个数。</p><p>所以$dp_{i,j,k}$代表在前$i$个物品中选择$k$个物品，背包容量为$j$时的最大价值。</p><p>还需要注意一下循环的范围：</p><ul><li>$i：1-n$</li></ul><p>（这个不需要解释了吧……）</p><ul><li>$j:0-3*i$</li></ul><p>（因为物品的重量被处理过，当原来的$W_i=W_1$时这个物品的重量为0。所以最小的背包容量有可能是 00。物品最大的重量不超过3，有$i$个物品，所以最大可能容量为$3*i$。）</p><ul><li>$k:1-i$</li></ul><p>（选择的物品数量不能超过总数。因为后面求答案$ans$的初始值就为0已经包括了一个都不选的情况，所以不需要考虑不选物品的情况。）</p><p>最后求答案的时候需要枚举$dp_{n,i,j}$，注意只有$i+j*h\leq m$时背包才不超限，可以更新答案。</p><p>具体见代码。</p><h3 id="Code">Code</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b) (a)&gt;(b)?(a):(b) <span class="comment">//卡常小技巧：用这个比库函数要快一些</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line">ll n,m,ans,h,w[<span class="number">105</span>],v[<span class="number">105</span>],dp[<span class="number">105</span>][<span class="number">305</span>][<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;h,&amp;v[<span class="number">1</span>]); <span class="comment">//h 代表 W1 的的重量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld&quot;</span>,&amp;w[i],&amp;v[i]);</span><br><span class="line">w[i]-=h; <span class="comment">//以 W1 为基准转化每一件物品的重量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=i;k++)&#123; <span class="comment">//选择的物品数量不能大于总数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">3</span>*i;j++)&#123; <span class="comment">//3*i 为被允许的最大容量</span></span><br><span class="line"><span class="keyword">if</span>(j&lt;w[i])</span><br><span class="line">dp[i][j][k]=dp[i<span class="number">-1</span>][j][k];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j][k]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][k],dp[i<span class="number">-1</span>][j-w[i]][k<span class="number">-1</span>]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//在合法的范围内寻找最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>*n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i+j*h&lt;=m)</span><br><span class="line">ans=<span class="built_in">max</span>(ans,dp[n][i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>再贴上另外一篇文章：<a href="https://www.luogu.com.cn/article/9a3g900f">题解AT_arc073_b - 洛谷专栏 (luogu.com.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC059</title>
      <link href="/posts/70b2bbe.html"/>
      <url>/posts/70b2bbe.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC059">ABC059</h1><blockquote><h1 id="ABC059A-Three-letter-acronym">[ABC059A] Three-letter acronym</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个由小写英文字母组成的字符串，以大写字母的方式输出它们的首字母。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる $ 3 $ つの単語 $ s_1 $, $ s_2 $, $ s_3 $ が空白区切りで与えられるので、単語の先頭の文字をつなげ、大文字にした略語を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s_1 $ $ s_2 $ $ s_3 $</p></blockquote><h2 id="输出格式">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoder beginner contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resident register number</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RRN</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">k nearest neighbor</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KNN</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async layered coding</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALC</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ s_1 $, $ s_2 $, $ s_3 $ は英小文字からなる。</li><li>$ 1\ ≦|s_i|≦\ 10\ (1≦i≦3) $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>atcoder</code> <code>beginner</code> <code>contest</code> の先頭の文字はそれぞれ<code>a</code> <code>b</code> <code>c</code>なので、<code>ABC</code>が答えになります。</p></blockquote><h2 id="思路">思路</h2><p>为什么会写这道题解？因为经常忘了ASCII码大小写字母转换差<strong>32</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[i][<span class="number">0</span>]&amp;&amp;s[i][<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)cout&lt;&lt;<span class="built_in">char</span>(s[i][<span class="number">0</span>]<span class="number">-32</span>);</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;s[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059B-Comparison">[ABC059B] Comparison</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题目描述-2">题目描述</h3><p>给定两个正整数 $a, b$，比较他们的大小。</p><h3 id="输入格式-2">输入格式</h3><p>输入有两行，第一行为数 $a$，第二行为数 $b$。</p><h3 id="输出格式-2">输出格式</h3><p>如果 $a &gt; b$，输出 “GREATER”；如果 $a = b$，输出 “EQUAL”，如果 $a &lt; b$，输出 “LESS”。</p><h3 id="数据范围">数据范围</h3><p>$1 \le a, b \le 10^{100}$，保证 $a, b$ 均无前导零。</p><h2 id="题目描述-3">题目描述</h2><p>$ 2 $ つの正整数 $ A,\ B $ が与えられるので、その大小を比較してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ A\ &gt;\ B $ のとき<code>GREATER</code>、$ A\ &lt;\ B $ のとき<code>LESS</code>、$ A=B $ のとき<code>EQUAL</code>と出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">36</span><br><span class="line">24</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GREATER</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">850</span><br><span class="line">3777</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9720246</span><br><span class="line">22516266</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456789012345678901234567890</span><br><span class="line">234567890123456789012345678901</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LESS</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦A,\ B\ ≦\ 10^{100} $</li><li>入力の $ A,\ B $ の先頭は<code>0</code>でない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 36\ &gt;\ 24 $ なので、答えは<code>GREATER</code>です。</p></blockquote><h2 id="思路-2">思路</h2><p>这题还WA了两次。</p><p>注意字符串比较的是字典序，所以得看长度是否相等。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//长度相等，比较字典序。</span></span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">length</span>()==b.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;b[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;GREATER&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b[i]&gt;a[i])&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;LESS&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;EQUAL&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则直接比较字典序即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="built_in">length</span>()&gt;b.<span class="built_in">length</span>())cout&lt;&lt;<span class="string">&quot;GREATER&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;LESS&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059C-Sequence">[ABC059C] Sequence</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个长度为 $N$ 的序列 $A$，每次操作可以选择一个 $i$ 使得 $A_i$ 大小减 $1$ 或加 $1$。</p><p>记 $S_i = \sum\limits_{j = 1} ^ i A_j$，求最少的操作次数使得：</p><ul><li><p>$\forall i \in [1, n], S_i \ne 0$</p></li><li><p>$\forall i \in [1, n - 1], S_i \times S_{i + 1} &lt; 0$</p></li></ul><h2 id="题目描述-4">题目描述</h2><p>長さ $ N $ の数列があり、$ i $ 番目の数は $ a_i $ です。 あなたは $ 1 $ 回の操作でどれか $ 1 $ つの項の値を $ 1 $ だけ増やすか減らすことができます。</p><p>以下の条件を満たすために必要な操作回数の最小値を求めてください。</p><ul><li>すべての$ i\ (1≦i≦n) $ に対し、第 $ 1 $ 項から第 $ i $ 項までの和は $ 0 $ でない</li><li>すべての$ i\ (1≦i≦n-1) $ に対し、$ i $ 項までの和と $ i+1 $ 項までの和の符号が異なる</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ a_1 $ $ a_2 $ $ … $ $ a_n $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>必要な操作回数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 -3 1 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 -6 4 -5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-1 4 3 2 -5 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦\ n\ ≦\ 10^5 $</li><li>$ |a_i|\ ≦\ 10^9 $</li><li>$ a_i $ は整数</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>例えば、数列を $ 1,\ -2,\ 2,\ -2 $ に $ 4 $ 回の操作で変更することができます。この数列は $ 1,\ 2,\ 3,\ 4 $ 項までの和がそれぞれ $ 1,\ -1,\ 1,\ -1 $ であるため、条件を満たしています。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>はじめから条件を満たしています。</p></blockquote><h2 id="思路-3">思路</h2><p>不难想到，有两种情况：</p><p>1、$±±±······$</p><p>2、$-±±+······$</p><p>我们可以分别计算这两种情况，这里注意$±$号代表的分别是$+1、-1$。如果是其他数字，那么代价只会更大，这个不难想到（其实就是贪心）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN],sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先讨论+-+-的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接用sum即可，没必要开前缀和数组，否则还得维护，更麻烦</span></span><br><span class="line">        <span class="comment">//sum这里其实只维护了a_i与a_i-1之间的关系，下面也一样</span></span><br><span class="line">        sum+=a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//奇数位应该为+，但这里却是-</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>)&#123;</span><br><span class="line">            ans1-=sum<span class="number">-1</span>;</span><br><span class="line">            sum=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数位应该为-，这里却为+</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;sum&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            ans1+=sum+<span class="number">1</span>;</span><br><span class="line">            sum=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再讨论-+-+的情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        sum+=a[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//偶数位应该为+，这里却为-</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            ans2-=sum<span class="number">-1</span>;</span><br><span class="line">            sum=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//奇数位应该位-，这里却为+</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;=<span class="number">0</span>&amp;&amp;i%<span class="number">2</span>)&#123;</span><br><span class="line">            ans2+=sum+<span class="number">1</span>;</span><br><span class="line">            sum=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选出两种方案中的最小情况</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(ans1,ans2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC059D-Alice-Brown">[ABC059D] Alice&amp;Brown</h1><h2 id="题面翻译-4">题面翻译</h2><p>大意：</p><p>现有两堆石子，Alice和Brown以此进行游戏，规则如下：</p><ul><li><p><code>Alice先手</code>，两方分别按照<code>回合制</code>取石子</p></li><li><p>每个人每回合可以任意从任一堆中取出<code>2的倍数个</code>石子（前提是该堆里有这么多石子），扔掉其中的一半，将另一半放入另一堆中。</p></li><li><p>当一方<code>无法进行取石子操作</code>时视作此方失败。</p></li></ul><p>现给出石子数量n,m$(0≤n,m≤10^{18})$，请你输出胜方名称(Alice|Brown)。</p><h2 id="题目描述-5">题目描述</h2><p>AliceとBrownはゲームをするのが好きです。今日は以下のゲームを思いつきました。</p><p>$ 2 $つの山があり、はじめに$ X,\ Y $個の石が置かれています。 AliceとBrownは毎ターン以下の操作を交互に行い、操作を行えなくなったプレイヤーは負けとなります。</p><ul><li>片方の山から $ 2i $ 個の石を取り、そのうち $ i $ 個の石を捨て、残りの $ i $ 個の石をもう片方の山に置く。ここで、整数 $ i\ (1≦i) $ の値は山に十分な個数の石がある範囲で自由に選ぶことができる。</li></ul><p>Aliceが先手で、二人とも最適にプレイすると仮定したとき、与えられた $ X,\ Y $ に対しどちらのプレイヤーが勝つか求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $ $ Y $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>Aliceが勝つとき<code>Alice</code>と、Brownが勝つとき<code>Brown</code>と出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brown</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Brown</span><br></pre></td></tr></table></figure><h2 id="样例-4-3">样例 #4</h2><h3 id="样例输入-4-3">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-3">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Alice</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 0≦\ X,\ Y\ ≦\ 10^{18} $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>Aliceは $ 2 $ 個石のある山から $ 2 $ 個取るしかありません。その結果、山の石の数はそれぞれ $ 0,\ 2 $ 個となり、Brownは $ 2 $ 個の石を取り、山の石の数はそれぞれ $ 1,\ 0 $ 個となります。 Aliceはこれ以上操作を行うことができないので、Brownの勝ちです。</p></blockquote><h2 id="思路-4">思路</h2><p>博弈论。</p><p>不难发现，当$n=0,m=0$或$n=1,m=0$或$n=0,m=1$或$n=1,m=1$时，也就是$abs(n-m)&lt;=1$时，先手必输，<s>于是这题就结束了</s>。</p><p>分析一下$why$。我们假设$abs(n-m)\leq 1$时，先手先从第一堆中取出$2x$个石子。</p><p>于是$n’=n-2x,m’=m+x$，接下来轮到后手。</p><p>后手执行相同的操作，那么$n’‘=n’+x=n-x,m’‘=m’-2x=m-x$。发现还是$abs(m’‘-n’')\leq 1$.</p><p>这样一直持续下去，直到最基础的四种情况，所以先手必输。</p><p>那么$abs(n-m)&gt; 1$呢？先手可以反客为主！先手可以很简单地将$abs(n-m)&gt;1$转换为$abs(n-m)\leq1$.</p><p>所以原来的先手变成了后手，原来的后手变成了先手</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll a[MAXN],sum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b)&lt;<span class="number">2</span>)cout&lt;&lt;<span class="string">&quot;Brown&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希与字典树</title>
      <link href="/posts/5be30a9c.html"/>
      <url>/posts/5be30a9c.html</url>
      
        <content type="html"><![CDATA[<h1 id="字符串哈希">字符串哈希</h1><p>文章转载自：<a href="https://www.luogu.com.cn/article/lxwwcykj">字符串学习笔记·哈希（HASH）与字典树（Trie） - 洛谷专栏 (luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr><p>** <em>这篇博客我打算皮一下qwq，适合初学者阅读（因为讲的是在太细了）</em> **</p><h1 id="一、首先理解字符串操作的意义：">一、首先理解字符串操作的意义：</h1><h2 id="没意义"><s>没意义</s></h2><p>其实字符串操作的意义是很浅显的，比如百度的推荐搜索啊，比如查找比对一篇题解里有多少个相同或者不同的脏字然后$kkksc03$再根据其数量、恶劣程度决定用多大的刀将博主$kill$掉。。。所以字符串操作很重要啊喂$qwq$。</p><p>再来考虑时间：如果百度对于一个人的一次“常搜”推荐需要$10s$，那么对于全国网友来说，同时上网的人群基数很高，那么如果服务器性能不好的话，怕不是要三星$note\ 7\ qwq???$</p><p>所以啊，打造高效的字符串算法是很有必要滴！</p><h1 id="二、言归正传，浅析字符串哈希">二、言归正传，浅析字符串哈希</h1><p>哈希其实是所有字符串操作中，笔者认为最简单的操作了（except输入输出qwq）。哈希的过程，其实可以看作<strong>对一个串的单向加密过程</strong>，并且需要保证所加的密<strong>不能高概率重复</strong>（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样qwq），通过这种方式来替代一些很费时间的操作。</p><p>比如，最常见的，当然就是通过哈希数组来判断几个串是否相同（洛谷P3370）。此处的操作呢，很简单，就是对于每个串，<strong>我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串 *尽量* 不同。</strong></p><p>此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如ab和ba，并不是同一个串，但是如是做却会让其认为是qwq）。这种情况就叫做**$hash$冲突**，并且在如此的单向加密哈希中，$hash$冲突的情况在所难免（bzoj就有这种让你给出一组样例，使得一段哈希代码冲突的题，读者可以尝试尝试）。</p><p>而我们此处介绍的，即是最常见的一种哈希：<strong>进制哈希</strong>。进制哈希的核心便是<strong>给出一个固定进制$base$，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个$base$进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同</strong></p><p>奉上$P3370AC$代码（单哈希）：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ull;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull a[<span class="number">10010</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> prime=<span class="number">233317</span>; </span><br><span class="line">ull mod=<span class="number">212370440130137957ll</span>;</span><br><span class="line"><span class="function">ull <span class="title">hashe</span><span class="params">(<span class="type">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line"> ull ans=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line"> ans=(ans*base+(ull)s[i])%mod+prime;</span><br><span class="line"> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"> a[i]=<span class="built_in">hashe</span>(s);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(a[i]!=a[i+<span class="number">1</span>])</span><br><span class="line"> ans++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性</p><h2 id="1、无错哈希">1、无错哈希</h2><p>其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突（比如somebody’s birthday qwq）。</p><p>先贴代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="comment">//m个串</span></span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;str;<span class="comment">//下一行的check为bool型 </span></span><br><span class="line"><span class="keyword">while</span>(check[<span class="built_in">hash</span>(str)])hash[i]+=<span class="number">19260817</span>;</span><br><span class="line">hash[i]+= <span class="built_in">hash</span>(str) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如下图（亲手做的<s>英文高逼格</s>）：</p><p><img src="https://img2.imgtp.com/2024/03/26/MMacPCbS.png" alt=""></p><p>但是，这种方法类似桶查找，但是桶查找的弊端2就会很恶心——数据过大，$check$数组无能为力来支持上亿个空间（弊端1是由于数据具有跳跃性，浪费最后的统计次数，但在此不是特别明显，就当我皮了一下qwq）</p><h2 id="2、多重哈希">2、多重哈希</h2><p>这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性。</p><p><img src="https://img2.imgtp.com/2024/03/26/Rih5RpxS.png" alt=""></p><p>下面皮一个哈希自动机qwq（不用百度了，名字自己起的）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//哈希自动机,需要二维hash数组 </span></span><br><span class="line"><span class="keyword">for</span>伪代码排序，用来使哈希值单调（更好判断相/不同的数量） </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">check=<span class="number">1</span>； </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=qwq;j++)<span class="comment">//皮一下</span></span><br><span class="line"><span class="keyword">if</span>(hash[j][i]==hash[j][i+<span class="number">1</span>])&#123;check=<span class="number">0</span>;<span class="keyword">break</span>;&#125; </span><br><span class="line"><span class="keyword">if</span>(check)ans++;<span class="comment">//此为判断相同个数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、字典树浅析">三、字典树浅析</h1><h2 id="1、简要介绍">1、简要介绍</h2><p>首先要知道，字典树是一种假想数据结构（数据结构不都是 假想的吗qwq），那么问题来了——为什么是要用字典树呢？为什么不用类似字典链表之类的东西呢？很简单，所有树形结构 都有一个基本特点，就是</p><p><strong>元素与元素间的关系为继承的一对多关系</strong>。</p><p>拿字典树来说，每一个元素都可以有几个子元素，作为它之后的字母；<strong>而倘若要比对两个字符串是否相同，只需要比对在这棵字典树上，这两个串最后一个元素的祖先链(即前缀)是否相同，并且对于祖先链来说，并不用逐个比较，只需要记录访问就行</strong></p><p>比如下图就是一棵$Trie$，这里用颜色区分单词路径上的点，</p><p><img src="https://img2.imgtp.com/2024/03/26/d33Z3qzO.png" alt=""></p><h2 id="2、字典树基础与如何建树（插入操作）">2、字典树基础与如何建树（插入操作）</h2><p>首先，关于字典树，我们一般不是用点来存储字符的，而是用边——为什么呢？之后再说（十分皮地卖个关子qwq）。</p><p>重新首先，一般来说，字典树是不会使用根节点的，原因很浅显，<strong>因为根节点的个数决定究竟有几棵字典树</strong>，而通常字典树是只有一棵的，否则产生森林会很麻烦（qwq你皮你就splay，并且如果有森林的话应该叫做“字典森林”啊喂）。</p><p>但是我们要知道，并不是一个题中所有的串都有公共前缀（肯定不会的吧qwq），<strong>可如果根节点唯一，就代表他们一定有公共前缀，并且公共前缀的长度必定大于等于1</strong>。</p><p>其次，<strong>字典树中每个节点的子节点数量都肯定会小于某个数。</strong></p><p>如果字典树里都是小写字母，那么“某个数”就是26；如果大小写都有，“某个数”就应该是52（证明过程：显然）；</p><p>并且<strong>每个节点的所有的边都不同</strong>，这条性质可以便于我们判断在某一棵字典树到底有没有某条链：<strong>只要前缀不符合，就不需要再判断，因为必然没有（同一深度、同一父亲，边与边必定互异）</strong></p><p>在这里，我选择用结构体来存树，具体解释见注释：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建树（其实就是存点啦）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">nodes</span>&#123;</span><br><span class="line"><span class="type">int</span> son[<span class="number">26</span>];</span><br><span class="line"><span class="comment">//此处只考虑小写字母字典树</span></span><br><span class="line">    <span class="type">bool</span> mark;</span><br><span class="line"><span class="comment">// 此为标记，作用下面说 </span></span><br><span class="line">&#125;trie[<span class="number">10001</span>]; </span><br><span class="line"><span class="type">int</span> root=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//根节点永久为0 qwq </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">insert_check</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> position=root;<span class="comment">//初始化位置,跟深度没有直接关系 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> symbol=(<span class="type">int</span>)str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">/*此处实际是因为我们的trie都是存int的,如果贸然存char会</span></span><br><span class="line"><span class="comment">很别扭qwq，并且此处由于都是小写字母，所以 -‘a’ ,如果</span></span><br><span class="line"><span class="comment">存了别的类型的字符，需要特判，保证字符容易确定 */</span></span><br><span class="line">    <span class="keyword">if</span>(!trie[position].son[symbol]) <span class="comment">//还没有被编号</span></span><br><span class="line">    trie[position].son[symbol]=++num;<span class="comment">//编一个号</span></span><br><span class="line"></span><br><span class="line">position=trie[position].son[symbol] ;</span><br><span class="line"><span class="comment">//更新迭代位置，直到字符链的最末端 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> temp=trie[position].mark;</span><br><span class="line">trie[position].mark =<span class="number">1</span>;</span><br><span class="line"><span class="comment">//将这条链的最末端置为1，如果还有重复的串，那么一定会出现</span></span><br><span class="line"><span class="comment">//最末端相同 ;反之，最末端节点的mark相同也可以推出链相同，</span></span><br><span class="line"><span class="comment">//借此来判断串是否相同 </span></span><br><span class="line"><span class="keyword">return</span> temp!=<span class="number">0</span>;</span><br><span class="line"><span class="comment">/*最后说一下为什么要编号：我们根据程序可以看出，字符串是</span></span><br><span class="line"><span class="comment">按秩插入树，所以一条链上的编号肯定满足单调，便于我们查找</span></span><br><span class="line"><span class="comment">和比对*/</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是便可以通过这种方式比对字符串，期望时间复杂度$O(n)$大多用于比对。</p><h2 id="3、关于字典树的查找">3、关于字典树的查找</h2><p>查找前缀比较好写，只需要一边判断是否符合要求，一边判断是否继续迭代即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> pos=root;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="type">int</span> x=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> <span class="keyword">if</span>(trie[pos].son[x]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> <span class="comment">//如果在建完树之后这个点还没有被编号，</span></span><br><span class="line"> <span class="comment">//那么就肯定不存在这条链。（互异性） </span></span><br><span class="line"> pos=trie[pos].son[x] ;<span class="comment">//继续迭代 </span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实查询单词和查询前缀差别不大，只是我们<strong>每次都需要维护一个$check<a href="bool">i</a>$</strong>，存在单词链的<strong>末尾</strong>。</p><p>每当一个新字符已经被标记时（即所<strong>查询单词的这个字母及其前缀都在树的某条链上</strong>），我们<strong>使这个字符$check$异于它祖先们的$check$</strong>，最后判断**该条匹配链结尾字符的$check$是否异于链上其他字符的$check$**即可判断是否有这个单词（如果没有的话，末尾的$check$肯定与链上其他的相同啊qwq）</p><p>至于前缀出现次数，很简单，只要将每一个前缀的出现次数存到它相连的子节点，最后输出前缀最后一个字符所带的次数即可（可以用数组维护，也可以直接写在结构体里）</p><p>好啦，就是这样，希望对大家有所帮助</p><h2 id="日拱一卒，功不唐捐！">日拱一卒，功不唐捐！</h2>]]></content>
      
      
      <categories>
          
          <category> 想成为串串大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序、拷贝、替换算法</title>
      <link href="/posts/e49a0ed1.html"/>
      <url>/posts/e49a0ed1.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-3-常用排序算法">5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort">5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myPrint);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle">5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge">5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line"><span class="built_in">merge</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vtarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vtarget.<span class="built_in">begin</span>(), vtarget.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse">5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法">5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy">5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace">5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if">5.4.3 replace_if</h4><p><strong>功能描述:</strong></p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceGreater30</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">replace_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">ReplaceGreater30</span>(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap">5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap</span>(v1, v2);</span><br><span class="line">for_each(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**swap交换容器时，注意交换的容器要同种类型</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用算术生成和集合算法</title>
      <link href="/posts/3c7d164.html"/>
      <url>/posts/3c7d164.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-5-常用算术生成算法">5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate">5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> total = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill">5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法">5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection">5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union">5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference">5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.<span class="built_in">resize</span>( <span class="built_in">max</span>(v1.<span class="built_in">size</span>() , v2.<span class="built_in">size</span>()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itEnd = </span><br><span class="line">        <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; endl;</span><br><span class="line">itEnd = <span class="built_in">set_difference</span>(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>());</span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), itEnd, <span class="built_in">myPrint</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用遍历与查找算法</title>
      <link href="/posts/9aa4115.html"/>
      <url>/posts/9aa4115.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="5-1-常用遍历算法">5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each">5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print01</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">print02</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), print01);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">print02</span>());</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform">5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransForm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.<span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vTarget.<span class="built_in">begin</span>(), <span class="built_in">TransForm</span>());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.<span class="built_in">begin</span>(), vTarget.<span class="built_in">end</span>(), <span class="built_in">MyPrint</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法">5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find">5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if">5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GreaterFive</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater20</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater20</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find">5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">adjacent_find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search">5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count">5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if">5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater4</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeLess35</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">AgeLess35</span>());</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**按值统计用count，按条件统计用count_if</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL-函数对象</title>
      <link href="/posts/4276ac05.html"/>
      <url>/posts/4276ac05.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-1-函数对象">4.1 函数对象</h3><h4 id="4-1-1-函数对象概念">4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用">4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd</span>(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyPrint</span>()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">mp</span>(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">doPrint</span>(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词">4.2  谓词</h3><h4 id="4-2-1-谓词概念">4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词">4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GreaterFive</span>&#123;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">GreaterFive</span>());</span><br><span class="line"><span class="keyword">if</span> (it == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词">4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">MyCompare</span>());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象">4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义">4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数">4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">50</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数">4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1,<span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数">4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!= v.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),  v2.<span class="built_in">begin</span>(), <span class="built_in">logical_not</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">bool</span>&gt;::iterator it = v2.<span class="built_in">begin</span>(); it != v2.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map容器</title>
      <link href="/posts/854fa047.html"/>
      <url>/posts/854fa047.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-9-map-multimap容器">3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念">3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值">3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数:</li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;<span class="built_in">m2</span>(m); <span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">printMap</span>(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换">3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m2;</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">m.<span class="built_in">swap</span>(m2);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"><span class="built_in">printMap</span>(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除">3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMap</span><span class="params">(map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">begin</span>(),m.<span class="built_in">end</span>());</span><br><span class="line">m.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printMap</span>(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计">3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;m; </span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator pos = m.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = m.<span class="built_in">count</span>(<span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序">3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (map&lt;<span class="type">int</span>, <span class="type">int</span>, MyCompare&gt;::iterator it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组">3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述">3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤">3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createWorker</span><span class="params">(vector&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = <span class="built_in">rand</span>() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setGroup</span><span class="params">(vector&lt;Worker&gt;&amp;v,multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;Worker&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="type">int</span> deptId = <span class="built_in">rand</span>() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showWorkerByGourp</span><span class="params">(multimap&lt;<span class="type">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">multimap&lt;<span class="type">int</span>,Worker&gt;::iterator pos = m.<span class="built_in">find</span>(CEHUA);</span><br><span class="line"><span class="type">int</span> count = m.<span class="built_in">count</span>(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(MEISHU);</span><br><span class="line">count = m.<span class="built_in">count</span>(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; endl;</span><br><span class="line">pos = m.<span class="built_in">find</span>(YANFA);</span><br><span class="line">count = m.<span class="built_in">count</span>(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.<span class="built_in">end</span>() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line">vector&lt;Worker&gt;vWorker;</span><br><span class="line"><span class="built_in">createWorker</span>(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line">multimap&lt;<span class="type">int</span>, Worker&gt;mWorker;</span><br><span class="line"><span class="built_in">setGroup</span>(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line"><span class="built_in">showWorkerByGourp</span>(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>set容器</title>
      <link href="/posts/9148134d.html"/>
      <url>/posts/9148134d.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-8-set-multiset-容器">3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念">3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值">3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;<span class="built_in">s2</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line"><span class="built_in">printSet</span>(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换">3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">100</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">300</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">200</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">swap</span>(s2);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"><span class="built_in">printSet</span>(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除">3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSet</span><span class="params">(set&lt;<span class="type">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printSet</span>(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计">3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator pos = s1.<span class="built_in">find</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="type">int</span> num = s1.<span class="built_in">count</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别">3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt;  ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; ms;</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">ms.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (multiset&lt;<span class="type">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建">3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(string(<span class="string">&quot;Tom&quot;</span>), <span class="number">20</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序">3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompare</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s1.<span class="built_in">begin</span>(); it != s1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line">set&lt;<span class="type">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">40</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">30</span>);</span><br><span class="line">s2.<span class="built_in">insert</span>(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>, MyCompare&gt;::iterator it = s2.<span class="built_in">begin</span>(); it != s2.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">comparePerson</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">set&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">insert</span>(p1);</span><br><span class="line">s.<span class="built_in">insert</span>(p2);</span><br><span class="line">s.<span class="built_in">insert</span>(p3);</span><br><span class="line">s.<span class="built_in">insert</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (set&lt;Person, comparePerson&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list容器</title>
      <link href="/posts/dc2a7b28.html"/>
      <url>/posts/dc2a7b28.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-7-list容器">3.7 list容器</h3><h4 id="3-7-1-list基本概念">3.7.1 list基本概念</h4><p>**功能：**将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://img2.imgtp.com/2024/03/26/1PdMd8EA.jpg" alt=""></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数">3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L2</span>(L1.<span class="built_in">begin</span>(),L1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L3</span>(L2);</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;<span class="built_in">L4</span>(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换">3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L3;</span><br><span class="line">L3.<span class="built_in">assign</span>(L2.<span class="built_in">begin</span>(), L2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printList</span>(L3);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L4;</span><br><span class="line">L4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printList</span>(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt;L2;</span><br><span class="line">L2.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">swap</span>(L2);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"><span class="built_in">printList</span>(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作">3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​    //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>//如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line"></span><br><span class="line">L1.<span class="built_in">resize</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">printList</span>(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除">3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line">L.<span class="built_in">push_front</span>(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">insert</span>(++it, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.<span class="built_in">begin</span>();</span><br><span class="line">L.<span class="built_in">erase</span>(++it);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">L.<span class="built_in">remove</span>(<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取">3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;L1;</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = L1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序">3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::const_iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(<span class="type">int</span> val1 , <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">90</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">L.<span class="built_in">push_back</span>(<span class="number">70</span>);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.<span class="built_in">sort</span>(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">sort</span>(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例">3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age , <span class="type">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">list&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.<span class="built_in">push_back</span>(p1);</span><br><span class="line">L.<span class="built_in">push_back</span>(p2);</span><br><span class="line">L.<span class="built_in">push_back</span>(p3);</span><br><span class="line">L.<span class="built_in">push_back</span>(p4);</span><br><span class="line">L.<span class="built_in">push_back</span>(p5);</span><br><span class="line">L.<span class="built_in">push_back</span>(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">L.<span class="built_in">sort</span>(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (list&lt;Person&gt;::iterator it = L.<span class="built_in">begin</span>(); it != L.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p></li><li><p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue容器</title>
      <link href="/posts/51c2e84a.html"/>
      <url>/posts/51c2e84a.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-6-queue-容器">3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念">3.6.1 queue 基本概念</h4><p><strong>概念：<strong>Queue是一种</strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://img2.imgtp.com/2024/03/26/nYjeUhcY.jpg" alt=""></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><h4 id="3-6-2-queue-常用接口">3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">queue&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.<span class="built_in">push</span>(p1);</span><br><span class="line">q.<span class="built_in">push</span>(p2);</span><br><span class="line">q.<span class="built_in">push</span>(p3);</span><br><span class="line">q.<span class="built_in">push</span>(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">front</span>().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.<span class="built_in">front</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.<span class="built_in">back</span>().m_Age &lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack容器</title>
      <link href="/posts/516b2848.html"/>
      <url>/posts/516b2848.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-5-stack容器">3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念">3.5.1 stack 基本概念</h4><p><strong>概念：<strong>stack是一种</strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="https://img2.imgtp.com/2024/03/26/FGuiFdJQ.jpg" alt=""></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><h4 id="3-5-2-stack-常用接口">3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque容器</title>
      <link href="/posts/58e11256.html"/>
      <url>/posts/58e11256.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-3-deque容器">3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念">3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/RUhva8I6.jpg" alt=""></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://img2.imgtp.com/2024/03/26/rnkkrVHb.jpg" alt=""></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数">3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"><span class="function">deque&lt;<span class="type">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;<span class="built_in">d3</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4 = d3;</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作">3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</p></li><li><p><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line"><span class="built_in">printDeque</span>(d2);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d3;</span><br><span class="line">d3.<span class="built_in">assign</span>(d1.<span class="built_in">begin</span>(), d1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d3);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d4;</span><br><span class="line">d4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作">3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                             //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line"></span><br><span class="line">d1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除">3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt;d2;</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">d2.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">insert</span>(d.<span class="built_in">begin</span>(), d2.<span class="built_in">begin</span>(), d2.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">d.<span class="built_in">erase</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line">d.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取">3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; d.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序">3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printDeque</span><span class="params">(<span class="type">const</span> deque&lt;<span class="type">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (deque&lt;<span class="type">int</span>&gt;::const_iterator it = d.<span class="built_in">begin</span>(); it != d.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">d.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line">d.<span class="built_in">push_front</span>(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"><span class="built_in">sort</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printDeque</span>(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector容器</title>
      <link href="/posts/4ac124aa.html"/>
      <url>/posts/4ac124aa.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-2-vector容器">3.2 vector容器</h3><h4 id="3-2-1-vector基本概念">3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/A35F09qp.jpg" alt=""></p><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数">3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                    //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作">3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</p></li><li><p><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</p></li><li><p><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">v4.<span class="built_in">assign</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小">3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​      //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.<span class="built_in">resize</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除">3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear</li></ul><h4 id="3-2-6-vector数据存取">3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器">3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="built_in">printVector</span>(v1);</span><br><span class="line"><span class="built_in">printVector</span>(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v).<span class="built_in">swap</span>(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间">3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>string容器</title>
      <link href="/posts/d1b5b4b6.html"/>
      <url>/posts/d1b5b4b6.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="3-1-string容器">3.1 string容器</h3><h4 id="3-1-1-string基本概念">3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数">3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>          //创建一个空的字符串 例如: string str;<br><code>string(const char* s);</code>        //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作">3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.<span class="built_in">assign</span>(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str6.<span class="built_in">assign</span>(str5);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str7;</span><br><span class="line">str7.<span class="built_in">assign</span>(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接">3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.<span class="built_in">append</span>(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换">3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos = str1.<span class="built_in">find</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.<span class="built_in">rfind</span>(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line">string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较">3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1</p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = s1.<span class="built_in">compare</span>(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取">3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.<span class="built_in">at</span>(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.<span class="built_in">at</span>(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除">3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串">3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">string subStr = str.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="type">int</span> pos = email.<span class="built_in">find</span>(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**总结：**灵活的运用求子串功能，可以在实际开发中获取有效的信息</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL初识</title>
      <link href="/posts/fd91c41c.html"/>
      <url>/posts/fd91c41c.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h2 id="2-STL初识">2 STL初识</h2><h3 id="2-1-STL的诞生">2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念">2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件">2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器">2.4  STL中容器、算法、迭代器</h3><p>**容器：**置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​<strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​<strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p>**算法：**问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p>**迭代器：**容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识">2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型">2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pBegin = v.<span class="built_in">begin</span>();</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator pEnd = v.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line">cout &lt;&lt; *pBegin &lt;&lt; endl;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型">2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string mName;</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p1);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p2);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p3);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p4);</span><br><span class="line">v.<span class="built_in">push_back</span>(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;Person*&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器">2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">v2.<span class="built_in">push_back</span>(i + <span class="number">2</span>);</span><br><span class="line">v3.<span class="built_in">push_back</span>(i + <span class="number">3</span>);</span><br><span class="line">v4.<span class="built_in">push_back</span>(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.<span class="built_in">push_back</span>(v1);</span><br><span class="line">v.<span class="built_in">push_back</span>(v2);</span><br><span class="line">v.<span class="built_in">push_back</span>(v3);</span><br><span class="line">v.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator vit = (*it).<span class="built_in">begin</span>(); vit != (*it).<span class="built_in">end</span>(); vit++) &#123;</span><br><span class="line">cout &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类模板</title>
      <link href="/posts/c7b3911f.html"/>
      <url>/posts/c7b3911f.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="1-3-类模板">1.3 类模板</h3><h4 id="1-3-1-类模板语法">1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">Person&lt;string, <span class="type">int</span>&gt;<span class="built_in">P1</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">P1.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别">1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;string ,<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string&gt; <span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机">1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson1</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.<span class="built_in">showPerson2</span>(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">m.<span class="built_in">fun1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数">1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">NameType</span>, <span class="keyword">class</span> <span class="title class_">AgeType</span> = <span class="type">int</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;string, <span class="type">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printPerson1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson3</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承">1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base&lt;<span class="type">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> :<span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son2</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T1).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">typeid</span>(T2).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="type">int</span>, <span class="type">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现">1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写">1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person&lt;T1, T2&gt;::<span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person&lt;T1, T2&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元">1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt; <span class="keyword">class</span> <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"><span class="keyword">friend</span> <span class="type">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printPerson</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;string, <span class="type">int</span> &gt;<span class="built_in">p</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="built_in">printPerson2</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例">1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">MyArray</span>(<span class="type">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="type">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push_back</span><span class="params">(<span class="type">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="type">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~<span class="built_in">MyArray</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="type">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="type">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.<span class="built_in">Push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="type">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.<span class="built_in">Pop_back</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printIntArray</span>(array2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125; </span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; personArr.<span class="built_in">getSize</span>(); i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p1);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p2);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p3);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p4);</span><br><span class="line">pArray.<span class="built_in">Push_back</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printPersonArray</span>(pArray);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.<span class="built_in">getSize</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.<span class="built_in">getCapacity</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数模板</title>
      <link href="/posts/c7cb3ba6.html"/>
      <url>/posts/c7cb3ba6.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++提高编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="1-2-函数模板">1.2 函数模板</h3><ul><li><p>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</p></li><li><p>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong></p></li></ul><h4 id="1-2-1-函数模板语法">1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板实现交换</span></span><br><span class="line"><span class="comment">//1、自动类型推导</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="built_in">mySwap</span>&lt;<span class="type">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个整型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapInt</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个浮点型交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapDouble</span><span class="params">(<span class="type">double</span>&amp; a, <span class="type">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//声明一个模板，告诉编译器后面的代码中紧跟的T不要报错，T是一个通用的数据类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"><span class="comment">//利用函数模板</span></span><br><span class="line"><span class="comment">//1、自动类型推导：由编译器自动推导，根据传入的数据</span></span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> c = <span class="number">1.1</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">2.2</span>;</span><br><span class="line"><span class="comment">//swapDouble(c, d);</span></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line"><span class="built_in">mySwap</span>&lt;<span class="type">double</span>&gt;(c, d);<span class="comment">//这里尖括号的数据类型对应T</span></span><br><span class="line">cout &lt;&lt; c &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项">1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li><p>自动类型推导，必须推导出一致的数据类型T,才可以使用</p></li><li><p>模板必须要确定出T的数据类型，才可以使用</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap</span>(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"><span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、自动类型推导，必须推导出一致的数据类型T才可以使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">mySwap</span>(a, b);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mySwap(a, c);//错误，推导出不一致的的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//func();//没有确定T的数据类型，无法调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="built_in">func</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例">1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">mySwap</span>(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试char数组</span></span><br><span class="line"><span class="type">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(charArr) / <span class="built_in">sizeof</span>(<span class="type">char</span>);</span><br><span class="line"><span class="built_in">mySort</span>(charArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试int数组</span></span><br><span class="line"><span class="type">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">sizeof</span>(intArr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="built_in">mySort</span>(intArr, num);</span><br><span class="line"><span class="built_in">printArray</span>(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别">1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则">1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"><span class="type">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性">1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(a, b);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"><span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"><span class="type">bool</span> ret = <span class="built_in">myCompare</span>(p1, p2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/posts/95495db.html"/>
      <url>/posts/95495db.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h2 id="5-文件操作">5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件">5.1文本文件</h3><h4 id="5-1-1写文件">5.1.1写文件</h4><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件">5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include &lt;fstream&gt;</p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><hr><p>自己的实现，有些奇怪</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ofstream a;</span><br><span class="line">    a.<span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>,ios::out);</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;123456&quot;</span>&lt;&lt;endl;</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;kkksc3&quot;</span>&lt;&lt;endl;</span><br><span class="line">    a&lt;&lt;<span class="string">&quot;scutwin&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ifstream b;</span><br><span class="line">    b.<span class="built_in">open</span>(<span class="string">&quot;测试.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="keyword">if</span>(!b.<span class="built_in">is_open</span>())&#123;</span><br><span class="line">        cerr&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种</span></span><br><span class="line">    <span class="comment">//char buf[1024]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//while(b&gt;&gt;buf)&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;buf&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">    <span class="comment">//char buf1[1024]=&#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//while(b.getline(buf1,sizeof(buf1)))&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;buf1&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">    <span class="comment">//char c;</span></span><br><span class="line">    <span class="comment">//while(b.get(c))&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种</span></span><br><span class="line">    <span class="comment">//char d;</span></span><br><span class="line">    <span class="comment">//while((d=b.get())!=EOF)&#123;</span></span><br><span class="line">    <span class="comment">//    cout&lt;&lt;d;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五种</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(b,s))&#123;</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    b.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-二进制文件">5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="5-2-1-写文件">5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件">5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="/posts/2bf420ab.html"/>
      <url>/posts/2bf420ab.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-5-运算符重载">4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载">4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//加号运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//1、成员函数重载+号</span></span><br><span class="line"></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = <span class="keyword">this</span>-&gt;m_a + p.m_a;</span><br><span class="line">temp.m_b = <span class="keyword">this</span>-&gt;m_b + p.m_b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2、全局函数重载符号</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person&amp; p1, Person&amp; p2) &#123;<span class="comment">//注意这个函数需要放在test01前面，否则会报错</span></span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数重载版本</span></span><br><span class="line">Person <span class="keyword">operator</span>+(Person &amp;p1,<span class="type">int</span> num) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_a = p1.m_a + num;</span><br><span class="line">temp.m_b = p1.m_b + num;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">p1.m_a = <span class="number">10</span>;</span><br><span class="line">p1.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_a = <span class="number">10</span>;</span><br><span class="line">p2.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数重载本质：</span></span><br><span class="line"><span class="comment">//Person p3 = p1.operator+(p2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数重载本质：</span></span><br><span class="line">Person p3 = <span class="keyword">operator</span>+(p1, p2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//两者都可以简化为以下版本</span></span><br><span class="line"><span class="comment">//Person p3 = p1 + p2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 也可以发生函数重载</span></span><br><span class="line">Person p4 = p1 + <span class="number">100</span>;<span class="comment">//Person +int;</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p3.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3.m_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p4.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p4.m_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、成员函数重载+号</span></span><br><span class="line"><span class="comment">//2、全局函数重载+号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载">4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">m_a = a;</span><br><span class="line">m_b = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//public:</span></span><br><span class="line"><span class="comment">//利用成员函数重载 左移运算符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person &amp;p) &#123; //等价于p.operator&lt;&lt;(p) 实际上需要传进两个对象，但我们只需要一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外的一种尝试</span></span><br><span class="line"><span class="comment">/*void operator&lt;&lt;(cout) &#123;//等价于p.operator&lt;&lt;(cout) 简化版本 p &lt;&lt; cout,输出结果为cout在右侧，与预期效果相反</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：不会利用成员函数重载&lt;&lt;运算符，因为无法实现 cout在左侧</span></span><br><span class="line"><span class="comment">//int m_a;</span></span><br><span class="line"><span class="comment">//int m_b;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一般来说,数据成员设置权限为私有，可以利用友元的技术解决函数调用的问题 但是注意类外无法访问数据成员</span></span><br><span class="line"><span class="comment">//所以应该先给他们赋初始值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能利用全局函数重载左移运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//点击cout，可以查看cout的数据类型</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(ostream &amp;cout, Person &amp;p) &#123;//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; p.m_a &lt;&lt; &quot; &quot; &lt;&lt; &quot;m_b=&quot; &lt;&lt; p.m_b;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="comment">//ostream &amp;operator&lt;&lt;(ostream&amp; cout, Person&amp; p) &#123;//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; p.m_a &lt;&lt; &quot; &quot; &lt;&lt; &quot;m_b=&quot; &lt;&lt; p.m_b;</span></span><br><span class="line"><span class="comment">//return cout;//直接返回，后面就不会再重载endl</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外一种写法：给out起别名，其实就是引用，指向同一块内存空间</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<span class="comment">//本质 operator&lt;&lt; (cout , p) 简化为cout &lt;&lt; p</span></span><br><span class="line">out &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;m_b=&quot;</span> &lt;&lt; p.m_b;</span><br><span class="line"><span class="keyword">return</span> out;<span class="comment">//直接返回，后面就不会再重载endl</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*Person p;</span></span><br><span class="line"><span class="comment">p.m_a = 10;</span></span><br><span class="line"><span class="comment">p.m_b = 10;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*Person p1;</span></span><br><span class="line"><span class="comment">p1.m_a = 10;</span></span><br><span class="line"><span class="comment">p1.m_b = 10*/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1;<span class="comment">//系统提示没有与这些操作数匹配的&quot;&lt;&lt;&quot;的运算符,重载后可以运行</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;<span class="comment">//会报错，因为后面添加了endl，解决方案在上</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;<span class="comment">//没输出一次就返回cout,可以往后无限叠加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载">4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义整形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"><span class="keyword">friend</span>  ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载前置++运算符</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;<span class="comment">//注意这里要返回的是引用，如果删去&amp;</span></span><br><span class="line"><span class="comment">//返回引用是为了一直对一个数据进行递增操作</span></span><br><span class="line"><span class="comment">//先进行++运算</span></span><br><span class="line">m_Num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//再进行自身返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;<span class="comment">//注意这里返回我们写的myint,this是指向自身，*是解引用的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载后置++运算符</span></span><br><span class="line"><span class="comment">//void operator++() &#123;//z这里会报错，因为发生重定义现象</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//后置返回的是值，注意不能返回引用，如果返回引用，返回的是一个局部的对象，局部对象在当前函数执行完后就被释放了，再返回它就是非法操作了</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;<span class="comment">//int 代表占位参数，可以用于区分前置和后置递增</span></span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="comment">//先 记录当时结果</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后递增</span></span><br><span class="line">m_Num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后将记录结果做返回</span></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//重载&lt;&lt;运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, MyInteger myint) &#123;</span><br><span class="line">cout &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint;</span><br><span class="line">cout &lt;&lt; myint &lt;&lt; endl;<span class="comment">//没有与之匹配的操作运算符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回引用的输出效果</span></span><br><span class="line"><span class="comment">//这种都是对同一个数据类型进行递增，也就是myint1</span></span><br><span class="line">cout &lt;&lt; ++myint1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ++(++myint1) &lt;&lt; endl;<span class="comment">//提示没有与之匹配的操作运算符,解决方案在上 </span></span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; myint1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">////不返回引用的输出效果</span></span><br><span class="line"><span class="comment">// 返回的是一个新的对象，再对该新对象++</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; ++myint1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">////输出为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; ++(++myint1) &lt;&lt; endl;//提示没有与之匹配的操作运算符,解决方案在上 </span></span><br><span class="line"><span class="comment">////输出为3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; myint1 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">////输出为2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myint2;</span><br><span class="line">cout &lt;&lt; myint2++ &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; myint2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载">4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//赋值运算符重载</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);<span class="comment">//new开辟出来的东西需要使用指针接受，堆区数据由程序员手动开辟，手动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>() &#123;<span class="comment">//把堆区数据释放干净</span></span><br><span class="line"><span class="comment">//这是一个浅拷贝</span></span><br><span class="line"><span class="comment">//调用时能正常输出，但系统崩溃，因为p1与p2指向同一块内存，内存被重复释放，导致系统崩溃</span></span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要使用深拷贝解决</span></span><br><span class="line"><span class="comment">//重载 赋值运算符</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p) &#123;</span><br><span class="line"><span class="comment">//编译器提供浅拷贝</span></span><br><span class="line"><span class="comment">//m_age=p.m_age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//应该先判断是否有属性在堆区，如果有先释放干净，然后再深拷贝</span></span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝操作</span></span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回对象自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> *m_age;<span class="comment">//需要开辟到堆区,所以使用指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p1.m_age &lt;&lt; endl;<span class="comment">//输出的是指针指向的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p1.m_age &lt;&lt; endl;<span class="comment">//解引用，输出p1年龄</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p2.m_age &lt;&lt; endl;<span class="comment">//输出p2年龄</span></span><br><span class="line"></span><br><span class="line">p2 = p1;<span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p2.m_age &lt;&lt; endl;<span class="comment">//输出年龄也是18</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p3.m_age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">c = b = a;</span><br><span class="line">    <span class="comment">//连续赋值操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; c &lt;&lt; endl;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载">4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age) &#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载==号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age == p.m_age) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载!=号</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person&amp; p) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_age != p.m_age || <span class="keyword">this</span>-&gt;m_name != p.m_name) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Sam&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Sam&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2) &#123;<span class="comment">//没有与之匹配的运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1==p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1!=p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1 != p2) &#123;<span class="comment">//没有与之匹配的运算符</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1!=p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1==p2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载">4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//函数调用运算符重载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印输出类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//重载函数调用运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyPrint2</span><span class="params">(string test)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//()小括号重载 让对象使用重载后的小括号 由于使用起来非常类似于函数调用，因此称为仿函数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MyPrint2</span>(<span class="string">&quot;Hello World&quot;</span>);<span class="comment">//函数的调用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//仿函数非常的灵活，没有固定的写法</span></span><br><span class="line"><span class="comment">//加法类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyAdd myadd;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">myadd</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret=&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;<span class="comment">//通过一个类名和一个()创建一个匿名对象，用完就被释放</span></span><br><span class="line"><span class="comment">//输出为200</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="/posts/63c99134.html"/>
      <url>/posts/63c99134.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-4-友元">4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元">4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//goodGay全局函数是Building的友元，可以访问Builing中的私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span>  <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building* building)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>()&#123;</span><br><span class="line">m_livingroom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingroom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedroom;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building *building)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_livingroom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;全局函数正在访问：&quot; &lt;&lt; building-&gt;m_bedroom &lt;&lt; endl;//报错，类外不可以访问</span></span><br><span class="line"><span class="comment">//解决方法：在类内的最上面添加函数的声明</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局函数正在访问：&quot;</span> &lt;&lt; building-&gt;m_bedroom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;<span class="comment">//公共属性，类外可以访问</span></span><br><span class="line">Building building;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2-类做友元">4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//参观函数 访问类中的属性</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//GoodGay类是该类的友元，可以访问本类中的私有成员</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">GoodGay</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingRoom;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外实现成员函数</span></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;<span class="comment">//加上::,说明作用域</span></span><br><span class="line">m_livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line"><span class="comment">//创建建筑物对象</span></span><br><span class="line">building = <span class="keyword">new</span> Building;<span class="comment">//在堆区开创建一个新的对象，并让Building* building;指向这个新的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;<span class="comment">//GoodGay::说明作用域</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;<span class="comment">//先调用GoodGay的构造函数，创建一个Building,同时会调用Building的构造函数</span></span><br><span class="line">ss.<span class="built_in">visit</span>();<span class="comment">//调用visit函数，访问builing中的livingRoom</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元">4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGay</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GoodGay</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;<span class="comment">//让visit函数可以访问Builing中的私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>;<span class="comment">//让visit2函数不可以访问Builing中的私有成员</span></span><br><span class="line"></span><br><span class="line">Building* building;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span> &#123;</span><br><span class="line"><span class="comment">//告诉编译器 GoodGay类下的visit成员函数作为本类的友元，可以访问私有成员</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;<span class="comment">//注意需要添加GoodGay::来说明作用域</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_livingRoom;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_bedRoom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>() &#123;</span><br><span class="line">m_livingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">m_bedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GoodGay::<span class="built_in">GoodGay</span>() &#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GoodGay::visit2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;visit函数正在访问&quot;</span> &lt;&lt; building-&gt;m_livingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;visit函数正在访问&quot; &lt;&lt; building-&gt;m_bedRoom &lt;&lt; endl;不可以访问类内的私有成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;</span><br><span class="line">ss.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">GoodGay ss;</span><br><span class="line">ss.<span class="built_in">visit2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++对象模型和this指针</title>
      <link href="/posts/c9c3276d.html"/>
      <url>/posts/c9c3276d.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-3-C-对象模型和this指针">4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储">4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，<strong>类内的成员变量和成员函数分开存储</strong></p><p><strong>只有非静态成员变量才属于类的对象上</strong></p><p>（静态成员变量和静态成员函数不属于某个对象，<strong>非静态成员函数不属于类的对象（非静态成员函数只有一份）</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person1</span> &#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person2</span> &#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员变量 属于类的对象上</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;<span class="comment">//静态成员变量 不属于类对象上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void func() &#123;//加了函数 字节还是4 说明非静态成员函数不属于类对象上</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//static void func2() &#123;//加了静态函数 字节还是4 说明静态成员函数不属于类对象上</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person2::m_b = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//空对象占用的内存空间</span></span><br><span class="line"><span class="comment">//C++编译器会给每个空对象也分配一个字节空间，为了区分不同的空对象所占用的内存空间的位置</span></span><br><span class="line"><span class="comment">//每个空对象也应该有一个独一无二的内存地址</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出为1</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person1 p1;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出为4，对应int m_a的字节，</span></span><br><span class="line"></span><br><span class="line">Person2 p2;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p2) &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出还是4，对应int m_a的字节</span></span><br><span class="line"><span class="comment">//说明static int m_b不属于类的对象上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01()</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念">4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li><strong>当形参和成员变量同名时，可用this指针来区分</strong></li><li>*<em>在类的非静态成员函数中返回对象本身，可使用return <em>this</em></em></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Person(int age) &#123;//点击左边的age，可以发现编译器认为该行的age与下一行的age是同一个，与最下行的age不是同一个</span></span><br><span class="line"><span class="comment">//age = age;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int age;//这个age实际上从来都没有进行过赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;<span class="comment">//this指向的是 被调用的成员函数 所属的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PersonAddAge</span><span class="params">(Person&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddAge1</span><span class="params">(Person&amp; p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//this指向p2的指针，而*this指向的是p2这个对象本体，注意这里需要用引用的方式返回本体</span></span><br><span class="line"><span class="comment">//如果是返回值的方式，输出结果是20</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//1、解决名称冲突</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">19</span>)</span></span>;<span class="comment">//this指向的是p1</span></span><br><span class="line">cout &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、返回对象本身用*this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//只加上1次</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p2.<span class="built_in">PersonAddAge</span>(p1);</span><br><span class="line">cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line"><span class="comment">//输出结果20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上多次</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p2.PersonAddAge(p1).PersonAddAge(p1).PersonAddAge(p1);这样写会报错，因为前面的函数返回值是void</span></span><br><span class="line"><span class="comment">//如果可以使得p2.PersonAddAge(p1)返回的还是p2，依此类推，可以持续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式编程思想</span></span><br><span class="line">p2.<span class="built_in">PersonAddAge1</span>(p1).<span class="built_in">PersonAddAge1</span>(p1).<span class="built_in">PersonAddAge1</span>(p1);</span><br><span class="line"><span class="comment">//如果是返回值的方式，输出结果是20，返回的不是本体了，而是用本体创建一个新的数据p2&#x27;，调用了拷贝构造函数，依此类推p2&#x27;&#x27;,p2&#x27;&#x27;&#x27;等等</span></span><br><span class="line">cout &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数">4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是<strong>也要注意有没有用到this指针</strong></p><p><strong>如果用到this指针，需要加以判断保证代码的健壮性</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person Class&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原因是传入的指针是NULL</span></span><br><span class="line">cout &lt;&lt; m_age &lt;&lt; endl;<span class="comment">//实际上在属性前面默认加上了this-&gt;,说明是当前对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPersonAge1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//解决方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原因是传入的指针是NULL</span></span><br><span class="line">cout &lt;&lt; m_age &lt;&lt; endl;<span class="comment">//实际上在属性前面默认加上了this-&gt;,说明是当前对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_age = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//老版本的结果是系统崩了，现在是没有输出</span></span><br><span class="line">Person* p=<span class="literal">NULL</span>;<span class="comment">//指针指向的Person是一个空指针，相当于this-&gt;是一个空的东西，没有实体，没有创建一个确定的对象，this根本就没有指向一个确定的数据</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showClassName</span>();<span class="comment">//正常输出</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge</span>();<span class="comment">//没有输出/崩了</span></span><br><span class="line"></span><br><span class="line">p-&gt;<span class="built_in">showPersonAge1</span>();<span class="comment">//没有输出/没崩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数">4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li><strong>常函数内不可以修改成员属性</strong></li><li><strong>成员属性声明时加关键字mutable后，在常函数中依然可以修改</strong></li></ul><p><strong>常对象：</strong></p><ul><li><strong>声明对象前加const称该对象为常对象</strong></li><li><strong>常对象只能调用常函数</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//常函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量 指针的指向是不可以修改的</span></span><br><span class="line"><span class="comment">//this实际上就是Person * const this</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson0</span><span class="params">()</span> </span>&#123;<span class="comment">//不可以修改成员属性的值</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_a = <span class="number">100</span>; <span class="comment">//实际上是this-&gt;m_a = 100;正常运行</span></span><br><span class="line"><span class="comment">//this=NULL;this指针不可以修改指针的指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量 </span></span><br><span class="line"><span class="comment">//下面加上了const 这里就是const Person * const this 此时this也不可以修改指针的值了</span></span><br><span class="line"><span class="comment">//在成员函数后面加上const,修饰的是this指向，让指针的指向的值也不可以修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showPerson1</span><span class="params">()</span> <span class="type">const</span></span>&#123;<span class="comment">//不可以修改成员属性的值</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_b = <span class="number">100</span>;<span class="comment">//正常，没有保错</span></span><br><span class="line"><span class="comment">//m_a = 100; 实际上是this-&gt;m_a = 100;执行时报错</span></span><br><span class="line"><span class="comment">//this=NULL;this指针不可以修改指针的指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_b;<span class="comment">//特殊变量，即使在常函数中，也可以修改这个值，加上mutable关键字</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">showPerson0</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Person p;<span class="comment">//在对象前面加上const,变为常对象</span></span><br><span class="line"><span class="comment">//p.m_a = 100;会报错，不可以修改</span></span><br><span class="line">p.m_b;<span class="comment">//正常运行，m_b在常对象下也可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象只能调用常函数</span></span><br><span class="line">p.<span class="built_in">showPerson1</span>();<span class="comment">//正常运行，没有报错</span></span><br><span class="line"><span class="comment">//p.showPerson0();//不可以调用，因为普通成员函数可以修改属性 否则的话说明常对象里面的数据也可以修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的初始化和清理</title>
      <link href="/posts/5bd18230.html"/>
      <url>/posts/5bd18230.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-2-对象的初始化和清理">4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数">4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p>​<strong>一个对象或者变量没有初始状态，对其使用后果是未知</strong></p><p>​<strong>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</strong></p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，<strong>这两个函数将会被编译器自动调用，完成对象初始化和清理工作</strong>。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现（函数体内一行代码都没有）。</strong></p><ul><li>构造函数：主要作用在于<strong>创建对象时为对象的成员属性赋值</strong>，<strong>构造函数由编译器自动调用，无须手动调用</strong>。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，<strong>没有返回，值也不写void</strong></li><li><strong>函数名称与类名相同</strong></li><li><strong>构造函数可以有参数，因此可以发生重载</strong></li><li>程序在<strong>调用对象时候会自动调用构造</strong>，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，<strong>没有返回值也不写void</strong></li><li><strong>函数名称与类名相同,在名称前加上符号  ~</strong></li><li><strong>析构函数不可以有参数，因此不可以发生重载</strong></li><li>程序在<strong>对象销毁前会自动调用析构</strong>，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//注意写清楚作用域    </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数：进行初始化操作</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数：进行清理的操作</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//**编译器提供的构造函数和析构函数是空实现（函数体内一行代码都没有）。**</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;<span class="comment">//在栈上的数据，test01执行完毕后，就会释放这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();<span class="comment">//输出结果为构造和析构都有调用</span></span><br><span class="line">    </span><br><span class="line">    Person p;<span class="comment">//输出结果为只有构造函数的调用。因为还有下面的system(&quot;pause&quot;),此时程序还没有执行完毕，只有当按下任意键后，在return 0之前（也就是在整个main函数执行完毕后，才会出现析构函数的调用）</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用">4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><p>​<strong>按参数分为： 有参构造和无参构造</strong></p><p>​<strong>按类型分为： 普通构造和拷贝构造</strong></p><p>三种调用方式：</p><p>​括号法</p><p>​显示法</p><p>​隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数：克隆复制另外一份，注意不能改变本身的属性（添加const）,用引用的方式调进来</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        <span class="comment">//将传入的人身上的所有属性，拷贝到我身上。</span></span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line">    Person p;<span class="comment">//默认构造函数调用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span><span class="comment">//拷贝构造函数调用</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意1：调用无参（默认）构造函数不能加括号，如果加了编译器认为这是一个函数声明，不会认为是在创建对象</span></span></span><br><span class="line"><span class="function"><span class="comment">//Person p2();没有任何的输出结果</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//2.2 显式法</span></span></span><br><span class="line"><span class="function">Person p3 </span>= <span class="built_in">Person</span>(<span class="number">10</span>); <span class="comment">//有参构造</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(p1); <span class="comment">//拷贝构造调用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Person(10)</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;111&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//单独写就是匿名对象  当前行执行结束之后，系统会立即回收匿名对象（马上析构）（也就是在test02()执行完毕之前就析构），后面无法使用该对象。</span></span><br><span class="line">    <span class="comment">//输出结果为</span></span><br><span class="line">    <span class="comment">//有参构造函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); 有参构造</span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); 拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line">    <span class="comment">//编译器会认为Person(p4)==Person p4,导致重定义</span></span><br><span class="line"><span class="comment">//Person (p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机">4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li><strong>使用一个已经创建完毕的对象来初始化一个新对象</strong></li><li><strong>值传递的方式给函数参数传值</strong></li><li><strong>以值方式返回局部对象</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    cout &lt;&lt; newman.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数！</span></span><br><span class="line">    <span class="comment">//拷贝构造函数!</span></span><br><span class="line">    <span class="comment">//100</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    </span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，而是赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;<span class="comment">//实参传给形参，会按照传进来的p1拷贝一份新的数据，把形参数据改变，不会影响实参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);<span class="comment">//拷贝构造函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;<span class="comment">//根据返回的这个p1创建一个新的对象，返回给test03,因为这是局部对象，执行后会被释放掉。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">test03</span>();</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//默认构造函数！</span></span><br><span class="line">    <span class="comment">//输出原本的p1的地址</span></span><br><span class="line">    <span class="comment">//拷贝构造函数！</span></span><br><span class="line">    <span class="comment">//析构函数！（原本的p1）</span></span><br><span class="line">    <span class="comment">//输出拷贝后p1的地址</span></span><br><span class="line">    <span class="comment">//析构函数！（拷贝的p1）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个的地址是不同的</span></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则">4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p><strong>1．默认构造函数(无参，函数体为空)</strong></p><p><strong>2．默认析构函数(无参，函数体为空)</strong></p><p><strong>3．默认拷贝构造函数，对属性进行值拷贝</strong></p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义<strong>有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</strong></p></li><li><p>如果用户定义<strong>拷贝构造函数，c++不会再提供其他构造函数</strong></p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数!</span></span><br><span class="line">    <span class="comment">//拷贝构造函数!</span></span><br><span class="line">    <span class="comment">//p2的年龄为18</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    <span class="comment">//析构函数!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果将拷贝函数注释，输出结果少了一行“拷贝构造函数!”，其他相同</span></span><br><span class="line">    <span class="comment">//编译器会自动提供一个拷贝构造函数，对属性进行简单的拷贝操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line">    <span class="comment">//不调用默认构造函数的话正常输出</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; </span><br><span class="line">    cout&lt;&lt;p3.age&lt;&lt;endl;</span><br><span class="line">    <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供，此时的输出结果为：</span></span><br><span class="line">    <span class="comment">//有参构造函数！</span></span><br><span class="line">    <span class="comment">//10</span></span><br><span class="line">    <span class="comment">//析构函数！</span></span><br><span class="line">    <span class="comment">//析构函数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝">4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p><strong>浅拷贝：简单的赋值拷贝操作，编译器提供的简单赋值操作</strong></p><p><strong>深拷贝：在堆区重新申请空间，进行拷贝操作</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<strong>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</strong></p></blockquote><p>自己的实现：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;默认构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age,<span class="type">int</span> height) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);<span class="comment">//手动开辟，手动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现拷贝函数，解决浅拷贝函数带来的问题</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_age = p.m_age;</span><br><span class="line"><span class="comment">//m_height=p.m_height;编译器默认的赋值</span></span><br><span class="line"><span class="comment">//深拷贝操作</span></span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"><span class="comment">//正常运行，可以看到地址不同</span></span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="comment">//析构代码，将堆区开辟的数据释放</span></span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">m_height = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//系统崩了，指向的是同一块地址，p2先析构（析构了一块堆区的地址），p1再析构（没有堆区的地址），此时系统崩溃</span></span><br><span class="line"><span class="comment">//自己实现拷贝函数，解决浅拷贝函数带来的问题</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">180</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄为&quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot;身高为&quot;</span>&lt;&lt;*p1.m_height&lt;&lt;endl;<span class="comment">//两个的输出结果一样</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄为&quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot;身高为&quot;</span>&lt;&lt;*p2.m_height&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-6-初始化列表">4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己的实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//传统初始化</span></span><br><span class="line"><span class="comment">/*Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">m_a = a;</span></span><br><span class="line"><span class="comment">m_b = b;</span></span><br><span class="line"><span class="comment">m_c = c;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表属性</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c) :<span class="built_in">m_a</span>(a), <span class="built_in">m_b</span>(b), <span class="built_in">m_c</span>(c) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//Person p(10, 20, 30);</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p.m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员">4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己写的：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//类对象作为类成员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string pName) &#123;</span><br><span class="line">m_Pname = pName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手机品牌</span></span><br><span class="line">string m_Pname;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Phone m_Phone=pName 隐式转化法初始化，上面也恰好有一个string的数据类型，因此可以实现</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其他类对象作为本类的成员时，构造时先构造类对象，再构造自身，析构则相反</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;苹果MAX&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_Phone.m_Pname &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-8-静态成员">4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li><strong>所有对象共享同一份数据</strong></li><li><strong>在编译阶段分配内存，即程序还没有运行之前就分配内存了。分配在全局区</strong></li><li><strong>类内声明，类外初始化</strong></li></ul></li><li>静态成员函数<ul><li><strong>所有对象共享同一个函数</strong></li><li><strong>静态成员函数只能访问静态成员变量</strong></li></ul></li></ul><p>**示例1 ：**静态成员变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己写的：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;<span class="comment">//必须在类外初始化，否则会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量也是有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_a = <span class="number">100</span>;<span class="comment">//不再需要加上static关键字，但是需要加类名和::</span></span><br><span class="line"><span class="type">int</span> Person::m_b = <span class="number">200</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p.m_a = <span class="number">200</span>;<span class="comment">//修改数据为200</span></span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量不属于某个对象，所有对象都够共享同一份数据</span></span><br><span class="line"><span class="comment">//因此静态成员有两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象进行访问</span></span><br><span class="line">Person p;</span><br><span class="line">cout &lt;&lt; p.m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名进行访问</span></span><br><span class="line">cout &lt;&lt; Person::m_a &lt;&lt; endl;<span class="comment">//类的名称加上::</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::m_b &lt;&lt; endl;在私有作用域内，类外不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>**示例2：**静态成员函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自己写的：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//静态成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_a = <span class="number">200</span>;<span class="comment">//静态成员函数可以访问静态成员变量</span></span><br><span class="line"><span class="comment">//m_b = 200;//静态成员函数不可以访问 非静态成员变量，无法区分到底是哪个对象的m_b的属性</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;<span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_b;<span class="comment">//非静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也有访问权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;static void func2函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//两种访问方式</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、通过对象进行访问</span></span><br><span class="line">Person p;</span><br><span class="line">p.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名访问</span></span><br><span class="line">cout &lt;&lt; Person::func &lt;&lt; endl;<span class="comment">//输出该静态函数的地址</span></span><br><span class="line">Person::<span class="built_in">func</span>();<span class="comment">//输出的是&quot;static void func函数&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2();//类外是不可以访问的</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; Person::func2 &lt;&lt; endl;//该静态函数的地址也不可以访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装</title>
      <link href="/posts/d60eb45.html"/>
      <url>/posts/d60eb45.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-1-封装">4.1 封装</h3><h4 id="4-1-1-封装的意义">4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>​在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p>**示例1：**设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为：常常使用函数来实现</span></span><br><span class="line"><span class="comment">//获取到圆的周长：这是一个函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建一个具体的圆（就是对象）</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">    <span class="comment">//实例化：通过一个类 创建一个对象的过程</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限</li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问 儿子可以访问父亲中的保护内容</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问 儿子不可以访问父亲的私有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//改成private,类外不可以访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个具体对象</span></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限的内容类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限的内容类外访问不到</span></span><br><span class="line">    </span><br><span class="line">    p.<span class="built_in">func</span>()<span class="comment">//public可以访问，private不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别">4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li><strong>struct 默认权限为公共</strong></li><li><strong>class 默认权限为私有</strong></li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限，不可以访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限，可以访问</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有">4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，<strong>可以自己控制读写权限</strong></p><p><strong>优点2：<strong>对于写权限，我们</strong>可以检测数据的有效性</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//成员属性设置为私有</span></span><br><span class="line"><span class="comment">//1、可以自己控制读写权限</span></span><br><span class="line"><span class="comment">//2、对于写可以检测数据的有效性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设计人类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:<span class="comment">//创建一个接口，利用函数访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="comment">//设置姓名</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//获取姓名</span></span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 可读可写 如果想修改（范围是0-150）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;<span class="comment">//对数据进行有效性地验证</span></span><br><span class="line">m_Age = <span class="number">0</span>;</span><br><span class="line">             cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/posts/ac4294eb.html"/>
      <url>/posts/ac4294eb.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-7-多态">4.7  多态</h3><h4 id="4-7-1-多态的基本概念">4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类">4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类">4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品">4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><img src="https://img2.imgtp.com/2024/03/26/rlTPWghq.png" alt=""></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象制作饮品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDrinking</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//规定流程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MakeDrink</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">Boil</span>();</span><br><span class="line"><span class="built_in">Brew</span>();</span><br><span class="line"><span class="built_in">PourInCup</span>();</span><br><span class="line"><span class="built_in">PutSomething</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coffee</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作茶水</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea</span> : <span class="keyword">public</span> AbstractDrinking &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//烧水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Boil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">(AbstractDrinking* drink)</span> </span>&#123;</span><br><span class="line">drink-&gt;<span class="built_in">MakeDrink</span>();</span><br><span class="line"><span class="keyword">delete</span> drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Coffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">DoWork</span>(<span class="keyword">new</span> Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构">4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​3. 拥有纯虚析构函数的类也属于抽象类</p><h4 id="4-7-6-多态案例三-电脑组装">4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象CPU类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象显卡类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VideoCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的显示函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象内存条类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//抽象的存储函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_vc = vc;</span><br><span class="line">m_mem = mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供工作的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//让零件工作起来，调用接口</span></span><br><span class="line">m_cpu-&gt;<span class="built_in">calculate</span>();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;<span class="built_in">storage</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提供析构函数 释放3个电脑零件</span></span><br><span class="line">~<span class="built_in">Computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放CPU零件</span></span><br><span class="line"><span class="keyword">if</span> (m_cpu != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放显卡零件</span></span><br><span class="line"><span class="keyword">if</span> (m_vc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_vc;</span><br><span class="line">m_vc = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放内存条零件</span></span><br><span class="line"><span class="keyword">if</span> (m_mem != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_mem;</span><br><span class="line">m_mem = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; <span class="comment">//CPU的零件指针</span></span><br><span class="line">VideoCard * m_vc; <span class="comment">//显卡零件指针</span></span><br><span class="line">Memory * m_mem; <span class="comment">//内存条零件指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体厂商</span></span><br><span class="line"><span class="comment">//Intel厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IntelMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo厂商</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoCPU</span> :<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoVideoCard</span> :<span class="keyword">public</span> VideoCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LenovoMemory</span> :<span class="keyword">public</span> Memory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">storage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一台电脑零件</span></span><br><span class="line">CPU * intelCpu = <span class="keyword">new</span> IntelCPU;</span><br><span class="line">VideoCard * intelCard = <span class="keyword">new</span> IntelVideoCard;</span><br><span class="line">Memory * intelMem = <span class="keyword">new</span> IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建第一台电脑</span></span><br><span class="line">Computer * computer1 = <span class="keyword">new</span> <span class="built_in">Computer</span>(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第二台电脑组装</span></span><br><span class="line">Computer * computer2 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> LenovoVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer2-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-----------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//第三台电脑组装</span></span><br><span class="line">Computer * computer3 = <span class="keyword">new</span> <span class="built_in">Computer</span>(<span class="keyword">new</span> LenovoCPU, <span class="keyword">new</span> IntelVideoCard, <span class="keyword">new</span> LenovoMemory);;</span><br><span class="line">computer3-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/posts/11d8b32d.html"/>
      <url>/posts/11d8b32d.html</url>
      
        <content type="html"><![CDATA[<p>文章内容转载自黑马程序员C++核心编程讲义，如有侵权，请联系作者删除</p><hr><h3 id="4-6-继承">4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系，例如下图中：</p><p><img src="https://img2.imgtp.com/2024/03/26/45FfiE86.png" alt=""></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="4-6-1-继承的基本语法">4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式">4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="https://img2.imgtp.com/2024/03/26/h2EaLshZ.png" alt=""></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型">4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p><img src="https://img2.imgtp.com/2024/03/26/WB7DLB75.png" alt=""></p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayout查看的类名   所属文件名</p><p>效果如下图：</p><p><img src="https://img2.imgtp.com/2024/03/26/SPiG6Y3o.png" alt=""></p><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序">4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式">4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式">4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法">4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承">4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><p>​两个派生类继承同一个基类</p><p>​又有某个类同时继承者两个派生类</p><p>​这种继承被称为菱形继承，或者钻石继承</p><p><strong>典型的菱形继承案例：</strong></p><p><img src="https://img2.imgtp.com/2024/03/26/VmrX5axh.jpg" alt=""></p><p><strong>菱形继承问题：</strong></p><ol><li><pre><code>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 想成为C++大神 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC058</title>
      <link href="/posts/700c1b28.html"/>
      <url>/posts/700c1b28.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC058">ABC058</h1><blockquote><h1 id="ABC058D-井井井">[ABC058D] 井井井</h1><h2 id="题面翻译">题面翻译</h2><p>给定 $n$ 条平行于 $y$ 轴的直线 $x_{1…n}$，和 $m$ 条平行于 $x$ 轴的直线 $y_{1…n}$，</p><p>计算 $x_i,x_j$ 和 $y_k,y_l$ 组成的矩形面积之和，$1\le x&lt;y\le n$，$1\le k&lt;l\le m$。</p><h2 id="题目描述">题目描述</h2><p>$ 2 $ 次元平面上に $ x $ 軸と平行な直線が $ m $ 本と $ y $ 軸と平行な直線が $ n $ 本引いてあります。 $ x $ 軸と平行な直線のうち下から $ i $ 番目は $ y\ =\ y_i $ で表せます。 $ y $ 軸と平行な直線のうち左から $ i $ 番目は $ x\ =\ x_i $ で表せます。</p><p>この中に存在しているすべての長方形についてその面積を求め、 合計を $ 10^9+7 $ で割ったあまりを出力してください。</p><p>つまり、$ 1\leq\ i\ &lt;\ j\leq\ n $ と $ 1\leq\ k\ &lt;\ l\leq\ m $ を満たすすべての組 $ (i,j,k,l) $ について、  直線 $ x=x_i $, $ x=x_j $, $ y=y_k $, $ y=y_l $ で囲まれる 長方形の面積を求め、合計を $ 10^9+7 $ で割ったあまりを出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ m $ $ x_1 $ $ x_2 $ $ … $ $ x_n $ $ y_1 $ $ y_2 $ $ … $ $ y_m $</p></blockquote><h2 id="输出格式">输出格式</h2><p>長方形の面積の合計を $ 10^9+7 $ で割ったあまりを $ 1 $ 行に出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 3 4</span><br><span class="line">1 3 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">60</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 5</span><br><span class="line">-790013317 -192321079 95834122 418379342 586260100 802780784</span><br><span class="line">-253230108 193944314 363756450 712662868 735867677</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">835067060</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2\ \leq\ n,m\ \leq\ 10^5 $</li><li>$ -10^9\ \leq\ x_1\ &lt;\ …\ &lt;\ x_n\ \leq\ 10^9 $</li><li>$ -10^9\ \leq\ y_1\ &lt;\ …\ &lt;\ y_m\ \leq\ 10^9 $</li><li>$ x_i,\ y_i $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>この入力を図にすると、以下のようになります。 ![sample1-1](<a href="https://atcoder.jp/img/arc071/aec4d5cc2e5c73dbee455be237a649a5.png">https://atcoder.jp/img/arc071/aec4d5cc2e5c73dbee455be237a649a5.png</a>) 長方形 A,B,…,I それぞれの面積を合計すると $ 60 $ になります。 ![sample1-2](<a href="https://atcoder.jp/img/arc071/f0771c0f7e68af2b00e7513186f585ff.png">https://atcoder.jp/img/arc071/f0771c0f7e68af2b00e7513186f585ff.png</a>)</p></blockquote><h2 id="思路">思路</h2><p>一开始想的是枚举可能有多少种排列方式（构成整个大矩形），然后统计输出即可，但是好像不合题意？</p><p>思路参考自：[【题解】AT2394 <a href="https://www.luogu.com.cn/article/wlvi5bx0">ARC071B] 井井井 / ### - 洛谷专栏 (luogu.com.cn)</a></p><p>可以将线段分解成相邻两直线之间的距离，如$x_i-x_{i-1}$，那么只需要枚举左右端点：$(i-1)*(n-i+1)$。</p><p>就可以得到所有的情况$(x_i-x_{i-1})<em>(i-1)</em>(n-i+1)$。同理$y$也是如此。最后$sumx*sumy$即为答案，注意不要忘记取模。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll x[MAXN],y[MAXN];</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=ans*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sumx=<span class="number">0</span>,sumy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;y[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)sumx=(sumx+(x[i]-x[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(n-i+<span class="number">1</span>))%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)sumy=(sumy+(y[i]-y[i<span class="number">-1</span>])*(i<span class="number">-1</span>)*(m-i+<span class="number">1</span>))%mod;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(sumx*sumy)%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC057</title>
      <link href="/posts/e0b306b9.html"/>
      <url>/posts/e0b306b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC057">ABC057</h1><blockquote><h1 id="ABC057C-Digits-in-Multiplication">[ABC057C] Digits in Multiplication</h1><h2 id="题面翻译">题面翻译</h2><p>对于两个正整数A和B，将F ( A，B )定义为以下两者中较大的一个: max（A的位数，B的位数） 例如，F ( 3，11 ) = 2，因为3有一位，11有两位。</p><p>给你一个整数n 求F ( A，B )的最小值为 使得 N = A×B</p><p>输入 n</p><p>输出 min f(a,b)</p><p>感谢@chengni 提供的翻译</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。<br>ここで、$ 2 $ つの正の整数 $ A,B $ に対して、$ F(A,B) $ を「$ 10 $ 進表記における、$ A $ の桁数と $ B $ の桁数のうち大きい方」と定義します。<br>例えば、$ F(3,11) $ の値は、$ 3 $ は $ 1 $ 桁、$ 11 $ は $ 2 $ 桁であるため、$ F(3,11)=2 $ となります。<br>$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くとき、$ F(A,B) $ の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ 2 $ つの正の整数の組 $ (A,B) $ が $ N=A×B $ を満たすように動くときの $ F(A,B) $ の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000003</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9876543210</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^{10} $</li><li>$ N $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ (A,B)=(100,100) $ のときに $ F(A,B) $ は最小値をとるため、$ F(100,100)=3 $ を出力します。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>条件を満たす $ (A,B) $ の組は $ (1,1000003) $ と $ (1000003,1) $ の $ 2 $ 通りで、$ F(1,1000003)=F(1000003,1)=7 $ です。</p></blockquote><h2 id="思路">思路</h2><p>不难想到，最小值与平方根有关，所以我们可以求出平方根，然后选出较大的数。分解位数并统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    ll d=(ll)<span class="built_in">sqrt</span>(n)+<span class="number">1</span>;</span><br><span class="line">    ll num=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//选出较大的数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=d;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            num=n/i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//分解数位并统计</span></span><br><span class="line">    <span class="keyword">while</span>(num)&#123;</span><br><span class="line">        num/=<span class="number">10</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC057D-Maximum-Average-Sets">[ABC057D] Maximum Average Sets</h1><h2 id="题面翻译-2">题面翻译</h2><p>有n个数，可以选取最少A个最多B个，使得所选的数的平均值最大。求可能的最大平均值 和 在平均值最大的情况下的方案数</p><h2 id="题目描述-2">题目描述</h2><p>$ N $ 個の品物が与えられます。<br>$ i $ 番目の品物の価値は $ v_i\ (1≦i≦N) $ です。<br>これらの品物から、$ A $ 個以上、$ B $ 個以下を選ばなければなりません。<br>この制約下において、選んだ品物の価値の平均の最大値を求めてください。<br>また、選んだ品物の平均が最大となるような品物の選び方が何通りあるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ v_1 $ $ v_2 $ $ … $ $ v_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>解答を $ 2 $ 行に出力せよ。<br>$ 1 $ 行目には、選んだ品物の価値の平均の最大値を出力せよ。絶対誤差または相対誤差が $ 10^{−6} $ 以下ならば正解となる。<br>$ 2 $ 行目には、選んだ品物の平均が最大となるような品物の選び方の数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2 2</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.500000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 3</span><br><span class="line">10 20 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15.000000</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 1 5</span><br><span class="line">1000000000000000 999999999999999 999999999999998 999999999999997 999999999999996</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000.000000</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">50 1 50</span><br><span class="line">1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.000000</span><br><span class="line">1125899906842623</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦50 $</li><li>$ 1≦A≦B≦N $</li><li>$ 1≦v_i≦10^{15} $</li><li>$ v_i $ は全て整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 4 $ 番目の品物と $ 5 $ 番目の品物を選ぶと価値の平均が最大となるため、出力の $ 1 $ 行目は $ 4.5 $ です。 また、それ以外の品物の選び方で価値の平均が $ 4.5 $ になるものはないため、出力の $ 2 $ 行目は $ 1 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>価値の平均が最大となる品物の選び方は複数存在することがあります。</p></blockquote><h2 id="思路-2">思路</h2><p>显然，选取最大的A个数，再往下选均值只会越来越小。</p><p>方案数只与临界值有关，其他更大的肯定被选了。</p><p>注意考虑临界情况，可能在最大的A个数后面还存在若干个数与临界值相等，所以利用排列组合计算方案。</p><p>但是还有一种特殊情况，就是最大值与临界值相等，所以不一定只选A个，还可能选A+1、A+2个等等。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line">ll n,a,b,num;</span><br><span class="line">ll v[MAXN];</span><br><span class="line">ll C[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="comment">//组合数预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">        C[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            C[i][j]=C[i<span class="number">-1</span>][j<span class="number">-1</span>]+C[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//选出最大的A个数</span></span><br><span class="line">    <span class="built_in">sort</span>(v+<span class="number">1</span>,v+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;fixed&lt;&lt;<span class="built_in">setprecision</span>(<span class="number">6</span>)&lt;&lt;(<span class="type">double</span>)ans/a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    ll cnt1=<span class="number">0</span>,cnt2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计n个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计a个数中有多少个临界值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i]==v[a])cnt2++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果最大值与临界值相等，那么最多可以选择b个</span></span><br><span class="line">    <span class="keyword">if</span>(v[<span class="number">1</span>]==v[a])&#123;</span><br><span class="line">        <span class="keyword">for</span>(ll i=a;i&lt;=b;i++)&#123;</span><br><span class="line">            num+=C[cnt1][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一般情况</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        num=C[cnt1][cnt2];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC056</title>
      <link href="/posts/97b4362f.html"/>
      <url>/posts/97b4362f.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC056">ABC056</h1><blockquote><h1 id="ABC056C-Go-Home">[ABC056C] Go Home</h1><h2 id="题面翻译">题面翻译</h2><p>在0秒的时候有一只袋鼠在左右无限长的数轴上的原点上。在i-1到i的时间内，袋鼠可以选择不动，也可以向任意方向跳i个单位长度。也就是说，如果袋鼠在坐标x，时间i-1到i的时候，可以存在x-i,x,x+i三点之中。袋鼠的家在坐标X。袋鼠想尽快移动到它家。求袋鼠到达家的时间的最小值。</p><p>输入格式：</p><p>输入由标准输入以下列格式给出：$ X $</p><p>输出：</p><p>袋鼠到达坐标的最早时间</p><h2 id="题目描述">题目描述</h2><p>無限に左右に伸びている数直線上の $ 0 $ の地点に時刻 $ 0 $ にカンガルーがいます。 カンガルーは時刻 $ i-1 $ から $ i $ にかけて、なにもしないか、もしくは長さがちょうど $ i $ のジャンプを、左右どちらかの方向を選んで行えます。 つまり、時刻 $ i-1 $ に座標 $ x $ にいたとすると、時刻 $ i $ には $ x-i $, $ x $, $ x+i $ のどれかに存在することが出来ます。 カンガルーの家は座標 $ X $ にあります。カンガルーはできるだけ早く座標 $ X $ まで移動しようとしています。 カンガルーが座標 $ X $ に到着する時刻の最小値を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ X $</p></blockquote><h2 id="输出格式">输出格式</h2><p>カンガルーが座標 $ X $ に到着する時刻の最小値を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ X $ は整数</li><li>$ 1≦X≦10^9 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 3 $ 回右にジャンプすると時刻 $ 3 $ に家にたどり着けて、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>時刻 $ 0 $ にはなにもせず、時刻 $ 1 $ に右にジャンプすることで時刻 $ 2 $ に家にたどり着けます。</p></blockquote><h2 id="思路">思路</h2><p>可以发现，一直往前跳，肯定跳得是最多的，所以我们采取贪心想法，一直跳，直到超过范围即可结束。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//ans记录的是时间</span></span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//i记录的是跳过的路程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        i+=ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC056D-No-Need">[ABC056D] No Need</h1><h2 id="题面翻译-2">题面翻译</h2><p>给出一个由 $N$ 个整数构成的集合和一个整数 $K$，若该集合中的的非空子集和大于等于 $K$，则称该子集为优秀的集合</p><p>若所有包含这个数的优秀子集去掉该数后仍然是优秀集合，则称该数字为“可有可无的数字”。</p><p>请求出在 $N$ 个数中“可有可无的数字”个数。</p><h2 id="题目描述-2">题目描述</h2><p>シカのAtCoDeerくんは正整数が書かれたカードを $ N $ 枚持っています。$ i(1≦i≦N) $ 枚目に書かれている数は $ a_i $ です。 AtCoDeerくんは大きい数が好きなので、カードに書かれた数の総和が $ K $ 以上になるようなカードの部分集合を<em>よい集合</em>と呼びます。</p><p>そして、各カード $ i $ に対して、そのカードが<em>不必要</em>かどうかを次のように判定します。</p><ul><li>「カード $ i $ を含む任意の<em>よい集合</em>に対して、その集合からカード $ i $ を除いたものも<em>よい集合</em>」 ならカード $ i $ は<em>不必要</em></li><li>それ以外の場合は、<em>不必要</em>でない</li></ul><p>不必要なカードの枚数を求めてください。ただし、それぞれの判定は独立に行われ、不必要だからと言ってカードが途中で捨てられたりすることはありません。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>不必要なカードの枚数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">1 4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 400</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 20</span><br><span class="line">10 4 3 10 25 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力は全て整数</li><li>$ 1≦N≦5000 $</li><li>$ 1≦K≦5000 $</li><li>$ 1≦a_i≦10^9\ (1≦i≦N) $</li></ul><h3 id="部分点">部分点</h3><ul><li>$ N,K≦400 $ を満たすデータセットに正解した場合は、部分点として $ 300 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>よい集合は {$ 2,3 $} と {$ 1,2,3 $} の二つです。 カード $ 1 $ を含むよい集合は {$ 1,2,3 $} しかなく、これから $ 1 $ を取り除いた {$ 2,3 $} もよい集合なので、カード $ 1 $ は不必要です。 また、よい集合である {$ 2,3 $} から $ 2 $ を取り除いた集合 {$ 3 $} はよい集合ではないため、カード $ 2 $ は不必要ではありません。 カード $ 3 $ も同様に不必要ではないため、答えは $ 1 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>この場合よい集合は存在しないため、全てのカードは不必要となります。</p></blockquote><h2 id="思路-2">思路</h2><p>直接算可有可无的，似乎有点困难，所以算那些是必须的。不难想到，只要一个数本身大于$k$，那么他就是必须的，所以可以先排个序，那些大于$k$的数肯定不是可有可无的。</p><p>接下来就是进行判断了：怎么判断一个数是不是必须的呢？我们不妨假设$x$是必须的，那么设原有的和为$sum$，则$sum&lt;k$且$sum+x\geq k$必成立。</p><p>那么我们不妨枚举一下$sum$，然后进行判断（可以用$DP$解决）。</p><p>设$dp[i]$表示的是当总和为$i$时，是否符合大于$k$，$0$表示不合法，$1$表示合法。并对此进行状态转移，具体看看代码。</p><p>思路参考自：[题解 AT2346【<a href="https://www.luogu.com.cn/article/qo9lzcig">ARC070B] No Need】 - 洛谷专栏 (luogu.com.cn)</a></p><p>​                       [题解 <a href="https://www.luogu.com.cn/article/g80jpt1t">ABC056D] No Need - 洛谷专栏 (luogu.com.cn)</a></p><p>题解区还有一些有趣的写法：[AT_arc070_b <a href="https://www.luogu.com.cn/problem/solution/AT_arc070_b">ABC056D] No Need - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">bool</span> dp[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意初始化</span></span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//a[i]&gt;=k，更新答案</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=k)cnt=i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//枚举不合法的总和，并枚举对应可能的a[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="comment">//如果dp[j]合法且j+a[i]&gt;=k,说明i不是必须的</span></span><br><span class="line">            <span class="keyword">if</span>(dp[j]&amp;&amp;j+a[i]&gt;=k)cnt=i;</span><br><span class="line">            <span class="comment">//如果dp[j]是合法的，则dp[j+a[i]]也是合法的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dp[j])dp[j+a[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC055</title>
      <link href="/posts/ebd6795.html"/>
      <url>/posts/ebd6795.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC055">ABC055</h1><blockquote><h1 id="ABC055D-Menagerie">[ABC055D] Menagerie</h1><h2 id="题面翻译">题面翻译</h2><h2 id="题目描述">题目描述</h2><p>Snuke，一个喜欢动物的人，建立了一个动物园。</p><p>一共有n个动物在动物园中，编号 $1-n$ ，被按顺序围成一个圈。</p><p>有两种动物：诚实的羊只说真话，不诚实的狼只说假话。</p><p>Snuke无法区别这两种动物，他问每只动物以下问题：“你旁边的两只动物是同一种吗？”第i只动物的答案为 $Si$ 。如果 $Si$ 为“o”，则表示相同，“x”则相反。</p><p>此外，若羊回答“o”，相邻的生物则都是羊或都是狼，而“x”则相反。若狼回答“x”，相邻的生物则都是羊或狼，而“o”则相反。</p><p>Snuke想知道是否有一种可行的排列方式。如果有，输出这种排列。如果没有，则输出“-1”。</p><p>注：“S”表示羊，“W”表示狼。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんは動物が好きなので動物園を作りました。</p><p>この動物園では $ 1,2,3,\ …,\ N $ の番号を割り振られた $ N $ 匹の動物が円環状に並べられています。 $ i\ (2≦i≦N-1) $ 番の動物は $ i-1 $ 番の動物と $ i+1 $ 番の動物と隣り合っています。また、$ 1 $ 番の動物は $ N $ 番の動物と $ 2 $ 番の動物と隣り合っており、$ N $ 番の動物は $ N-1 $ 番の動物と $ 1 $ 番の動物と隣り合っています。</p><p>動物園には本当のことしか言わない正直者の羊と、嘘しか言わない嘘つきの狼の 2 種類の動物がいます。</p><p>すぬけくんには羊と狼の区別がつかないので、それぞれの動物に両隣の動物が同じ種類かどうかを訪ねたところ、$ i $ 番目の動物は $ s_i $ と答えました。$ s_i $ が <code>o</code> ならば両隣の動物が同じ種類であると、<code>x</code> ならば異なる種類であると $ i $ 番の動物が言ったことを示します。</p><p>より形式的には、羊は両隣の動物がどちらも羊あるいはどちらも狼のとき <code>o</code> と答え、そうでないとき <code>x</code> と答えます。 狼は両隣の動物がどちらも羊あるいはどちらも狼のとき <code>x</code> と答え、そうでないとき <code>o</code> と答えます。</p><p>これらの回答結果と矛盾しないような各動物の種別の割り当てが存在するか、すぬけくんは気になっています。存在するならば一例を示し、存在しないならば <code>-1</code> を出力しなさい。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ s $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ s $ と矛盾しないような各動物の種類の割当てが存在しないならば <code>-1</code> を出力してください。 存在するならば以下の形式で文字列 $ t $ を出力してください。 $ t $ で示される割り当てが $ s $ と矛盾しないならば正解となります。</p><ul><li>$ t $ は長さ $ N $ で <code>S</code> と <code>W</code> のみからなる文字列</li><li>$ t_i $ が <code>S</code> ならば $ i $ 番の動物が羊であることを、<code>W</code> ならば狼であることを示す</li></ul><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">ooxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSSWWS</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">oox</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">oxooxoxoox</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SSWWSSSWWS</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 3\ ≦\ N\ ≦\ 10^{5} $</li><li>$ s $ は <code>o</code> と <code>x</code> のみからなる長さ $ N $ の文字列</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>例えば $ 1,2,3,4,5,6 $ 番の動物がそれぞれ羊、羊、羊、狼、狼、羊であるとき発言と矛盾しません。その他、狼、羊、狼、羊、狼、狼であるようなときも矛盾しません。 両隣が同じ種類の動物のとき羊は <code>o</code> と発言し、狼は <code>x</code> と発言すること、 両隣が異なる種類の動物のとき羊は <code>x</code> と発言し、狼は <code>o</code> と発言することに注意してください。 ![b34c052fc21c42d2def9b98d6dccd05c.png](<a href="https://atcoder.jp/img/arc069/b34c052fc21c42d2def9b98d6dccd05c.png">https://atcoder.jp/img/arc069/b34c052fc21c42d2def9b98d6dccd05c.png</a>)</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>存在しない場合は <code>-1</code> を出力してください。</p></blockquote><h2 id="思路">思路</h2><p>思路转载自：[AT_arc069_b <a href="https://www.luogu.com.cn/article/6yhy8dr1">ABC055D] Menagerie 题解 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>我们只要知道了前两个动物的种类，就可以推出所有动物的种类。那么思路就是，枚举前两个动物的种类即可。</p><p>但如果每种情况都讨论的话未免太复杂，所以我们考虑一种简化方法。</p><table><thead><tr><th>前两个动物的种类</th><th>第 22 个动物的回答</th><th>第 33 个动物的种类</th></tr></thead><tbody><tr><td>SS</td><td>o</td><td>S</td></tr><tr><td>SS</td><td>x</td><td>W</td></tr><tr><td>SW</td><td>o</td><td>W</td></tr><tr><td>SW</td><td>x</td><td>S</td></tr><tr><td>WS</td><td>o</td><td>W</td></tr><tr><td>WS</td><td>x</td><td>S</td></tr><tr><td>WW</td><td>o</td><td>S</td></tr><tr><td>WW</td><td>x</td><td>W</td></tr></tbody></table><p>找规律得：如果设$S=1,W=0,o=1，x=0$，则第三个动物种类为$(a_2+b_1+b_2)mod\ 2$，可以得到递推式：<br>$$<br>b_i=(b_{i-1}+b_{i-2}+a_{i-1})mod\ 2<br>$$<br>推出所有动物的种类之后，还要进行验证，第一、二个动物再往前两个在环的情况下是否一样，需要特判。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e11</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">bool</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="comment">//b数组代表的是动物种类，a数组代表的是第i个动物说的话是真是假</span></span><br><span class="line"><span class="comment">//判断函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    b[<span class="number">1</span>]=x,b[<span class="number">2</span>]=y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        b[i]=(a[i<span class="number">-1</span>]+b[i<span class="number">-1</span>]+b[i<span class="number">-2</span>])%<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里需要特判推导出来的1、2是否与实际一致</span></span><br><span class="line">    <span class="keyword">if</span>((b[<span class="number">1</span>]==(a[n]+b[n]+b[n<span class="number">-1</span>])%<span class="number">2</span>)&amp;&amp;(b[<span class="number">2</span>]==(a[<span class="number">1</span>]+b[<span class="number">1</span>]+b[n])%<span class="number">2</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i])cout&lt;&lt;<span class="string">&quot;S&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;W&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">    <span class="comment">//进行初始化，如果为o，初始化为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=(s[i]==<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//枚举1、2号动物所有可能情况</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                <span class="built_in">print</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC054</title>
      <link href="/posts/79ba5703.html"/>
      <url>/posts/79ba5703.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC054">ABC054</h1><blockquote><h1 id="ABC054B-Template-Matching">[ABC054B] Template Matching</h1><h2 id="题面翻译">题面翻译</h2><p>给与纵N行，横N N列像素排列了的图像A，纵M行，横M M列像素排列了的模板图像B。</p><p>像素是构成图像的最小单位，其中1×1×1的正方形。</p><p>另外，给定的图像全部是二值图像，各像素的颜色用白和黑两种表示。</p><p>在输入中，全部的像素用文字表示，.白色的像素，#与黑色的像素对应。图像A由N N个字符串A_1、…、A_N A 1、…、A_N A N表示。字符串A_i Ai</p><p>的j j字符目对应于图像A上第i i、从左边第j j j个像素。(1≤i，j≤N) (1≤i，j≤N)同样，模板图像B由M M个字符串B_1，…，B_M B 1，…，B M M M表示。字符串B_i B i的j j j字符目对应于模板图像B上第i i、从左边第j j j的像素。(1≤i,j≤M) (1≤i,j≤M)</p><p>当仅允许图像平行移动时，请确定模板图像B是否包含在图像A中。</p><h2 id="题目描述">题目描述</h2><p>縦 $ N $ 行、横 $ N $ 列に画素が並んだ画像Aと、縦 $ M $ 行、横 $ M $ 列に画素が並んだテンプレート画像Bが与えられます。<br>画素は画像を構成する最小単位であり、ここでは $ 1×1 $ の正方形とします。<br>また、与えられる画像は全て2値画像であり、各画素の色は白と黒の2種類で表されます。</p><p>入力において、全ての画素は文字で表されており、<code>.</code>は白色の画素、 <code>#</code> は黒色の画素に対応します。<br>画像Aは $ N $ 個の文字列 $ A_1,…,A_N $ で表されます。<br>文字列 $ A_i $ の $ j $ 文字目は、画像Aの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦N) $<br>同様に、テンプレート画像Bは $ M $ 個の文字列 $ B_1,…,B_M $ で表されます。<br>文字列 $ B_i $ の $ j $ 文字目は、テンプレート画像Bの上から $ i $ 番目、左から $ j $ 番目の画素に対応します。$ (1≦i,j≦M) $</p><p>画像の平行移動のみ許されるとき、テンプレート画像Bが画像Aの中に含まれているかを判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ A_1 $ $ A_2 $ $ : $ $ A_N $ $ B_1 $ $ B_2 $ $ : $ $ B_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>画像Aの中にテンプレート画像Bを含む場合は <code>Yes</code>、含まない場合は <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">#.#</span><br><span class="line">.#.</span><br><span class="line">#.#</span><br><span class="line">#.</span><br><span class="line">.#</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦M≦N≦50 $</li><li>$ A_i $ は <code>#</code> と <code>.</code> からなる長さ $ N $ の文字列</li><li>$ B_i $ は <code>#</code> と <code>.</code> からなる長さ $ M $ の文字列</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>テンプレート画像Bが、画像A中の左上の $ 2\ ×\ 2 $ の部分画像と右下の $ 2\ ×\ 2 $ の部分画像に一致するため、<code>Yes</code> と出力します。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>画像Aは白色の画素、テンプレート画像Bは黒色の画素で構成されるため、含まれることはありません。</p></blockquote><h2 id="思路">思路</h2><p>直接从矩形的左上角开始暴力匹配即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">string a[<span class="number">55</span>],b[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//思路，从左上角开始暴力匹配即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i+x<span class="number">-1</span>][j+y<span class="number">-1</span>]!=b[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i],a[i]=<span class="string">&quot; &quot;</span>+a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;b[i],b[i]=<span class="string">&quot; &quot;</span>+b[i];</span><br><span class="line">    <span class="comment">//从左上角开始暴力匹配，注意范围</span></span><br><span class="line">    <span class="comment">//如果合法，cout&lt;&lt;&quot;YES&quot;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-m+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n-m+<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i,j))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC054C-One-stroke-Path">[ABC054C] One-stroke Path</h1><h2 id="题面翻译-2">题面翻译</h2><h4 id="题目描述-2">题目描述</h4><p>给定一个没有重边和自环的 $N$ 个点 $M$ 条边的无权无向图，第 $i$ 条边连接顶点 $a _ i$ 和 $b _ i$。</p><p>求以顶点 $1$ 为起点，只访问 $1$ 次所有顶点的路径有多少条？特别地，起点和终点也视为被访问。</p><h4 id="输入格式-2">输入格式</h4><p>第一行两个整数 $N, M$。</p><p>接下来 $m$ 行，其中第 $i$ 行两个整数 $a _ i, b _ i$。</p><p>$<br>N M \<br>a _ 1 b _ 1 \<br>a _ 2 b _ 2 \<br>\kern {0.667 em} \vdots \<br>a _ M b _ M<br>$</p><h4 id="输出格式-2">输出格式</h4><p>输出满足条件的路径有多少。</p><h4 id="数据范围">数据范围</h4><p>$<br>2 \le N \le 8 \<br>0 \le M \le N(N - 1) \<br>1 \le a _ i &lt; b _ i \le N<br>$</p><p>给定的无向图中不包含重边和自环。</p><h2 id="题目描述-3">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $ 辺の重み無し無向グラフが与えられます。<br>$ i\ (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を結びます。<br>ここで、自己ループは $ a_i\ =\ b_i\ (1≦i≦M) $ となる辺のことを表します。<br>また、二重辺は $ a_i=a_j $ かつ $ b_i=b_j\ (1≦i\ &lt;\ j≦M) $ となる辺のことを表します。<br>頂点 $ 1 $ を始点として、全ての頂点を1度だけ訪れるパスは何通りありますか。<br>ただし、パスの始点と終点の頂点も訪れたものとみなします。</p><p>例として、図1のような無向グラフが与えられたとします。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/5764771c0b3041c3346efe47c98edb49c94a9b3d.png" alt="">図1：無向グラフの例</p><p>このとき、図2で表されるパスは条件を満たします。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/7f5174784cef5e6da48aed9eeb9756a6de9199db.png" alt="">図2：条件を満たすパスの例</p><p>しかし、図3で表されるパスは条件を満たしません。全ての頂点を訪れていないからです。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad6e861039122f07481a4ef820a2461de4e5e54c.png" alt="">図3：条件を満たさないパスの例1</p><p>また、図4で表されるパスも条件を満たしません。始点が頂点 $ 1 $ ではないからです。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc054_c/ad37aa02ed59054ab7ef974821bffd978f95285d.png" alt="">図4：条件を満たさないパスの例2</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ a_2 $ $ b_2 $ $ : $ $ a_M $ $ b_M $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>問題文の条件を満たすパスが何通りあるか出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7</span><br><span class="line">1 3</span><br><span class="line">2 7</span><br><span class="line">3 4</span><br><span class="line">4 5</span><br><span class="line">4 6</span><br><span class="line">5 6</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2≦N≦8 $</li><li>$ 0≦M≦N(N-1)/2 $</li><li>$ 1≦a_i\ &lt;\ b_i≦N $</li><li>与えられるグラフは自己ループと二重辺を含まない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>与えられるグラフは以下の図で表されます。 ![43c0ac53de20d989d100bf60b3cd05fa.png](<a href="https://atcoder.jp/img/5013/43c0ac53de20d989d100bf60b3cd05fa.png">https://atcoder.jp/img/5013/43c0ac53de20d989d100bf60b3cd05fa.png</a>) 条件を満たすパスは以下の $ 2 $ 通りです。 ![c4a27b591d364fa479314e3261b85071.png](<a href="https://atcoder.jp/img/5013/c4a27b591d364fa479314e3261b85071.png">https://atcoder.jp/img/5013/c4a27b591d364fa479314e3261b85071.png</a>)</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>このテストケースは問題文の例と同じです。</p></blockquote><h2 id="思路-2">思路</h2><p>范围很小，直接DFS即可，记录从1开始能否访问所有顶点的路径数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">bool</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from,to;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">    Edge e=&#123;from,to&#125;;</span><br><span class="line">    edge[from].<span class="built_in">push_back</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x是当前所在的点，cnt是当前统计的经过点数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意标记</span></span><br><span class="line">    b[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> t:edge[x])&#123;</span><br><span class="line">        <span class="type">int</span> to=t.to;</span><br><span class="line">        <span class="keyword">if</span>(b[to])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//这里写cnt+1，不要写cnt++</span></span><br><span class="line">        <span class="built_in">dfs</span>(to,cnt+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    b[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC054D-Mixing-Experiment">[ABC054D] Mixing Experiment</h1><h2 id="题面翻译-3">题面翻译</h2><hr><h2 id="题目描述：">题目描述：</h2><p>有 $N$ 个物体，第 $i$ 个物体含有 $a_i$ 质量的 A 元素 和 $b_i$ 质量的 B 元素，代价为 $c_i$ 。</p><p>问能否取若干个物体，使 A 元素与 B 元素质量之比为 $M_a : M_b$ ，并使代价最小。</p><hr><h2 id="输入格式-4">输入格式:</h2><p>第一行3个整数 $N ,M_a ,M_b$</p><p>下面 $N$ 行，每行3个整数 $a_i ,b_i ,c_i$</p><p>$ N $   $ M_a $   $ M_b $<br>$ a_1 $   $ b_1 $   $ c_1 $<br>$ a_2 $   $ b_2 $   $ c_2 $</p><p>$ : $<br>$ a_N $   $ b_N $   $ c_N $</p><hr><h2 id="输出格式：">输出格式：</h2><p>若能满足条件则输出 <strong>最小代价</strong>。</p><p>否则输出 -1</p><hr><h2 id="数据范围：">数据范围：</h2><ul><li><p>$1\le N\le 40$</p></li><li><p>$1\le a_i,b_i\le 10$</p></li><li><p>$1\le c_i\le 100$</p></li><li><p>$1\le M_a,M_b\le 10$</p></li><li><p>$gcd(M_a,M_b)=1$</p></li><li><p>输入都为整数。</p></li></ul><hr><p>translated by @君のNOIP。</p><h2 id="题目描述-4">题目描述</h2><p>イルカは、微量の物質Cを生成したいと考えています。<br>物質Cを生成するためには、タイプAの物質とタイプBの物質の混合比が $ M_a:M_b $ となる溶液を用意する必要があります。<br>しかし、イルカは薬品を1つも持っていないため、薬局へ薬品を買いに行くことにしました。<br>薬局では、$ N $ 種類の薬品を取り扱っており、各薬品 $ i $ の在庫はちょうど1つです。<br>各薬品 $ i $ は、タイプAの物質 $ a_i $ グラム、タイプBの物質 $ b_i $ グラム含んでおり、価格 $ c_i $ 円で売られています。<br>イルカは、いくつかの薬品を薬局で買います。買った薬品は全て使わなければなりません。<br>物質Cを生成するために、必要な最小予算を求めてください。<br>薬局で売られている薬品の組み合わせで、物質Cを生成できない場合はそれを報告してください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M_a $ $ M_b $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_N $ $ b_N $ $ c_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>物質Cを生成するために必要な最小予算を出力せよ。物質Cを生成できない場合には <code>-1</code> を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 1</span><br><span class="line">1 2 1</span><br><span class="line">2 1 2</span><br><span class="line">3 3 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 10</span><br><span class="line">10 10 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦40 $</li><li>$ 1≦a_i,b_i≦10 $</li><li>$ 1≦c_i≦100 $</li><li>$ 1≦M_a,M_b≦10 $</li><li>$ gcd(M_a,M_b)=1 $</li><li>$ a_i $、$ b_i $、$ c_i $、$ M_a $、$ M_b $は整数である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>最小予算となる組み合わせは、薬品 $ 1 $ と薬品 $ 2 $ を混合する場合です。 この場合、混合した溶液中に物質Aは $ 3 $ グラム、物質Bは $ 3 $ グラム含まれており、混合比は $ 3:3=1:1 $ となって条件を満たします。 このときの合計価格は $ 3 $ 円となります。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>物質Aと物質Bの混合比が $ 1:10 $ となる薬品の組み合わせはないので、<code>-1</code>を出力します。</p></blockquote><h2 id="思路-3">思路</h2><p>很容易看出来这是一个01背包问题。</p><p>注意有两个维度：$dp[i][j]$表示$A$总质量为$i$，$B$总质量为$j$。由此可得状态转移方程，注意要倒序枚举。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> n,m_a,m_b,suma,sumb;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m_a&gt;&gt;m_b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">        suma+=a[i];</span><br><span class="line">        sumb+=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不要忘记初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=suma;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=sumb;j++)&#123;</span><br><span class="line">            dp[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//ans存储答案</span></span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//倒序枚举，进行状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=suma;i&gt;=a[k];i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=sumb;j&gt;=b[k];j--)&#123;</span><br><span class="line">                dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i-a[k]][j-b[k]]+c[k]);</span><br><span class="line">                <span class="comment">//如果有满足合法比的情况，则更新答案</span></span><br><span class="line">                <span class="keyword">if</span>(i*m_b==j*m_a)ans=<span class="built_in">min</span>(ans,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==INF)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC053</title>
      <link href="/posts/e7dec2a0.html"/>
      <url>/posts/e7dec2a0.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC053">ABC053</h1><blockquote><h1 id="ABC053C-X-Yet-Another-Die-Game">[ABC053C] X: Yet Another Die Game</h1><h2 id="题面翻译">题面翻译</h2><p>一个骰子，初始的时候任意的一个面朝上，接下来每一轮可以翻转骰子到相邻的一面，并获得此面的得分（那一面的数值即是得分）。问至少要几轮才可以获得够 $x$ 分。</p><p><strong>注</strong>：所有数均在$longlong$范围内。</p><h3 id="输入格式">输入格式</h3><p>一个数 $x$ 。</p><h3 id="输出格式">输出格式</h3><p>输出也是一个数，即最少的轮数。</p><h2 id="题目描述">题目描述</h2><p>すぬけくんは $ 6 $ 面サイコロで遊ぶことにしました。 サイコロは $ 1 $ から $ 6 $ までの整数がそれぞれの面に書かれており、向かい合う面に書かれた数の和はどれも $ 7 $ です。</p><p>すぬけくんはサイコロの好きな面が上向きになるように置いたのち何回か以下の操作を行います。</p><ul><li>操作：サイコロを手前、奥、左、右のどれかの方向に $ 90° $ だけ回転させる。その後、上を向いている面に書かれた数を $ y $ として $ y $ 点得る。</li></ul><p>例えば、図のように $ 1 $ と書かれた面が上を向いており、手前側の面に $ 5 $ が、右側の面に $ 4 $ が書かれている状況を考えます。<br>図に示されるように右方向に回転させることで $ 3 $ と書かれた面が上を向くようにすることが可能です。 その他、左方向に回転させた場合は $ 4 $ と書かれた面が、手前方向に回転させた場合は $ 2 $ と書かれた面が、奥方向に回転させた場合は $ 5 $ と書かれた面が上を向くようにすることが可能です。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_arc068_a/853455ad24539a0166e2da8cad62831372eeae9b.png" alt="864abc2e4a08c26015ffd007a30aab03.png"></p><p>すぬけくんが合計で $ x $ 点以上得るために必要な最小の操作回数を求めなさい。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ x $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">149696127901</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">27217477801</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ x\ ≦\ 10^{15} $</li><li>$ x $ は整数</li></ul></blockquote><h2 id="思路">思路</h2><p>被题意误导了，其实大于$x$也是可以的</p><p>如果要步骤最少，我们可以6-5-6-5······，这样一路下来，就能得到最小的操作次数。</p><p>注意下面的一轮是按6-5算的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll x;cin&gt;&gt;x;</span><br><span class="line">    <span class="comment">//注意这里要乘上2</span></span><br><span class="line">    ll ans=(x/<span class="number">11</span>)*<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果恰好完成，直接输出即可</span></span><br><span class="line">    <span class="keyword">if</span>(x%<span class="number">11</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有，判断是否在0-6之间，如果是则加1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>&lt;=x%<span class="number">11</span>&amp;&amp;x%<span class="number">11</span>&lt;=<span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则加2</span></span><br><span class="line">    cout&lt;&lt;ans+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC053D-Card-Eater">[ABC053D] Card Eater</h1><h2 id="题面翻译-2">题面翻译</h2><p>有一堆牌，每张牌上有一个数字。 每次可以取出其中3张，丢掉数字最大的和数字最小的牌，把中间那张再放回牌堆。 要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。</p><h2 id="题目描述-2">题目描述</h2><p>すぬけくんはカードゲームで遊ぶことにしました。 $ N $ 枚からなるカードの山があり、上から $ i $ 枚目のカードには整数 $ A_i $ が書かれています。</p><p>すぬけくんはこのカードの山に対し $ 0 $ 回以上、以下の操作を行い、残ったカードに書かれた値が互いに異なるようにしたいです。最大で何枚のカードを残すことが可能か求めなさい。なお、$ N $ は奇数であり、少なくとも $ 1 $ 枚のカードを残すことが可能であることが保証されます。</p><p>操作：カードの山から任意の $ 3 $ 枚のカードを抜き出す。抜き出したカードのうち書かれた値が最大であるようなカード $ 1 $ 枚と最小であるようなカード $ 1 $ 枚の合計 $ 2 $ 枚を選んで食べる。その後残った $ 1 $ 枚をカードの山に戻す。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ A_3 $ … $ A_{N} $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>答えを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 3 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">1 3 5 2 1 3 2 8 8 6 2 6 11 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 3\ ≦\ N\ ≦\ 10^{5} $</li><li>$ N $ は奇数</li><li>$ 1\ ≦\ A_i\ ≦\ 10^{5} $</li><li>$ A_i $ は整数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>操作を $ 1 $ 回行って $ 1,1,2 $ を取り出すというのが最適な操作手順の $ 1 $ つです。最大値である $ 2 $ と書かれたカードで最小値である $ 1 $ と書かれたカードがそれぞれ $ 1 $ 枚ずつ食べられ、残った $ 1 $ と書かれたカードがカードの山に戻されます。カードの山に残っているカードは $ 1,3,7 $ となり、これらは互いに異なります。</p></blockquote><h2 id="思路-2">思路</h2><p>一个很好想的思路，可以统计一下有多少种牌的数量是大于1的（记作$cnt$），这样的话，他们之间就可以两两配对，这样可以避免减少卡牌的种类。</p><p>但是有特殊情况，如果$cnt$是奇数，说明会剩下一张重复的卡牌，所以我们不得不重新选出一张牌来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,a=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//记录重复的卡牌数量</span></span><br><span class="line">        <span class="keyword">if</span>(m[a])cnt++;</span><br><span class="line">        <span class="keyword">else</span> m[a]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否可能无法配对</span></span><br><span class="line">    cnt+=cnt%<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;n-cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC052</title>
      <link href="/posts/90d9f236.html"/>
      <url>/posts/90d9f236.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC052">ABC052</h1><blockquote><h1 id="ABC052C-Factors-of-Factorial">[ABC052C] Factors of Factorial</h1><h2 id="题面翻译">题面翻译</h2><p>给定正整数 $N \left( 1\leq N \leq 10 ^3 \right)$ 求 $N!$ 的约数个数。结果对 $10^9 + 7$ 取模</p><h2 id="题目描述">题目描述</h2><p>整数 $ N $ が与えられます。 $ N! $ の正の約数の個数を $ 10^9+7 $ で割った余りを求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>$ N! $ の正の約数の個数を $ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">972926972</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦10^3 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 3! $ $ =6 $ です。$ 6 $ の正の約数は $ 1,2,3,6 $ の $ 4 $ 個なので、$ 4 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>需要一点点数论知识（可惜我没有）。</p><p>思路转载自：[<a href="https://www.luogu.com.cn/article/5yq3f4lw">题解] AT2286 [ARC067A] Factors of Factorial - 洛谷专栏 (luogu.com.cn)</a></p><p>若一个正整数$n&gt;1$，且可分解为一系列质因数的乘积：<br>$$<br>n=\prod \limits_{i=1}^k {p}^{a_i}<em>i<br>$$<br>则$n$约数的个数$f(n)$为：<br>$$<br>f(n)=\prod \limits</em>{i=1}^k(a_i+1)<br>$$<br>由于观察到数据并不大，$n\leq1000$，我们可以考虑从$1$到$n$，每乘到一个数时，都分解一次质因数，用一个$map$数组统计可分解的质因数个数。中间的每个数可以分解的质因数指数都加 1，到最后就统计出了$n!$的质因数分解形式。时间复杂度$O(n^2)$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator p;</span><br><span class="line"><span class="comment">//分解质因数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">            n/=i;</span><br><span class="line">            <span class="comment">//进行统计</span></span><br><span class="line">            m[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">solve</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(p=m.<span class="built_in">begin</span>();p!=m.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">        ans=ans*(p-&gt;second+<span class="number">1</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC052D-Walk-and-Teleport">[ABC052D] Walk and Teleport</h1><h2 id="题面翻译-2">题面翻译</h2><p>在东西方向延伸的直线上，有N个城市。城市坐标按从西到东递增。</p><p>你现在在某个城市里，想去其他所有的城市。移动的方法有以下两种。</p><p>一，在直线上按东西方向平移，每移动一个单位距离疲劳值加A</p><p>二，直接瞬移到某个坐标，并且疲劳值加B</p><p>请使用以上两种方式直到去完其他所有的城市，并求出最小的疲劳值。</p><p><strong>输入输出格式</strong></p><p>输入格式：</p><p>第一行三个数,即N,A,B,</p><p>第二行N个数，即X[1],X[2]…,X[N]。</p><p>输出格式：</p><p>输出最小的疲劳值。</p><p><strong>说明</strong></p><p>2&lt;=N&lt;=1e5</p><p>1&lt;=Xi,A,B&lt;=1e9且X(i)&lt;X(i+1)</p><h2 id="题目描述-2">题目描述</h2><p>東西方向にのびる直線上に、$ N $ 個の町があります。 町には、西から順に $ 1 $ から $ N $ までの番号がついています。 直線上には座標が設定されていて、東に行くほど座標が大きくなります。 町 $ i $ の座標は $ X_i $ です。</p><p>あなたは今、町 $ 1 $ にいて、これからほかの全ての町を訪れたいです。 移動する手段は次の $ 2 $ 種類あります。</p><ul><li>直線上を歩いて移動する。 東西どちらに歩いても、$ 1 $ 移動する度に疲労度が $ A $ 上がります。</li><li>好きな場所へテレポートする。 テレポートをすると、移動した距離によらず疲労度が $ B $ 上がります。</li></ul><p>この $ 2 $ 種類の移動を繰り返して全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるか求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ B $ $ X_1 $ $ X_2 $ $ … $ $ X_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>全ての町を最適に回った時、疲労度の上昇値の合計の最小値がいくつになるかを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 5</span><br><span class="line">1 2 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 100</span><br><span class="line">40 43 45 105 108 115 124</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">84</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 1 2</span><br><span class="line">24 35 40 68 72 99 103</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>入力は全て整数である</li><li>$ 2≦N≦10^5 $</li><li>$ 1≦X_i≦10^9 $</li><li>全ての $ i(1≦i≦N-1) $ について、$ X_i\ &lt;\ X_{i+1} $ が成り立つ</li><li>$ 1≦A≦10^9 $</li><li>$ 1≦B≦10^9 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>町 $ 1 $ から町 $ 2 $ まで $ 1 $ の距離歩いて移動したあと、町 $ 3 $ にテレポートし、そこから町 $ 4 $ まで $ 2 $ の距離歩いて移動すると、 疲労度の上昇値の合計が $ 2×1+5+2×2=11 $ になり、これが最小です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>町 $ 1 $ から町 $ 7 $ まで歩き続けると、疲労度の上昇値の合計が $ 84 $ になり、これが最小です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>どのような順番でもよいので、$ 6 $ 回のテレポートで全ての町を訪れると、疲労度の上昇値の合計が $ 12 $ になり、これが最小です。</p></blockquote><h2 id="思路-2">思路</h2><p>一眼的贪心</p><p>题解区发现一篇奇怪的题解：[题解 AT2287 【<a href="https://www.luogu.com.cn/article/gs4bm7sp">ARC067B] Walk and Teleport】 - 洛谷专栏 (luogu.com.cn)</a>，可以看看。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> x[MAXN];</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a*(x[i]-x[i<span class="number">-1</span>])&lt;b)ans+=a*(x[i]-x[i<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">else</span> ans+=b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC051</title>
      <link href="/posts/9d0a38c.html"/>
      <url>/posts/9d0a38c.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC051">ABC051</h1><blockquote><h1 id="ABC051B-Sum-of-Three-Integers">[ABC051B] Sum of Three Integers</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目描述">题目描述</h1><p>有两个整数 $K$ , $S$</p><p>求有几种方案使得三个非负整数 $X$ , $Y$ , $Z$ 之和= $S$ 并且均 $\leq K$</p><h1 id="输入格式">输入格式</h1><p>两个正整数 $K$ , $S$ , 见题目描述。</p><h1 id="输出格式">输出格式</h1><p>一个整数，表示方案数</p><h2 id="题目描述-2">题目描述</h2><p>$ 2 $ つの整数 $ K,S $ が与えられます。<br>$ 3 $ つの変数 $ X,Y,Z $ があり、$ 0≦X,Y,Z≦K $ を満たす整数の値を取ります。<br>$ X\ +\ Y\ +\ Z\ =\ S $ を満たす $ X,Y,Z $ への値の割り当ては何通りありますか。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ K $ $ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>問題文の条件を満たす $ X,Y,Z $ の組が何通りあるか出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 15</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 2≦K≦2500 $</li><li>$ 0≦S≦3K $</li><li>$ K,S $ は整数である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>問題文の条件を満たす $ X,Y,Z $ の組は以下の $ 6 $ 通りです。 - $ X\ =\ 0,\ Y\ =\ 0,\ Z\ =\ 2 $ - $ X\ =\ 0,\ Y\ =\ 2,\ Z\ =\ 0 $ - $ X\ =\ 2,\ Y\ =\ 0,\ Z\ =\ 0 $ - $ X\ =\ 0,\ Y\ =\ 1,\ Z\ =\ 1 $ - $ X\ =\ 1,\ Y\ =\ 0,\ Z\ =\ 1 $ - $ X\ =\ 1,\ Y\ =\ 1,\ Z\ =\ 0 $</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>$ X\ +\ Y\ +\ Z $ の最大値は $ 15 $ であり、それを満たす組は $ 1 $ 通りです。</p></blockquote><h2 id="思路">思路</h2><p>直接枚举不行，所以我们可以只要枚举X，Y，然后判断是否存在符合要求的Z即可，注意X,Y,Z的范围</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> k,s;cin&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=k;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i+j&lt;=s&amp;&amp;s-j-i&lt;=k)ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC051C-Back-and-Forth">[ABC051C] Back and Forth</h1><h2 id="题面翻译-2">题面翻译</h2><p>在平面直角坐标系中，有点 $A（sx,sy）$ 和 点 $B（tx,ty）$ 保证 $sx&lt;tx$，$sy&lt;ty$ 并且 $sx,sy,tx,ty$ 都为整数。</p><p>在 $A$ 点有一只海豚，它每次可以向上下左右其中一个方向移动一个单位长度。这只海豚想从 $A$ 点到 $B$ 点再回到 $A$ 点再到 $B$ 点再回到 $A$ 点。</p><p>要求：除了 $A,B$ 点以外，所有格点都不能走第二遍。海豚不能斜着走。</p><p>输出一个字符串 <code>S</code> 表示海豚的最短路径，<br><code>S</code> 中只包括 $U,R,D,L$。</p><ul><li>$U$：向上走一个单位长度。</li><li>$R$：向右走一个单位长度。</li><li>$D$：向下走一个单位长度。</li><li>$L$：向左走一个单位长度。</li></ul><h1 id="输入格式：">输入格式：</h1><p>一行，$sx,sy,tx,ty$。</p><h1 id="输出格式：">输出格式：</h1><p>一行，字符串 <code>S</code>。</p><p>如果有多个最短路径，输出其中任意一个。</p><p>Translate by @sqh_let_it_be</p><h2 id="题目描述-3">题目描述</h2><p>イルカは $ x $ 軸正方向を右、$ y $ 軸正方向を上とする 2 次元座標平面にいます。<br>イルカは現在点 $ (sx,sy) $ にいて、$ 1 $ 秒あたり上下左右に距離 $ 1 $ だけ進むことができます。<br>このとき、移動前と移動後の $ x $ 座標、$ y $ 座標はともに整数でなければなりません。<br>イルカはここから $ sx\ と\ sy\ を満たす点\ (tx,ty) $ に行き、その後点 $ (sx,sy) $ に戻り、また点 $ (tx,ty) $ に行き、その後点 $ (sx,sy) $ に戻ります。<br>このとき、イルカは点 $ (sx,sy) $ と点 $ (tx,ty) $ を除いて、途中で同じ座標を複数回通らないように移動しなければなりません。<br>このような条件を満たすイルカの最短経路を $ 1 $ つ求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ sx $ $ sy $ $ tx $ $ ty $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>イルカの最短経路を表す文字列 $ S $ を出力せよ。<br>$ S $ の $ i $ 番目の文字はイルカの $ i $ 番目の移動を表す。<br>イルカの各方向への移動を表す文字の対応関係は以下のとおりである。</p><ul><li><code>U</code>: 上方向</li><li><code>D</code>: 下方向</li><li><code>L</code>: 左方向</li><li><code>R</code>: 右方向</li></ul><p>条件を満たすような最短経路が複数ある場合、そのうちどれか $ 1 $ つを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURDDLLUUURRDRDDDLLU</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-2 -2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UURRURRDDDLLDLLULUUURRURRDDDLLDL</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ -1000≦\ sx $</li><li>$ -1000≦\ sy $</li><li>$ sx,sy,tx,ty $ は整数である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>以下に示す移動経路が最短経路の $ 1 $ つです。 - $ 1 $ 回目の $ (sx,sy) $ から $ (tx,ty) $ への移動: $ (0,0) $ → $ (0,1) $ → $ (0,2) $ → $ (1,2) $ - $ 1 $ 回目の $ (tx,ty) $ から $ (sx,sy) $ への移動: $ (1,2) $ → $ (1,1) $ → $ (1,0) $ → $ (0,0) $ - $ 2 $ 回目の $ (sx,sy) $ から $ (tx,ty) $ への移動: $ (0,0) $ → $ (-1,0) $ → $ (-1,1) $ → $ (-1,2) $ → $ (-1,3) $ → $ (0,3) $ → $ (1,3) $ → $ (1,2) $ - $ 2 $ 回目の $ (tx,ty) $ から $ (sx,sy) $ への移動: $ (1,2) $ → $ (2,2) $ → $ (2,1) $ → $ (2,0) $ → $ (2,-1) $ → $ (1,-1) $ → $ (0,-1) $ → $ (0,0) $</p></blockquote><h2 id="思路-2">思路</h2><p>直接暴力模拟过程即可。</p><p>具体看大佬的图示：</p><p><img src="https://img2.imgtp.com/2024/03/24/t2daHxyP.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> sx,sy,tx,ty;cin&gt;&gt;sx&gt;&gt;sy&gt;&gt;tx&gt;&gt;ty;</span><br><span class="line">    <span class="type">int</span> x=tx-sx,y=ty-sy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;R&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;DR&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=y+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;D&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;i++)cout&lt;&lt;<span class="string">&quot;L&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;U&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC051D-Candidates-of-No-Shortest-Paths">[ABC051D] Candidates of No Shortest Paths</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定一个 $n$ 个点，$m$ 条边的无重边无自环的加权无向连通图，问全源最短路有几条边没被用到。</p><h2 id="题目描述-4">题目描述</h2><p>自己ループと二重辺を含まない $ N $ 頂点 $ M $ 辺の重み付き無向連結グラフが与えられます。<br>$ i\ (1≦i≦M) $ 番目の辺は頂点 $ a_i $ と頂点 $ b_i $ を距離 $ c_i $ で結びます。<br>ここで、自己ループは $ a_i\ =\ b_i\ (1≦i≦M) $ となる辺のことを表します。<br>また、二重辺は $ (a_i,b_i)=(a_j,b_j) $ または $ (a_i,b_i)=(b_j,a_j)\ (1≦i\ &lt;\ j≦M) $ となる辺のことを表します。<br>連結グラフは、どの異なる $ 2 $ 頂点間にも経路が存在するグラフのことを表します。<br>どの異なる $ 2 $ 頂点間の、どの最短経路にも含まれない辺の数を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ M $ $ a_1 $ $ b_1 $ $ c_1 $ $ a_2 $ $ b_2 $ $ c_2 $ $ : $ $ a_M $ $ b_M $ $ c_M $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>グラフ上の、どの異なる $ 2 $ 頂点間の、どの最短経路にも含まれない辺の数を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">2 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2≦N≦100 $</li><li>$ N-1≦M≦min(N(N-1)/2,1000) $</li><li>$ 1≦a_i,b_i≦N $</li><li>$ 1≦c_i≦1000 $</li><li>$ c_i $ は整数である。</li><li>与えられるグラフは自己ループと二重辺を含まない。</li><li>与えられるグラフは連結である。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>この入力例で与えられるグラフにおける、全ての異なる $ 2 $ 頂点間の最短経路は以下の通りです。 - 頂点 $ 1 $ から頂点 $ 2 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 1 $ - 頂点 $ 1 $ から頂点 $ 3 $ への最短経路は、頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 1 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 2 $ から頂点 $ 3 $ への最短経路は、頂点 $ 2 $ → 頂点 $ 1 $ → 頂点 $ 3 $ で経路長は $ 2 $ - 頂点 $ 3 $ から頂点 $ 1 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ で経路長は $ 1 $ - 頂点 $ 3 $ から頂点 $ 2 $ への最短経路は、頂点 $ 3 $ → 頂点 $ 1 $ → 頂点 $ 2 $ で経路長は $ 2 $ したがって、一度も最短経路として使用されていない辺は、頂点 $ 2 $ と頂点 $ 3 $ を結ぶ長さ $ 3 $ の辺のみであるため、$ 1 $ を出力します。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>全ての辺が異なる $ 2 $ 頂点間のある最短経路で使用されます。</p></blockquote><h2 id="思路-3">思路</h2><p>$n$只有100，所以直接用$Floyd$即可，再每次记录当前边有没有被松弛掉，如果是第一次松弛就$ans++$。</p><p>注意到是无向图，所以$ans$要除以二。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],ans;</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,z;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">g[x][y]=g[y][x]=z,vis[x][y]=vis[y][x]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//记录边，并且给边打上标记</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(g[i][j]&gt;g[i][k]+g[k][j])&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i][j])ans++,vis[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="comment">//如果是第一次松弛，ans++</span></span><br><span class="line">g[i][j]=g[i][k]+g[k][j];</span><br><span class="line">&#125;<span class="comment">//Floyd模板</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans&gt;&gt;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC050</title>
      <link href="/posts/7ed7931a.html"/>
      <url>/posts/7ed7931a.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC050">ABC050</h1><blockquote><h1 id="ABC050B-Contest-with-Drinks-Easy">[ABC050B] Contest with Drinks Easy</h1><h2 id="题面翻译">题面翻译</h2><p>joisino 小姐姐即将参加某个编程比赛的决赛。在这个比赛中，准备了 $N$ 个问题，其中从 $1$ 到 $N$ 号码。我知道 joisino 小姐姐要解决问题 $i$（$1≤i≤N$）需要的时间是 $T_i$ 秒。</p><p>另外，在这个比赛中，提供M种不同的饮料，有 $1$~$M$ 的号码。如果喝了饮料 $i$（$1≤i≤M$） 的话，参赛者的大脑会被给予强烈的刺激，解决问题 $P_i$ 的时间是 $X_i$ 秒。问题之间的时间互不<br>影响。</p><p>每名参赛者在比赛开始前可以喝一瓶饮料。小姐姐joisino对于各自的饮料，想知道要解答所有的问题需要多少秒。解决所有问题的时间是解决各个问题的时间的总和。你的工作是为了帮助(取悦)小姐姐写一个程序。</p><h2 id="题目描述">题目描述</h2><p>joisinoお姉ちゃんは、あるプログラミングコンテストの決勝を控えています。 このコンテストでは、$ N $ 問の問題が用意されており、それらには $ 1～N $ の番号がついています。 joisinoお姉ちゃんは、問題 $ i(1≦i≦N) $ を解くのにかかる時間が $ T_i $ 秒であることを知っています。</p><p>また、このコンテストでは、$ M $ 種類のドリンクが提供されており、$ 1～M $ の番号がついています。 そして、ドリンク $ i(1≦i≦M) $ を飲むと、脳が刺激され、問題 $ P_i $ を解くのにかかる時間が $ X_i $ 秒になります。 他の問題を解くのにかかる時間に変化はありません。</p><p>コンテスタントは、コンテスト開始前にいずれかのドリンクを $ 1 $ 本だけ飲むことができます。 joisinoお姉ちゃんは、それぞれのドリンクについて、それを飲んだ際に、全ての問題を解くのに何秒必要なのかを知りたくなりました。 全ての問題を解くのに必要な時間とは、それぞれの問題を解くのにかかる時間の合計です。 あなたの仕事は、joisinoお姉ちゃんの代わりにこれを求めるプログラムを作成することです。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ T_2 $ $ … $ $ T_N $ $ M $ $ P_1 $ $ X_1 $ $ P_2 $ $ X_2 $ $ : $ $ P_M $ $ X_M $</p></blockquote><h2 id="输出格式">输出格式</h2><p>それぞれのドリンクについて、それを飲んだ際に全ての問題を解くのに必要な時間を求め、順番に $ 1 $ 行ずつ出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 1 4</span><br><span class="line">2</span><br><span class="line">1 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">7 2 3 8 5</span><br><span class="line">3</span><br><span class="line">4 2</span><br><span class="line">1 7</span><br><span class="line">4 13</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br><span class="line">25</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>入力は全て整数である</li><li>$ 1≦N≦100 $</li><li>$ 1≦T_i≦10^5 $</li><li>$ 1≦M≦100 $</li><li>$ 1≦P_i≦N $</li><li>$ 1≦X_i≦10^5 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>一つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$ 1 $ 秒、$ 1 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 6 $ 秒が答えになり、$ 6 $ を出力します。 二つ目のドリンクを飲んだ場合、それぞれの問題を解くのに要する時間は、$ 2 $ 秒、$ 3 $ 秒、$ 4 $ 秒になります。 なので、それらを合計した $ 9 $ 秒が答えになり、$ 9 $ を出力します。</p></blockquote><h2 id="思路">思路</h2><p>其实求的就是喝下第$i$杯饮料后，总时间变为多少。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> t[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i],sum+=t[i];</span><br><span class="line">    <span class="type">int</span> m;cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;sum-t[x]+y&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC050C-Lining-Up">[ABC050C] Lining Up</h1><h2 id="题面翻译-2">题面翻译</h2><p>有编号为1-N号的N个人，他们都记得“自己左边排队的人数和自己右边排队的人数之差的绝对值”，根据他们的报告，给你i的「自己的左排列的人数和自己的右排列的人数的差的绝对值」Ai。<br>请根据他们的报告，求出原来的排列方法有几种。但是，因为答案有时候会变得很大，请对10^9+7取模 。另外，他们的报告可能有错误，没有可能的排列方法，此时请输出0。</p><p>范围：<br>$$<br>1≦N≦10^5;<br>0≦Ai≦N−1.<br>$$</p><h2 id="题目描述-2">题目描述</h2><p>$ 1～N $ までの番号がついた、$ N $ 人の人がいます。 彼らは昨日、ある順番で左右一列に並んでいましたが、今日になってその並び方が分からなくなってしまいました。 しかし、彼らは全員、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」を覚えています。 彼らの報告によると、人 $ i $ の、「自分の左に並んでいた人数と自分の右に並んでいた人数の差の絶対値」は $ A_i $ です。</p><p>彼らの報告を元に、元の並び方が何通りあり得るかを求めてください。 ただし、答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを出力してください。 また、彼らの報告が間違っており、ありうる並び方がないこともありえます。 その際は $ 0 $ を出力してください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A_1 $ $ A_2 $ $ … $ $ A_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>元の並び順としてありうるものが何通りあるか求め、$ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 4 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">6 4 0 2 4 0 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">7 5 1 1 7 3 5 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ 0≦A_i≦N-1 $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ありうる並び方は、人の番号で書くと、 - $ 2,1,4,5,3 $ - $ 2,5,4,1,3 $ - $ 3,1,4,5,2 $ - $ 3,5,4,1,2 $ の $ 4 $ 通りです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>どのような並び方でも、報告と矛盾するので、$ 0 $ が答えになります。</p></blockquote><h2 id="思路-2">思路</h2><p>当初WA了好多发，不是忘记取模，就是WA了一个点qwq。</p><p>思路不难想，不过要注意分奇偶讨论。</p><p>注意到分布的值$A_i$应该具有对称性，所以对于每一个$A_i$值，它可能的个数就只能是0或2（除了为奇数情况时，0值只有一个，其他情况没有0值）。</p><p>所以我们只需要分奇偶讨论，然后判断即可。</p><p>注意到范围很大，所以可以用快速幂优化一下（我也不知道没有快速幂会不会喜提$TLE$）。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num&gt;b.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i].num;</span><br><span class="line">        b[a[i].num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[<span class="number">0</span>]!=<span class="number">1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b[i]!=<span class="number">2</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="built_in">qpower</span>(<span class="number">2</span>,n/<span class="number">2</span>);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC050D-Xor-Sum">[ABC050D] Xor Sum</h1><h2 id="题面翻译-3">题面翻译</h2><h2 id="题目描述-3">题目描述</h2><p>给出正整数$N$.</p><p>求出整数对$u$和$v$ $(0≤u,v≤N)$的数目，使得存在两个非负整数$a$和$b$满足$a\ xor\  b = u$和$a\ +\ b= v$。这里，$xor$表示按位异或。 要求对答案取模$10^9 + 7$。</p><h2 id="输入输出格式">输入输出格式</h2><h3 id="输入格式-3">输入格式</h3><p>一个正整数$N$</p><h3 id="输出格式-3">输出格式</h3><p>满足条件的$u,v$的个数，对$10^9+7$取模</p><h2 id="数据范围：">数据范围：</h2><p>$N&lt;=10^{18}$</p><h2 id="题目描述-4">题目描述</h2><p>正の整数 $ N $ が与えられます。 $ 2 $ つの整数 $ u,v(0≦u,v≦N) $ であって、ある非負整数 $ a,b $ が存在して、$ a $ $ xor $ $ b=u $、$ a+b=v $ となるようなものが何通りあるかを求めてください。 ここで、$ xor $ はビットごとの排他的論理和を表します。 なお、答えは非常に大きくなることがあるので、$ 10^9+7 $ で割った余りを求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>ありうる $ 2 $ 数の組が何通りあるかを求め、$ 10^9+7 $ で割った余りを出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1422</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">52277</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000000000000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">787014179</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦10^{18} $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ u,v $ としてありうるものは、以下の $ 5 $ 通りです。 - $ u=0,v=0 $（ $ a=0,b=0 $ とすると、$ 0 $ $ xor $ $ 0=0 $、$ 0+0=0 $ となります。） - $ u=0,v=2 $（ $ a=1,b=1 $ とすると、$ 1 $ $ xor $ $ 1=0 $、$ 1+1=2 $ となります。） - $ u=1,v=1 $（ $ a=1,b=0 $ とすると、$ 1 $ $ xor $ $ 0=1 $、$ 1+0=1 $ となります。） - $ u=2,v=2 $（ $ a=2,b=0 $ とすると、$ 2 $ $ xor $ $ 0=2 $、$ 2+0=2 $ となります。） - $ u=3,v=3 $（ $ a=3,b=0 $ とすると、$ 3 $ $ xor $ $ 0=3 $、$ 3+0=3 $ となります。）</p></blockquote><h2 id="思路-3">思路</h2><p>[题解 <a href="https://www.luogu.com.cn/article/s9kikzf6">ARC066] B - 洛谷专栏 (luogu.com.cn)</a></p><p>暂时先不写思路了，帮舍友配博客去了。可以先看看上面的文章，大佬讲得很好。</p><hr><p>补思路</p><p>一开始的想法是$v$可能与$u$相同，或者比$u$多出一位（这里是二进制位），所以肯定比$u$多出$2^{n+1}$（假设$u$原来有$n$位），然后想办法枚举，发现好像不行？也许以后尝试实现一下</p><p>下面的思路是大佬的：</p><blockquote><p>考虑<br>$$<br>a+b=((a\ and\ b)&lt;&lt;1)+(a\ xor\ b)<br>$$<br>$</p><p>这个式子的意义在于，后半部分是因为异或运算是二进制下不进位的加法，前半部分则是在描述二进制下的进位。反正无论怎么样，我们可以轻松得到$a+b\geq a\ xor b$这样的结论。</p><p>那么如果由于$u&lt;v$，所以如果$v$不越界那么$u$一定不越界。于是考虑按$v$进行$dp$。具体的，考虑状态$f_{i,j}$表示考虑了$a$和$b$二进制下的前$i$位，当前$v=a+b=j$的方案数。</p><p>考虑如何转移。对于$a$和$b$而言，第$i$位有三种情况，$(0,0),(0,1),(1,1)$。那么也就是假设原来的和为$j’$，和当前的和$j$可能有以下关系：</p><p>1、$2*(j’+1)=j$对应着都补一位1。</p><p>2、$2*j’=j$对应着都补一位0 。</p><p>3、$j’+(j’+1)=j$对应着一个补1一个补0 。</p><p>那么也就是<br>$$<br>f_{i,j}=f_{i-1,\lfloor \frac{j}{2}\rfloor}+f_{i-1,\lfloor \frac{(j-1)}{2}\rfloor}+f_{i-1,\lfloor{\frac{(j-2)}{2}\rfloor}}<br>$$</p><p>考虑把第一维压掉之后，就是另一篇题解的那种做法了。</p><p>（下面的代码就是优化的）</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//注意范围为10^18，所以用map</span></span><br><span class="line">map&lt;ll,ll&gt; m;</span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll n)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m[x])<span class="keyword">return</span> m[x];</span><br><span class="line">    <span class="keyword">return</span> m[x]=(<span class="built_in">solve</span>(x/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-1</span>)/<span class="number">2</span>)+<span class="built_in">solve</span>((x<span class="number">-2</span>)/<span class="number">2</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    m[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    m[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    ll ans=<span class="built_in">solve</span>(n);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC049</title>
      <link href="/posts/1e101aff.html"/>
      <url>/posts/1e101aff.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC049">ABC049</h1><blockquote><h1 id="ABC049C-白昼夢">[ABC049C] 白昼夢</h1><h2 id="题面翻译">题面翻译</h2><h1 id="题目大意">题目大意</h1><p>输入一个以英文小写字母组成的字符串S，规定一个空的字符串T，现在你可对字符串T进行你喜欢的操作，问是否能让字符串T变为字符串S？</p><p><strong>喜欢的操作如下 ：</strong></p><p>在字符串T的末尾加入<br>“dream”或“dreamer”或“erase”或“eraser”。</p><hr><h2 id="输入格式">输入格式</h2><p>一个字符串S</p><h2 id="输出格式">输出格式</h2><p>若可以输出<strong>YES</strong>,否则输出<strong>NO</strong>。</p><h2 id="题目描述">题目描述</h2><p>英小文字からなる文字列 $ S $ が与えられます。 $ T $が空文字列である状態から始め、以下の操作を好きな回数繰り返すことで $ S\ =\ T $ とすることができるか判定してください。</p><ul><li>$ T $ の末尾に <code>dream</code> <code>dreamer</code> <code>erase</code> <code>eraser</code> のいずれかを追加する。</li></ul><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ S\ =\ T $ とすることができる場合 <code>YES</code> を、そうでない場合 <code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erasedream</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreameraser</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dreamerer</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦|S|≦10^5 $</li><li>$ S $ は英小文字からなる。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p><code>erase</code> <code>dream</code> の順で $ T $ の末尾に追加することで $ S\ =\ T $ とすることができます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p><code>dream</code> <code>eraser</code> の順で $ T $ の末尾に追加することで $ S\ =\ T $ とすることができます。</p></blockquote><h2 id="思路">思路</h2><p>其实是一道模拟题（doge），只要判断读到$d$或$e$时，判断是不是$dream、dreamer、erase、eraser$中的一个即可，注意$dreamer$与$erase、eraser$会首尾重叠，所以还需进一步分类。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">char</span> a[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//读到e，判断是不是eraser或erase</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;s&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i+<span class="number">5</span>]==<span class="string">&#x27;r&#x27;</span>)&#123;</span><br><span class="line">                    i+=<span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i+=<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读到d，判断是不是dream、dreamer、dreamerase、dreameraser即可</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;d&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i+<span class="number">1</span>]==<span class="string">&#x27;r&#x27;</span>&amp;&amp;s[i+<span class="number">2</span>]==<span class="string">&#x27;e&#x27;</span>&amp;&amp;s[i+<span class="number">3</span>]==<span class="string">&#x27;a&#x27;</span>&amp;&amp;s[i+<span class="number">4</span>]==<span class="string">&#x27;m&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span> &amp;&amp; s[i + <span class="number">7</span>] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i + <span class="number">8</span>] == <span class="string">&#x27;s&#x27;</span> &amp;&amp; s[i + <span class="number">9</span>] == <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">                    i += <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[i + <span class="number">5</span>] == <span class="string">&#x27;e&#x27;</span> &amp;&amp; s[i + <span class="number">6</span>] == <span class="string">&#x27;r&#x27;</span>) &#123;</span><br><span class="line">                        i += <span class="number">6</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        i += <span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC049D-連結">[ABC049D] 連結</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>有$N$个城市，$K$条道路（指地面上的道路）和$L$条地铁。道路和地铁都是无向的。对于每个点，请你求出它只通过道路<strong>和</strong>只通过地铁都能到达的点的个数。道路和地铁之间不能换乘，你只能<strong>完全</strong>通过地铁到达某个点，或者<strong>完全</strong>通过道路到达某个点。</p><h2 id="输入格式-3">输入格式</h2><p>第一行三个正整数$N,K,L$<br>($N\le2\times 10^5,K,L\le10^5$)<br>然后$K$行，每行两个数$p,q$，表示城市$p$和城市$q$通过道路连接。<br>然后$L$行，每行两个数$r,s$，表示城市$r$和城市$s$通过地铁连接。</p><h2 id="输出格式-3">输出格式</h2><p>一行$N$个正整数，表示每个点只通过道路和只通过地铁都能到达的点的个数。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の都市があり、$ K $ 本の道路と $ L $ 本の鉄道が都市の間に伸びています。 $ i $ 番目の道路は $ p_i $ 番目と $ q_i $ 番目の都市を双方向に結び、 $ i $ 番目の鉄道は $ r_i $ 番目と $ s_i $ 番目の都市を双方向に結びます。 異なる道路が同じ $ 2 $ つの都市を結ぶことはありません。同様に、異なる鉄道が同じ $ 2 $ つの都市を結ぶことはありません。</p><p>ある都市から別の都市に何本かの道路を通って到達できるとき、それらの都市は道路で連結しているとします。また、すべての都市はそれ自身と道路で連結しているとみなします。<br>鉄道についても同様に定めます。</p><p>全ての都市について、その都市と道路・鉄道のどちらでも連結している都市の数を求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ L $ $ p_1 $ $ q_1 $ : $ p_K $ $ q_K $ $ r_1 $ $ s_1 $ : $ r_L $ $ s_L $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>$ N $ 個の整数を出力せよ。$ i $ 番目の数は $ i $ 番目の都市と道路・鉄道の両方で連結している都市の数である。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 4</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 4 4</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 5</span><br><span class="line">6 7</span><br><span class="line">3 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2 2 2</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 2\ ≦\ N\ ≦\ 2*10^5 $</li><li>$ 1\ ≦\ K,\ L≦\ 10^5 $</li><li>$ 1\ ≦\ p_i,\ q_i,\ r_i,\ s_i\ ≦\ N $</li><li>$ p_i\ &lt;\ q_i $</li><li>$ r_i\ &lt;\ s_i $</li><li>$ i\ ≠\ j $ のとき、$ (p_i,\ q_i)\ ≠\ (p_j,\ q_j) $</li><li>$ i\ ≠\ j $ のとき、$ (r_i,\ s_i)\ ≠\ (r_j,\ s_j) $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 1,\ 2,\ 3,\ 4 $ 番目の都市は全て互いに道路で連結しています。 鉄道で連結している都市は $ 2,\ 3 $ のみなので、答えは順に $ 1,\ 2,\ 2,\ 1 $ となります。</p></blockquote><h2 id="思路-2">思路</h2><p>并查集+map，具体也不知道怎么解释，太累了，不想写了qwq</p><p>直接看题解吧：<a href="https://www.luogu.com.cn/article/j3jx0o1z">题解 AT2159 【連結 / Connectivity】 - 洛谷专栏 (luogu.com.cn)</a></p><hr><p>补思路补思路~~~</p><p>可以发现这是一个连通性问题，<s>所以我们不难想到用并查集</s>。</p><p>但是答案求的是这两个图的交集的元素个数，所以我们可以开一个数组$Fa[i][j]$，表示有多少个点满足在$fa1$中的祖先是$i$，有多少个点在$fa2$中的祖先是$j$。那么，对于一个点$u$，它走两条线路都能到的点数量就是<code>Fa[fa1.find(i)][fa2.find(i)]</code>（其中$find$是查找祖先的函数）。记录这个数组的方法也很简单，就是对于每个点，<code>Fa[fa1.find(i)][fa2.find(i)]++</code>。</p><p>但是这样会喜提$MLE$，所以我们可以拿出神器：$map+pair$</p><p>用$map&lt;pair&lt;int,int&gt;,int&gt;$就可以省下很多空间，而我们其实只需要遍历这$n$个点即可，所以绰绰有余，我们只需要遍历每个点时加一即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> fa1[MAXN],fa2[MAXN];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="comment">//思路：并查集+stl</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x]=<span class="built_in">find</span>(fa[x],fa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> *fa)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x,fa),fy=<span class="built_in">find</span>(y,fa);</span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">        fa[fx]=fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,k,l;cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa1[i]=i,fa2[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123;</span><br><span class="line">        ll x,y;cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">join</span>(x,y,fa2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;m[<span class="built_in">make_pair</span>(<span class="built_in">find</span>(i,fa1),<span class="built_in">find</span>(i,fa2))]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC048</title>
      <link href="/posts/69172a69.html"/>
      <url>/posts/69172a69.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC048">ABC048</h1><blockquote><h1 id="ABC048A-AtCoder-Contest">[ABC048A] AtCoder *** Contest</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个字符串，求这三个字符串的首字母并输出。</p><p>翻译提供者：一条小鱼</p><h2 id="题目描述">题目描述</h2><p>すぬけ君は、AtCoder $ s $ Contest という名前のコンテストを開こうとしています。 ここで、$ s $ は長さ $ 1 $ 以上の文字列であり、$ 1 $ 文字目は英大文字、$ 2 $ 文字目以降は英小文字です。</p><p>すぬけ君は、このコンテストの略称を A$ x $C に決めました。 ここで、$ x $ は $ s $ の先頭の英大文字です。</p><p>コンテストの名前が与えられるので、コンテストの略称を出力してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>AtCoder $ s $ Contest</p></blockquote><h2 id="输出格式">输出格式</h2><p>コンテストの略称を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Beginner Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ABC</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder Snuke Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASC</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AtCoder X Contest</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AXC</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ s $ の長さは $ 1 $ 以上 $ 100 $ 以下である。</li><li>$ s $ の $ 1 $ 文字目は英大文字である。</li><li>$ s $ の $ 2 $ 文字目以降は英小文字である。</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>今あなたが参加しているコンテストです。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>このコンテストは存在しません。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s1,s2,s;cin&gt;&gt;s1&gt;&gt;s&gt;&gt;s2;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span>&lt;=s[<span class="number">0</span>]&amp;&amp;s[<span class="number">0</span>]&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">        s[<span class="number">0</span>]=s[<span class="number">0</span>]<span class="number">-32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;s[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;C&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048B-Between-a-and-b-…">[ABC048B] Between a and b …</h1><h2 id="题面翻译-2">题面翻译</h2><h2 id="题目描述-2">题目描述</h2><p>给出两个非负整数a，b（a≤b）和一个正整数x。请在 a 以上 b 以下（包含a，b）的整数中， 找出可被 x 整除的数数量。</p><h2 id="输入输出格式">输入输出格式</h2><h4 id="输入格式：">输入格式：</h4><p>三个数，a b x</p><h4 id="输出格式：">输出格式：</h4><p>一行，一个整数，在 a 以上 b 以下（包含a，b）的整数中可被 x 整除的数数量。</p><h2 id="输入输出样例">输入输出样例</h2><ol><li>输入样例#1:<br>4 8 2<br>输出样例#1:<br>3</li><li>输入样例#2:<br>0 5 1<br>输出样例#2:<br>6</li><li>输入样例#3:<br>9 9 2<br>输出样例#3:<br>(无)</li><li>输入样例#4:<br>1 1000000000000000000 3<br>输出样例#4:<br>333333333333333333</li></ol><h3 id="数据范围：">数据范围：</h3><p>0 ≤ a ≤ b ≤ 10^18<br>1 ≤ x ≤ 10^18</p><h4 id="样例说明1">样例说明1:</h4><p>4 6 8 可以</p><h4 id="样例说明2">样例说明2:</h4><p>0 1 2 3 4 5 可以</p><h4 id="样例说明3">样例说明3:</h4><p>没有能被2整除的</p><h4 id="样例说明4">样例说明4:</h4><p>请注意溢出</p><p>感谢@2x6_81和 @曾熠辰 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>非負の整数 $ a $, $ b $ ($ a\ &lt;\ =\ b $) と、正の整数 $ x $ が与えられます。 $ a $ 以上 $ b $ 以下の整数のうち、$ x $ で割り切れるものの個数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ x $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>$ a $ 以上 $ b $ 以下の整数のうち、$ x $ で割り切れるものの個数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9 9 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1000000000000000000 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">333333333333333333</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 0\ &lt;\ =\ a\ &lt;\ =\ b\ &lt;\ =\ 10^{18} $</li><li>$ 1\ &lt;\ =\ x\ &lt;\ =\ 10^{18} $</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>$ 4 $ 以上 $ 8 $ 以下の整数のうち $ 2 $ で割り切れるものは、$ 4 $, $ 6 $, $ 8 $ です。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>$ 0 $ 以上 $ 5 $ 以下の整数のうち $ 1 $ で割り切れるものは、$ 0 $, $ 1 $, $ 2 $, $ 3 $, $ 4 $, $ 5 $ です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>$ 9 $ 以上 $ 9 $ 以下の整数のうち $ 2 $ で割り切れるものはありません。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>オーバーフローに注意してください。</p></blockquote><h2 id="思路-2">思路</h2><p>数据范围很大，所以肯定不能暴力枚举。</p><p>我们只需要找到最小的大于$a$的数，同时也是$x$的倍数，最大的小于$b$的数，同时也是$x$的倍数。</p><p>然后简单算一下即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll a,b,x;cin&gt;&gt;a&gt;&gt;b&gt;&gt;x;</span><br><span class="line">    ll ans1=(a/x+(a%x==<span class="number">0</span>?<span class="number">0</span>:<span class="number">1</span>))*x;</span><br><span class="line">    ll ans2=(b/x)*x;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    ans=(ans2-ans1)/x;</span><br><span class="line">    cout&lt;&lt;ans+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048C-Boxes-and-Candies">[ABC048C] Boxes and Candies</h1><h2 id="题面翻译-3">题面翻译</h2><p>$N$个箱子横排成一列，左边第$i$个箱子里装着$a_i$个糖果。</p><p>Snuke可以多次执行以下操作：</p><p>选一个里面不少于$1$个糖果的箱子，从那个箱子里吃一个糖果。</p><p>他的目标：</p><p>任何$2$个相邻的箱子都不多于$x$个糖果。</p><p>请确定实现他的目标所需的最小操作次数。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 個の箱が横一列に並んでいます。 最初、左から $ i $ 番目の箱には $ a_i $ 個のキャンディが入っています。</p><p>すぬけ君は次の操作を好きな回数だけ行うことができます。</p><ul><li>キャンディが $ 1 $ 個以上入っている箱をひとつ選び、その箱のキャンディを $ 1 $ 個食べる。</li></ul><p>すぬけ君の目標は次の通りです。</p><ul><li>どの隣り合う $ 2 $ つの箱を見ても、それらの箱に入っているキャンディの個数の総和が $ x $ 以下である。</li></ul><p>目標を達成するために必要な操作回数の最小値を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ x $ $ a_1 $ $ a_2 $ $ … $ $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>目標を達成するために必要な操作回数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 1</span><br><span class="line">1 6 1 2 0 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 9</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 0</span><br><span class="line">5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 2\ &lt;\ =\ N\ &lt;\ =\ 10^5 $</li><li>$ 0\ &lt;\ =\ a_i\ &lt;\ =\ 10^9 $</li><li>$ 0\ &lt;\ =\ x\ &lt;\ =\ 10^9 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>$ 2 $ 番目の箱のキャンディを $ 1 $ 個食べればよいです。 すると、各箱のキャンディの個数は $ (2,\ 1,\ 2) $ となります。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>たとえば、$ 2 $ 番目の箱のキャンディを $ 6 $ 個食べ、$ 4 $ 番目の箱のキャンディを $ 2 $ 個食べ、$ 6 $ 番目の箱のキャンディを $ 3 $ 個食べればよいです。 すると、各箱キャンディの個数は $ (1,\ 0,\ 1,\ 0,\ 0,\ 1) $ となります。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>最初から目標が達成されているので、操作を行う必要はありません。</p><h3 id="Sample-Explanation-4-2">Sample Explanation 4</h3><p>すべてのキャンディを食べなければなりません。</p></blockquote><h2 id="思路-3">思路</h2><p>贪心题，和前一个盒子进行判断是否大于$x$，简单的模拟即可，注意一下当前盒子数目情况的判断。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,x;cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]+a[i]&gt;x)&#123;</span><br><span class="line">            ans+=(a[i<span class="number">-1</span>]+a[i]-x);</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;=a[i<span class="number">-1</span>]+a[i]-x)&#123;</span><br><span class="line">                a[i]-=a[i<span class="number">-1</span>]+a[i]-x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC048D-An-Ordinary-Game">[ABC048D] An Ordinary Game</h1><h2 id="题面翻译-4">题面翻译</h2><p>给定一个长度大于等于3的字符串$S$,$S$中没有相邻的两个字符相等。</p><p><strong>玩法</strong>:</p><p>玩家$1$和玩家$2$交替进行操作——从$S$中删除一个字符,但删除后$S$不能有相邻的两个字符相等,否则另一位玩家获胜(两人都很聪明)</p><p>现在玩家$1$先操作,请问谁可以获得胜利?</p><p>输入一个字符串$S$</p><p>若玩家$1$胜利,输出<code>first</code>;玩家$2$获胜,输出<code>Second</code></p><h2 id="题目描述-5">题目描述</h2><p>長さ $ 3 $ 以上の文字列 $ s $ があります。 $ s $ の中に同一の文字が隣り合う箇所はありません。</p><p>高橋君と青木君がゲームで勝負します。 二人は交互に次の操作を行います。 高橋君が先手です。</p><ul><li>$ s $ から両端以外の文字をひとつ取り除く。 ただし、その文字を取り除くことで、$ s $ の中に同一の文字が隣り合う箇所ができる場合、その文字を取り除くことはできない。</li></ul><p>先に操作を行えなくなった人が負けです。 二人が最適に行動したとき、どちらが勝つかを判定してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>先手の高橋君が勝つならば <code>First</code> を、後手の青木君が勝つならば <code>Second</code> を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Second</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcab</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">First</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 3\ &lt;\ =\ |s|\ &lt;\ =\ 10^5 $</li><li>$ s $ は英小文字のみからなる。</li><li>$ s $ の中に同一の文字が隣り合う箇所はない。</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>先手の高橋君は操作を行うことができません。 なぜならば、$ s $ から両端以外の文字の <code>b</code> を取り除くと、$ s $ は <code>aa</code> となって <code>a</code> が隣り合うからです。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>先手の高橋君が $ s $ から <code>b</code> を取り除くと、$ s $ は <code>ac</code> となります。 すると、後手の青木君は操作を行うことができません。 なぜならば、$ s $ には両端以外の文字が存在しないからです。</p></blockquote><h2 id="思路-4">思路</h2><p>应该是博弈论。</p><p>推导过程看这里：[题解 AT2153 【<a href="https://www.luogu.com.cn/article/lwt0riem">ARC064B] An Ordinary Game】 - 洛谷专栏 (luogu.com.cn)</a></p><p>我就直接贴代码了qwq</p><hr><p>好的，我来补思路了uwu</p><p>其实从样例中可以比较明显地发现，结果与字符串的长度、首尾是否相同有关。</p><p>引用$DPair$大佬思路：</p><blockquote><p>首先我们发现一个及其显然的结论：删除到无法删除时，字符串情况只可能是这样的：</p><p>$$ababababa···ababab$$</p><p>即字符串中出现且只出现<strong>两种不同</strong>的字符，并<strong>交替出现</strong>（或只剩两个，但也可以看作这种情况）。</p><p>字符不可能只有一个，否则就违背题意了，而且由于首尾不能被删除，因此最后至少剩下两个字符，即不可能出现只有一个字符的情况。</p><p>排除这种可能性后，只出现两种不同字符的原因在于，由于相邻字符保证不同，且我要保证我现在的状态是一个死局，那么字符串$s$中$s_{i-1}=s_{i+1}$，即所有奇数下标位置的字符相同，所有偶数下标位置的字符相同，且这两种字符不同。故只有两种字符，且<strong>奇偶交替出现</strong>。</p><p>然后我们发现，若字符串长度为奇数，则首尾下标都为奇数，故要使该状态成为死局必须保证<strong>首尾相同</strong>，反之，即<strong>首尾不同</strong>，则绝对安全，不可能死局，也就是必胜，那么对手也就必败（这一步好像是博弈论的一个<strong>经典思考环节</strong>）。所以当<strong>字符串长度为偶数且首尾不同</strong>时，我的下一步操作一定会使对手进入必胜态，那么我就必败（因为本游戏没有平局）。</p><p><strong>首尾相同</strong>的情况也类似，只不过此时字符串长度为偶数时是安全的必胜态，奇数才为必败态。</p><p>因此当<strong>首尾相同且长度偶数</strong>或<strong>首尾不同且长度奇数</strong>时，先手必胜，反之后手必胜。</p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//ababababa</span></span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==s[len<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;First&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Second&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC047</title>
      <link href="/posts/f9a837f8.html"/>
      <url>/posts/f9a837f8.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC047">ABC047</h1><blockquote><h1 id="ABC047A-キャンディーと2人の子供">[ABC047A] キャンディーと2人の子供</h1><h2 id="题面翻译">题面翻译</h2><p>输入三个数，如果存在其中两个数的和等于第三个数，输出Yes，不存在，输出No，强调一下，岛国的题最后输出要记得换行，否则听取WA声一片</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園に通う $ 2 $ 人の子供がキャンディーの取り合いをしています。</p><p>$ 3 $ 個のキャンディーパックがあり、それぞれのパックにはキャンディーが $ a $, $ b $, $ c $ 個入っています。</p><p>えび先生はこの $ 3 $ 個のパックを、キャンディーの個数が等しくなるように $ 2 $ 人に分けようとしています。そのような分け方が可能かどうかを判定してください。</p><p>ただし、キャンディーをパックから取り出すことはできず、それぞれのパックをそのままどちらかの子供にあげる必要があります。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>キャンディーを同じ個数に分けられるなら <code>Yes</code> を、そうでなければ <code>No</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 30 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 30 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">56 25 31</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ ≦\ a,\ b,\ c\ ≦\ 100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>ひとりめの子供に $ 30 $ 個のキャンディーの入ったパックを、もう一方の子供に $ 10 $ 個と $ 20 $ 個のキャンディーの入ったパックをあげると、$ 2 $ 人のもらうキャンディーの個数を等しくすることができます。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>この場合、$ 100 $ 個のキャンディーの入ったパックを貰った子供は必ずもう一方の子供より多くのキャンディーを貰うことになってしまいます。 $ 3 $ つすべてのパックをどちらかの子供にあげるように分けなければならないことに注意してください。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">if</span>(a+b==c||a+c==b||b+c==a)cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC047B-すぬけ君の塗り絵-2-イージー">[ABC047B] すぬけ君の塗り絵 2 イージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>平面上有一个左下角坐标$(0,0)$，右上角坐标$(W,H)$ 的矩形，起初长方形内部被涂白。</p><p>现在给出$N$个操作，每个操作都给定一个点$(x_i,y_i)$和一个参数$a_i$，代表：</p><ul><li>$a_i=1$时，$x&lt;x_i$的区域将被涂黑</li><li>$a_i=2$时，$x&gt;x_i$的区域将被涂黑</li><li>$a_i=3$时，$y&lt;y_i$的区域将被涂黑</li><li>$a_i=4$时，$y&gt;y_i$的区域将被涂黑</li></ul><p>现在问当所有操作均结束后剩下的白色区域的面积</p><h2 id="题目描述-2">题目描述</h2><p>$ xy $ 平面上に、左下の座標が $ (0,\ 0) $、右上の座標が $ (W,\ H) $ で、各辺が $ x $ 軸か $ y $ 軸に平行な長方形があります。最初、長方形の内部は白く塗られています。</p><p>すぬけ君はこの長方形の中に $ N $ 個の点を打ちました。$ i $ 個目 ($ 1\ ≦\ i\ ≦\ N $) 点の座標は $ (x_i,\ y_i) $ でした。</p><p>また、すぬけ君は長さ $ N $ の数列 $ a $ を決めて、各 $ 1\ ≦\ i\ ≦\ N $ に対し、</p><ul><li>$ a_i\ =\ 1 $ のときは長方形の $ x\ &lt;\ x_i $ をみたす領域</li><li>$ a_i\ =\ 2 $ のときは長方形の $ x\ &gt;\ x_i $ をみたす領域</li><li>$ a_i\ =\ 3 $ のときは長方形の $ y\ &lt;\ y_i $ をみたす領域</li><li>$ a_i\ =\ 4 $ のときは長方形の $ y\ &gt;\ y_i $ をみたす領域</li></ul><p>を黒く塗りました。</p><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ W $ $ H $ $ N $ $ x_1 $ $ y_1 $ $ a_1 $ $ x_2 $ $ y_2 $ $ a_2 $ $ : $ $ x_N $ $ y_N $ $ a_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>塗りつぶしが終わったあとの長方形内での白い部分の面積を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 2</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 3</span><br><span class="line">2 1 1</span><br><span class="line">3 3 4</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 5</span><br><span class="line">1 6 1</span><br><span class="line">4 1 3</span><br><span class="line">6 9 4</span><br><span class="line">9 4 2</span><br><span class="line">3 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">64</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ W,\ H\ ≦\ 100 $</li><li>$ 1\ ≦\ N\ ≦\ 100 $</li><li>$ 0\ ≦\ x_i\ ≦\ W $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ 0\ ≦\ y_i\ ≦\ H $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ W $, $ H $ (21:32 追記), $ x_i $, $ y_i $ は整数である</li><li>$ a_i $ ($ 1\ ≦\ i\ ≦\ N $) は $ 1,\ 2,\ 3,\ 4 $ のいずれかである</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>すぬけ君が塗りつぶしを始める前の長方形は以下の図のようになっています。 ![e19e673abcd0882783f635cce9d2f94d.png](<a href="https://atcoder.jp/img/abc047/e19e673abcd0882783f635cce9d2f94d.png">https://atcoder.jp/img/abc047/e19e673abcd0882783f635cce9d2f94d.png</a>) $ (x_1,\ y_1)\ =\ (2,\ 1) $、$ a_1\ =\ 1 $ なので、まずすぬけ君は $ x $ 座標が $ 2 $ より小さい領域を塗りつぶし、長方形は以下のようになります。 ![f25cd04bbac23c4e5426d70511a9762f.png](<a href="https://atcoder.jp/img/abc047/f25cd04bbac23c4e5426d70511a9762f.png">https://atcoder.jp/img/abc047/f25cd04bbac23c4e5426d70511a9762f.png</a>) $ (x_2,\ y_2)\ =\ (3,\ 3) $、$ a_2\ =\ 4 $ なので、次にすぬけ君は $ y $ 座標が $ 3 $ より大きい領域を塗りつぶし、長方形は最終的に以下のようになります。 ![46b0c06fd9eee4f148e1f441f7abca53.png](<a href="https://atcoder.jp/img/abc047/46b0c06fd9eee4f148e1f441f7abca53.png">https://atcoder.jp/img/abc047/46b0c06fd9eee4f148e1f441f7abca53.png</a>) この最終的な状態における白い部分の面積は $ 9 $ なので、出力は $ 9 $ となります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>塗りつぶした結果、白い部分が残らないこともありえます。</p></blockquote><h2 id="思路-2">思路</h2><p>其实直接暴力就可以，但是我们想想优化方法</p><p>以$a=1$为例，可以发现：对结果有影响的只有当$a=1$时，所有$x$的可能取值中最大的，其他的只是重复填涂而已，对结果没影响。同理可得$a=2,a=3,a=4$的情况。</p><p>注意可能是否不存在的情况</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> w,h,n;cin&gt;&gt;w&gt;&gt;h&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">0</span>,a2=w,a3=<span class="number">0</span>,a4=h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,a;cin&gt;&gt;x&gt;&gt;y&gt;&gt;a;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">            a1=<span class="built_in">max</span>(a1,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">            a2=<span class="built_in">min</span>(a2,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">3</span>)&#123;</span><br><span class="line">            a3=<span class="built_in">max</span>(a3,y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">4</span>)&#123;</span><br><span class="line">            a4=<span class="built_in">min</span>(a4,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果右边界小于左边界，或者上边界小于下边界</span></span><br><span class="line">    <span class="keyword">if</span>(a4&lt;a3||a2&lt;a1)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;(a2-a1)*(a4-a3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC047C-一次元リバーシ">[ABC047C] 一次元リバーシ</h1><h2 id="题面翻译-3">题面翻译</h2><p>输入一个长度不多于$10^5$的字符串，只包含B或W。若前后两个字符不一样，答案累加，输出答案。</p><p>感谢@da32s1da 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>きつねの次郎と三郎が一次元リバーシで遊んでいます。一次元リバーシでは、盤面には白か黒の石が一列に並んだ状態となっており、列の右端か左端に新たに石を打っていきます。通常のリバーシと同じように、たとえば白の石を打つことで黒の石を挟むと、挟まれた黒の石は白い石に変わります。</p><p>ゲームの途中で三郎に急用ができて帰ってしまうことになりました。このとき、盤面の状態は文字列 $ S $ で表されます。石は $ |S| $ (文字列の長さ) 個並んでおり、左から $ i $ ($ 1\ ≦\ i\ ≦\ |S| $) 個目の石の色は、$ S $ の $ i $ 文字目が <code>B</code> のとき黒、<code>W</code> のとき白です。</p><p>次郎は現在の盤面に対して、できるだけ少ない個数の石を新たに打つことで全ての石を同じ色にしようと考えました。最小で何個の石を打てばよいかを求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>全ての石を同じ色にするために打つ必要のある石の個数の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BBBWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WWWWWW</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3-3">样例 #3</h2><h3 id="样例输入-3-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WBWBWBWBWB</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ |S|\ ≦\ 10^5 $</li><li>$ S $ に含まれる文字は <code>B</code> または <code>W</code> のいずれかである</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>たとえば右端に黒い石を打つとすべての白い石を黒い石にすることができます。他にも、左端に白い石を打つことでもすべての石の色を同じにできます。 いずれの場合も $ 1 $ 個の石ですべての石を同じ色にすることができるので、$ 1 $ を出力します。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>最初から全ての石が同じ色の場合、新たに石を打つ必要はありません。</p></blockquote><h2 id="思路-3">思路</h2><p>开个$flag$记录一下即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> m[<span class="number">110</span>][<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="type">char</span> flag=s[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag!=s[i])&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>])&#123;</span><br><span class="line">            flag=s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>发现自己$SB$了，直接统计有多少个相邻的字符不同即可</p><blockquote><h1 id="ABC047D-高橋君と見えざる手">[ABC047D] 高橋君と見えざる手</h1><h2 id="题面翻译-4">题面翻译</h2><h1 id="高桥君和不可见之手">高桥君和不可见之手</h1><h2 id="问题描述">问题描述</h2><p>有 $N$ 个小镇排在一条直线上。旅行商人高桥君从小镇 $1$ 出发，一边买卖苹果一边朝小镇 $N$ 前行。</p><p>开始时高桥君处在小镇 $1$ ，身上一个苹果也没有。高桥君不断进行以下行动。</p><ul><li>移动：从小镇 $i(i &lt; N)$ 开始，移动到小镇 $i+1$ 。</li><li>买卖苹果：买进或卖出任意个苹果。在小镇 $i(1 \leq i \leq N)$ 买进或卖出苹果单价都为 $A_i$ 円。 $A_i$ 为相异的整数。</li></ul><p>在每个小镇进行交易的苹果数量没有限制，但是旅行中所买进和卖出的苹果总数(买进苹果数加上卖出苹果数)必须在 $T$ 以内。高桥君会使自己在旅程中所获利益(卖苹果所得钱数减去买苹果所花钱数)最大。</p><p>在高桥君进行旅行之前，青木君可以对于任意 $i$ ，使 $A_i$ 变为非负整数 $A_i’$ 。这个操作的代价为 $|A_i-A_i’|$ 。操作后即使出现相异小镇苹果单价相同的情况也没关系。</p><p>青木君的目的是：花费尽量少的代价，使高桥君所得的最大利益至少下降 $1$ 円。请求出最小代价。</p><p>数据保证初始状态下高桥君至少能获得 $1$ 円的利益。</p><h2 id="数据范围">数据范围</h2><ul><li>$1 \leq N \leq 10^5$</li><li>$1 \leq A_i \leq 10^9$</li><li>$A_i$ 相异</li><li>$2 \leq T \leq 10^9$</li><li>保证初始状态下高桥君至少能获得 $1$ 円的利益。</li></ul><h2 id="输入">输入</h2><p>输入按以下标准：<br>$$ N \space T $$<br>$$ A_1 \space A_2 \space \dots \space A_N $$</p><h2 id="输出">输出</h2><p>输出使高桥君最大收益至少下降 $1$ 円的最小代价和。</p><h2 id="样例1解释">样例1解释</h2><p>在初始状态下，高桥君能够进行以下的行动来获得最大收益( $150$ 円)：</p><ol><li>从小镇 $1$ 移动到小镇 $2$ 。</li><li>在小镇 $2$ 处花 $50$ 円买一个苹果。</li><li>从小镇 $2$ 移动到小镇 $3$ 。</li><li>在小镇 $3$ 处卖掉一个苹果获得 $200$ 円。</li></ol><p>举例来说，如果青木君把小镇 $2$ 的苹果单价从 $50$ 円上调至 $51$ 円，高桥君就无法获得 $150$ 円的收益。也就是说，此操作能够使高桥君的最大收益至少下降 $1$ 円，所以答案为 $1$ 。</p><p>另外，将小镇 $3$ 的苹果单价从 $200$ 円降至 $199$ 円也能够达到目的。</p><h2 id="题目描述-4">题目描述</h2><p>$ N $ 個の町が一直線上に並んでいます。行商人の高橋君は町 $ 1 $ から出発し、リンゴの売買をしながら町 $ N $ へと向かいます。</p><p>はじめ高橋君は町 $ 1 $ におり、リンゴを $ 1 $ つも持っていません。高橋君は次のいずれかの行動を繰り返し行います。</p><ul><li>移動: 町 $ i $ ($ i\ &lt;\ N $) にいるとき、町 $ i\ +\ 1 $ へ移動する。</li><li>リンゴの売買: リンゴを好きな個数だけ売買する。ここで、町 $ i $ ($ 1\ ≦\ i\ ≦\ N $) ではリンゴの買値も売値もともに $ A_i $ 円とする。ここで $ A_i $ は相異なる整数です。</li></ul><p>$ 1 $ つの町で売買するリンゴの個数に制限はありませんが、旅の中で売買するリンゴの個数は合計で (買う個数と売る個数を合わせて) $ T $ 個以下にしなくてはなりません。</p><p>高橋君は旅の利益、すなわちリンゴを売った代金から買った代金を引いた値を最大にするように旅をするとします。旅が終わったときに持っていたリンゴの価値は考えず、旅の中で売買した金額だけを考えます。</p><p>この旅に先立って、青木君は任意の町 $ i $ に対して $ A_i $ を好きな非負整数 $ A_i’ $ に変えるという操作を好きなだけ行うことができます。ただし、この操作は行うごとに $ |A_i\ -\ A_i’| $ のコストがかかります。操作後には異なる町の間でリンゴの値段が同じになっていても構いません。</p><p>青木君の目的はできるだけ少ない合計コストの操作で高橋君の利益を少なくとも $ 1 $ 円下げることです。合計コストの最小値を求めてください。</p><p>ただし、元の状態で高橋君が $ 1 $ 円以上の利益を上げられることは仮定して構いません。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T $ $ A_1 $ $ A_2 $ $ … $ $ A_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>高橋君の収益を少なくとも $ 1 $ 円下げるために必要な合計コストの最小値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">100 50 200</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 8</span><br><span class="line">50 30 40 10 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-3-4">样例 #3</h2><h3 id="样例输入-3-4">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 100</span><br><span class="line">7 10 4 5 9 3 6 8 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-4">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ ≦\ N\ ≦\ 10^5 $</li><li>$ 1\ ≦\ A_i\ ≦\ 10^9 $ ($ 1\ ≦\ i\ ≦\ N $)</li><li>$ A_i $ は相異なる</li><li>$ 2\ ≦\ T\ ≦\ 10^9 $</li><li>入力の状態では高橋君は $ 1 $ 円以上の利益を上げられることが保証される</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>この入力の状態では、高橋君は次のようにして最大の利益である $ 150 $ 円を達成することができます。 1. 町 $ 1 $ から町 $ 2 $ へ移動する。 2. 町 $ 2 $ で $ 50 $ 円を支払い、リンゴを $ 1 $ 個買う。 3. 町 $ 2 $ から町 $ 3 $ へ移動する。 4. 町 $ 3 $ で $ 200 $ 円でリンゴを $ 1 $ 個売る。 たとえば、青木君が町 $ 2 $ のリンゴの値段を $ 50 $ 円から $ 51 $ 円に変えると、高橋君はどのようにしても $ 150 $ 円の利益を上げることができなくなります。すなわち、コスト $ 1 $ で高橋君の利益を少なくとも $ 1 $ 円下げることが可能であり、答えは $ 1 $ となります。 他にも、町 $ 3 $ のリンゴの値段を $ 200 $ 円から $ 199 $ 円に変えることでもコスト $ 1 $ で高橋君の利益を下げることが可能です。</p></blockquote><h2 id="思路-4">思路</h2><p>高木的理想情况就是最高售价-最低买价（记作$MAX$），那么我们只需要找到所有的满足情况即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    ll n,t;cin&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    ll MAX=LONG_LONG_MIN,MIN=LONG_LONG_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll a;cin&gt;&gt;a;</span><br><span class="line">        <span class="comment">//b记录的是该方案对应的利润</span></span><br><span class="line">        b[i]=a-MIN;</span><br><span class="line">        <span class="comment">//MIN：最低购入价格</span></span><br><span class="line">        MIN=<span class="built_in">min</span>(MIN,a);</span><br><span class="line">        <span class="comment">//MAX最大利润</span></span><br><span class="line">        MAX=<span class="built_in">max</span>(MAX,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b[i]==MAX)ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC046</title>
      <link href="/posts/8eaf076e.html"/>
      <url>/posts/8eaf076e.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC046">ABC046</h1><blockquote><h1 id="ABC046A-AtCoDeerくんとペンキ">[ABC046A] AtCoDeerくんとペンキ</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>AtCoDeer先生最近买了三个油漆罐。两天前他买的那一种颜色是A，他昨天买的颜色是B，他今天买的颜色是C。每个颜料的颜色可以用1到100之间的正整数来表示。</p><p>由于AtCoDeer先生出生健忘村，AtCoDeer先生可能买了一个以上的油漆罐颜色相同。计算这些油漆罐的不同颜色的数量并告诉AtCoDeer先生。</p><p>范围：</p><p>1&lt;=(a,b,c)&lt;=100</p><p>输入格式： 三个正整数a,b,c</p><p>输出格式： 一个正整数，表示不同颜色数量</p><h2 id="题目描述">题目描述</h2><p>シカのAtCoDeerくんはペンキをこれまでに$ 3 $つ買いました。おととい買ったペンキの色は $ a $ , 昨日買ったペンキの色は $ b $ , 今日買ったペンキの色は $ c $ です。各ペンキの色は$ 1 $以上$ 100 $以下の整数で表されます。 AtCoDeerくんはわすれんぼうなため、同じ色のペンキを買ってしまっていることがあります。AtCoDeerくんが買ったペンキの色の種類の個数を教えてあげてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ c $</p></blockquote><h2 id="输出格式">输出格式</h2><p>AtCoDeerくんが買ったペンキの色の種類の個数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3 33</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦a,b,c≦100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>色 $ 1 $,$ 3 $,$ 4 $ の $ 3 $ 種類です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>色 $ 3 $,$ 33 $ の $ 2 $ 種類です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可，可以用map</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(m[x])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> m[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;m.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046B-AtCoDeerくんとボール色塗り">[ABC046B] AtCoDeerくんとボール色塗り</h1><h2 id="题面翻译-2">题面翻译</h2><p>你有N个球，K种颜料</p><p>你要把N个球涂上颜料，但是为了美观相邻的两个球不能是一样颜色的。</p><p>问有多少种涂色方法？</p><p>样例1：输入 2 2 输出 2 样例解释：只有01和10这两种涂色方法</p><p>样例2:输入 1 10 输出 10 样例解释：有0,1,2,3,4,5,6,7,8和9这些方法</p><p>感谢@RioBlu 提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>シカのAtCoDeerくんは一列に並んだ $ N $ 個のボールをそれぞれ $ K $ 色のペンキの色のうちのどれかで塗ろうとしています。見栄えが悪くならないように、隣り合ったボールは別の色で塗ることにします。ボールの塗り方としてあり得るものの個数を求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>ボールの塗り方としてあり得るものの個数を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">322828856</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 2≦K≦1000 $</li><li>答えは $ 2^{31}-1 $ 以下</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>色を$ 0 $,$ 1 $で表すと、左のボールを$ 0 $で塗り、右のボールを$ 1 $で塗る という方法と、 左のボールを$ 1 $で塗り、右のボールを$ 0 $で塗る という方法の$ 2 $通りがあります。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>ボールは一つしか無いため,$ 10 $色のうちどれを使っても良いので答えは$ 10 $通りです。</p></blockquote><h2 id="思路-2">思路</h2><p>简单的组合数学</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    ll ans=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans*=(k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046C-AtCoDeerくんと選挙速報">[ABC046C] AtCoDeerくんと選挙速報</h1><h2 id="题面翻译-3">题面翻译</h2><p>给定 $n$ 和 $n$ 对正整数 $T_i,A_i$，已知正整数数列 $t_i,a_i$ 满足以下条件：</p><ul><li>$t_i\le t_{i+1}$，$a_i\le a_{i+1}$</li><li>$t_i/a_i=T_i/A_i$</li></ul><p>求 $t_n+a_n$ 的最小值，保证答案不超过 $10^{18}$。</p><h2 id="题目描述-3">题目描述</h2><p>シカのAtCoDeerくんは選挙速報を見ています。選挙には二人の候補高橋くんと青木くんが出ています。速報では、現在の二人の得票数の比が表示されていますが、得票数そのものは表示されていません。AtCoDeerくんは $ N $ 回画面を見て、 $ i(1≦i≦N) $ 回目に見たときに表示されている比は $ T_i:A_i $ でした。ここで、AtCoDeerくんが選挙速報の画面を$ 1 $回目に見た段階で既にどちらの候補にも少なくとも一票は入っていたことがわかっています。 $ N $ 回目に画面を見たときの投票数(二人の得票数の和)として考えられるもののうち最小となるものを求めてください。ただし、得票数が途中で減ることはありません。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ T_1 $ $ A_1 $ $ T_2 $ $ A_2 $ $ : $ $ T_N $ $ A_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ N $ 回目に画面を見たときの投票数として考えられる最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">1 1</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1 1</span><br><span class="line">1 1</span><br><span class="line">1 5</span><br><span class="line">1 100</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 10</span><br><span class="line">48 17</span><br><span class="line">31 199</span><br><span class="line">231 23</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6930</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦1000 $</li><li>$ 1≦T_i,A_i≦1000\ (1≦i≦N) $</li><li>$ T_i $ と $ A_i $ は互いに素 $ (1≦i≦N) $</li><li>答えが $ 10^{18} $ 以下になることは保証されている</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>二人の得票数が $ 2,3 $ -&gt; $ 3,3 $ -&gt; $ 6,4 $ と動くと投票数は $ 10 $ になって、これが最小値です。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>一度画面を見てからもう一度画面を見るまでに一票も入ってないことがありえます。</p></blockquote><h2 id="思路-3">思路</h2><p>有意思的一道题。</p><p>思路参考自<a href="https://www.luogu.com.cn/article/5qxzbt31">AT2140题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>设$u,v$为目前两个人的得票数，需要保证在以后的每一步中都有$u:v=T_i:A_i$</p><p>先设$u,v$分别为$T_i,A_i$的倍数。注意到总票数不会减少，所以$u,v$应该变为大于他们的最小的$T_i$或者$A_i$的倍数。</p><p>所以接下来这一步：$u=T_i*\lceil\frac{u}{T_i}\rceil，u=A_i*\lceil\frac{v}{A_i}\rceil$。</p><p>因为要一直保证$u:v=T_i:A_i$，所以接下来需要比较$\frac{u}{T_i}$和$\frac{v}{A_i}$的大小：</p><p>$\frac{u}{T_i}$小，根据比例的基本性质，$u=\frac {vT_i}{A_i}$。同理可得其他情况。</p><p>答案即$u+v$。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;t[i]&gt;&gt;a[i];</span><br><span class="line">    ll u=t[<span class="number">1</span>],v=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        u=((u<span class="number">-1</span>)/t[i]+<span class="number">1</span>)*t[i],v=((v<span class="number">-1</span>)/a[i]+<span class="number">1</span>)*a[i];</span><br><span class="line">        <span class="keyword">if</span>(u/t[i]&lt;v/a[i])u=(v/a[i])*t[i];</span><br><span class="line">        <span class="keyword">else</span> v=(u/t[i])*a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;u+v;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC046D-AtCoDeerくんと変なじゃんけん">[ABC046D] AtCoDeerくんと変なじゃんけん</h1><h2 id="题面翻译-4">题面翻译</h2><p>你和对手都只有两种出拳方式：石头（$g$）和布（$p$），规则一样，赢了得一分，平局不得分，输了减一分。<br>现给你对手的出拳方式，设你到 $i$ 位置共出了 $x_i$ 次石头，$y_i$ 次布，在对于任意位置 $i$ 满足 $x_i \geq y_i$ 的条件下，输出你能得到的最大分数。</p><h2 id="题目描述-4">题目描述</h2><p>シカのAtCoDeerくんは友達のTopCoDeerくんとあるゲームをして対戦しています。 このゲームは $ N $ ターンからなります。各ターンではそれぞれのプレイヤーはじゃんけんのグーかパーを出します。ただし、各プレイヤーは次の条件を満たす必要があります。</p><p>(※) 各ターンの後で、(今までにパーを出した回数)$ ≦ $(今までにグーを出した回数) を満たす</p><p>このゲームでの各プレイヤーの得点は、(勝ったターンの数) $ - $ (負けたターンの数) です。 AtCoDeerくんは特殊能力を持っているので、ゲームが始まる前にTopCoDeerくんの出す $ N $ ターンの手を全て知ることが出来ました。 AtCoDeerくんの各ターンでの手を決めて、AtCoDeerくんの得点を最大化してください。 TopCoDeerくんの出す手の情報は文字列 $ s $ で与えられます。 $ s $ の $ i(1≦i≦N) $ 文字目が <code>g</code>のときは $ i $ ターン目でTopCoDeerくんがグーを出すことを、 <code>p</code>のときはパーを出すことを表します。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>AtCoDeerくんの得点の最大値を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpg</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ggppgggpgg</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1≦N≦10^5 $</li><li>$ N=|s| $</li><li>$ s $ の各文字は<code>g</code>か<code>p</code></li><li>$ s $ で表される手は、条件(※)を満たしている</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>常に相手とあいこになるように手を出すことで、$ 0 $点を取ることができて、これが最大値です。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>例えばグー,パー,グー,パー,グー,グー,パー,パー,グー,パー と出すことで、 $ 3 $回勝って$ 1 $回負けているので得点は$ 2 $点になり、これが最大値です。</p></blockquote><h2 id="思路-4">思路</h2><p>直接模拟，判断$p$是否大于$max_p$。再处理即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>],t[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    ll p=<span class="number">0</span>,g=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;p&#x27;</span>)p++;</span><br><span class="line">    &#125;</span><br><span class="line">    ll lose=<span class="number">0</span>,win=<span class="number">0</span>;</span><br><span class="line">    ll max_p=s.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;=max_p)lose+=(p-max_p);</span><br><span class="line">    <span class="keyword">else</span> win+=(max_p-p);</span><br><span class="line">    cout&lt;&lt;win-lose;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC044</title>
      <link href="/posts/60a16642.html"/>
      <url>/posts/60a16642.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC044">ABC044</h1><p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC044A-高橋君とホテルイージー">[ABC044A] 高橋君とホテルイージー</h1><h2 id="题面翻译">题面翻译</h2><p>有一家酒店，这家酒店住宿费的收取规则如下</p><ul><li>前K晚每晚X元</li><li>从K+1晚开始每晚Y元</li></ul><p>高橋老弟要在这里连续住N晚，问他的住宿费合计为多少元</p><h4 id="输入格式">输入格式</h4><p>第一行，N</p><p>第二行，K</p><p>第三行，X</p><p>第四行，Y</p><h4 id="输出格式">输出格式</h4><p>一行，住宿总费用</p><h2 id="题目描述">题目描述</h2><p>$ 1 $ 軒のホテルがあります。 このホテルの宿泊費は、次のようになっています。</p><ul><li>最初の $ K $ 泊までは、$ 1 $ 泊あたり $ X $ 円</li><li>$ K+1 $ 泊目以降は、$ 1 $ 泊あたり $ Y $ 円</li></ul><p>高橋君は、このホテルに $ N $ 泊連続で宿泊することにしました。 高橋君の宿泊費は合計で何円になるか求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ X $ $ Y $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>高橋君の宿泊費の合計金額を表す整数を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">48000</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">10000</span><br><span class="line">9000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20000</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ N,\ K\ \leq\ 10000 $</li><li>$ 1\ \leq\ Y $</li><li>$ N,,K,,X,,Y $ はいずれも整数である</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>宿泊費は次のようになります。 - $ 1 $ 泊目は $ 10000 $ 円 - $ 2 $ 泊目は $ 10000 $ 円 - $ 3 $ 泊目は $ 10000 $ 円 - $ 4 $ 泊目は $ 9000 $ 円 - $ 5 $ 泊目は $ 9000 $ 円 したがって、合計は $ 48000 $ 円です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k,x,y;cin&gt;&gt;n&gt;&gt;k&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=k)&#123;</span><br><span class="line">        cout&lt;&lt;n*x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ll ans=<span class="number">0</span>;</span><br><span class="line">        ans+=k*x+(n-k)*y;</span><br><span class="line">        cout&lt;&lt;ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044B-美しい文字列">[ABC044B] 美しい文字列</h1><h2 id="题面翻译-2">题面翻译</h2><p>输入一个字符串，判断每个字母出现的次数是否都为偶数</p><p>如果是，输出“Yes”，否则输出“No”</p><h2 id="题目描述-2">题目描述</h2><p>$ w $ を、英小文字のみからなる文字列とします。 $ w $ が以下の条件を満たすならば、$ w $ を<em>美しい文字列</em>と呼ぶことにします。</p><ul><li>どの英小文字も、$ w $ 中に偶数回出現する。</li></ul><p>文字列 $ w $ が与えられます。$ w $ が美しい文字列かどうか判定してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ w $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>$ w $ が美しい文字列ならば <code>Yes</code> を、それ以外の場合は <code>No</code> を出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abaccaba</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hthth</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ |w|\ \leq\ 100 $</li><li>$ w $ は英小文字 (<code>a</code>-<code>z</code>) のみからなる文字列である</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p><code>a</code> が $ 4 $ 回、<code>b</code> が $ 2 $ 回、<code>c</code> が $ 2 $ 回、それ以外の英小文字が $ 0 $ 回出現します。</p></blockquote><h2 id="思路-2">思路</h2><p>开个桶，直接统计即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        m[s[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> i=<span class="string">&#x27;a&#x27;</span>;i&lt;=<span class="string">&#x27;z&#x27;</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i]%<span class="number">2</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;No\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Yes\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044C-高橋君とカード">[ABC044C] 高橋君とカード</h1><h2 id="题面翻译-3">题面翻译</h2><p>高桥有n张卡。在i(1≤i≤n)的第一个磁卡上，卡上面写着整数x_i。</p><p>高桥从这些卡片中挑选1张以上，想把选择的卡片上写的整数的平均数变成等于A的数。问有几种方案。</p><p>读入： 第一行读入N,A； 接下来一行读入N个数</p><p>输出： 一个数，记得加回车</p><p>感谢@STEPHEN_ 提供的翻译</p><h2 id="题目描述-3">题目描述</h2><p>高橋君は、$ N $ 枚のカードを持っています。 $ i\ ,\ (1\ \leq\ i\ \leq\ N) $ 番目のカードには、整数 $ x_i $ が書かれています。 高橋君は、これらのカードの中から $ 1 $ 枚以上を選び、 選んだカードに書かれた整数の平均をちょうど $ A $ にしたいと考えています。 そのようなカードの選び方が何通りあるか求めてください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ A $ $ x_1 $ $ x_2 $ $ … $ $ x_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>書かれた整数の平均がちょうど $ A $ となるようなカードの選び方の総数を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">7 9 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 8</span><br><span class="line">6 6 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 5</span><br><span class="line">3 6 2 8 7 6 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33 3</span><br><span class="line">3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8589934591</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ \leq\ N\ \leq\ 50 $</li><li>$ 1\ \leq\ A\ \leq\ 50 $</li><li>$ 1\ \leq\ x_i\ \leq\ 50 $</li><li>$ N,,A,,x_i $ はいずれも整数である</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 1\ \leq\ N\ \leq\ 16 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>- 平均が $ 8 $ となるカードの選び方は、以下の $ 5 $ 通りです。 - $ 3 $ 枚目のカードのみを選ぶ。 - $ 1 $ 枚目と $ 2 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目と $ 4 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 2 $ 枚目および $ 3 $ 枚目のカードを選ぶ。 - $ 1 $ 枚目、$ 3 $ 枚目および $ 4 $ 枚目のカードを選ぶ。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>- 答えは $ 32 $ ビット整数型に収まらない場合があります。</p></blockquote><h2 id="思路-3">思路</h2><p>转载自<a href="https://www.luogu.com.cn/article/z25wx5t7">AT2037 题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>计数型01背包。</p><p>一开始想的是只写$f_{j}$，表示的是和为$j$的方法数。</p><p>但是最后发现不行，因为有可能最后可能不同的组合组成的数为$j$，所以得多加一个维度$i$，表示的是取了$i$个数</p><p>所以状态中存了两个值：$f_{i,j}$表示取了$i$个数，和为$j$的方法数。</p><p>这样转移方程为：$f_{i,j}=f_{i,j}+f_{i-1,j-a_k}$，$i-1$是这个数还没取，也就是少取了一个，$j-a_k$表示当前这个和减去现在的这个值，也就是之前的和。</p><p>注意就是枚举$i$和$j$时要反着枚举，初始化$f[0][0]=1$，开$long\ long$。</p><p>注意平均值不一定是整数哦。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">55</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">55</span>][<span class="number">2505</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//设初值。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">  <span class="comment">//注意这两重循环是反着的，否则会从已经改过的值转移来。</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)</span><br><span class="line">            sum+=(j*<span class="number">1.0</span>/i==<span class="built_in">double</span>(m))*f[i][j];</span><br><span class="line">  <span class="comment">//如果平均值等于 m 就将 sum 加上 f[i][j]。</span></span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;<span class="comment">//AT 加换行。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,A;cin&gt;&gt;n&gt;&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2500</span>;j&gt;=a[i];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=n;k&gt;=<span class="number">1</span>;k--)&#123;</span><br><span class="line">                f[k][j]+=f[k<span class="number">-1</span>][j-a[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">2500</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((j*<span class="number">1.0</span>/i)==(<span class="type">double</span>)A)sum+=f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC044D-桁和">[ABC044D] 桁和</h1><h2 id="题面翻译-4">题面翻译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">题目描述</span><br><span class="line"></span><br><span class="line">对于2以上的整数b和一个1以上的整数n，函数f(b,n)的定义如下：</span><br><span class="line"></span><br><span class="line">1.若n&lt;b,f(b，n)=n;</span><br><span class="line"></span><br><span class="line">2.若n&gt;=b,f(b,n)=f(b,floor(n/b))+(n%b).</span><br><span class="line"></span><br><span class="line">说白了就是即n在b进制下各位数的和 举个例子：</span><br><span class="line"></span><br><span class="line">f(10,87654)=8+7+6+5+4=30</span><br><span class="line"></span><br><span class="line">f(100,87654)=8+76+54=138</span><br><span class="line"></span><br><span class="line">设函数f(b,n)的值为s；</span><br><span class="line"></span><br><span class="line">输入输出格式</span><br><span class="line"></span><br><span class="line">输入格式</span><br><span class="line"></span><br><span class="line">输入包含两个数，代表n,s的值</span><br><span class="line"></span><br><span class="line">输出格式</span><br><span class="line"></span><br><span class="line">输出包含1个数，是b的值，如果找不到符合要求的b值，则输出-1</span><br></pre></td></tr></table></figure><p>注：此为<a href="https://www.luogu.org/space/show?uid=118196">Over_The_Best</a>翻译，但他被禁言了，由我代发</p><h2 id="题目描述-4">题目描述</h2><p>$ 2 $ 以上の整数 $ b $ および $ 1 $ 以上の整数 $ n $ に対し、関数 $ f(b,n) $ を次のように定義します。</p><ul><li>$ n\ &lt;\ b $ のとき $ f(b,n)\ =\ n $</li><li>$ n\ \geq\ b $ のとき $ f(b,n)\ =\ f(b,,{\rm\ floor}(n\ /\ b))\ +\ (n\ {\rm\ mod}\ b) $</li></ul><p>ここで、$ {\rm\ floor}(n\ /\ b) $ は $ n\ /\ b $ を超えない最大の整数を、 $ n\ {\rm\ mod}\ b $ は $ n $ を $ b $ で割った余りを表します。</p><p>直感的に言えば、$ f(b,n) $ は、$ n $ を $ b $ 進表記したときの各桁の和となります。 例えば、</p><ul><li>$ f(10,,87654)=8+7+6+5+4=30 $</li><li>$ f(100,,87654)=8+76+54=138 $</li></ul><p>などとなります。</p><p>整数 $ n $ と $ s $ が与えられます。 $ f(b,n)=s $ を満たすような $ 2 $ 以上の整数 $ b $ が存在するか判定してください。 さらに、そのような $ b $ が存在するならば、その最小値を求めてください。</p><h2 id="输入格式-5">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ n $ $ s $</p></blockquote><h2 id="输出格式-5">输出格式</h2><p>$ f(b,n)=s $ を満たす $ 2 $ 以上の整数 $ b $ が存在するならば、そのような $ b $ の最小値を出力せよ。 そのような $ b $ が存在しないならば、代わりに <code>-1</code> を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">138</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">87654</span><br><span class="line">45678</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-4-2">样例 #4</h2><h3 id="样例输入-4-2">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-2">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">31415926535</span><br></pre></td></tr></table></figure><h2 id="样例-5">样例 #5</h2><h3 id="样例输入-5">样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">31415926535</span><br></pre></td></tr></table></figure><h3 id="样例输出-5">样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ \leq\ n\ \leq\ 10^{11} $</li><li>$ 1\ \leq\ s\ \leq\ 10^{11} $</li><li>$ n,,s $ はいずれも整数である</li></ul></blockquote><h2 id="思路-4">思路</h2><p>题解区都是一堆奇怪的显然，莫名其妙的就是$O(\sqrt{n})$的时间复杂度。幸好在下面翻到一篇好文章，这里是原文链接：<a href="https://www.luogu.com.cn/article/qkzeokn7">AT2038 - 洛谷专栏 (luogu.com.cn)</a></p><p>其实是一道数学题</p><p>不妨设$n=a_0+a_1b+a_2b^2+······$，则$s=a_0+a_1+a_2+······$。</p><p>先考虑特殊情况 :</p><p>1、$n=s$，则$b=n+1$</p><p>2、$n&lt;s$，则无解。</p><p>我们用$n$减去$s$：</p><p>$n-s=a_1(b-1)+a_2(b^2-1)+a_3(b^3-1)+······$。</p><p>容易知道，$b^n-1=(b-1)(b^{n-1}+b^{n-2}+b^{n-3}+······+1)$，所以说 , 右式可以提出$b-1$。</p><p>显然：$(b-1)|n-s$，那么$b$可能的取值范围就缩成了$\sqrt{n}$数量级，接下来直接调用函数，暴力枚举即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll n,s;</span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll b,ll n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(b,n/b)+n%b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(b,n)==s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;s)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==s)&#123;</span><br><span class="line">        cout&lt;&lt;n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll tot=n-s,ans=<span class="number">1e15</span>;</span><br><span class="line">    <span class="comment">//可以结合最基础的素数筛，理解为什么枚举到根号n即可</span></span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=(ll)<span class="built_in">sqrt</span>(tot)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tot%i==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//注意是判断两个哦</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(tot/i+<span class="number">1</span>))ans=<span class="built_in">min</span>(ans,tot/i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e15</span>)cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC045</title>
      <link href="/posts/17a656d4.html"/>
      <url>/posts/17a656d4.html</url>
      
        <content type="html"><![CDATA[<h1 id="ABC045">ABC045</h1><blockquote><h1 id="ABC045A-台形">[ABC045A] 台形</h1><h2 id="题面翻译">题面翻译</h2><p>一个梯形，给出上底a，下底b，高h的长度，求它的面积~~~</p><h2 id="题目描述">题目描述</h2><p>上底の長さが $ a $、下底の長さが $ b $、高さが $ h $ の台形があります。</p><p><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/AT_abc045_a/695fd302082c8c27a3f1814f7489c8be1c4f74c9.png" alt="">台形の例</p><p>この台形の面積を求めてください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ a $ $ b $ $ h $</p></blockquote><h2 id="输出格式">输出格式</h2><p>台形の面積を整数で出力せよ。面積が整数になることは保障されている。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1\ \leq\ a\ \leq\ 100 $</li><li>$ 1\ \leq\ b\ \leq\ 100 $</li><li>$ 1\ \leq\ h\ \leq\ 100 $</li><li>入力で与えられる値はすべて整数</li><li>$ h $ は偶数</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>上底の長さ $ 3 $、下底の長さ $ 4 $、高さ $ 2 $ の台形の面積は、 $ (3+4)×2/2\ =\ 7 $ です。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>この例で与えられるのは平行四辺形ですが、平行四辺形も台形です。</p></blockquote><h2 id="思路">思路</h2><p>直接模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">55</span>],f[<span class="number">55</span>][<span class="number">2510</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">palindrome</span><span class="params">(ll n)</span> </span>&#123;<span class="comment">//判定回文，不懂请参考数字反转</span></span><br><span class="line">    ll sum = <span class="number">0</span>;</span><br><span class="line">    ll k = n;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum = sum * <span class="number">10</span> + n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum == k)<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    ll a,b,h;cin&gt;&gt;a&gt;&gt;b&gt;&gt;h;</span><br><span class="line">    cout&lt;&lt;(a+b)*h/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC045B-3人でカードゲームイージー">[ABC045B] 3人でカードゲームイージー</h1><h2 id="题面翻译-2">题面翻译</h2><h3 id="题面描述">题面描述</h3><p>Alice、Bob 和 Charlie 在玩 <em>Card Game for Three</em>。</p><ul><li>开始时，每名玩家有一叠由卡牌组成的牌堆。每张牌上有一个字母 $\texttt a, \texttt b$ 或 $\texttt c$。 卡牌的顺序不能被改变。</li><li>Alice 先开始游戏。</li><li>玩家的牌堆中至少有一张牌，当前玩家从牌堆顶抽出一张牌，这张牌代表的玩家进行下一回合（$\texttt a$ 代表 Alice，$\texttt c$ 代表 Bob，$\texttt c$ 代表 Charlie）。</li><li><strong>从左往右抽牌</strong>（牌堆顶在左边）。</li><li>如果当前玩家的牌堆空了，游戏结束，这名玩家胜利。</li></ul><p>你得到了每名玩家最初的牌堆 $S_a, S_b, S_c$，求出胜者。</p><h3 id="数据范围">数据范围</h3><p>对于 $100 %$ 的数据，保证 $1 \leq |S_a|, |S_b|, |S_c| \leq 100$ 且 $S_a, S_b, S_c$ 仅由 $\texttt{abc}$ 三个小写拉丁字母组成。</p><h2 id="题目描述-2">题目描述</h2><p>A さん、B さん、C さんの $ 3 $ 人が以下のようなカードゲームをプレイしています。</p><ul><li>最初、$ 3 $ 人はそれぞれ <code>a</code>、<code>b</code>、<code>c</code> いずれかの文字が書かれたカードを、何枚か持っている。これらは入力で与えられた順番に持っており、途中で並べ替えたりしない。</li><li>$ A $ さんのターンから始まる。</li><li>現在自分のターンである人がカードを $ 1 $ 枚以上持っているならば、そのうち先頭のカードを捨てる。その後、捨てられたカードに書かれているアルファベットと同じ名前の人 (例えば、カードに <code>a</code> と書かれていたならば A さん) のターンとなる。</li><li>現在自分のターンである人がカードを $ 1 $ 枚も持っていないならば、その人がゲームの勝者となり、ゲームは終了する。</li></ul><p>$ 3 $ 人が最初に持っているカードがそれぞれ先頭から順に与えられます。 具体的には、文字列 $ S_A $、$ S_B $、$ S_C $ が与えられます。文字列 $ S_A $ の $ i $ 文字目 ( $ 1\ \leq\ i\ \leq\ |S_A| $ ) に書かれている文字が、A さんの持っている中で先頭から $ i $ 番目のカードに 書かれている文字です。文字列 $ S_B $、 $ S_C $ についても同様です。</p><p>最終的に誰がこのゲームの勝者となるかを求めてください。</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S_A $ $ S_B $ $ S_C $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>A さんが勝つなら <code>A</code>、B さんが勝つなら <code>B</code>、C さんが勝つなら <code>C</code> と出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aca</span><br><span class="line">accc</span><br><span class="line">ca</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcb</span><br><span class="line">aacb</span><br><span class="line">bccc</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ \leq\ S_A\ \leq\ 100 $</li><li>$ 1\ \leq\ S_B\ \leq\ 100 $</li><li>$ 1\ \leq\ S_C\ \leq\ 100 $</li><li>$ S_A $、$ S_B $、$ S_C $ に含まれる文字はそれぞれ <code>a</code>、<code>b</code>、<code>c</code> のいずれか</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>ゲームは以下のように進行します。 - A さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんが、持っている中で最初のカード <code>c</code> を捨てる。次は C さんの番となる。 - C さんが、持っている中で最初のカード <code>c</code> を捨てる。次は C さんの番となる。 - C さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんが、持っている中で最初のカード <code>a</code> を捨てる。次は A さんの番となる。 - A さんはもう持っているカードがない。よって A さんの勝利となり、ゲームは終了する。</p></blockquote><h2 id="思路-2">思路</h2><p>其实是到模拟题，感觉有点像链表。</p><p>用$p$代表每个字符串对应的指针，不断按照题意进行移动操作，直到当前牌堆空为止。</p><p>思路参考自[题解 AT2066 <a href="https://www.luogu.com.cn/article/ssxcmj7y">ABC045B] 3人でカードゲームイージー / Card Game for Three (ABC Edit) - 洛谷专栏 (luogu.com.cn)</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">3</span>];</span><br><span class="line">ll len[<span class="number">3</span>],p[<span class="number">4</span>],k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)cin&gt;&gt;s[i],len[i]=s[i].<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span>(p[k]&lt;len[k])&#123;</span><br><span class="line">        k=s[k][p[k]++]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="type">char</span>)(k+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC045C-たくさんの数式">[ABC045C] たくさんの数式</h1><h2 id="题面翻译-3">题面翻译</h2><p><strong>Translated by <a href="https://www.luogu.org/space/show?uid=77834">aoweiyin</a></strong></p><h2 id="题意翻译">题意翻译</h2><p>有一个仅由字符<code>1</code>到<code>9</code>构成的字符串$S(1\leq |S|\leq 10)$，让你在中间添加<code>+</code>，使其变成一个加式。求所有方案的和值（详见样例解释）。</p><h4 id="样例解释1：">样例解释1：</h4><p>输入<code>125</code>,输出<code>176</code>.</p><p>有4种：</p><ul><li>125</li><li>1+25=26</li><li>12+5=17</li><li>1+2+5=8</li></ul><h2 id="题目描述-3">题目描述</h2><p><code>1</code> 以上 <code>9</code> 以下の数字のみからなる文字列 $ S $ が与えられます。 この文字列の中で、あなたはこれら文字と文字の間のうち、いくつかの場所に <code>+</code> を入れることができます。 一つも入れなくてもかまいません。 ただし、<code>+</code> が連続してはいけません。</p><p>このようにして出来る全ての文字列を数式とみなし、和を計算することができます。</p><p>ありうる全ての数式の値を計算し、その合計を出力してください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ S $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>ありうる全ての数式の値の総和を $ 1 $ 行に出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">125</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">176</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999999999</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12656242944</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\leq \left|S\right|\leq 10 $</li><li>$ S $ に含まれる文字は全て <code>1</code> 〜 <code>9</code> の数字</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>考えられる数式としては、 <code>125</code>、<code>1+25</code>、<code>12+5</code>、<code>1+2+5</code> の $ 4 $ 通りがあります。それぞれの数式を計算すると、 - $ 125 $ - $ 1+25=26 $ - $ 12+5=17 $ - $ 1+2+5=8 $ となり、これらの総和は $ 125+26+17+8=176 $ となります。</p></blockquote><h2 id="思路-3">思路</h2><p>用DFS就可以解决了，将每一位进行拆分，用数组记录下来。</p><p>$+$的插入有两种情况：</p><p>DFS数字的每一位，可以将这一位与上一个数进行结合，也可以在中间加上一个$+$，具体看代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">15</span>],ans,n;</span><br><span class="line"><span class="comment">//k表示当前是第几位数字，sum表示的是当前的总和，num表示的是当前新开的数字</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll k,ll sum,ll num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果大于n位，则结束</span></span><br><span class="line">    <span class="keyword">if</span>(k&gt;n)&#123;</span><br><span class="line">        <span class="comment">//加上答案和当前数字</span></span><br><span class="line">        ans+=sum+num;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num=num*<span class="number">10</span>+a[k];</span><br><span class="line">    <span class="comment">//对应+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum+num,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//对应没有+</span></span><br><span class="line">    <span class="built_in">dfs</span>(k+<span class="number">1</span>,sum,num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="comment">//分离每一位数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        a[i+<span class="number">1</span>]=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//开始DFS</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//注意答案要除以2</span></span><br><span class="line">    cout&lt;&lt;ans/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实有更好的方法：看看这篇文章</p><p>[题解 AT2067 【<a href="https://www.luogu.com.cn/article/eevodhvs">ARC061A] たくさんの数式 / Many Formulas】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="ABC045D-すぬけ君の塗り絵">[ABC045D] すぬけ君の塗り絵</h1><h2 id="题面翻译-4">题面翻译</h2><p>给定一个 $H$ 行 $W$ 列的矩形，再给定矩形上 $N$ 个黑格子的坐标。对于每个 $0\le j\le9$ ，求出有多少个 $3\times3$ 的子矩阵包含有<strong>恰好</strong> $j$ 个黑格子。</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ 行、横 $ W $ 列のマス目からなる盤があります。最初、どのマス目も白く塗られています。</p><p>すぬけ君が、このうち $ N $ マスを黒く塗りつぶしました。$ i $ 回目 ( $ 1\ \leq\ i\ \leq\ N $ ) に塗りつぶしたのは、 上から $ a_i $ 行目で左から $ b_i $ 列目のマスでした。</p><p>すぬけ君がマス目を塗りつぶした後の盤の状態について、以下のものの個数を計算してください。</p><ul><li>各整数 $ j $ ( $ 0\ \leq\ j\ \leq\ 9 $ ) について、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $ 列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるもの。</li></ul><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ N $ $ a_1 $ $ b_1 $ : $ a_N $ $ b_N $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>出力は $ 10 $ 行からなる。 $ j+1 $ 行目 ( $ 0\ \leq\ j\ \leq\ 9 $ ) には、盤の中に完全に含まれるすべての $ 3 $ 行 $ 3 $ 列の連続するマス目のうち、黒いマスがちょうど $ j $ 個あるものの 総数を出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 8</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 4</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 10 20</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">1 9</span><br><span class="line">2 5</span><br><span class="line">3 10</span><br><span class="line">4 2</span><br><span class="line">4 7</span><br><span class="line">5 9</span><br><span class="line">6 4</span><br><span class="line">6 6</span><br><span class="line">6 7</span><br><span class="line">7 1</span><br><span class="line">7 3</span><br><span class="line">7 7</span><br><span class="line">8 1</span><br><span class="line">8 5</span><br><span class="line">8 10</span><br><span class="line">9 2</span><br><span class="line">10 4</span><br><span class="line">10 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">26</span><br><span class="line">22</span><br><span class="line">10</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000000000 1000000000 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">999999996000000004</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 3\ \leq\ H\ \leq\ 10^9 $</li><li>$ 3\ \leq\ W\ \leq\ 10^9 $</li><li>$ 0\ \leq\ N\ \leq\ min(10^5,H×W) $</li><li>$ 1\ \leq\ a_i\ \leq\ H $ $ (1\ \leq\ i\ \leq\ N) $</li><li>$ 1\ \leq\ b_i\ \leq\ W $ $ (1\ \leq\ i\ \leq\ N) $</li><li>$ (a_i,\ b_i)\ \neq\ (a_j,\ b_j) $ $ (i\ \neq\ j) $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>![](<a href="https://atcoder.jp/img/arc061/30326702be007759dce81231012a8353.png">https://atcoder.jp/img/arc061/30326702be007759dce81231012a8353.png</a>) この盤に含まれる $ 3×3 $ の正方形は全部で $ 6 $ 個ありますが、これらのうち $ 2 $ 個の内部には黒いマスが $ 3 $ 個、残りの $ 4 $ 個の内部には黒いマスが $ 4 $ 個含まれています。</p></blockquote><h2 id="思路-4">思路</h2><p>思路参考自<a href="https://www.luogu.com.cn/article/9kz3t00a">AT2068题解 - 洛谷专栏 (luogu.com.cn)</a></p><p>直接开数组模拟肯定<s>喜提</s>TLE,MLE。</p><p>这时候就要想到贡献法，就是每输入一个格子，计算它对包含它的九宫格的贡献（记得判边界）</p><p>所以我们只需维护一个答案数组，每次计算新格子对它的影响就行了</p><p>但是，又有个新问题：如何记录新加进来的格子所在的九宫格原来黑格子的个数呢？</p><p><s>显然</s>我们可以用 map 来解决，用它来维护以$x,y$为中心的九宫格黑格子个数</p><p>完结撒花！</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span>  ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;<span class="comment">//用pair来维护二元组 </span></span><br><span class="line">map&lt;pii,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> h,w;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;h&gt;&gt;w&gt;&gt;n;</span><br><span class="line">ans[<span class="number">0</span>]=(h<span class="number">-2</span>)*(w<span class="number">-2</span>);<span class="comment">//初始化，一开始一个黑格子都没有 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">-1</span>;j&lt;=<span class="number">1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">-1</span>;k&lt;=<span class="number">1</span>;k++)<span class="comment">//遍历计算影响 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=a+j,y=b+k;<span class="comment">//九宫格的中心 </span></span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>&amp;&amp;x&lt;h&amp;&amp;y&gt;<span class="number">1</span>&amp;&amp;y&lt;w)<span class="comment">//判断边界 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> now;<span class="comment">//now表示现在这个九宫格的黑格子的数量 </span></span><br><span class="line">now=++mp[&#123;x,y&#125;];</span><br><span class="line">                    <span class="comment">//now++,那么now-1肯定就是要--啦</span></span><br><span class="line">ans[now]++,ans[now<span class="number">-1</span>]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC043</title>
      <link href="/posts/fec5f3e1.html"/>
      <url>/posts/fec5f3e1.html</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC043A-キャンディーとN人の子供イージー">[ABC043A] キャンディーとN人の子供イージー</h1><h2 id="题面翻译">题面翻译</h2><p>幼儿园有N个孩子。教授决定给孩子们糖果，第一个人要一个糖果，第二个人要两个糖果…… ，第N个人要N个糖果。总共需要多少糖果？</p><h2 id="题目描述">题目描述</h2><p>競プロ幼稚園には$ N $人の子供がいます。えび先生は、子供たちを一列に並べ、一人目にはキャンディーを$ 1 $個,二人目には$ 2 $個,…,$ N $人目には$ N $個あげることにしました。必要なキャンディーの個数の合計は何個でしょう?</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $</p></blockquote><h2 id="输出格式">输出格式</h2><p>必要なキャンディーの個数の合計を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">55</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦N≦100 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>$ 1+2+3=6 $が答えになります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>$ 1 $から$ 10 $までの和は$ 55 $です。</p><h3 id="Sample-Explanation-3">Sample Explanation 3</h3><p>子供は一人しかいません。この時答えは$ 1 $になります。</p></blockquote><h2 id="思路">思路</h2><p>等差数列计算即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;(n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC043B-バイナリハックイージー">[ABC043B] バイナリハックイージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>$Sig$已经打造了他自己的键盘。为了设计最简单，在这个键盘上面只有$3$个按键：$0$号键，$1$号键和退格键。</p><p>首先，他正在用他的键盘使用纯文本编辑器。这个编辑器总是显示一个字符串（可能为空）。就在编辑开始的时候，这个字符串是空的。当键盘上的任意按键被按下时，字符串将发生以下变化：</p><ul><li><p>$0$号键：一个文字$0$将被插入到字符串的右边。</p></li><li><p>$1$号键：一个文字$1$将被插入到字符串的右边。</p></li><li><p>退格键：如果字符串是空的，什么都不会发生。否则字符串最右边的文字将被删除。</p></li></ul><p>$Sig$已经开始了编辑，并且按下了这些按键几次。你将被给予一个他敲击键盘的顺序字符串s。在这个字符串中，文字$0$代表$0$号键，文字$1$代表$1$号键，而字母$B$则代表退格键。请问现在编辑器上会显示什么字符串呢？</p><h2 id="题目描述-2">题目描述</h2><p>しぐはキーボードを製作しました。シンプルさを極限まで追求したこのキーボードには、<code>0</code> キー、<code>1</code> キー、バックスペースキーの $ 3 $ つしかキーがありません。</p><p>手始めに、しぐはこのキーボードで簡単なテキストエディタを操作してみることにしました。このエディタには常に一つの文字列が表示されます（文字列が空のこともあります）。エディタを起動した直後では、文字列は空です。キーボードの各キーを押すと、文字列が次のように変化します。</p><ul><li><code>0</code> キー: 文字列の右端に文字 <code>0</code> が挿入される。</li><li><code>1</code> キー: 文字列の右端に文字 <code>1</code> が挿入される。</li><li>バックスペースキー: 文字列が空なら、何も起こらない。そうでなければ、文字列の右端の $ 1 $ 文字が削除される。</li></ul><p>しぐはエディタを起動し、これらのキーを何回か押しました。しぐが押したキーを順番に記録した文字列 $ s $ が与えられます。$ s $ の中の文字 <code>0</code> は <code>0</code> キー、文字 <code>1</code> は <code>1</code> キー、文字 <code>B</code> はバックスペースキーを表します。いま、エディタの画面にはどのような文字列が表示されているでしょうか？</p><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>最終的にエディタに表示されている文字列を出力せよ。（「制約」セクションで述べたように、この文字列が空になるような入力は与えられない）</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">01B0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0BB1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ |s|\ ≦\ 10 $ ($ |s| $ は $ s $ の長さを表す)</li><li>$ s $ は文字 <code>0</code>, <code>1</code>, <code>B</code> のみからなる。</li><li>正解は空文字列ではない。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>, <code>01</code>, <code>0</code>, <code>00</code> と変化します。</p><h3 id="Sample-Explanation-2-2">Sample Explanation 2</h3><p>キーが押されるたびに、エディタの文字列は <code>0</code>, <code>(空文字列)</code>, <code>(空文字列)</code>, <code>1</code> と変化します。</p></blockquote><h2 id="思路-2">思路</h2><p>使用deque模拟即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    deque&lt;<span class="type">char</span>&gt; q;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;B&#x27;</span>&amp;&amp;q.<span class="built_in">size</span>())q.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>||s[i]==<span class="string">&#x27;1&#x27;</span>)q.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        cout&lt;&lt;q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ARC059C-いっしょ">[ARC059C] いっしょ</h1><h2 id="题面翻译-3">题面翻译</h2><p>Evi有$n$个整数，分别为$a_1$，$a_2$，直到$a_n$。</p><p>他的目标是通过改变其中的一些数来使所有数相等。</p><p>对于每个整数，他最多可以变换一次。</p><p>将一个整数$x$转换为一个整数$y$会花费他$\left(x-y\right)^2$美元。</p><p>即使第$i$个数$a_i$与第$j$个数$a_j$ $\left(i!=j\right)$相等，他仍需为了改变它们中的每个数分别花费代价(请见样例2)。</p><p>请找到能够实现他目标的最小花费。</p><h2 id="题目描述-3">题目描述</h2><p>$ N $ 個の整数 $ a_1,a_2,…,a_N $ が与えられます。えび君はこれらを書き換えて全て同じ<strong>整数</strong>にしようとしています。各$ a_i\ (1≦i≦N) $は高々一回しか書き換えられません(書き換えなくても良い)。整数$ x $を整数$ y $に書き換えるとき、コストが$ (x-y)^2 $かかります。仮に$ a_i=a_j\ (i≠j) $だとしても、ひとつ分のコストで同時に書き換えることは出来ません(入出力例$ 2 $ を参照)。えび君が目的を達成するのに必要なコストの総和の最小値を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ a_1 $ $ a_2 $ … $ a_N $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>えび君が全てを同じ整数に書き換えるのに必要なコストの総和の最小値を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-3-2">样例 #3</h2><h3 id="样例输入-3-2">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-100 -100 -100 -100</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1≦N≦100 $</li><li>$ -100≦a_i≦100 $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>全てを$ 6 $に書き換えると、コストの総和は$ (4-6)^2+(8-6)^2=8 $となり、これが最小です。</p><h3 id="Sample-Explanation-2-3">Sample Explanation 2</h3><p>全てを$ 2 $に書き換えると$ (1-2)^2+(1-2)^2+(3-2)^2=3 $となります。各$ a_i $ごとに書き換えるので、二つの$ 1 $を一度にコスト$ (1-2)^2 $で書き換えられるわけではないことに注意してください。</p><h3 id="Sample-Explanation-3-2">Sample Explanation 3</h3><p>$ 4 $は書き換えずに、$ 2 $と$ 5 $を共に$ 4 $に書き換えることで$ (2-4)^2+(5-4)^2=5 $が達成できて、これが最小です。</p><h3 id="Sample-Explanation-4">Sample Explanation 4</h3><p>何も書き換えなくともえび君は目的を達成しています。よってこの場合コストは$ 0 $です。</p></blockquote><h2 id="思路-3">思路</h2><p>因为范围实在是太小了，所以直接暴力枚举即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> MIN=<span class="number">200</span>,MAX=<span class="number">-200</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        MIN=<span class="built_in">min</span>(a[i],MIN);</span><br><span class="line">        MAX=<span class="built_in">max</span>(a[i],MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=MIN;i&lt;=MAX;i++)&#123;</span><br><span class="line">        ll tmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            tmp+=(a[j]-i)*(a[j]-i);</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">min</span>(tmp,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这里是有规律的，答案只可能是平均值，或者离平均值最近的两个数（也就是是这三者中的其中一个），原理大概是利用均值不等式吧。</p><blockquote><h1 id="ARC059D-アンバランス">[ARC059D] アンバランス</h1><h2 id="题面翻译-4">题面翻译</h2><p>给出字符串$s$,求区间$[l,r]$,使得该子串中有一种字母出现的次数严格大于该子串长度的一半.<br>如果没有符合条件的子串,输出两个-1.</p><p>由 @Fuko_Ibuki 提供翻译</p><h2 id="题目描述-4">题目描述</h2><p>文字列 $ t $ について、$ t $ の長さが $ 2 $ 以上であり、かつ $ t $ の中の文字のうち過半数が同じ文字であるとき、$ t $ を<em>アンバランス</em>であると呼ぶことにします。例えば、<code>voodoo</code> や <code>melee</code> はアンバランスであり、<code>noon</code> や <code>a</code> はアンバランスではありません。</p><p>小文字のアルファベットからなる文字列 $ s $ が与えられます。$ s $ にアンバランスな (連続する) 部分文字列が存在するか判定してください。存在する場合は、$ s $ の中でそのような部分文字列が存在する位置を一つ示してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ s $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>$ s $ にアンバランスな部分文字列が存在しない場合は、<code>-1 -1</code> と出力せよ。</p><p>$ s $ にアンバランスな部分文字列が存在する場合は、そのような部分文字列の一つを $ s_a\ s_{a+1}\ …\ s_{b} $ $ (1\ ≦\ a\ &lt;\ b\ ≦\ |s|) $ として、<code>$ a $ $ b $</code> と出力せよ。そのような部分文字列が複数存在する場合は、いずれも正解とみなされる。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">needed</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 5</span><br></pre></td></tr></table></figure><h2 id="样例-2-4">样例 #2</h2><h3 id="样例输入-2-4">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">atcoder</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 2\ ≦\ |s|\ ≦\ 10^5 $</li><li>$ s $ は小文字のアルファベットのみからなる。</li></ul><h3 id="部分点">部分点</h3><ul><li>$ 2\ ≦\ |s|\ ≦\ 100 $ を満たすデータセットに正解した場合は、$ 200 $ 点が与えられる。</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>文字列 $ s_2\ s_3\ s_4\ s_5 $ $ = $ <code>eede</code> はアンバランスな文字列です。他にもアンバランスな部分文字列は存在し、例えば <code>2 6</code> と出力しても正解となります。</p><h3 id="Sample-Explanation-2-4">Sample Explanation 2</h3><p>文字列 <code>atcoder</code> はアンバランスな部分文字列を持ちません。</p></blockquote><h2 id="思路-4">思路</h2><p>思维题吧，反正我是没什么思维qwq。</p><p>引用这位大佬的文章：[题解 AT2020 【<a href="https://www.luogu.com.cn/article/55sca778">ARC059B] アンバランス / Unbalanced】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><p>思路大致如下，与其它题解的差不多：</p><blockquote><p>从字符串的开头搜索到结尾，如果该字符串与后面一个或者后面第二个是相同的，那么该字符与跟它相同的就是一个符合题目要求的子序列。</p></blockquote><blockquote><p>例如$IIIAM$，虽然$IIIAM$是一个符合要求的子序列，但是$II$也符合，所以直接输出$II$就可以了。</p></blockquote><blockquote><p>再举一个例子：$IOIII$，它本身就是一个符合要求的子序列，但是，最前面的是$IOI$ ，所以可以得出结论，答案不是两个长度的子序列就是三个长度的子序列。</p></blockquote></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    string s;cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="comment">//判断第i项与第i+1项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">1</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断第i项与第i+2项是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[i+<span class="number">2</span>])&#123;</span><br><span class="line">            cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i+<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ABC042</title>
      <link href="/posts/89c2c377.html"/>
      <url>/posts/89c2c377.html</url>
      
        <content type="html"><![CDATA[<p>要开始加训了！！！不然太菜找不到队友了┭┮﹏┭┮</p><hr><blockquote><h1 id="ABC042A-和風いろはちゃんイージー">[ABC042A] 和風いろはちゃんイージー</h1><h2 id="题面翻译">题面翻译</h2><p>给出三个数$A,B,C$，$1≤A,B,C≤10$，判断$A,B,C$是否能重新排列为$575$。</p><p>翻译由<a href="https://www.luogu.com.cn/user/793625">$@PCT2506$</a>提供</p><h2 id="题目描述">题目描述</h2><p>日本の誇る美しいリズムとして、五七五というものがあります。いろはちゃんは五七五が大好きです。</p><p>$ 3 $ つの文節の並びの長さがそれぞれ $ 5,7,5 $ となるようにこの順番で並んでいるとき、その $ 3 $ つの文節の並びは五七五であると言います。</p><p>並び替えたい $ 3 $ つの文節の長さを表す整数 $ A,B,C $ が与えられるので、それらの文節を並び替えて五七五にできるか判定してください。</p><h2 id="输入格式">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ A $ $ B $ $ C $</p></blockquote><h2 id="输出格式">输出格式</h2><p>文節の並びを五七五にすることができるなら <code>YES</code> 、そうでないなら <code>NO</code> を出力せよ。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br></pre></td></tr></table></figure><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 7 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><h3 id="制約">制約</h3><ul><li>$ 1≦A,B,C≦10 $</li></ul><h3 id="Sample-Explanation-1">Sample Explanation 1</h3><p>与えられる文節の長さはそれぞれ $ 5,5,7 $ であり、$ 5,7,5 $ となるように文節を並び替えることができます。したがって、文節の並びを五七五にすることは可能といえます。</p></blockquote><h2 id="思路">思路</h2><p>直接统计5和7的个数判断即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> cnt5=<span class="number">0</span>,cnt7=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">5</span>)cnt5++;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">7</span>)cnt7++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt5==<span class="number">2</span>&amp;&amp;cnt7==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ABC042B-文字列大好きいろはちゃんイージー">[ABC042B] 文字列大好きいろはちゃんイージー</h1><h2 id="题面翻译-2">题面翻译</h2><p>题目描述：<br>有n个长为L的字符串</p><p>要求把他们按照字典序进行排序并在一行内输出</p><p>输入格式：<br>第一行两个正整数n，L<br>以下n行每行一个字符串</p><p>输出格式：<br>仅一行：排序过后的字符串</p><p>（注 ： 这次岛国的题末尾可以不换行）</p><p><s>输入输出不敲了</s></p><p>说明：约定：</p><p>1，1 &lt;= n,L &lt;= 100且n，L 都是正整数</p><p>2，对于第i(1 &lt;= i &lt;= n)个字符串，保证长度为L</p><p>3，所有字符串都由小写字母构成</p><p>感谢@lsy263  提供的翻译</p><h2 id="题目描述-2">题目描述</h2><p>いろはちゃんは 長さ $ L $ の文字列を $ N $ 個持っており、それぞれ $ S_1,\ S_2,\ …,\ S_N $ です。</p><p>それらの文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを求めてください。</p><p>なお、ある文字列 $ s=s_1s_2s_3 $…$ s_n $ と $ t=t_1t_2t_3 $…$ t_m $ について、以下のどちらかを満たすとき、辞書順比較で $ s\ &lt;\ t $ であるといいます。</p><ul><li>ある整数 $ i(1≦i≦min(n,m)) $ に関して、 $ 1≦j\ &lt;\ i $ を満たす任意の整数 $ j $ において $ s_j\ =\ t_j $ が成立し、かつ $ s_i\ &lt;\ t_i $ が成立する。</li><li>任意の整数 $ i(1≦i≦min(n,m)) $ に関して $ s_i\ =\ t_i $ が成立し、かつ $ n\ &lt;\ m $ が成立する。</li></ul><h2 id="输入格式-2">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ L $ $ S_1 $ $ S_2 $ : $ S_N $</p></blockquote><h2 id="输出格式-2">输出格式</h2><p>与えられる文字列を好きな順番で全て結合してできる文字列のうち、もっとも辞書順で小さいものを出力せよ。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">dxx</span><br><span class="line">axx</span><br><span class="line">cxx</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">axxcxxdxx</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><h3 id="制約-2">制約</h3><ul><li>$ 1\ ≦\ N,\ L\ ≦\ 100 $</li><li>全ての $ i\ (1≦i≦N) $ に対し、$ S_i $ の長さは $ L $ に等しい。</li><li>各 $ i $ について, $ S_i $ は全て半角英小文字のみから成る文字列である。</li></ul><h3 id="Sample-Explanation-1-2">Sample Explanation 1</h3><p>与えられた文字列を <code>axx</code>,<code>cxx</code>,<code>dxx</code> という順番に並び替えてから結合することで、辞書順最小を達成できます。</p></blockquote><h2 id="思路-2">思路</h2><p>直接排序即可，其实cmp函数可以不用写的</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,l=<span class="number">0</span>;cin&gt;&gt;n&gt;&gt;l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cout&lt;&lt;s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到题解区有大佬用了优先队列，可以看看qwq</p><p>[题解 AT1978 【<a href="https://www.luogu.com.cn/article/8um5juk5">ABC042B] 文字列大好きいろはちゃんイージー / Iroha Loves Strings (ABC Edition)】 - 洛谷专栏 (luogu.com.cn)</a></p><blockquote><h1 id="ARC058C-こだわり者いろはちゃん">[ARC058C] こだわり者いろはちゃん</h1><h2 id="题面翻译-3">题面翻译</h2><p>买家想买一个价格为N的物品，但他又讨厌k个数字，分别为D_1，D_2，……，D_K。问他最少出多少钱，才能在保证买下这个物品的同时使自己出的钱不包括自己讨厌的数字。</p><h2 id="题目描述-3">题目描述</h2><p>いろはちゃんはこだわりもので、嫌いな数字が $ K $ 個あり、それぞれ $ D_1,\ D_2,\ …,\ D_K $ です。</p><p>いろはちゃんはお店でお買い物をしていて、 $ N $ 円の品物を買おうとしています。 もちろん、この品物は $ N $ 円以上のお金を支払えば買うことができます。 しかし、先ほど述べたようにいろはちゃんは強いこだわりがあるので、自分がお店に支払う金額の $ 10 $ 進表記にいろはちゃんの嫌いな数字が出現しないような最も少ない金額を支払おうとします。</p><p>いろはちゃんが支払う金額を求めてください。</p><h2 id="输入格式-3">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ N $ $ K $ $ D_1 $ $ D_2 $ … $ D_K $</p></blockquote><h2 id="输出格式-3">输出格式</h2><p>いろはちゃんが支払う金額を出力せよ。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000 8</span><br><span class="line">1 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><h2 id="样例-2-2">样例 #2</h2><h3 id="样例输入-2-2">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999</span><br></pre></td></tr></table></figure><h2 id="提示-3">提示</h2><h3 id="制約-3">制約</h3><ul><li>$ 1\ ≦\ N\ &lt;\ 10000 $</li><li>$ 1\ ≦\ K\ &lt;\ 10 $</li><li>$ 0\ ≦\ D_1\ &lt;\ D_2\ &lt;\ …\ &lt;\ D_K≦9 $</li><li>$ {D_1,D_2,…,D_K}\ ≠\ {1,2,3,4,5,6,7,8,9} $</li></ul><h3 id="Sample-Explanation-1-3">Sample Explanation 1</h3><p>嫌いでない数字は $ 0 $ と $ 2 $ のみです。 $ N=1000 $ 以上の整数で、桁に $ 0 $ と $ 2 $ のみが含まれる最小の整数は $ 2000 $ なのでそれを出力してください。</p></blockquote><h2 id="思路-3">思路</h2><p>这题想复杂了，其实直接枚举即可，从$n$开始向上枚举，并将其进行逐位拆分，判断其中是否出现讨厌的数字即可。注意如果出现0的话，直接退出循环，输出$num$即可</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//开个桶记录一下讨厌的数字</span></span><br><span class="line">        a[x]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        num=n;</span><br><span class="line">        <span class="comment">//进行逐位拆分，判断是否出现讨厌的数字</span></span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[num%<span class="number">10</span>])<span class="keyword">break</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为0，说明拆分完毕，满足要求</span></span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//否则，说明存在讨厌的数字，继续向上枚举</span></span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h1 id="ARC058D-いろはちゃんとマス目">[ARC058D] いろはちゃんとマス目</h1><h2 id="题面翻译-4">题面翻译</h2><h3 id="题意">题意</h3><p>有一个 $H\times W$ 的矩阵, 现在你正位于左上角的格子, 并且你只能向右移动或向下移动, 不幸的是, 矩阵的左下角 $A\times B$ 的地方被划为了禁区, 即你不能在此行走, 那么现在你有多少种方法从左上角走到右下角的格子呢?</p><h3 id="输入">输入</h3><p>一行四个整数 $H,W,A,B$.</p><h3 id="输出">输出</h3><p>方案数. 由于方案数很大, 请对 $10^9+7$ 取模.</p><p>感谢@凌幽 提供的翻译</p><h2 id="题目描述-4">题目描述</h2><p>縦 $ H $ マス、横 $ W $ マスのマス目があります。 いろはちゃんは、今一番左上のマス目にいます。 そして、右か下に1マス移動することを繰り返し、一番右下のマス目へと移動します。 ただし、下から $ A $ 個以内、かつ左から $ B $ 個以内のマス目へは移動することは出来ません。</p><p>移動する方法は何通りあるか求めてください。</p><p>なお、答えは非常に大きくなることがあるので、答えは $ 10^9+7 $ で割ったあまりを出力してください。</p><h2 id="输入格式-4">输入格式</h2><p>入力は以下の形式で標準入力から与えられる。</p><blockquote><p>$ H $ $ W $ $ A $ $ B $</p></blockquote><h2 id="输出格式-4">输出格式</h2><p>移動する方法の数を $ 10^9+7 $ で割ったあまりを出力せよ。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2-3">样例 #2</h2><h3 id="样例输入-2-3">样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 7 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3">样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3570</span><br></pre></td></tr></table></figure><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 99999 99999</span><br></pre></td></tr></table></figure><h3 id="样例输出-3">样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4">样例 #4</h2><h3 id="样例输入-4">样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 100000 44444 55555</span><br></pre></td></tr></table></figure><h3 id="样例输出-4">样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">738162020</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="制約-4">制約</h3><ul><li>$ 1\ ≦\ H,\ W\ ≦\ 100,000 $</li><li>$ 1\ ≦\ A\ &lt;\ H $</li><li>$ 1\ ≦\ B\ &lt;\ W $</li></ul><h3 id="Sample-Explanation-1-4">Sample Explanation 1</h3><p>$ 2×3 $ マスありますが、左下の $ 1 $ マスには移動することができません。「右右下」、「右下右」という $ 2 $ つの移動の仕方があります。</p><h3 id="Sample-Explanation-2">Sample Explanation 2</h3><p>移動できないマスが $ 12 $ マスあります。</p></blockquote><h2 id="思路-4">思路</h2><p>其实是一道数学题，思路不难想，大致有两种：</p><p>1、从$(1,1)$到$(a-1,b)$，再从$(a-1,b+1)$到$(h,w)$走，具体怎么算？其实就是高中的组合数学。</p><p>2、先考虑从$(1,1)$到$(h,w)$的所有路径数，记作$ans1$，不考虑任何要求。然后我们再考虑可能经过禁区的路径数：这时，问题相当于在前$a+b-2$步中，向下走的步数大于或等于$b-2$步，那我们只需要计算对应的每种情况：当走完向下走完$i$步时，且走完前$a+b-2$步时的所有路径数，并从当前位置开始，重新计算到$(h,w)$的所有路径数，注意两者需要一一对应相乘，然后把所有不合法的情况统计起来，记作$ans2$。那么答案就是$ans1-ans2$。</p><p>这里先贴上大佬的代码，自己写的没过qwq，而且大佬们的板子也挺漂亮的，可以整理作为自己的板子。</p><h3 id="思路1">思路1</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll fac[MAXN],inv[MAXN];</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qpower</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>)ans=(ans*a)%mod;</span><br><span class="line">        a=(a*a)%mod;</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n==m||m==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((fac[n]*inv[m])%mod*inv[n-m]%mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">get</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(x2+y2-x1-y1,x2-x1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> h,w,a,b;cin&gt;&gt;h&gt;&gt;w&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//注意记得初始化哦</span></span><br><span class="line">    fac[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算阶乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200000</span>;i++)&#123;</span><br><span class="line">        fac[i]=(i*fac[i<span class="number">-1</span>])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[<span class="number">200000</span>]= <span class="built_in">qpower</span>(fac[<span class="number">200000</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">199999</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">        inv[i]=(inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>))%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=h-a;i++)&#123;</span><br><span class="line">        ans+=<span class="built_in">get</span>(<span class="number">1</span>,<span class="number">1</span>,i,b)*<span class="built_in">get</span>(i,b+<span class="number">1</span>,h,w)%mod;</span><br><span class="line">        <span class="comment">//注意这里还需要取模哦</span></span><br><span class="line">        ans%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2">思路2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = b; i; i &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i &amp; <span class="number">1</span>) res = (<span class="type">long</span> <span class="type">long</span>)res * a % mod;</span><br><span class="line">a = (<span class="type">long</span> <span class="type">long</span>)a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算组合数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n == m || m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span> <span class="type">long</span>)jc[n] * inv[m] % mod * inv[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>() - <span class="number">1</span>; m = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">a = n - <span class="built_in">read</span>() + <span class="number">1</span>; b = <span class="built_in">read</span>() - <span class="number">1</span>;</span><br><span class="line">jc[<span class="number">0</span>] = inv[<span class="number">0</span>] = <span class="number">1</span>; k = n + m + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求阶乘</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">jc[i] = (<span class="type">long</span> <span class="type">long</span>)jc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//费马小定理求逆元</span></span><br><span class="line">    inv[k] = <span class="built_in">qpow</span>(jc[k], mod - <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递推方法求逆元</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = k - <span class="number">1</span>; i; --i)</span><br><span class="line">inv[i] = (<span class="type">long</span> <span class="type">long</span>)inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算所有的情况</span></span><br><span class="line">    ans = <span class="built_in">c</span>(n + m, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减去走入禁区的情况</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt;= b; ++i)</span><br><span class="line">ans = (ans - (<span class="type">long</span> <span class="type">long</span>)<span class="built_in">c</span>(a + b, i) * <span class="built_in">c</span>(n + m - a - b, m - i) % mod * now + mod) % mod;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">write</span>(ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 累了~就打打Atcoder吧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ABC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧拉定理</title>
      <link href="/posts/f0e90591.html"/>
      <url>/posts/f0e90591.html</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧拉定理">拓展欧拉定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33): 拓展欧拉定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p>先介绍一下<strong>欧拉定理</strong>：</p><blockquote><p>若正整数$a$与$m$互质，则$a^{\varphi(m)}\equiv 1(mod\ m)$。</p></blockquote><p>这里的$\varphi (m)$指的是欧拉函数，即小于或等于$m$且与$m$互质的正整数个数。当$m$是质数 $p$时，欧拉定理退化成费马小定理$a^{p-1}\equiv1(mod\ p)$ 。</p><p>在算法竞赛中，我们常常会用到它的一个重要的推论：若正整数$a$与$m$互质，则</p><p>$a^b\equiv a^{b\ mod\ \varphi(m)}(mod\ m)$。</p><p>（这是因为$a^b=a^{\varphi(m)\lfloor b/\varphi(m)\rfloor+b\ mod\  \varphi (m)}\equiv 1·a^{b\ mod\ \varphi(m)}(mod\ m)$）</p><p>利用这个推论，即使$b$比较大，我们也可以轻松地算出$a^b\ mod\ m$的值，但需要满足$a$与$m$互质的前提。</p><hr><p>为了解决$a$与$m$不互质时的问题，我们引入了<strong>拓展欧拉定理</strong>：若$b\geq\varphi(m)$，则：$a^b\equiv a^{b\ mod\ \varphi(m)+varphi(m)}\ (mod\ m)\ (*)$</p><p>这里仍有前提条件，但影响不大，因为$b\leq\varphi (m)$时直接用快速幂计算即可。</p><p>当$a$与$m$<strong>互质</strong>时，由于$a^b\equiv a^{b\ mod\ \varphi(m)}·1\equiv a^{b\ mod\ \varphi(m)}·a^{\varphi(m)}\ (mod\ m)\ (*)$式显然成立。</p><p>当$a$与$m$<strong>不互质</strong>时，我们考虑吧$m$<strong>质因数分解</strong>成${p_1}^{q_1}{p_2}^{q_2}······{p_n}^{q_n}$，我们只需要证明的每个${p_i}^{q_i}$，都有$a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}(mod\ {p_i}^{q_i})$即可。因为如果设$m_1、m_2$互质，且$x\equiv y\ (mod\ m_1)$同时$x\equiv y\ (mod\ m_2)$，则$x\equiv y(mod\ m_1m_2)$必成立（$x-y$既是$m_1$的倍数又是$m_2$的倍数），所以这里可以进行合并。</p><p>现在分类讨论${p_i}^{q_i}$：</p><p>若$gcd(a,{p_i}^{q_i})=1$，则：</p><p>$a^b\equiv a^{\lfloor b/\varphi(m)\rfloor\varphi(m)+b\ mod\ \varphi(m)}\equiv a^{b\ mod\ \varphi(m)}(mod\ {p_i}^{q_i})$</p><p>（注意到$\lfloor b/\varphi(m)\rfloor\varphi(m)$必然是$\varphi ({p_i}^{q_i})$的倍数，因为欧拉函数是<strong>积性函数</strong>）</p><p>若$gcd(a,{p_i}^{q_i})\ne1$，则$a$必然是$p$的倍数。设$a=np$，注意到$\varphi({p_i}^{q_i})={p_i}^{q_i-1}(p_i-1)$，则可以证明$\varphi ({p_i}^{q_i}\geq q_i)$。则：</p><p>$b\geq \varphi(m) \geq \varphi({p_i}^{q_i})\geq q_i$</p><p>所以${p_i}^{q_i}$是$a^{b\ mod\ \varphi (m)+\varphi(m)}$的因数，也是$a^b$的因数，即：</p><p>$a\equiv a^{b\ mod\ \varphi(m)+\varphi(m)}\equiv 0(mod\ {p_i}^{q_i})$</p><p>综上，$a^b\equiv a^{b\ mod\ \varphi(m)+\varphi(m)(mod\ m)}(b\geq\varphi(m))$</p><p>代码实现时可以边读入边取模，另外一定要注意这个式子仅在$b\geq \varphi(m)$时成立。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> large_enough = <span class="literal">false</span>; <span class="comment">// 判断是否有b &gt;= phi(m)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">(<span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>)</span> <span class="comment">// 快速读入稍加修改即可以边读入边取模，不取模时直接模一个大于数据范围的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c))</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &gt;= MOD)</span><br><span class="line">        &#123;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">            large_enough = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> <span class="comment">// 求欧拉函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n, <span class="type">int</span> MOD)</span> <span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = <span class="number">1LL</span> * ans * a % MOD; <span class="comment">// 注意防止溢出</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = <span class="number">1LL</span> * a * a % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), phiM = <span class="built_in">phi</span>(m), b = <span class="built_in">read</span>(phiM);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qpow</span>(a, b + (large_enough ? phiM : <span class="number">0</span>), m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>关于欧拉定理的证明我就不放上来了，实在是太难了┭┮﹏┭┮，如果感兴趣的话可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/131536831">算法学习笔记(33): 拓展欧拉定理 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卢卡斯定理</title>
      <link href="/posts/16810717.html"/>
      <url>/posts/16810717.html</url>
      
        <content type="html"><![CDATA[<h1 id="卢卡斯定理">卢卡斯定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr><p><strong>卢卡斯定理</strong>是一个与组合数有关的数论定理，在算法竞赛中用于求组合数对某质数的模。</p><p>这里接下来直接介绍卢卡斯定理，原文章的引入和证明不会涉及qwq。如果想看的话可以看看原作者的文章：<a href="https://zhuanlan.zhihu.com/p/116698264">算法学习笔记(25): 卢卡斯定理 - 知乎 (zhihu.com)</a></p><hr><p>直接根据定义$\binom{m}{n}=\frac{m!}{n!(m-n)!}$计算，很容易溢出，当然我们可以边乘边除，但有点麻烦。于是我们有另外一种思路，利用递推式：$\binom{m}{n}=\binom{m-1}{n-1}+\binom{m-1}{n}$（这个递推式可以从杨辉三角中得到），这种方法相对不容易溢出，时间复杂度为$O(n^2)$。</p><p>但是，然而，实际上，组合数的增长速度是非常快的，如$\binom{300}{150}$则有89位数字，比宇宙中的原子数还多。所谓递推不容易溢出，那如果结果本身就溢出了，你又怎么办呢？</p><p>所幸算法竞赛中的题目常常会要求将结果对某个质数$p$取模，这样一来，溢出的问题就不用太担心了。我们干脆直接回到最原始的方法：$\binom{m}{n}=\frac{m!}{n!(m-n)!}$。只不过，现在我们要把除法变成求<a href="https://zhuanlan.zhihu.com/p/100587745">逆元</a>，也即：$\binom{m}{n}=m!·inv(n!)·inv[(m-n)!](mod\ p)$。</p><p>模$p$ 意义下阶乘和逆元都可以$O(n)$预处理出来，然后直接$O(1)$查询即可（实际上不预处理逆元直接$O(log\ n)$求也绰绰有余）。这基本上是<strong>最常用</strong>的求组合数方法。</p><p>绕了一圈，怎么还没提到卢卡斯定理呢？嗯……一般来说，这个方法够用了。偏偏，有时候，$p$可能比$m$小……</p><p>这下麻烦了。如果$p$比$m$小，就不能保证$n$和$m-n$的逆元存在了（它们可能是$p$的倍数）。当然还是可以用杨辉三角递推，但$O(n^2)$还是太不理想。于是，本文的主角——卢卡斯定理终于要出场了。</p><hr><h2 id="卢卡斯定理-2">卢卡斯定理</h2><blockquote><p>对于非负整数$m,n$和质数$p$ ，$\binom{m}{n}\equiv \prod_{i=0}^k \binom{m_i}{n_i}(mod\ p)$ ，其中$m=m_kp^k+······+m_1p+m_0、n=n_kp^k+······+n_1p+n_0$是$m$和$n$的 $p$进制展开。</p></blockquote><p>但其实，我们一般使用的是这个可以与之互推的式子：</p><blockquote><p>$\binom{m}{n}=\binom{m\ mod\ p}{n\ mod\ p}·\binom{\lfloor m/p \rfloor}{\lfloor n/p \rfloor}(mod\ p)$</p></blockquote><p>当$m&lt;n$时，规定$\binom{m}{n}=0$（待会讲这个定义的含义）。</p><p>就像辗转相除法那样，可以利用这个式子递归求解，递归出口是 $n=0$。其实这篇文章只需要这个好记的公式就够了，你甚至可以马上写出卢卡斯定理的板子：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要先预处理出fact[]，即阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m &lt; n ? <span class="number">0</span> : fact[m] * <span class="built_in">inv</span>(fact[n], p) % p * <span class="built_in">inv</span>(fact[m - n], p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">lucas</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> % p : <span class="built_in">lucas</span>(m / p, n / p, p) * <span class="built_in">C</span>(m % p, n % p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为$O(p+log_p\ m)$，前提是：</p><p>阶乘和逆元都采取递推的方式预处理出来，（只需要预处理$p$以内的即可），每次调用$C$函数都是$O(1)$，一共要调用$log_p\ m$次，总的时间复杂度即为$O(p+log_p\ m)$。</p><hr><p>没想到吧o(*≧▽≦)ツ，全文只需要这个代码模板即可（ε=ε=ε=┏(゜ロ゜;)┛逃）。</p><p>定理的证明maybe以后会补充？？？因为都是数学符号，看得有点烦了。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉函数</title>
      <link href="/posts/f60286b9.html"/>
      <url>/posts/f60286b9.html</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉函数">欧拉函数</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><h2 id="欧拉函数的引入及性质">欧拉函数的引入及性质</h2><p>**欧拉函数$\varphi(x)$**是一个非常重要的函数，它定义为小于（或不大于，这里是一样的）$x$但与$x$互质的正整数的数量，例如$\varphi (12)=4$，有1、5、7、11与之互质。特别地，规定$\varphi (1)=1$。</p><p>主要性质如下：</p><blockquote><p>若$p$是质数，则$\varphi (p^n)=p^{n-1}(p-1)$</p><p>若$a|x$，则$\varphi (ax)=a\varphi (x)$</p><p>若$a、b$互质，则$\varphi(a)\varphi(b)=\varphi(ab)$</p><p>（这里跳过证明，想要看证明的可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/108422764">算法学习笔记(18): 欧拉函数 - 知乎 (zhihu.com)</a>）（也许我自己以后会补充？）</p></blockquote><p>注意：符合第三个性质的函数称为积性函数。</p><hr><p>我们把正整数<strong>质因数分解</strong>：</p><p>$x={p_1}^{k_1}{p_2}^{k_2}······{p_n}^{k_n}$。</p><p>所有${p_i}^{k_i}$两两互质，由欧拉函数的性质得：</p><p>$\varphi (x)={p_1}^{k_1-1}(p_1-1){p_2}^{k_2-1}(p_2-1)······{p_n}^{k_n-1}(p_n-1)$.</p><p>即：</p><p>$\varphi (x)=x·\frac{p_1-1}{p_1}·\frac{p_2-1}{p_2}······\frac{p_n-1}{p_n}$</p><p>我们可以利用这个方法以最坏的时间复杂度$O(\sqrt{n})$内求出指定正整数的欧拉函数值。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>); <span class="comment">// 先除再乘防止溢出</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) <span class="comment">// 每个质因数只处理一次，可以把已经找到的质因数除干净</span></span><br><span class="line">            n /= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        res = res / n * (n - <span class="number">1</span>); <span class="comment">// 最后剩下的部分也是原来的n的质因数</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>我们还可以把求欧拉函数与<strong>筛法</strong>结合起来，例如用类似埃氏筛的方法，求1~n的欧拉函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> phi[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        phi[i] = i; <span class="comment">// 除1外没有数的欧拉函数是本身，所以如果phi[i] = i则说明未被筛到</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (phi[i] == i) <span class="comment">// 未被筛到</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) <span class="comment">// 所有含有该因子的数都进行一次操作</span></span><br><span class="line">                phi[j] = phi[j] / i * (i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以保证范围内每个数都能被它的所有质因数筛且只筛一次。注意一个正整数$x$是质数的充要条件是</p><p>$\varphi (x)=x-1$，所以我们其实顺便求出了所有的素数。这个方法的时间复杂度是$O(nloglog\ n)$，比一个一个求的$O(n\sqrt{n})$更好。</p><p>当然也可以在欧拉筛途中顺便求出：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i), phi[i] = i - <span class="number">1</span>; <span class="comment">// 性质一，指数为1的情形</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                phi[p * i] = phi[i] * p; <span class="comment">// 性质二</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                phi[p * i] = phi[p] * phi[i]; <span class="comment">// 这时肯定互质，用性质三</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里没有进行质因数分解，综合运用了开头提到的三种性质，时间复杂度为$O(n)$ 。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二次剩余</title>
      <link href="/posts/98066e3c.html"/>
      <url>/posts/98066e3c.html</url>
      
        <content type="html"><![CDATA[<p>还没写好，可能这几天补好</p><hr><h1 id="二次剩余">二次剩余</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/166123245">算法学习笔记(41): 二次剩余 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p><strong>二次剩余</strong>，常被称为模意义开根，是求满足$n\equiv x^2(mod\ m)$的$x$的值。</p><p>首先需要注意，并不是对每个$n$而言上面的方程都有解。如果上面的方程有非零解，我们称$n$是模$m$的<strong>二次剩余</strong>。如果方程无解，则称$n$是模$m$的<strong>二次非剩余</strong>。</p><p>为了方便讨论，我们引入<strong>勒让德符号</strong>：</p><p>$ (\frac{a}{b})=\left{<br>\begin{aligned}<br>1     &amp;  , 如果a是p的二次剩余\<br>0     &amp;  , 如果a\ mod\ p=0\<br>{-1}  &amp;  , 如果a是p的二次非剩余<br>\end{aligned}<br>\right.<br>$</p><p>接下来讨论如何求解二次剩余，一般只考虑奇素数的情况。</p><hr><h2 id="欧拉准则">欧拉准则</h2><p>当模数是奇素数$p$且与$a$互质时，由费马小定理，$a^{p-1}\equiv1\ (mod\ p)$，设$p=2q+1$，</p><p>则有$a^{2q}\equiv 1\ (mod\ p)$，于是$(a^q-1)(a^q+1)\equiv 0\ (mod\ p)$，故$a^q\equiv \pm1 (mod\ p)$，即$a^{\frac{p-1}{2}}\equiv\pm1\ (mod\ p)$。</p><p>所以只要$a、p$互质，$a^{\frac{p-1}{2}}$在模$p$意义下就只可能等于$1$或${-1}$。到底是$1$还是${-1}$，这与二次剩余紧密相关，实际上，有以下公式：</p><blockquote><p>$(\frac{a}{p})\equiv a^{\frac{p-1}{2}}(mod\ p)$</p></blockquote><p>以上公式被称为<strong>欧拉准则</strong>，我们只需要计算$a^{\frac{p-1}{2}}$即可判断$a$是否为$p$的二次剩余。</p><hr><p>这里实际上有一个<strong>证明</strong>：“$a$是模$p$的二次剩余”是&quot;$a^{\frac{p-1}{2}}\equiv 1(mod\ p)$&quot;的充要条件。</p><p>但是目前没时间写，可能过两天再写。咕咕咕</p><hr><p>由此可以有一个推论：当$\frac{p-1}{2}$是奇数时，如果$a$是模$p$的二次剩余，则${-a}$是mo$p$的二次非剩余。相反，当$\frac{p-1}{2}$是偶数时，如果$a$是模$p$的二次剩余，则${-a}$也是模$p$的二次剩余。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欧拉筛</title>
      <link href="/posts/96683d0c.html"/>
      <url>/posts/96683d0c.html</url>
      
        <content type="html"><![CDATA[<h1 id="欧拉筛">欧拉筛</h1><p>文章部分内容转载自<a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 - 知乎 (zhihu.com)</a>、<a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏 (luogu.com.cn)</a>，如有侵权，请联系作者删除。</p><hr><p>不想再写一遍原理了qwq（如果忘记原理就去看看大佬们的详细证明吧，感觉注释也说得很清楚了@w@）。</p><p><a href="https://zhuanlan.zhihu.com/p/100051075">算法学习笔记(17): 素数筛 - 知乎 (zhihu.com)</a></p><p><a href="https://www.luogu.com.cn/article/mpwf8pd3">欧拉筛筛素数 - 洛谷专栏 (luogu.com.cn)</a></p><p>所以我就直接贴上欧拉筛的模板了。</p><hr><blockquote><h1 id="【模板】线性筛素数">【模板】线性筛素数</h1><h2 id="题目背景">题目背景</h2><p>本题已更新，从判断素数改为了查询第 $k$ 小的素数<br>提示：如果你使用  <code>cin</code> 来读入，建议使用 <code>std::ios::sync_with_stdio(0)</code> 来加速。</p><h2 id="题目描述">题目描述</h2><p>如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。</p><h2 id="输入格式">输入格式</h2><p>第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。</p><p>接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。</p><h2 id="输出格式">输出格式</h2><p>输出 $q$ 行，每行一个正整数表示答案。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【数据范围】<br>对于 $100%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。</p><p>Data by NaCly_Fish.</p></blockquote><p><strong>学委大佬的代码</strong>：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> isPrime[N];<span class="comment">//isPrime[i]==1表示：i是质数</span></span><br><span class="line"><span class="type">int</span> Prime[N], cnt = <span class="number">0</span>;<span class="comment">//Prime存质数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isPrime, <span class="number">1</span>, <span class="built_in">sizeof</span>(isPrime));</span><br><span class="line"><span class="comment">//以“每个数都是素数”为初始状态，逐个删去</span></span><br><span class="line">isPrime[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//1不是素数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (isPrime[i]) &#123;<span class="comment">//没被筛掉</span></span><br><span class="line">Prime[++cnt] = i;<span class="comment">//i成为下一个素数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * Prime[j] &lt;= n; j++) &#123;</span><br><span class="line"><span class="comment">//从Prime[1]，即最小质数2开始，逐个枚举已知的质数，并期望Prime[j]是(i*Prime[j])的最小质因数</span></span><br><span class="line"><span class="comment">//当然，i肯定比Prime[j]大，因为Prime[j]是在i之前得出的</span></span><br><span class="line">isPrime[i * Prime[j]] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i % Prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="built_in">getPrime</span>(n);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; Prime[k] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>pecco</strong>大佬的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isnp[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes; <span class="comment">// 质数表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])</span><br><span class="line">            primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            isnp[p * i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>两者的写法其实很相似了，如果忘记了原理，可以先看看<strong>学委大佬</strong>的，要写题的话，推荐用<strong>pecco</strong>大佬的板子。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国剩余定理</title>
      <link href="/posts/2cf738e6.html"/>
      <url>/posts/2cf738e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="中国剩余定理">中国剩余定理</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/103394468">算法学习笔记(10): 中国剩余定理 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><p><strong>中国剩余定理</strong>，也叫<strong>孙子定理</strong>，之所以叫这个名字，是因为《孙子算经》中有这样一个问题：</p><blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><p>实际上就是求解下面的<strong>同余方程组</strong>：<br>$$<br>\left{<br>\begin{aligned}<br>x &amp; \equiv b_1 &amp; (mod\ a_1)\<br>x &amp; \equiv b_2 &amp; (mod\ a_2)\<br>x &amp; \equiv b_n &amp; (mod\ a_n)<br>\end{aligned}<br>\right.<br>$$<br>这个方程组有解的一个<strong>充分条件</strong>是：$a_1、a_2······a_n$<strong>两两互质</strong>，可以使用构造法得到下面方程的通解，一下面这道模板题为例：</p><p>（<strong>洛谷P1495 曹冲养猪</strong>）</p><blockquote><p><strong>题目描述</strong><br>自从曹冲搞定了大象以后，曹操就开始捉摸让儿子干些事业，于是派他到中原养猪场养猪，可是曹冲满不高兴，于是在工作中马马虎虎，有一次曹操想知道母猪的数量，于是曹冲想狠狠耍曹操一把。举个例子，假如有16头母猪，如果建了3个猪圈，剩下1头猪就没有地方安家了。如果建造了5个猪圈，但是仍然有1头猪没有地方去，然后如果建造了7个猪圈，还有2头没有地方去。你作为曹总的私人秘书理所当然要将准确的猪数报给曹总，你该怎么办？<br><strong>输入格式</strong><br>第一行包含一个整数$n\ (n \leq10)——$建立猪圈的次数，解下来n行，每行两个整数$a_i,b_i\ (b_i\leq a_i \leq1000)$表示建立了$a_i$个猪圈，有$b_i$头猪没有去处。你可以假定$a_i,a_j$互质.<br><strong>输出格式</strong><br>输出包含一个正整数，即为曹冲至少养母猪的数目。</p></blockquote><p>(本质上就是给“物不知数”套了个背景)。</p><hr><p>我们从“物不知数”这个具体问题出发。<strong>（接下来一大波数学公式，请做好心理再看）</strong></p><p>要想直接找到一个$n$使得方程组$\left{<br>\begin{aligned}<br>x &amp; \equiv 2 &amp;(mod\ 3)\<br>y &amp; \equiv 3 &amp;(mod\ 5)\<br>z &amp; \equiv 2 &amp;(mod\ 7)<br>\end{aligned}<br>\right.<br>$ 成立时不容易的，但是要找到</p><p>$n_1,n_2,n_3$使得$\left{<br>\begin{aligned}<br>n_1 &amp; \equiv 2&amp; (mod\ 3) \<br>n_2 &amp; \equiv 3&amp; (mod\ 5) \<br>n_3 &amp; \equiv 2&amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$是相对容易的。</p><p>直接令$x=n_1+n_2+n_3$可以吗？恐怕未必。在什么情况下$n_1\equiv 2(mod\ 3)$可以推出$n_1+n_2\equiv2(mod\ 3)$呢？显然，那只有当$n_2$是3的倍数时成立。同理，要想让$n_1+n_2+n_3$也符合前式，也需要$n_2$和$n_3$都是3的倍数。</p><p>这样推导下来，$x=n_1+n_2+n_3$符合方程组的条件是$n_1$是35的倍数，$n_2$是21的倍数，$n_3$是15的倍数。也就是说，现在我们需要求三个同余方程：</p><p>$\left{<br>\begin{aligned}<br>35m_1 &amp; \equiv 2 &amp; (mod\ 3) \<br>21m_2 &amp; \equiv 3 &amp; (mod\ 5) \<br>15m_3 &amp; \equiv 2 &amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$</p><p>注意到模数两两互质，则$gcd(35,3)=gcd(21,5)=gcd(15,7)=1$，所以我们可以用拓展欧几里得的方法解（我愿称之为最妙的一步<strong>qwq</strong>，这里用的是求逆元的方法）：</p><p>$ \left{<br>\begin{aligned}<br>35w_1 &amp; \equiv 1&amp; (mod\ 3) \<br>21w_2 &amp; \equiv 1&amp; (mod\ 5)\<br>15w_3 &amp; \equiv 1&amp; (mod\ 7)<br>\end{aligned}<br>\right.<br>$</p><p>解得$w_1=2,w_2=1,w_3=1$，然后可得：$\left{<br>\begin{aligned}<br>m_1 &amp; =2w_1=4 \<br>m_2 &amp; =3w_2=3 \<br>m_3 &amp; =2w_3=2<br>\end{aligned}<br>\right.<br>$</p><p>于是：$\left{<br>\begin{aligned}<br>n_1 &amp; = 35m_1=140 \<br>n_2 &amp; = 21m_2=63 \<br>n_3 &amp; = 15m_3=30<br>\end{aligned}<br>\right.<br>$。</p><p>三者相加，即得一<strong>特解233</strong>（这里的233不是网络意义下的233，但我算出来不禁233了）。所有与233在<strong>模</strong>105<strong>意义下同余</strong>的数都是这个方程组的解，要求<strong>最小正数解</strong>只需对105取模即可，这里得出来是<strong>23</strong>。</p><hr><p>接下来将这个过程一般化（<strong>个人感觉严重劝退qwq</strong>）。设$p=\prod_{i=1}^{n}a_i$（即所有模数的乘积），并设$r_i=\frac{p}{a_i}$（在“物不知数”中即为35、21和15）。于是$w_i={inv(r_i)|}_{a_i}$（表示$r_i$在模$a_i$意义下的逆元），$m_i=b_iw_i$，而$n_i=r_im_i$，所有$n_i$相加得到$x$。</p><p>以上这些综合起来就是：</p><p>$x\equiv \sum_{i=1}^nb_ir_i{[r_i]^{-1}|}_{a_i}\ (mod\ p)$</p><p>下面贴上代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span>  <span class="comment">// a是模数数组，b是余数数组，n是数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;   <span class="comment">// 逆元的求法参见上篇文章，或者下面有完整代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回的是符合方程组的最小正整数解，一般题目要求的就是这个。</p><p>再附上曹冲养猪的完整AC代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">CRT</span><span class="params">(ll a[], ll b[], ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll p = <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        p *= a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll r = p / a[i];</span><br><span class="line">        x += (b[i] * r * <span class="built_in">inv</span>(r, a[i])) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n, a[<span class="number">10</span>], b[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, a + i, b + i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">CRT</span>(a, b, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现（其实就是照抄作者的qwq）：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[<span class="number">10</span>],b[<span class="number">10</span>];</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=(a/b)*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a,p,x,y);</span><br><span class="line">    <span class="keyword">return</span> (x%p+p)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(ll a[],ll b[],ll n)</span></span>&#123;</span><br><span class="line">    ll p=<span class="number">1</span>,x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p*=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ll r=p/a[i];</span><br><span class="line">        x+=(b[i]*r*<span class="built_in">inv</span>(r,a[i]))%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">CRT</span>(a,b,n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆元</title>
      <link href="/posts/64311e43.html"/>
      <url>/posts/64311e43.html</url>
      
        <content type="html"><![CDATA[<h1 id="逆元">逆元</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/100587745">算法学习笔记(9)：逆元 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除。</p><hr><h2 id="逆元的引入">逆元的引入</h2><p>在数论中，如果$ab\equiv1(mod\ p)$，我们就说$a$和$b$在模$p$意义下互为乘法逆元，记作$a=inv(b)$。</p><p>为什么要引入逆元？常常会遇到一些题目要求结果对一个大质数$p$取模，这是因为答案很大，出题人为了不麻烦大家写高精，就采取这样的方法。<strong>加减法</strong>和<strong>乘法</strong>对取模运算都是<strong>封闭</strong>的，所以你可以处处取模来避免溢出。</p><p><img src="https://img2.imgtp.com/2024/03/18/RqrxFVdZ.png" alt=""></p><p>但是遇到除法时，就麻烦了：</p><p><img src="https://img2.imgtp.com/2024/03/18/AdajgadB.png" alt=""></p><p>为了解决模意义下的除法问题，我们引入了逆元。$inv(a)$其实可以看作是模$p$意义下的$\frac{1}{a}$，那么在模$p$意义下，$\frac{a}{b}$就可以变成$a*inv(b)(mod\ p)$。</p><p>实际上，在模10意义下的$inv(3)=7$，所以上面的式子可以这样计算：</p><p><img src="https://img2.imgtp.com/2024/03/18/mah9Ky6H.png" alt=""></p><p>这里介绍三种计算逆元的方法：<strong>拓展欧几里得</strong>，<strong>费马小定理</strong>，<strong>线性递推</strong>。</p><hr><h2 id="拓展欧几里得">拓展欧几里得</h2><p>最常用的求逆元方法，代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span><span class="comment">// 拓欧</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exgcd</span>(a, p, x, y) != <span class="number">1</span>) <span class="comment">// 无解的情形</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> (x % p + p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="费马小定理">费马小定理</h2><p>费马小定理叙述如下：</p><blockquote><p>若$p$是质数，且$gcd(a,p)=1$，则有$a^{p-1}\equiv1(mod\ p)$</p></blockquote><p>从逆元的定义可以推导：$a*inv(a)\equiv a^{p-1}(mod\ p)$，于是有$inv(a)\equiv a^{p-2}(mod\ p)$。</p><p>于是对$a^{p-2}$算一下<strong>快速幂</strong>即可。注意：这个方法的前提是：$p$是质数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">qpow</span><span class="params">(ll a, ll n, ll p)</span><span class="comment">// 快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans % p * a % p;</span><br><span class="line">        a = a % p * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="线性递推">线性递推</h2><p>以上两种方法都是常用的求逆元方法，但是，洛谷上的这道毒瘤模板题，必须要用特殊的方法：</p><p>（<strong>洛谷P3811 【模板】乘法逆元</strong>）</p><blockquote><p><strong>题目背景</strong><br>这是一道模板题<br><strong>题目描述</strong><br>给定$n$，$p$ ，求 $1 \sim n$中所有整数在模$p$意义下的乘法逆元。<br><strong>输入格式</strong><br>一行两个正整数$n,p$。<br><strong>输出格式</strong><br>输出$n$行，第$i$行表示$i$在模$p$下的乘法逆元。</p></blockquote><p>因为这道题要求一系列的乘法逆元，而且数据范围是$1\leq n\leq 3*10^{6} $ ，常规方法是行不通的。这里介绍逆元的<strong>线性递推</strong>求法（需保证$p$是质数）。</p><p>设$p=aq+r$，即$q=\lfloor p/a \rfloor，r=p\ mod\ a$。</p><p>在模$p$意义下，有$aq+r\equiv 0\ (mod\ p)$。</p><p>整理可得：$a=-r*inv(q)\ (mod\ p)$。</p><p>那么$inv(a)=-q*inv®\ (mod\ p)$。</p><p>即：$inv(a)=-\lfloor p/a \rfloor *inv(p\ mod\ a)\ (mod\ p)$。</p><p>其实和拓展欧几里得还是有不少相似之处的。我们可以用<strong>记忆化搜索</strong>的方法，减少多次查询的时间复杂度（空间换时间）。（<strong>递推</strong>亦可，其实就这题而言递推更好）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多次对不同的p使用需要清空Inv数组</span></span><br><span class="line">ll Inv[MAXN] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mod</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a % p + p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Inv[a])</span><br><span class="line">        <span class="keyword">return</span> Inv[a];</span><br><span class="line">    Inv[a] = <span class="built_in">mod</span>(-p / a * <span class="built_in">inv</span>(p % a, p), p);</span><br><span class="line">    <span class="keyword">return</span> Inv[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>自己的实现</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>+<span class="number">10</span>;</span><br><span class="line">ll inv[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,p;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        inv[i]=(p-p/i)*inv[p%i]%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;inv[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓展欧几里得</title>
      <link href="/posts/68bc28a9.html"/>
      <url>/posts/68bc28a9.html</url>
      
        <content type="html"><![CDATA[<h1 id="拓展欧几里得">拓展欧几里得</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a></p><p>如有侵权，请联系作者删除</p><hr><h2 id="辗转相除法">辗转相除法</h2><p>在介绍拓展欧几里得算法之前，先看看<strong>欧几里得算法</strong>（又称<strong>辗转相除法</strong>）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//辗转相除法，求两个数的最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体原理这里省略，详情请参考原作者的文章：<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a></p><hr><h2 id="拓展欧几里得-2">拓展欧几里得</h2><p>拓展欧几里得是可以在<strong>辗转相除</strong>的途中求出不定方程$ax+by=c$的一组解</p><p><img src="https://img2.imgtp.com/2024/03/17/US3JbpKq.png" alt=""></p><p>可以发现：倒数第二行的$3+6<em>3=21$，可以改写成$3=6</em>(-3)+21$，也就是说：3可以被表示为6和21的线性组合。</p><p>倒数第三行，$6+21*1=27$，说明6可以被表示为21和27的线性组合，那么3也可以被表示为21和27的线性组合。具体地：</p><p>$3=6*(-3)+21=(27-21)<em>(-3)+21=27</em>(-3)+21*4$</p><p>这样一路推导下来，可以得到3表示为75和48的线性组合。那么$75x+48y=3$就能找到解了。</p><p>由上文可以得到求解$ax+by=gcd(a,b)$的一种方法。但如果$c$是其他数呢？</p><p>实际上，$c$必须是 $gcd(a,b)$的倍数，因为我们由方程 $ax+by=c$ 两边除以 $gcd(a,b)$ 可得 $\frac{a}{gcd(a,b)}x+\frac{b}{gcd(a,b)}y=\frac{c}{gcd(a,b)}$ ，方程左边当然是整数，那么方程右边也必须是整数。所以$c$是$gcd(a,b)$的倍数。</p><p>这其实上是一个数论定理：</p><blockquote><p><strong>裴蜀定理</strong></p><p>设$a、b$为正整数，则关于$x、y$的方程$ax+by=c$有整数解当且仅当$c$是$gcd(a,b)$的倍数</p></blockquote><p><img src="https://img2.imgtp.com/2024/03/17/ohJDTt3U.png" alt=""></p><p>可以发现，通过求$bx_0+(a\ mod\ b)y_0=c$的解，可以得出$ax+by=c$的解。</p><p>前者等价于$bx_0+(a-\lfloor a/b \rfloor)y_0=c$，也就是$ay_0+b(x_0-\lfloor a/b \rfloor y_0)=c$，可以对比两者的系数，可以让：<br>$$<br>\left{<br>\begin{aligned}<br>x &amp; =  y_0 \<br>y &amp; =  x_0-\lfloor a/b \rfloor y_0 \<br>\end{aligned}<br>\right.<br>$$<br>当$b==0$时递归结束即可，简化版如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x); <span class="comment">//这里交换了x和y</span></span><br><span class="line">    y -= (a / b) * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（这里其实有个普通版的，但是我偷懒了，直接搬了简化版qwq，若谷想看原版的，或者进一步探究原理的可以看看原文章：<a href="https://zhuanlan.zhihu.com/p/100567253">算法学习笔记(8)：拓展欧几里得 - 知乎 (zhihu.com)</a>）</strong></p><hr><p>这样我们求出来的$ax+by=gcd(a,b)$的一组特解，那么通解是什么？</p><p>设除了已经求出来的$x,y$之外还有一组解$x_1=x+\delta$和$y_1$，那么由$ax_1-a\delta+by==gcd(a,b)$，可以得到$ax_1+b(y-\frac{a\delta}{b})=gcd(a,b)$，可以得到：</p><p>$y_1=y-\frac{a\delta}{b}$。</p><p>注意：我们还需要保证$\delta$和$\frac{a\delta}{b}$都是整数，后者等于$\frac{a’}{b’}\delta$，其中：<br>$$<br>\left{<br>\begin{aligned}<br>a’ &amp; =  \frac{a}{gcd(a,b)} \<br>b’ &amp; =  \frac{b}{gcd(a,b)} \<br>\end{aligned}<br>\right.<br>$$<br>由于$a’、b’$互质，$\delta$应当等于$kb’$（$k$是整数），即：<br>$$<br>\left{<br>\begin{aligned}<br>x_k &amp; =  x+k*\frac{b}{gcd(a,b)} \<br>y_k &amp; =  y-k*\frac{a}{gcd(a,b)} \<br>\end{aligned}<br>\right.<br>$$<br>这就是该不定方程的解。一般题目求的符合某些条件的解。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/posts/20c47d09.html"/>
      <url>/posts/20c47d09.html</url>
      
        <content type="html"><![CDATA[<h1 id="快速幂">快速幂</h1><p>文章转载自<a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂 - 知乎 (zhihu.com)</a>，如有侵权，请联系作者删除</p><hr><p><strong>快速幂</strong>（<strong>Exponentiation by squaring</strong>，平方求幂）是一种简单而有效的小算法，它可以以$O(log_2n)$的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p><p><strong>方法1：<strong>最朴素的想法，7 * 7=49，49 * 7=343，… 一步一步算，共进行了</strong>9次</strong>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><strong>方法2：<strong>先算7的5次方，即7 * 7 * 7 * 7 * 7，再算它的平方，共进行了</strong>5次</strong>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><strong>方法3：<strong>先算7 * 7得49，则7的5次方为49 * 49 * 7，再算它的平方，共进行了</strong>4次</strong>乘法。</p><p>模仿这样的过程，我们得到一个在$O(log_2 n)$时间内计算出幂的算法，也就是快速幂。</p><hr><h2 id="递归快速幂">递归快速幂</h2><p>刚刚我们用到的，无非是一个<strong>二分</strong>的思路。我们很自然地可以得到一个递归方程：<br>$$<br>a^n=\left{<br>\begin{aligned}<br>a^n*a                               &amp;      &amp;if\ n\ is\ odd\<br>a^{\frac{n}{2}}*a^{\frac{n}{2}}     &amp;      &amp;if\ n\ is\ even\ but\ not\ 0 \<br>1                                   &amp;      &amp;if\ n\ is\ 0<br>\end{aligned} \right.<br>$$</p><p>对应的递归形式写法如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这个temp不能省略，如果写成了qpow(a,n/2) * qpow(a,n/2)，那会计算两次$a^\frac{n}{2}$，时间复杂度会退化成$O(n)$</p><p>经常会遇到取模类的问题，这里我们的应对策略是在利用快速幂进行计算时也需要取模，此时应当注意：<strong>原则是步步取模</strong>，如果mod较大，还需开<strong>long long</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归快速幂的缺点是：产生<strong>额外的空间开销</strong>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<strong>非递归快速幂</strong></p><hr><h2 id="非递归快速幂">非递归快速幂</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以$7^{10}$为例，转换为计算$7^{1010_{(2)}}$，我们可以把它拆成$7^{1000_{(2)}}$和$7^{10_{(2)}}$，由此类推，任何数都可以拆分成若干个$a^{(100···)_{(2)}}$的形式相乘，恰好对应的就是$a^1$、$a^2$、$a^4$ ······来计算，只需要<strong>不断地对底数平方即可算出它们</strong></p><p><img src="https://img2.imgtp.com/2024/03/17/HhfSbxa6.png" alt=""></p><p>可以结合代码进行理解（如果实在看不懂只能看看原作者的文章了qwq）</p><hr><h2 id="快速幂的拓展">快速幂的拓展</h2><p>快速幂算法的应用范围实际上不止于此：在计算$a^{\frac{n}{2}}$时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的非递归快速幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">qpow</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a; <span class="comment">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>此时的时间复杂度不再是$O(log_2\ n)$，此时还与底数的乘法的时间复杂度有关。</p>]]></content>
      
      
      <categories>
          
          <category> 数论大魔王 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex语法（第一弹）</title>
      <link href="/posts/ac4902f0.html"/>
      <url>/posts/ac4902f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Latex-语法">Latex 语法</h1><p>先简单整理下Latex的语法，以后会经常用到<br><a href="https://blog.csdn.net/ccnice99/article/details/127507471?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Latex%E8%AF%AD%E6%B3%95&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-2-127507471.142%5Ev99%5Epc_search_result_base6&amp;spm=1018.2226.3001.4449">【自用】【持续更新】LaTeX常用基础语法大全_latex语法-CSDN博客</a></p><h2 id="基础语法">基础语法</h2><h3 id="段落">段落</h3><h4 id="居中">居中</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;center&#125;</span><br><span class="line">要居中的内容</span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br></pre></td></tr></table></figure><h4 id="排序列表">排序列表</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 原始模板</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 自定义排序列表的编号形式</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(1)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a.]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[a)]</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="comment">% 实心圆点列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 第一小题</span><br><span class="line"><span class="keyword">\item</span> 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"><span class="comment">% 短横杠列表</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span>[-] 第一小题</span><br><span class="line"><span class="keyword">\item</span>[-] 第二小题</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文本、变量">文本、变量</h3><h4 id="加粗">加粗</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\textbf</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;A&#125;、<span class="keyword">\boldsymbol</span>&#123;我们&#125;、<span class="keyword">\textbf</span>&#123;我们&#125;、我们</span><br><span class="line">注意：boldsymbol会变斜体（可能仅限英文）</span><br></pre></td></tr></table></figure><p>$$<br>\textbf{A}、\boldsymbol{A}、\boldsymbol{我们}、\textbf{我们}、我们<br>$$</p><h4 id="斜体">斜体</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\textit&#123;我们&#125;、\it&#123;我们&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\textit{我们}、\it{我们}<br>$$</p><h4 id="向量（顶有向量箭头）">向量（顶有向量箭头）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\vec</span> v</span><br></pre></td></tr></table></figure><p>$$<br>\vec v<br>$$</p><h4 id="估计（顶有尖头hat）">估计（顶有尖头hat）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\hat</span>&#123;y&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\hat{y}<br>$$</p><h4 id="平均（顶有横线）">平均（顶有横线）</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \overline的线稍长，能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\bar</span> x ，<span class="keyword">\overline</span> x，<span class="keyword">\bar</span>&#123;AB&#125; ，<span class="keyword">\overline</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% \overline的线稍长，能覆盖所有字符<br>\bar x ，\overline x，\bar{AB} ，\overline{AB}<br>$$</p><h4 id="顶有波浪号">顶有波浪号~</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% \widetilde能覆盖所有字符</span></span><br><span class="line"><span class="keyword">\tilde</span> x ，<span class="keyword">\widetilde</span> x，<span class="keyword">\tilde</span>&#123;AB&#125; ，<span class="keyword">\widetilde</span>&#123;AB&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% \widetilde能覆盖所有字符<br>\tilde x ，\widetilde x，\tilde{AB} ，\widetilde{AB}<br>$$</p><h4 id="分式">分式</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;分子&#125;&#123;分母&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\frac{分子}{分母}<br>$$</p><h4 id="24个希腊字母">24个希腊字母</h4><p><img src="https://img2.imgtp.com/2024/03/17/9AmVbzpN.png" alt=""></p><h4 id="花体、集合手写体">花体、集合手写体</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 花体</span></span><br><span class="line"><span class="keyword">\mathcal</span>&#123;X&#125; ，<span class="keyword">\mathcal</span>&#123;Y&#125; ，<span class="keyword">\mathcal</span>&#123;D&#125;</span><br><span class="line"><span class="comment">% 集合手写体</span></span><br><span class="line"><span class="keyword">\mathbb</span>&#123;N&#125; ，<span class="keyword">\mathbb</span>&#123;Z&#125; ，<span class="keyword">\mathbb</span>&#123;R&#125; ，<span class="keyword">\mathbb</span>&#123;C&#125; ，<span class="keyword">\mathbb</span>&#123;Q&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 花体<br>\mathcal{X} ，\mathcal{Y} ，\mathcal{D}<br>$$</p><p>$$<br>% 集合手写体<br>\mathbb{N} ，\mathbb{Z} ，\mathbb{R} ，\mathbb{C} ，\mathbb{Q}<br>$$</p><h3 id="大型运算">大型运算</h3><h4 id="求和">求和</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在右边</span><br><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;i=1&#125;<span class="built_in">^</span>&#123;n&#125;x<span class="built_in">_</span>i<span class="built_in">$</span>  <span class="params">#</span> 上下标在正上、正下</span><br><span class="line"><span class="keyword">\\</span> 换行</span><br></pre></td></tr></table></figure><p>$$<br>\sum_{i=1}^{n}x_i<br>$$</p><p>$$<br>\sum\limits_{i=1}^{n}x_i<br>$$</p><p>求和符号的上下位置也可以缺省</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>i <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">^</span>n<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>\sum\limits_i \sum\limits^n<br>$$</p><h3 id="数组矩阵">数组矩阵</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 无括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="comment">% 圆括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="comment">% 单竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="comment">% 双竖线矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="comment">% 方括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="comment">% 花括号矩阵</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125;</span><br><span class="line">-1 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 2<span class="keyword">\\</span></span><br><span class="line">0 <span class="built_in">&amp;</span> 1 <span class="built_in">&amp;</span> 4<span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 无括号矩阵<br>\begin{matrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{matrix}<br>\<br>% 圆括号矩阵<br>\begin{pmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{pmatrix}<br>\<br>% 单竖线矩阵<br>\begin{vmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{vmatrix}<br>\<br>% 双竖线矩阵<br>\begin{Vmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{Vmatrix}<br>\<br>% 方括号矩阵<br>\begin{bmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{bmatrix}<br>\<br>% 花括号矩阵<br>\begin{Bmatrix}<br>-1 &amp; 1 &amp; 2\<br>0 &amp; 1 &amp; 4\<br>\end{Bmatrix}<br>$$</p><h3 id="符号">符号</h3><h4 id="属于">属于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\in</span></span><br></pre></td></tr></table></figure><p>$$<br>\in<br>$$</p><h4 id="集合之间的各种运算关系">集合之间的各种运算关系</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">A<span class="keyword">\subset</span> B</span><br><span class="line">A<span class="keyword">\supset</span> B</span><br><span class="line">A<span class="keyword">\subseteq</span> B</span><br><span class="line">A<span class="keyword">\supseteq</span> B</span><br><span class="line">A<span class="keyword">\cap</span> B</span><br><span class="line">A<span class="keyword">\cup</span> B</span><br><span class="line"><span class="comment">% A减B</span></span><br><span class="line">A<span class="keyword">\setminus</span> B</span><br><span class="line"><span class="keyword">\emptyset</span></span><br></pre></td></tr></table></figure><p>$A\subset B$     $A\supset B$     $A\subseteq B$      $A\supseteq B$     $A\cap B$     $A\cup B$     $A\setminus B$     $\emptyset$</p><h4 id="任意">任意</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\forall</span></span><br></pre></td></tr></table></figure><p>$$<br>\forall<br>$$</p><h4 id="存在">存在</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\exists</span></span><br></pre></td></tr></table></figure><p>$$<br>\exists<br>$$</p><h4 id="因为、所以">因为、所以</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\because</span> 和 <span class="keyword">\therefore</span></span><br></pre></td></tr></table></figure><p>注意：如果没有编译成功，需要在导言区导入宏包amssymb</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amssymb&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\because 和 \therefore<br>$$</p><h4 id="无穷大">无穷大</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\infty</span>+<span class="keyword">\infty</span> -<span class="keyword">\infty</span></span><br></pre></td></tr></table></figure><p>$$<br>\infty +\infty -\infty<br>$$</p><h4 id="尖括号">尖括号</h4><p>注意与小于号&lt;，大于号&gt; 区别</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\langle</span></span><br><span class="line"><span class="keyword">\rangle</span></span><br></pre></td></tr></table></figure><p>$$<br>\langle<br>\<br>\rangle<br>$$</p><h4 id="小于等于、大于等于、不等于、恒等于、恒不等于">小于等于、大于等于、不等于、恒等于、恒不等于</h4><p>巧记：等于equation，所以这几个符号都是从 <em>eq</em> 词根出发的</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\le</span> 或者 <span class="keyword">\leq</span></span><br><span class="line"><span class="keyword">\ge</span> 或者 <span class="keyword">\geq</span></span><br><span class="line"><span class="keyword">\ne</span> 或者 <span class="keyword">\neq</span></span><br><span class="line"><span class="keyword">\equiv</span></span><br><span class="line"><span class="keyword">\not</span><span class="keyword">\equiv</span>  <span class="params">#</span> 注意这里只能是拼接<span class="keyword">\not</span>和<span class="keyword">\equiv</span>，<span class="keyword">\nequiv</span>无效</span><br></pre></td></tr></table></figure><p>$\le 或者 \leq$     $\ge 或者 \geq$     $\ne 或者 \neq$     $\equiv$     $\not\equiv$</p><h4 id="远小于、远大于">远小于、远大于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\ll</span>，<span class="keyword">\gg</span></span><br></pre></td></tr></table></figure><p>$$<br>\ll，\gg<br>$$</p><h4 id="约等于">约等于</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\approx</span></span><br></pre></td></tr></table></figure><p>$$<br>\approx<br>$$</p><h4 id="向上取整、向下取整">向上取整、向下取整</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\lceil</span> x <span class="keyword">\rceil</span></span><br><span class="line"><span class="keyword">\lfloor</span> x <span class="keyword">\rfloor</span></span><br></pre></td></tr></table></figure><p>$$<br>\lceil x \rceil<br>\<br>\lfloor x \rfloor<br>$$</p><h4 id="绝对值">绝对值</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\left</span>|-2<span class="keyword">\right</span>| 或者 <span class="keyword">\vert</span> -2<span class="keyword">\vert</span> 或者  <span class="keyword">\lvert</span> -2<span class="keyword">\rvert</span> </span><br></pre></td></tr></table></figure><p>可以观察一下区别<br>$$<br>\left|-2\right| 或者 \vert -2\vert 或者  \lvert -2\rvert<br>$$</p><h4 id="双竖线">双竖线</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\|</span> A<span class="keyword">\|</span> 或者 <span class="keyword">\left</span><span class="keyword">\|</span>A<span class="keyword">\right</span><span class="keyword">\|</span> 或者 <span class="keyword">\Vert</span> A<span class="keyword">\Vert</span></span><br></pre></td></tr></table></figure><p>$$<br>| A| 或者 \left|A\right| 或者 \Vert A\Vert<br>$$</p><h4 id="花括号">花括号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\&#123;</span> A<span class="keyword">\&#125;</span> 或者 <span class="keyword">\left</span><span class="keyword">\&#123;</span> A <span class="keyword">\right</span><span class="keyword">\&#125;</span> </span><br></pre></td></tr></table></figure><p>$$<br>{ A} 或者 \left{ A \right}<br>$$</p><h4 id="乘号">乘号</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\times</span> 或者 ×</span><br></pre></td></tr></table></figure><p>$$<br>\times 或者 ×<br>$$</p><h4 id="开n次方">开n次方</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="keyword">\sqrt</span>&#123;2&#125;、<span class="keyword">\sqrt</span>[4]&#123;16&#125;</span><br></pre></td></tr></table></figure><p>$$<br>\sqrt{2}、\sqrt[4]{16}<br>$$</p><h4 id="导数">导数</h4><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 求导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x&#125;</span><br><span class="line"><span class="comment">% 高阶导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\mathrm</span>&#123;d&#125;<span class="built_in">^</span>&#123;n&#125; y&#125;&#123;<span class="keyword">\mathrm</span>&#123;d&#125;x<span class="built_in">^</span>&#123;n&#125;&#125;</span><br><span class="line"><span class="comment">% 求偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#123;Loss&#125;&#125;&#123;<span class="keyword">\partial</span>&#123;w&#125;&#125;</span><br><span class="line"><span class="comment">% 二阶偏导</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="built_in">^</span>&#123;2&#125;&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span><span class="built_in">^</span>&#123;2&#125;z&#125;&#123;<span class="keyword">\partial</span>&#123;x&#125;<span class="keyword">\partial</span>&#123;y&#125;&#125;</span><br></pre></td></tr></table></figure><p>$$<br>% 求导<br>\frac{\mathrm{d}y}{\mathrm{d}x}<br>% 高阶导<br>\frac{\mathrm{d}^{n} y}{\mathrm{d}x^{n}}<br>% 求偏导<br>\frac{\partial{Loss}}{\partial{w}}<br>% 二阶偏导<br>\frac{\partial^{2}z}{\partial{x}^{2}}<br>\frac{\partial^{2}z}{\partial{x}\partial{y}}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> Latex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和、差分、离散化</title>
      <link href="/posts/22f330e3.html"/>
      <url>/posts/22f330e3.html</url>
      
        <content type="html"><![CDATA[<h1 id="【深进1-例1】求区间和"><a href="https://www.luogu.com.cn/problem/P8218">【深进1.例1】求区间和</a></h1><blockquote><h1 id="【深进1-例1】求区间和-2">【深进1.例1】求区间和</h1><h2 id="题目描述">题目描述</h2><p>给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这<br>$m$ 个区间的区间和。</p><p>对于所有测试数据，$n,m\le10^5,a_i\le 10^4$</p><h2 id="输入格式">输入格式</h2><p>第一行，为一个正整数 $n$ 。</p><p>第二行，为 $n$ 个正整数 $a_1,a_2, \cdots ,a_n$</p><p>第三行，为一个正整数 $m$ 。</p><p>接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\le l_i\le r_i\le n$</p><h2 id="输出格式">输出格式</h2><p>共 $m$ 行。</p><p>第 $i$ 行为第 $i$ 组答案的询问。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>4 4 3 2 1 2 1 4 2 3 </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>10 5 </code></p><h2 id="提示">提示</h2><p>样例解释：第 $1$ 到第 $4$ 个数加起来和为 $10$。第 $2$ 个数到第 $3$ 个数加起来和为 $5$。</p><p>对于 $50 %$ 的数据：$n,m\le 1000$；</p><p>对于 $100 %$ 的数据：$1 \le n, m\le 10^5$，$1 \le a_i\le 10^4$</p></blockquote><h2 id="思路分析">思路分析</h2><p>简单的前缀和板子，不多说。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll =<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m;</span><br><span class="line">ll a[<span class="number">200000</span>];</span><br><span class="line">ll pre[<span class="number">200000</span>], sum[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">pre[i] = a[i] + pre[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">ll l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">sum[i] = pre[r] - pre[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cout &lt;&lt; sum[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大加权矩形"><a href="https://www.luogu.com.cn/problem/P1719">最大加权矩形</a></h1><h2 id="题目描述-2">题目描述</h2><p>为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。</p><p>校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 0 –2 –7  0 </span><br><span class="line"> 9  2 –6  2</span><br><span class="line">-4  1 –4  1 </span><br><span class="line">-1  8  0 –2</span><br></pre></td></tr></table></figure><p>在左下角：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9  2</span><br><span class="line">-4  1</span><br><span class="line">-1  8</span><br></pre></td></tr></table></figure><p>和为 $15$。</p><p>几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？</p><h2 id="输入格式-2">输入格式</h2><p>第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。</p><h2 id="输出格式-2">输出格式</h2><p>最大矩形（子矩阵）的和。</p><h2 id="样例-1-2">样例 #1</h2><h3 id="样例输入-1-2">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 -2 -7 0</span><br><span class="line"> 9 2 -6 2</span><br><span class="line">-4 1 -4  1 </span><br><span class="line">-1 8  0 -2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="提示-2">提示</h2><p>$1 \leq n\le 120$<br>其实是二维前缀和的板子，这里给出几份代码，看看不同的思路（大多都是细节上处理的方法不同）。</p><h2 id="AC代码-2">AC代码</h2><h3 id="CODE1">CODE1</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n, ans = <span class="number">-99999999</span>;</span><br><span class="line"><span class="type">int</span> squ[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="type">int</span> lin[<span class="number">130</span>][<span class="number">130</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; squ[i][j];</span><br><span class="line"><span class="comment">//lin[i][j]表示的是第i行前j个（其实也就是第j列）数字的和</span></span><br><span class="line">lin[i][j] = lin[i][j - <span class="number">1</span>] + squ[i][j];</span><br><span class="line"><span class="comment">//sum[i][j]表示的是以第1行第1个数字为左上角，以第i行第j个数字为右下角的矩形的面积。</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + lin[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分别枚举左上角的坐标(x1,y1)和右下角(x2,y2)的坐标。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x1 = <span class="number">1</span>; x1 &lt;= n; x1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y1 = <span class="number">1</span>; y1 &lt;= n; y1++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x2 = <span class="number">1</span>; x2 &lt;= n; x2++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> y2 = <span class="number">1</span>; y2 &lt;= n; y2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x2 &lt; x1||y2&lt;y1) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] +sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能有人对$sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] +sum[x1-1][y1-1]$为什么是以$(x_1,y_1)$为左上角，以$(x_2,y_2)$为右下角的矩形的面积有点疑惑。画个图解释一下：<br><img src="https://img-blog.csdnimg.cn/direct/3c6c29a63e80437eaf7b54057daf5860.png#pic_center" alt="在这里插入图片描述"><br>这下应该能看懂了吧qwq。</p><h3 id="CODE2">CODE2</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//还是跟上面的操作一样</span></span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            <span class="comment">//预处理出以(i,j)为右下角的矩形的面积，画画图就懂了</span></span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="comment">//枚举左上角(i,j)，右下角(k,m)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//注意k&gt;=i,m&gt;=j</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=n;k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> m=j;m&lt;=n;m++)&#123;</span><br><span class="line">                    ans=<span class="built_in">max</span>(ans,<span class="built_in">query</span>(i,j,k,m));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CODE3">CODE3</h3><p>实际上是在枚举时优化了一下，降低时间复杂度。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">125</span>][<span class="number">125</span>],mat[<span class="number">125</span>][<span class="number">125</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> k,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mat[k][m]-mat[k][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][m]+mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">            mat[i][j]=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>,sum;</span><br><span class="line">    <span class="comment">//这里改成了枚举矩形的上下边i与j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//k枚举的是第几列，从左往右扫描每一列的面积，并加到sum中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                sum+=<span class="built_in">query</span>(i,k,j,k);</span><br><span class="line">                <span class="comment">//如果sum&gt;ans，说明在以i行为上界，j行为下界的，并且右界限为k的构成的连续矩形面积（即sum）更大，更新ans</span></span><br><span class="line">                <span class="keyword">if</span>(sum&gt;ans)ans=sum;</span><br><span class="line">                <span class="comment">//如果sum&lt;0，那么只能另开一段，置sum为0</span></span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)sum=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者可以理解成是矩阵压缩，可以看看题解的第一篇，本质其实是一样的。<br><a href="https://www.luogu.com.cn/problem/solution/P1719">P1719 最大加权矩形</a></p><h1 id="语文成绩"><a href="https://www.luogu.com.cn/problem/P2367">语文成绩</a></h1><blockquote><h1 id="语文成绩-2">语文成绩</h1><h2 id="题目背景">题目背景</h2><p>语文考试结束了，成绩还是一如既往地有问题。</p><h2 id="题目描述-3">题目描述</h2><p>语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？</p><h2 id="输入格式-3">输入格式</h2><p>第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。</p><p>第二行有 $n$ 个数，$a_1 \sim a_n$，代表各个学生的初始成绩。</p><p>接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。</p><h2 id="输出格式-3">输出格式</h2><p>输出仅一行，代表更改分数后，全班的最低分。</p><h2 id="样例-1-3">样例 #1</h2><h3 id="样例输入-1-3">样例输入 #1</h3><p><code>3 2 1 1 1 1 2 1 2 3 1 </code></p><h3 id="样例输出-1-3">样例输出 #1</h3><p><code>2 </code></p><h2 id="提示-3">提示</h2><p>对于 $40%$ 的数据，有 $n \le 10^3$。</p><p>对于 $60%$ 的数据，有 $n \le 10^4$。</p><p>对于 $80%$ 的数据，有 $n \le 10^5$。</p><p>对于 $100%$ 的数据，有 $n \le 5\times 10^6$，$p \le n$，学生初始成绩 $ \le 100$，$z<br>\le 100$。</p></blockquote><h2 id="思路分析-2">思路分析</h2><p>差分的板子题，但是我经常忘记怎么操作了，贴上证明。<br><img src="https://img-blog.csdnimg.cn/direct/7348fc92b069475784845bf92f234e14.png#pic_center" alt="在这里插入图片描述"><br>这里贴的是<a href="https://www.luogu.com.cn/blog/156353/solution-p2367">GoldenFishX大佬的博客</a>，可以看看（大佬如果觉得侵权，联系我删除即可qwq）。</p><h2 id="AC代码-3">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll p, n, a[<span class="number">5000500</span>], d[<span class="number">5000500</span>];</span><br><span class="line">ll x, y, z, ans=<span class="number">9999999999</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//求出差分数组</span></span><br><span class="line">d[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="comment">//上面讲得很清楚了</span></span><br><span class="line">d[x] += z;</span><br><span class="line">d[y + <span class="number">1</span>] -= z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">//差分的性质：a[i]=d[i]+d[i-1]+d[i-2]+······+d[1]</span></span><br><span class="line">a[i] = a[i - <span class="number">1</span>] + d[i];</span><br><span class="line">ans = <span class="built_in">min</span>(ans, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="地毯"><a href="https://www.luogu.com.cn/problem/P3397">地毯</a></h1><h2 id="题目描述-4">题目描述</h2><p>在 $n\times n$ 的格子上有 $m$ 个地毯。</p><p>给出这些地毯的信息，问每个点被多少个地毯覆盖。</p><h2 id="输入格式-4">输入格式</h2><p>第一行，两个正整数 $n,m$。意义如题所述。</p><p>接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。</p><h2 id="输出格式-4">输出格式</h2><p>输出 $n$ 行，每行 $n$ 个正整数。</p><p>第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。</p><h2 id="样例-1-4">样例 #1</h2><h3 id="样例输入-1-4">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 2 3 3</span><br><span class="line">3 3 5 5</span><br><span class="line">1 2 1 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 1 1 0</span><br><span class="line">0 1 1 0 0</span><br><span class="line">0 1 2 1 1</span><br><span class="line">0 0 1 1 1</span><br><span class="line">0 0 1 1 1</span><br></pre></td></tr></table></figure><h2 id="提示-4">提示</h2><h3 id="样例解释">样例解释</h3><p>覆盖第一个地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr></tbody></table><p>覆盖第一、二个地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$2$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr></tbody></table><p>覆盖所有地毯后：</p><table><thead><tr><th style="text-align:center">$0$</th><th style="text-align:center">$1$</th><th style="text-align:center">$1$</th><th style="text-align:center">$1$</th><th style="text-align:center">$0$</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$2$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr><tr><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td><td style="text-align:center">$1$</td></tr></tbody></table><hr><h3 id="数据范围">数据范围</h3><p>对于 $20%$ 的数据，有 $n\le 50$，$m\le 100$。</p><p>对于 $100%$ 的数据，有 $n,m\le 1000$。</p><h2 id="思路分析-3">思路分析</h2><p>这题其实可以暴力模拟水过去，但实际上正解是二维差分。（补学一下qwq）。<br>设数组$a$的差分数组为$b$，则：<br>$$b[[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1]$$.<br>（偷懒了，直接贴书上的内容qwq）</p><blockquote><p><img src="https://img-blog.csdnimg.cn/direct/268ddecc2f5c4e04bcbd0ab4d710df40.png#pic_center" alt="在这里插入图片描述"></p></blockquote><p>可以看到(a)，(b)图中，右下角的矩形中的各点都+1了，可以试着结合一维差分的证明理解一下wsm。©，(d)图其实就是相同的操作罢了。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mat[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        <span class="comment">//上面提到的操作</span></span><br><span class="line">        mat[x1][y1]++;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y1]--;</span><br><span class="line">        mat[x1][y2+<span class="number">1</span>]--;</span><br><span class="line">        mat[x2+<span class="number">1</span>][y2+<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="comment">//求前缀和，处理出每个点的值</span></span><br><span class="line">            mat[i][j]+=mat[i<span class="number">-1</span>][j]+mat[i][j<span class="number">-1</span>]-mat[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            cout&lt;&lt;mat[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="火烧赤壁"><a href="https://www.luogu.com.cn/problem/P1496">火烧赤壁</a></h1><h2 id="题目背景-2">题目背景</h2><p>曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。</p><p>孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。</p><p>隆冬的十一月，天气突然回暖，刮起了东南风。</p><p>没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。</p><p>曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！</p><h2 id="题目描述-5">题目描述</h2><p>给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。</p><h2 id="输入格式-5">输入格式</h2><p>第一行一个整数，表示起火的信息条数 $n$。<br>接下来 $n$ 行，每行两个整数 $a, b$，表示一个着火位置的起点和终点（<strong>注意：左闭右开</strong>）。</p><h2 id="输出格式-5">输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-5">样例 #1</h2><h3 id="样例输入-1-5">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1 1</span><br><span class="line">5 11</span><br><span class="line">2 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h2 id="提示-5">提示</h2><h3 id="数据规模与约定">数据规模与约定</h3><p>对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a \leq  b \lt 2^{31}$，且答案小于 $2^{31}$。</p><h2 id="思路分析-4">思路分析</h2><p>实际上这是一道离散化的题目，但是我当初做的时候还不会离散化qwq，看了题解区大佬的绝妙思路：<br><a href="https://wxwoo.blog.luogu.org/solution-p1496">大佬的题解</a><br><img src="https://img-blog.csdnimg.cn/direct/dbcb14ba5ade43389d9fc5e8b3e94590.png#pic_center" alt="在这里插入图片描述"><br>可以发现，覆盖的范围是一样的，那么我们可以这样操作：<br>1、将起点和终点排个序。<br>2、将他们按照从小到大的顺序一一匹配，计算长度。<br>3、如果有重复的覆盖范围，减去即可。（也就是当前的终点坐标比下一个的起点坐标大时）</p><h2 id="AC代码-5">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll a[<span class="number">20200</span>], b[<span class="number">20200</span>], l;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">l += b[i] - a[i];</span><br><span class="line"><span class="comment">//注意i&lt;n,因为a[n]，b[n]是最后的起点和终点</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] &gt; a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">l -= b[i] - a[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="领地选择"><a href="https://www.luogu.com.cn/problem/P2004">领地选择</a></h1><h2 id="题目描述-6">题目描述</h2><p>作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。</p><p>首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。</p><h2 id="输入格式-6">输入格式</h2><p>第一行三个整数 $N,M,C$，表示地图的宽和长以及首都的边长。</p><p>接下来 $N$ 行每行 $M$ 个整数，表示了地图上每个地块的价值。价值可能为负数。</p><h2 id="输出格式-6">输出格式</h2><p>一行两个整数 $X,Y$，表示首都左上角的坐标。</p><h2 id="样例-1-6">样例 #1</h2><h3 id="样例输入-1-6">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 2 3 1</span><br><span class="line">-1 9 0 2</span><br><span class="line">2 0 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure><h2 id="提示-6">提示</h2><p>对于 $60%$ 的数据，$N,M\le 50$。</p><p>对于 $90%$ 的数据，$N,M\le 300$。</p><p>对于 $100%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。</p><h2 id="思路分析-5">思路分析</h2><p>二维前缀和的练习题，不解释了qwq。</p><h2 id="AC代码-6">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll n, m, c;</span><br><span class="line">ll map[<span class="number">1010</span>][<span class="number">1010</span>], sum[<span class="number">1010</span>][<span class="number">1010</span>], maxn = <span class="number">-999999999</span>, nx,ny;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; c;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (ll j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cin &gt;&gt; map[i][j];</span><br><span class="line"><span class="comment">//求前缀和</span></span><br><span class="line">sum[i][j] = sum[i - <span class="number">1</span>][j] + sum[i][j - <span class="number">1</span>] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + map[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = c; j &lt;= m; j++) &#123;</span><br><span class="line">    <span class="comment">//枚举以(i,j)为右下角、边长为c的正方形的面积，注意更新坐标</span></span><br><span class="line"><span class="keyword">if</span> (sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c] &gt; maxn) &#123;</span><br><span class="line">maxn = sum[i][j] - sum[i - c][j] - sum[i][j - c] + sum[i - c][j - c];</span><br><span class="line">nx = i - c + <span class="number">1</span>;</span><br><span class="line">ny = j - c + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; nx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ny;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="聪明的质检员"><a href="https://www.luogu.com.cn/problem/P1314">聪明的质检员</a></h1><blockquote><h2 id="题目描述-7">题目描述</h2><p><code>小T</code> 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 $n$ 个矿石，从 $1$ 到 $n$<br>逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值 $v_i$ 。检验矿产的流程是：</p><ol><li>给定$ m$ 个区间 $[l_i,r_i]$；</li><li>选出一个参数 $W$；</li><li>对于一个区间 $[l_i,r_i]$，计算矿石在这个区间上的检验值 $y_i$：</li></ol><p>$$y_i=\sum\limits_{j=l_i}^{r_i}[w_j \ge W] \times<br>\sum\limits_{j=l_i}^{r_i}[w_j \ge W]v_j$$</p><p>其中 $j$ 为矿石编号。</p><p>这批矿产的检验结果 $y$ 为各个区间的检验值之和。即：$\sum\limits_{i=1}^m y_i$</p><p>若这批矿产的检验结果与所给标准值 $s$ 相差太多，就需要再去检验另一批矿产。<code>小T</code> 不想费时间去检验另一批矿产，所以他想通过调整参数<br>$W$ 的值，让检验结果尽可能的靠近标准值 $s$，即使得 $|s-y|$ 最小。请你帮忙求出这个最小值。</p><h2 id="输入格式-7">输入格式</h2><p>第一行包含三个整数 $n,m,s$，分别表示矿石的个数、区间的个数和标准值。</p><p>接下来的 $n$ 行，每行两个整数，中间用空格隔开，第 $i+1$ 行表示 $i$ 号矿石的重量 $w_i$ 和价值 $v_i$。</p><p>接下来的 $m$ 行，表示区间，每行两个整数，中间用空格隔开，第 $i+n+1$ 行表示区间 $[l_i,r_i]$ 的两个端点 $l_i$<br>和 $r_i$。注意：不同区间可能重合或相互重叠。</p><h2 id="输出格式-7">输出格式</h2><p>一个整数，表示所求的最小值。</p><h2 id="样例-1-7">样例 #1</h2><h3 id="样例输入-1-7">样例输入 #1</h3><p><code>5 3 15  1 5  2 5  3 5  4 5  5 5  1 5  2 4  3 3 </code></p><h3 id="样例输出-1-7">样例输出 #1</h3><p><code>10 </code></p><h2 id="提示-7">提示</h2><p>【输入输出样例说明】</p><p>当 $W$ 选 $4$ 的时候，三个区间上检验值分别为 $20,5 ,0$ ，这批矿产的检验结果为 $25$，此时与标准值 $S$<br>相差最小为 $10$。</p><p>【数据范围】</p><p>对于 $10%$ 的数据，有 $1 ≤n ,m≤10$；</p><p>对于 $30%$的数据，有 $1 ≤n ,m≤500$ ；</p><p>对于 $50%$ 的数据，有 $1 ≤n ,m≤5,000$；   对于 $70%$ 的数据，有 $1 ≤n ,m≤10,000$ ；</p><p>对于 $100%$ 的数据，有 $1 ≤n ,m≤200,000$，$0 &lt; w_i,v_i≤10^6$，$0 &lt;<br>s≤10^{12}$，$1 ≤l_i ≤r_i ≤n$</p></blockquote><h2 id="思路分析-6">思路分析</h2><p>直接暴力枚举求出这个点肯定不行，并且看到题目要求最小值，所以可以猜测：使用二分。<br>二分的是$W$的值，$check(mid)$的判断条件是$s-\sum\limits_{i=1}^m y_i$是否大于0，由此缩减二分的范围，分析一下单调性：当$W$减少时，$\sum\limits_{i=1}^m y_i$增大，反之，则变小，并且当$W$足够小时，$\sum\limits_{i=1}^m y_i$会大于$s$,符合单调性，可以使用二分。具体看看注释。<br>还需要先预处理出前缀和：包括个数和总价值，否则会TLE。</p><h2 id="AC代码-7">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN],w[MAXN],l[MAXN],r[MAXN],cnt_num[MAXN],cnt_val[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    ll sum,ans,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    ans=s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//w是矿石的重量，v是矿石的价值</span></span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//输入的是查询的区间</span></span><br><span class="line">        cin&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(cnt_num,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_num));</span><br><span class="line">        <span class="built_in">memset</span>(cnt_val,<span class="number">0</span>,<span class="built_in">sizeof</span>(cnt_val));</span><br><span class="line">        <span class="comment">//利用前缀和，预处理出合格品的个数和总价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i]&gt;=mid)&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>]+v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cnt_num[i]=cnt_num[i<span class="number">-1</span>];</span><br><span class="line">                cnt_val[i]=cnt_val[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计一下检测结果，也就是查询的各个区间总价值之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            sum+=(cnt_val[r[i]]-cnt_val[l[i]<span class="number">-1</span>])*(cnt_num[r[i]]-cnt_num[l[i]<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意更新答案，得到的是最小值，注意ans初始化为无穷大</span></span><br><span class="line">        ans=<span class="built_in">min</span>(ans,<span class="built_in">abs</span>(sum-s));</span><br><span class="line">        <span class="comment">//说明这个解合法，将右端点确定下来</span></span><br><span class="line">        <span class="keyword">if</span>(sum&lt;=s)right=mid;</span><br><span class="line">        <span class="comment">//否则，将左端点确定下来</span></span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="程序自动分析"><a href="https://www.luogu.com.cn/problem/P1955">程序自动分析</a></h1><blockquote><h1 id="NOI2015-程序自动分析">[NOI2015] 程序自动分析</h1><h2 id="题目描述-8">题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p><p>考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如<br>$x_i=x_j$ 或 $x_i\neq x_j$<br>的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq<br>x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p><p>现在给出一些约束满足问题，请分别对它们进行判定。</p><h2 id="输入格式-8">输入格式</h2><p>输入的第一行包含一个正整数 $t$，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p><p>对于每个问题，包含若干行：</p><p>第一行包含一个正整数 $n$，表示该问题中需要被满足的约束条件个数。接下来 $n$ 行，每行包括三个整数<br>$i,j,e$，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $e=1$，则该约束条件为<br>$x_i=x_j$。若$e=0$，则该约束条件为 $x_i\neq x_j$。</p><h2 id="输出格式-8">输出格式</h2><p>输出包括 $t$ 行。</p><p>输出文件的第 $k$ 行输出一个字符串 <code>YES</code> 或者 <code>NO</code>（字母全部大写），<code>YES</code> 表示输入中的第 $k$<br>个问题判定为可以被满足，<code>NO</code> 表示不可被满足。</p><h2 id="样例-1-8">样例 #1</h2><h3 id="样例输入-1-8">样例输入 #1</h3><p><code>2 2 1 2 1 1 2 0 2 1 2 1 2 1 1 </code></p><h3 id="样例输出-1-8">样例输出 #1</h3><p><code>NO YES </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>2 3 1 2 1 2 3 1 3 1 1 4 1 2 1 2 3 1 3 4 1 1 4 0 </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>YES NO </code></p><h2 id="提示-8">提示</h2><p>【样例解释1】</p><p>在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。</p><p>在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。</p><p>【样例说明2】</p><p>在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得<br>$x_1=x_2=x_3$，即可同时满足所有的约束条件。</p><p>在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出<br>$x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。</p><p>【数据范围】</p><p>所有测试数据的范围和特点如下表所示：</p><h3 id="勘误：测试点-8-sim-10-的-i-j-约束为-1-leq-i-j-leq-10-9-，而不是下图中的-10-10-。">勘误：测试点 $8 \sim 10$ 的 $i, j$ 约束为 $1 \leq i, j \leq 10^9$，而不是下图中的 $10^{10}$。</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/4a99dde45fc5970ecba60d38c39a3bc2.png" alt=""></p></blockquote><h2 id="思路分析-7">思路分析</h2><p>这个其实是并查集+离散化，但是离散化我还不太熟，暂时没写。当初用了$unordered-map$混过去了qwq。<br>说正题，这道题有两个特征，查询和赋值，我们分析一下，这其实跟并查集的功能很相似，并查集维护的是一些元素的分组，用的是查询和合并两个操作。这里的赋值，我们其实可以用合并来实现：<br>1、如果是赋值，合并为一组。<br>2、如果是查询，那么我们只要看两者是否在同一组内即可。<br>这里并查集写的是按秩合并，不会的可以用普通的并查集代替。</p><h2 id="AC代码-8">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;pre;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;Rank;</span><br><span class="line"><span class="type">int</span> x[MAXN],y[MAXN],e[MAXN];</span><br><span class="line"><span class="comment">//并查集的查询功能</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==pre[x])<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> pre[x]=<span class="built_in">find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集的合并功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]&gt;=Rank[fy])pre[fy]=fx;</span><br><span class="line">    <span class="keyword">else</span> pre[fx]=fy;</span><br><span class="line">    <span class="keyword">if</span>(Rank[fx]==Rank[fy]&amp;&amp;fx!=fy)Rank[fx]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//注意清空数组，因为有多组数据输入，不然喜迎WA qwq</span></span><br><span class="line">    pre.<span class="built_in">clear</span>();</span><br><span class="line">    Rank.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(x,<span class="number">0</span>,<span class="built_in">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y,<span class="number">0</span>,<span class="built_in">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="built_in">sizeof</span>(e));</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//输入元素，以及对应的操作，注意在原题中指的是下标x，y</span></span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;e[i];</span><br><span class="line">        <span class="comment">//将并查集初始化</span></span><br><span class="line">        pre[x[i]]=x[i];</span><br><span class="line">        pre[y[i]]=y[i];</span><br><span class="line">        <span class="comment">//按秩合并才需要的初始化，其实这一行也可以不用写@~@</span></span><br><span class="line">        Rank[x[i]]=<span class="number">1</span>,Rank[y[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果是1，合并两个元素</span></span><br><span class="line">        <span class="keyword">if</span>(e[i])<span class="built_in">join</span>(x[i],y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果不是1，查看两者的祖先是否一样</span></span><br><span class="line">        <span class="keyword">if</span>(!e[i])&#123;</span><br><span class="line">            <span class="comment">//不一样的话，直接输出NO，return 0</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x[i])==<span class="built_in">find</span>(y[i]))&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经历重重困难，终于是YES了！！！</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO11MAR-Brownie-Slicing-G"><a href="https://www.luogu.com.cn/problem/P3017">[USACO11MAR] Brownie Slicing G</a></h1><h2 id="题面翻译">题面翻译</h2><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由 $R\times C(1\leq R,C\leq 500)$ 个小的巧克力蛋糕组成的。第 $i$ 行，第 $j$ 列的蛋糕有 $N_{i,j}(N_{i,j}\leq 4000)$ 块巧克力碎屑。</p><p>Bessie想把蛋糕分成 $A\times B(1\leq A\leq R,1\leq B\leq C)$ 块，:给 $A\times B$ 只奶牛。蛋糕先水平地切 $A-1$ 刀（只能切沿整数坐标切）来把蛋糕划分成 $A$ 块。然后再把剩下来的每一块独立地切 $B-1$ 刀，也只能切沿整数坐标切。其他 $A\times B-1$ 只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个$5\times4$的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>这样，Bessie至少能获得 $3$ 块巧克力碎屑</p><h2 id="题目描述-9">题目描述</h2><p>Bessie has baked a rectangular brownie that can be thought of as an RxC grid (1 &lt;= R &lt;= 500; 1 &lt;= C &lt;= 500) of little brownie squares. The square at row i, column j contains N_ij (0 &lt;= N_ij &lt;= 4,000) chocolate chips.</p><p>Bessie wants to partition the brownie up into A*B chunks (1 &lt;= A &lt;= R; 1 &lt;= B &lt;= C): one for each of the A*B cows. The brownie is cut by first making A-1 horizontal cuts (always along integer</p><p>coordinates) to divide the brownie into A strips.  Then cut each strip *independently* with B-1 vertical cuts, also on integer</p><p>boundaries. The other A*B-1 cows then each choose a brownie piece, leaving the last chunk for Bessie. Being greedy, they leave Bessie the brownie that has the least number of chocolate chips on it.</p><p>Determine the maximum number of chocolate chips Bessie can receive, assuming she cuts the brownies optimally.</p><p>As an example, consider a 5 row x 4 column brownie with chips</p><p>distributed like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie must partition the brownie into 4 horizontal strips, each with two pieces. Bessie can cut the brownie like this:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 | 2 1</span><br><span class="line">---------</span><br><span class="line">3 | 1 1 1</span><br><span class="line">---------</span><br><span class="line">2 0 1 | 3</span><br><span class="line">---------</span><br><span class="line">1 1 | 1 1</span><br><span class="line">1 1 | 1 1</span><br></pre></td></tr></table></figure><p>Thus, when the other greedy cows take their brownie piece, Bessie still gets 3 chocolate chips.</p><p>Bessie烘焙了一块巧克力蛋糕。这块蛋糕是由R*C(1 &lt;= R,C &lt;= 500)个小的巧克力蛋糕组成的。第i行，第j列的蛋糕有N_ij(1&lt;= N_ij &lt;= 4,000)块巧克力碎屑。</p><p>Bessie想把蛋糕分成A*B块，(1 &lt;= A&lt;= R,1 &lt;= B &lt;= C): 给A*B只奶牛。蛋糕先水平地切A-1刀（只能切沿整数坐标切）来把蛋糕划分成A块。然后再把剩下来的每一块独立地切B-1刀，也只能切沿整数坐标切。其他A*B-1只奶牛就每人选一块，留下一块给Bessie。由于贪心，他们只会留给Bessie巧克力碎屑最少的那块。求出Bessie最优情况下会获得多少巧克力碎屑。</p><p>例如，考虑一个5*4的蛋糕，上面的碎屑分布如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 2 1</span><br><span class="line">3 1 1 1</span><br><span class="line">2 0 1 3</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><p>Bessie必须把蛋糕切成4条，每条分成2块。Bessie能像这样切蛋糕:</p><h2 id="输入格式-9">输入格式</h2><p>* Line 1: Four space-separated integers: R, C, A, and B</p><p>* Lines 2…R+1: Line i+1 contains C space-separated integers: N_i1, …, N_iC</p><h2 id="输出格式-9">输出格式</h2><p>* Line 1: A single integer: the maximum number of chocolate chips that Bessie guarantee on her brownie</p><h2 id="样例-1-9">样例 #1</h2><h3 id="样例输入-1-9">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4 4 2 </span><br><span class="line">1 2 2 1 </span><br><span class="line">3 1 1 1 </span><br><span class="line">2 0 1 3 </span><br><span class="line">1 1 1 1 </span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="思路分析-8">思路分析</h2><p>当初也没想出来怎么二分，看了题解区大佬的题解恍然大悟。<br>蛋糕要分成$A * B$块，注意可以先分成$A$横块，每一块再分成$B$条，也就是切条时可以不用一刀切！！！<br>那么要统计一块蛋糕的巧克力屑，肯定就是使用前缀和了。我们也可以先预处理出前缀和，再进行二分。<br>二分的是巧克力屑的数量，$check(mid)$的是能否切出$A*B$块蛋糕，具体$check(mid)$怎么写可以看看代码+注释。</p><h2 id="AC代码-9">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> cake[<span class="number">510</span>][<span class="number">510</span>],line[<span class="number">510</span>][<span class="number">510</span>],pre[<span class="number">510</span>][<span class="number">510</span>],r,c,a,b,ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//我们先切一行，再将这一行切成B列，看看最终能否满足A*B块蛋糕</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>,sum_cake=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i枚举的是当前行，j枚举的是当前列，last记录的是上一块（行）蛋糕的最底行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="comment">//判断当前切的蛋糕的巧克力屑的数量是否大于x，也就是二分的值</span></span><br><span class="line">            <span class="comment">//我们一列一列的补充蛋糕，判断补充后，其巧克力屑数目是否大于x，不满足，则补充。</span></span><br><span class="line">            <span class="keyword">if</span>(sum_cake+(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>])&lt;x)&#123;</span><br><span class="line">                sum_cake+=(pre[i][j]-pre[i][j<span class="number">-1</span>])-(pre[last][j]-pre[last][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//满足，另开一列，注意统计的蛋糕数目+1，蛋糕上的巧克力屑数目重置为0</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                sum_cake=<span class="number">0</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断这一行蛋糕，切出来是否有B块</span></span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=b)&#123;</span><br><span class="line">        <span class="comment">//如果有B块，我们则记录这块蛋糕的最后一行，并且记录 行的蛋糕数量++，没有只能再加上一行继续切了，直到满足为止。</span></span><br><span class="line">            last=i;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看看是否能不能切除A行蛋糕，满足return true，否则，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(num&lt;a)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//输入R、C、A、B</span></span><br><span class="line">    cin&gt;&gt;r&gt;&gt;c&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="comment">//输入蛋糕的巧克力屑</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            cin&gt;&gt;cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//预处理出前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+cake[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=MAXN;</span><br><span class="line">    <span class="comment">//二分，不多说了，重点在check(x)</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="海底高铁"><a href="https://www.luogu.com.cn/problem/P3406">海底高铁</a></h1><h2 id="思路分析-9">思路分析</h2><p>先想想暴力怎么办？我们可以先统计每段铁路要经过几次，再贪心，看看是办卡优惠还是买票优惠。<br>但是这样肯定会TLE，想想怎么改——————前缀和吗？不对，前缀和求的是多个元素之间的关系。<br>差分吗？差分维护的是多个元素之间的逻辑关系，最终得到的是单个元素。<br>那就是差分了！我们可以利用它来得出每段铁路经过的次数，想想差分的作用，O(1)修改区间的值，O(n)查询单个元素的值。基于此，我们可以先O(1)预处理区间总共要修改的值，再O(n)得到每段铁路经过的次数，最后贪心得出最小花费。具体可以看看注释。<br>可以看看这篇<a href="https://www.luogu.com.cn/article/srpjwp5w">搞笑的故事</a>，相信会有所收获。</p><h2 id="AC代码-10">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll p[MAXN],a[MAXN],b[MAXN],c[MAXN],ans[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)cin&gt;&gt;p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分，统计修改次数，注意相邻元素不一定是从小到大，所以可能得交换顺序</span></span><br><span class="line">    <span class="comment">//一般来说，是d[l]++,d[r+1]--。l指的是左端点，r指的是右端点，但是我们这里d[l]++,d[r]--即可，因为其实从r城市出发的铁路我们根本不需要经过。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        ans[<span class="built_in">min</span>(p[i],p[i+<span class="number">1</span>])]++;</span><br><span class="line">        ans[<span class="built_in">max</span>(p[i],p[i+<span class="number">1</span>])]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得出每段铁路需要经过的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        ans[i]+=ans[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//贪心，看看每一段铁路是买票优惠还是买卡优惠</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=<span class="built_in">min</span>(ans[i]*a[i],ans[i]*b[i]+c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Poetize6-IncDec-Sequence"><a href="https://www.luogu.com.cn/problem/P4552">[Poetize6] IncDec Sequence</a></h1><blockquote><h1 id="Poetize6-IncDec-Sequence-2">[Poetize6] IncDec Sequence</h1><h2 id="题目描述-10">题目描述</h2><p>给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加<br>$1$ 或者都减 $1$。     请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。</p><h2 id="输入格式-10">输入格式</h2><p>第一行一个正整数 $n$    接下来 $n$ 行,每行一个整数,第 $i+1 $行的整数表示 $a_i$。</p><h2 id="输出格式-10">输出格式</h2><p>第一行输出最少操作次数    第二行输出最终能得到多少种结果</p><h2 id="样例-1-10">样例 #1</h2><h3 id="样例输入-1-10">样例输入 #1</h3><p><code>4 1 1 2 2 </code></p><h3 id="样例输出-1-10">样例输出 #1</h3><p><code>1 2 </code></p><h2 id="提示-9">提示</h2><p>对于 $100%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。</p></blockquote><h2 id="思路分析-10">思路分析</h2><p>先想想元素相同？其实就是他们的差都是0，我们关注的是单个元素，并且是各元素之间的逻辑关系问题，所以我们使用差分来求解。<br>那么问题就变成了怎么让差分数组全为0（除了$diff[1]$不为0，因为$a[0]$为0），对一个区间$[l,r]$进行修改，其实就是$diff[l]++$、$dff[r+1]–$。而一个差分数组里元素肯定有正有负，最好的情况是，一次修改，可以让一个负数加1，一个正数减1，这样操作步骤就是最少的。<br>但是如果只剩下正数或者负数，就只能一次一次进行了。<br>至于有多少可能结果，其实就是最后只剩正数或者负数时，一步步修改的操作次数了。为什么？<br>前面修改的时候，我们修改的是$[l,r]$，对$diff[1]$无影响，而只剩正数或者负数时，我们可以$diff[1]++$$diff[x]–$了，也可以$diff[1]–$$diff[x]++$，也可以不动，所以可能的结果就是：剩余的正数/负数+1，因为本身不修改，也要加上。</p><h2 id="AC代码-11">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,x=<span class="number">0</span>,y=<span class="number">0</span>,d;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="comment">//求差分数组：x统计正数，y统计负数</span></span><br><span class="line">        d=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(d&gt;<span class="number">0</span>)x+=d;</span><br><span class="line">        <span class="keyword">else</span> y-=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//严格的证明是:ans1=min(x,y)+abs(x-y),所以ans1=max(x,y)。</span></span><br><span class="line">    ll ans1=<span class="built_in">max</span>(x,y);</span><br><span class="line">    <span class="comment">//不解释了，看看上面</span></span><br><span class="line">    ll ans2=<span class="built_in">abs</span>(x-y)+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;ans2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2012-提高组-借教室"><a href="https://www.luogu.com.cn/problem/P1083">[NOIP2012 提高组] 借教室</a></h1><h2 id="题目描述-11">题目描述</h2><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来 $n$ 天的借教室信息，其中第 $i$ 天学校有 $r_i$ 个教室可供租借。共有 $m$ 份订单，每份订单用三个正整数描述，分别为 $d_j,s_j,t_j$，表示某租借者需要从第 $s_j$ 天到第 $t_j$ 天租借教室（包括第 $s_j$ 天和第 $t_j$ 天），每天需要租借 $d_j$ 个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供 $d_j$ 个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第 $s_j$ 天到第 $t_j$ 天中有至少一天剩余的教室数量不足 $d_j$ 个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><h2 id="输入格式-11">输入格式</h2><p>第一行包含两个正整数 $n,m$，表示天数和订单的数量。</p><p>第二行包含 $n$ 个正整数，其中第 $i$ 个数为 $r_i$，表示第 $i$ 天可用于租借的教室数量。</p><p>接下来有 $m$ 行，每行包含三个正整数 $d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从 $1$ 开始的整数编号。</p><h2 id="输出格式-11">输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数 $-1$，第二行输出需要修改订单的申请人编号。</p><h2 id="样例-1-11">样例 #1</h2><h3 id="样例输入-1-11">样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">2 5 4 3 </span><br><span class="line">2 1 3 </span><br><span class="line">3 2 4 </span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11">样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-10">提示</h2><p>【输入输出样例说明】</p><p>第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供$3$个教室，而第 $3$ 天剩余的教室数为$2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。</p><p>【数据范围】</p><p>对于10%的数据，有$1≤ n,m≤ 10$；</p><p>对于30%的数据，有$1≤ n,m≤1000$；</p><p>对于 70%的数据，有$1 ≤ n,m ≤ 10^5$；</p><p>对于 100%的数据，有$1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n$。</p><p>NOIP 2012 提高组 第二天 第二题</p><p>2022.2.20 新增一组 hack 数据</p><h2 id="思路分析-11">思路分析</h2><p>（这道当初也不会qwq，看了题解<a href="https://www.luogu.com.cn/article/sncheqxz">大佬——皎月半洒花</a>的博客）还是想想暴力，可以暴力先枚举订单数量，然后减少可以使用的教室数目，直到超过上限为止，但是这肯定会TLE。<br>想想怎么办？我们修改的是教室的数目，并且是一个区间，所以想到的是差分。<br>因为需要找到哪一个不满足，所以加上二分进行查询即可。<br>引用大佬的话：</p><blockquote><p>一般来说，二分是个很有用的优化途径，因为这样会直接导致减半运算，而对于能否二分，有一个界定标准：状态的决策过程或者序列<strong>是否满足单调性或者可以局部舍弃性</strong>。 而在这个题里，因为如果前一份订单都不满足，那么之后的所有订单都不用继续考虑；而如果后一份订单都满足，那么之前的所有订单一定都可以满足，符合局部舍弃性，所以可以二分订单数量。</p></blockquote><h2 id="AC代码-12">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line">ll r[MAXN],d_j[MAXN],s_j[MAXN],t_j[MAXN],diff[MAXN],need[MAXN],ans,n,m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(diff,<span class="number">0</span>,<span class="built_in">sizeof</span>(diff));</span><br><span class="line">    <span class="comment">//利用差分进行区间修改</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x;i++)&#123;</span><br><span class="line">        diff[s_j[i]]+=d_j[i];</span><br><span class="line">        diff[t_j[i]+<span class="number">1</span>]-=d_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//利用差分得到每天需要的教室数目</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        need[i]=need[i<span class="number">-1</span>]+diff[i];</span><br><span class="line">        <span class="comment">//看看每天的教室数目能否满足需求</span></span><br><span class="line">        <span class="keyword">if</span>(need[i]&gt;r[i])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;d_j[i]&gt;&gt;s_j[i]&gt;&gt;t_j[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//可以先判断是否能全部满足，如果能输出0</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">1</span>,right=m;</span><br><span class="line">    <span class="comment">//二分的是订单号，check的是每天的教室数目能否满足</span></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>&lt;&lt;left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P4391</title>
      <link href="/posts/79901f01.html"/>
      <url>/posts/79901f01.html</url>
      
        <content type="html"><![CDATA[<h1 id="BOI2009-Radio-Transmission-无线传输">[BOI2009] Radio Transmission 无线传输</h1><blockquote><h2 id="题目描述">题目描述</h2><p>给你一个字符串 $s_1$，它是由某个字符串 $s_2$ 不断自我连接形成的（保证至少重复 $2$ 次）。但是字符串 $s_2$<br>是不确定的，现在只想知道它的最短长度是多少。</p><h2 id="输入格式">输入格式</h2><p>第一行一个整数 $L$，表示给出字符串的长度。</p><p>第二行给出字符串 $s_1$ 的一个子串，全由小写字母组成。</p><h2 id="输出格式">输出格式</h2><p>仅一行，表示 $s_2$ 的最短长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 cabcabca </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>3 </code></p><h2 id="提示">提示</h2><h4 id="样例输入输出-1-解释-对于样例，我们可以利用-texttt-abc-不断自我连接得到-texttt-abcabcabcabc-，读入的-texttt-cabcabca-，是它的子串。">样例输入输出 1 解释 对于样例，我们可以利用 $\texttt{abc}$ 不断自我连接得到 $\texttt{abcabcabcabc}$，读入的 $\texttt{cabcabca}$，是它的子串。</h4><h4 id="规模与约定-对于全部的测试点，保证-1-L-le-10-6-。">规模与约定 对于全部的测试点，保证 $1 &lt; L \le 10^6$。</h4></blockquote><p>按照题意，我们要求的是$s_2$的最短长度，也就是$s_1$最小的循环字串。<br>这里实际上有一个结论：答案就是$n-pmt[n-1]$。(可能有的结论是$n-pmt[n]$，只是因为下标是从1开始)<br>具体证明可以看这篇博客：（写得很清楚了）<br><a href="https://lyyy.blog.luogu.org/p4391-boi2009radio-transmission-wu-xian-zhuan-shu-ti-xie">大佬的详解</a><br>下面贴上代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充证明">补充证明</h2><p><img src="https://img-blog.csdnimg.cn/direct/444dc91cd4ed450f93fd37e51a114e9d.png#pic_center" alt="在这里插入图片描述"><br>上面的前后缀是$max(border)$。不妨记上面的前缀为$s_1$，下面的后缀为$s_2$。<br>我们可以发现<img src="https://img-blog.csdnimg.cn/direct/be681483c20c45ec91851a924eecfe1b.png#pic_center" alt="在这里插入图片描述"><br>箭头联系起来的各部分是相等的，也就是$s_1[1]=s_2[2]、s_1[2]=s_2[3]、s_1[3]=s_2[4]······$，由此类推。<br>同时，又因为$s_1[1]=s_2[1]、s_1[2]=s_2[2]、s_1[3]=s_2[3]······$，将两者联系起来，我们可以得到：<br>$$s_1[i]=s_2[j]|1&lt;=i&lt;=5，1&lt;=j&lt;=5$$<br>那有没有可能：更一般的情况是：$s_1$红色部分的后面加上一小段普通的字符串$t$。<br>我们可以分析一下：实际上这是可能的。我们可以结合样例进行分析。（这里不写了，样例的解释很清楚，可以认为：最后的循环节被强行切割了一部分。）<br>所以我们总结一下上面的内容：红色部分的字符串就是我们要求的最小循环节了。<br>所以问题转化为：求$max(border)$。<br>只需要求出$pmt[n-1]$即可，那么$n-pmt[n-1]$就是答案了。</p><h2 id="AC代码：">AC代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n-pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 929(Div.3)</title>
      <link href="/posts/3b64a30f.html"/>
      <url>/posts/3b64a30f.html</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-A"><a href="https://codeforces.com/contest/1933/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接累计各元素绝对值即可</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>)ans+=x;</span><br><span class="line">        <span class="keyword">else</span> ans-=x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-B"><a href="https://codeforces.com/contest/1933/problem/B">Problem B</a></h1><h2 id="思路分析-2">思路分析</h2><p>两种操作：去除一个元素，或者某个元素+1。<br>其实可以发现，$sum$%$3$结果只有$0,1,2$.<br>$0：$直接输出0即可。<br>$1：$要不删去一个元素(其取模结果为1)，要不加2，所以可以用个$flag$，看看有没有这样的元素存在。<br>$2：$要不删去一个元素，要不加1，无所谓，都是两次操作。</p><h2 id="AC代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,flag=<span class="number">0</span>;cin&gt;&gt;n;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">3</span>==<span class="number">1</span>)flag=<span class="number">1</span>;</span><br><span class="line">        sum+=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">0</span>)cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum%<span class="number">3</span>==<span class="number">2</span>)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-C"><a href="https://codeforces.com/contest/1933/problem/C">Problem C</a></h1><h2 id="思路分析-3">思路分析</h2><p>坐牢的开始qwq，自己想得太复杂了，其实直接用快速幂枚举$x,y$即可（看了队里大佬的代码）。<br>这里去重有个小技巧，可以用$set$，这样就可以不用写判断是否重复的条件（set可以直接去重），最后输出$set.size()$即可。</p><h2 id="AC代码-3">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickpower</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)ans*=a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a*=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,l;cin&gt;&gt;a&gt;&gt;b&gt;&gt;l;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;<span class="built_in">quickpower</span>(a,x)&lt;=l;x++)&#123;</span><br><span class="line">        <span class="comment">//注意y的枚举条件是quickpower(a,x)*quickpower(b,y)&lt;=l</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; <span class="built_in">quickpower</span>(a,x)*<span class="built_in">quickpower</span>(b,y)&lt;=l;y++)&#123;</span><br><span class="line">            <span class="type">int</span> num=<span class="built_in">quickpower</span>(a,x)* <span class="built_in">quickpower</span>(b,y);</span><br><span class="line">            <span class="keyword">if</span>(l%num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//将l/num存入set中</span></span><br><span class="line">                s.<span class="built_in">insert</span>(l/num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-D"><a href="https://codeforces.com/contest/1933/problem/D">Problem D</a></h1><h2 id="思路分析-4">思路分析</h2><p>看看样例，可以大胆猜测一下，先从小到大排序，可以发现，$SmallElememt$%$BigElememt$肯定不为0，那么这样贪心排序下来，如果可以得到结果不为0，满足题意，直接$return$即可。<br>但是，需要特判是否有相同的情况，只需要考虑$a_0、a_1$即可，后面是否连续无影响，如果$a_0==a_1$，则不满足题意。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//元素按照从小到大排序</span></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">1</span>]!=a[<span class="number">0</span>])&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//如果%!=0，输出yes</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]%a[<span class="number">0</span>]!=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Problem-E"><a href="https://codeforces.com/contest/1933/problem/E">Problem E</a></h1><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 928(Div.4)</title>
      <link href="/posts/b88f3556.html"/>
      <url>/posts/b88f3556.html</url>
      
        <content type="html"><![CDATA[<h1 id="Problem-A"><a href="https://codeforces.com/contest/1926/problem/A">Problem A</a></h1><h2 id="思路分析">思路分析</h2><p>直接模拟即可</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;A&#x27;</span>)a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;<span class="number">5</span>-a)cout&lt;&lt;<span class="string">&quot;A\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;B\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-B"><a href="https://codeforces.com/contest/1926/problem/B">Problem B</a></h1><h2 id="思路分析-2">思路分析</h2><p>我的思路是：当统计每一行1的个数，当第$i$与第$i-1$行中统计到的1的个数（前提是这两行中1的个数不为0）不同时，就是三角形，否则是正方形。</p><p>一开始的时候WA了一次，就是没考虑到第$i$行与第$i+1$行中1的个数都得不为0</p><h2 id="WA代码">WA代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AC代码-2">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚写博客的时候想到可以改进一下，如果$flag==1$了，那么后面的输入其实都是没有意义的，也就不需要统计和判断了，修改如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt_1</span><span class="params">(MAXN)</span></span>;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n&amp;&amp;!flag;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j]==<span class="string">&#x27;1&#x27;</span>)cnt_1[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">2</span>&amp;&amp;cnt_1[i<span class="number">-1</span>]&amp;&amp;cnt_1[i]&amp;&amp;!flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt_1[i<span class="number">-1</span>]!=cnt_1[i])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)cout&lt;&lt;<span class="string">&quot;TRIANGLE\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;SQUARE\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-C"><a href="https://codeforces.com/contest/1926/problem/C">Problem C</a></h1><h2 id="思路分析-3">思路分析</h2><p>其实是一个见过很多次的操作了qwq，先离线处理计算（没错，就是你想的暴力计算$qwq$）出所有在数据范围内的答案，然后用一个数组将其存下即可。这样可以做到$O(1)询问$，预处理时间是$O(MAXN)$，总的时间复杂度为$O(MAXN+n)$</p><h2 id="AC代码-3">AC代码</h2><p>具体细节看看代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x的各位数字拆解，并统计各位数字总和</span></span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        tot+=(x%<span class="number">10</span>);</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//直接输出计算好的ans[n]即可</span></span><br><span class="line">    cout&lt;&lt;ans[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++)&#123;</span><br><span class="line">        <span class="comment">//需要用前缀和数组存下来，因为后面有多次询问，所以需要对应记录哪个i，对应哪个ans[i]</span></span><br><span class="line">        ans[i]=ans[i<span class="number">-1</span>]+<span class="built_in">cal</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-D"><a href="https://codeforces.com/contest/1926/problem/D">Problem D</a></h1><h2 id="思路分析-4">思路分析</h2><p>题目的意思：将给的数字分成若干组，同一组中的若干个数字之间，他们的二进制形式的每一位必须都是不同的，求最小组数<br>我们可以先分析同一组中的数字有什么特点：<br><img src="https://img-blog.csdnimg.cn/direct/064ba75fccfd477c99803f52409a641e.png#pic_center" alt="在这里插入图片描述"><br>那么我们可以根据这个性质，来求解这道题了，具体还得看代码。</p><h2 id="AC代码-4">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LUOGU_RID: 148392530</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//book：输入的数字x的个数，可以理解为存放x的库</span></span><br><span class="line">    map&lt;ll,<span class="type">int</span>&gt; book;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="comment">//查看存放 x对应的异或数（记作y）的库 是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x])&#123;</span><br><span class="line">            <span class="comment">//如果存在，那么book[y]的数量--</span></span><br><span class="line">            book[((<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span>)^x]--;</span><br><span class="line">            <span class="comment">//说明可以创建出一组满组（也就是有x，y的组），ans++，统计一下</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，book[x]++，说明x库中x的数量增加了一个</span></span><br><span class="line">        <span class="keyword">else</span> book[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再遍历一下无法找到 对应的y 的x，那么他们只能单独成组了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:book)&#123;</span><br><span class="line">        ans+=x.second;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Problem-E"><a href="https://codeforces.com/contest/1926/problem/E">Problem E</a></h1><h2 id="思路分析-5">思路分析</h2><p>可以先模拟一下题目说的流程：<br><img src="https://img-blog.csdnimg.cn/direct/c675e02c15524d56a0222edca40eef9e.png#pic_center" alt="在这里插入图片描述"></p><h2 id="AC代码-5">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意得向上取整</span></span><br><span class="line">    <span class="keyword">while</span>(k&gt;(n+<span class="number">1</span>)/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tot=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        k-=tot;</span><br><span class="line">        <span class="comment">//注意总数/2</span></span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//轮数++</span></span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//说实话，我也没太懂为什么是2*k-1</span></span><br><span class="line">    <span class="comment">//owo 我们每一次删除的时候删的是K*(1,3,5······)，所以这里2*k-1，才是对应删的奇数（K泛指系数）</span></span><br><span class="line">    cout&lt;&lt;((<span class="number">2</span>*k<span class="number">-1</span>)&lt;&lt;cnt)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Edu 162</title>
      <link href="/posts/35c7d269.html"/>
      <url>/posts/35c7d269.html</url>
      
        <content type="html"><![CDATA[<h2 id="Problem-A"><a href="https://codeforces.com/contest/1923/problem/A">Problem A</a></h2><h3 id="思路分析">思路分析</h3><p>贪心，因为$chips$只能左移到最近的空格子，所以其实只需要考虑在最长的以1开头和以1结尾的串内（记作$s$）移动即可（其他部分没用，不然只会做多余的移动）。<br>至于怎么移，可以想象把从第一个1串右端的所有1串保持成串的形式，轮流滚近第一个1串，恰好接上为止，可以证明，滚的次数恰好就是$s$内0的个数。<br>画个图比较好理解：<br><img src="https://img-blog.csdnimg.cn/direct/52b551df24b94fe297337faaa27b22d7.png#pic_center" alt="在这里插入图片描述"><br>不难发现：答案就是$s$中0的个数，可以多结合几个样例分析一下。</p><h3 id="代码实现">代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,l=MAXN,r,cnt=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        <span class="comment">//预处理出最长的$s$串的左右端点，注意l初始化为MAXN，并且统计出1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;    </span><br><span class="line">            r=i;</span><br><span class="line">            l=<span class="built_in">min</span>(l,i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;r-l+<span class="number">1</span>-cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//求出0的个数，也就是最少的移动次数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-B"><a href="https://codeforces.com/contest/1923/problem/B">Problem B</a></h2><h3 id="思路分析-2">思路分析</h3><p>贪心，很显然，肯定是需要先打举例我们最近的怪物，再打次近的怪物，依此类推，只要在其中，有一个怪物打不死，那么我们就输了。<br>所以这里可以用到前缀和，预处理出前$i$个最近的怪物们的总血量（记作$pre[i]$），如果在对应的这段时间内，（也就是$abs(a[i].pos)$），我们打出的子弹数$k*abs(a[i].pos)&lt;pre[i]$，那么我们就输出$NO$直接判掉。<br>注意得先派个序，按距离从小到大，可以用结构体+$cmp$。</p><h3 id="代码实现-2">代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll hp,pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a.pos)&lt;<span class="built_in">abs</span>(b.pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,k,ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].hp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;a[i].pos;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans+=a[i].hp;</span><br><span class="line">        <span class="keyword">if</span>(ans&gt;k*<span class="built_in">abs</span>(a[i].pos))&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-C"><a href="https://codeforces.com/contest/1923/problem/C">Problem C</a></h2><h3 id="思路分析-3">思路分析</h3><p>其实就是看能否根据给出的子数组，构造出一个好数组（被翻译坑了）。<br>怎么构造？？？总和相同，但是相同位置的元素不同，并且元素都大于0。<br>有一个比较容易实现的想法：就是在原有的基础上，部分元素加1，显然，有一些元素需要减少，但是又不能减太多（不然就小于0了）。<br>这其中就有一个比较特别的元素：1。1只能加，不能减，那么要加多少个1（记作$x$）就只能由其他非一元素（能够贡献的记作$y$）贡献了。</p><h3 id="代码实现-3">代码实现</h3><p>可以用前缀和，预处理出在各个区间内1的个数，以及各个区间内非一元素的最大贡献。<br>这里有用到一些小技巧：可以先在输入$a[i]$时，将$a[i]–$，这样求出来$sum[r]-sum[l-1]$就是$y$了。<br>需要注意特判一下：如果$l==r$，那么我们就无法构造出好数组（很显然）。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n,q,l,r,tot;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">cnt</span><span class="params">(n+<span class="number">1</span>)</span>,<span class="title">sum</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        a[i]--;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];       <span class="comment">//预处理出前i个元素的最大贡献</span></span><br><span class="line">        cnt[i]=cnt[i<span class="number">-1</span>]+(a[i]==<span class="number">0</span>);  <span class="comment">//预处理出前i个元素中1的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        ll x=cnt[r]-cnt[l<span class="number">-1</span>];</span><br><span class="line">        ll y=sum[r]-sum[l<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(l==r||x&gt;y)cout&lt;&lt;<span class="string">&quot;NO\n&quot;</span>;  <span class="comment">//无法满足或者长度为1，就NO，否则YES</span></span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Problem-D"><a href="https://codeforces.com/contest/1923/problem/D">Problem D</a></h2><h3 id="思路分析-4">思路分析</h3><p>分析题意，很容易想到$i-nd$史莱姆只能被左边的或者右边的吃掉，先分析左边的情况。<br>假设$i$（偷懒，其实是$i-nd$史莱姆，下面也一样）被左边的史莱姆吃掉，先做一些定义：<br>$ans[i]$：被吃掉的最小操作次数。<br>$l[i]$：第$i$个数字的上一个与$a[i]$不同的位置。<br>$left$：记录一个区间的左端点。</p><p>如果存在$left$，使得：<br>1、$[left,i-1]$区间的和&gt;$ans[i]$。<br>2、$[left,i-1]$区间数字种类$&gt;=2$（因为相同不能互相吞并，那么最少需两种大小不同的史莱姆）。<br>那么操作次数就是:$i-left$。</p><p>可以发现$i-1$其实是固定的（对于每一个$i$来说）,并且$left$越小，区间和越大，反之，区间和越小，所以想到可以用二分。<br>那么我们就需要用前缀和求出区间和，再用二分求出端点位置。</p><p>但是怎么判断$[left,i-1]$区间数字种类$&gt;=2$，这时候$l[i]$就派上用场了。<br>二分的左右端点分别为$left$（这里的$left$与上面的$left$无关，是完全不同的两个），$right$。中间值为$mid$。<br>如果$mid&gt;l[i-1]$，那么第二个条件就不成立（此时区间数字种类只有1）.</p><p>基本上就分析完了，但是如果是右边怎么办，我们只需要将数组反转即可。</p><h3 id="代码实现-4">代码实现</h3><p>一些细节可以看注释</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">a</span><span class="params">(MAXN)</span>,<span class="title">pre</span><span class="params">(MAXN)</span>,<span class="title">l</span><span class="params">(MAXN)</span>,<span class="title">ans</span><span class="params">(MAXN)</span>,<span class="title">b</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">//其实跟下面的条件2判断一样，也就是前面的一段全都是同一个数字</span></span><br><span class="line">    <span class="comment">//思路是参考RegenFallen大佬的，但我感觉这一行不用加上去，因为不可能二分到位置为0，试了一下，删去也AC了，所以加不加无所谓</span></span><br><span class="line">    <span class="comment">//if(x&lt;=0)return 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//条件2：区间内数字种类小于2</span></span><br><span class="line">    <span class="keyword">if</span>(x&gt;l[i<span class="number">-1</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//条件1</span></span><br><span class="line">    <span class="keyword">if</span>(pre[i<span class="number">-1</span>]-pre[x<span class="number">-1</span>]&gt;a[i])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        b[n-i+<span class="number">1</span>]=a[i];    <span class="comment">//先反转，存起来</span></span><br><span class="line">        ans[i]=<span class="number">1e9</span>;       <span class="comment">//ans[i]先预处理为1e9</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];         <span class="comment">//预处理出前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];  <span class="comment">//预处理出l[i],可以举几个例子：0333332222</span></span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="comment">//特殊情况判断</span></span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右端点都得判，先判右，再判左，可以保证求出来ans[i]最小，并且有可能右端点不满足（check==false），所以左端点也必须得判断。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[i]=<span class="built_in">min</span>(ans[i],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[i]=<span class="built_in">min</span>(ans[i],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来就是相同的操作，但是注意ans数组的下标要反转</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i]=b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=l[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==a[i<span class="number">-1</span>])l[i]=l[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">else</span> l[i]=i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[i<span class="number">-1</span>])&#123;</span><br><span class="line">            ans[n-i+<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll left=<span class="number">1</span>,right=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">            ll mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid,i))left=mid;</span><br><span class="line">            <span class="keyword">else</span> right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(right,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(left,i))ans[n-i+<span class="number">1</span>]=<span class="built_in">min</span>(ans[n-i+<span class="number">1</span>],i-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cout&lt;&lt;(ans[i]==<span class="number">1e9</span>?<span class="number">-1</span>:ans[i])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Problem-E"><a href="https://codeforces.com/contest/1923/problem/E">Problem E</a></h2><p>以后再补qwq</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF1029A</title>
      <link href="/posts/7554fd3e.html"/>
      <url>/posts/7554fd3e.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Many-Equal-Substrings">Many Equal Substrings</h1><h2 id="题面翻译">题面翻译</h2><p>题目描述：</p><p>你有一个字符串t，它由n个字母组成。</p><p>定义一个字符串s的子串为s[l…r]，表示从位置l到r构成的一个新的串。</p><p>你的目标是构造一个字符串s，使得它的可能长度最小，要求s中存在k个位置i,可以找到k个以i为出发点的子串t。</p><p>输入： 第一行输入两个整数n和k，表示t的长度和需要k个子串</p><p>第二行输入字符串t</p><p>输出：</p><p>输出满足条件的长度最小的s。题目保证答案唯一。</p><h2 id="题目描述">题目描述</h2><p>You are given a string $ t $ consisting of $ n $ lowercase Latin<br>letters and an integer number $ k $ .</p><p>Let’s define a substring of some string $ s $ with indices from $ l $<br>to $ r $ as $ s[l \dots r] $ .</p><p>Your task is to construct such string $ s $ of minimum possible length<br>that there are exactly $ k $ positions $ i $ such that $ s[i \dots i +<br>n - 1] = t $ . In other words, your task is to construct such string $<br>s $ of minimum possible length that there are exactly $ k $ substrings<br>of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="输入格式">输入格式</h2><p>The first line of the input contains two integers $ n $ and $ k $ ( $<br>1 \le n, k \le 50 $ ) — the length of the string $ t $ and the number<br>of substrings.</p><p>The second line of the input contains the string $ t $ consisting of<br>exactly $ n $ lowercase Latin letters.</p><h2 id="输出格式">输出格式</h2><p>Print such string $ s $ of minimum possible length that there are<br>exactly $ k $ substrings of $ s $ equal to $ t $ .</p><p>It is guaranteed that the answer is always unique.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 4 aba </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababababa </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>3 2 cat </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>catcat </code></p></blockquote><p>看到这道题要求的答案，想到了熟悉的循环节问题，就从这入手吧。<br>还是先求出来$t$的最小的循环节（记作$p$），并根据$k$进行多次构造。</p><p>但是，通过样例一可以发现，构造出来的$s$可能不是恰好由整数个$p$构成。<br>看样例一，可以发现最后恰好是由$pmt[n-1]$构成。</p><p>根据题意，可以总结出：前面输出$k-1$个循环节，后面输出$t$即可。<br>因为前面的$k-1$个循环节首尾相连，已经是构成了$k-1$个$t$结构了。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],n,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;s.<span class="built_in">length</span>()-pmt[s.<span class="built_in">length</span>()<span class="number">-1</span>];j++)&#123;</span><br><span class="line">            cout&lt;&lt;s[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF45D</title>
      <link href="/posts/97ecd816.html"/>
      <url>/posts/97ecd816.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Writing-a-Song">Writing a Song</h1><h2 id="题面翻译">题面翻译</h2><p><strong>题目大意</strong></p><p>求一个字符串s，满足该串长度为n，只出现字母表中前k个字母，并且在指定位置必须出现指定字符串p</p><p><strong>输入格式</strong></p><p>第一行 n，k。(n为所需字符串的长度 n&lt;=100，k为相应的字母大小 2&lt;=k&lt;=26)</p><p>第二行 p。（一个长度小于n，只包含字母表中前k个字母的字符串）</p><p>第三行 01串。（在第i个位置的数字1表示p的出现应该从s的第i个位置开始，而0表示从这里开始没有出现。）</p><p><strong>输出格式</strong></p><p>输出任意一个符合题意的字符串s</p><p>若无，输出“No solution”</p><h2 id="题目描述">题目描述</h2><p>One of the Hedgehog and his friend’s favorite entertainments is to<br>take some sentence or a song and replace half of the words (sometimes<br>even all of them) with each other’s names.</p><p>The friend’s birthday is approaching and the Hedgehog decided to make<br>a special present to his friend: a very long song, where his name will<br>be repeated many times. But try as he might, he can’t write a decent<br>song!</p><p>The problem is that the Hedgehog has already decided how long the<br>resulting sentence should be (i.e. how many letters it should contain)<br>and in which positions in the sentence the friend’s name should occur,<br>and it must not occur in any other position in the sentence. Besides,<br>the Hedgehog decided to limit himself to using only the first $ K $<br>letters of an English alphabet in this sentence (so it will be not<br>even a sentence, but one long word).</p><p>The resulting problem is indeed quite complicated, that’s why the<br>Hedgehog asks you to help him and write a program that will make the<br>desired word by the given name $ P $ , the length $ N $ of the<br>required word, the given positions of the occurrences of the name $ P<br>$ in the desired word and the alphabet’s size $ K $ . Note that the<br>occurrences of the name can overlap with each other.</p><h2 id="输入格式">输入格式</h2><p>The first line contains numbers $ N $ and $ K $ which are the length<br>of the required string and the alphabet size accordingly. The<br>limitations are: $ 1&lt;=N&lt;=100 $ , $ 2&lt;=K&lt;=26 $ .</p><p>The second line contains the name $ P $ which is a non-empty string<br>whose length does not exceed $ N $ characters. The string consists<br>only of the first $ K $ lowercase symbols of an English alphabet.</p><p>The third line contains the string of length $ N-length(P)+1 $ ,<br>consisting only of numbers zero and one. A number one in the $ i $ -th<br>position means that an occurrence of the name $ P $ should start from<br>$ i $ -th position of the desired word, while a zero means that there<br>is no occurrence starting here.</p><h2 id="输出格式">输出格式</h2><p>Print the desired word $ S $ . If there are several answers, print any<br>of them.</p><p>If there is no solution, then print “No solution”.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>5 2 aba 101 </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>ababa </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>5 2 a 10001 </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>abbba </code></p><h2 id="样例-3">样例 #3</h2><h3 id="样例输入-3">样例输入 #3</h3><p><code>6 2 abba 101 </code></p><h3 id="样例输出-3">样例输出 #3</h3><p><code>No solution </code></p></blockquote><p>可怕的构造题，不会qwq，只能看题解区大佬了（大佬讲得很清楚）：<br><a href="https://www.luogu.com.cn/problem/solution/CF54D">https://www.luogu.com.cn/problem/solution/CF54D</a><br>构造这方面得加强qwq，贴上AC代码：</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">char</span> ans[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    string p;</span><br><span class="line">    cin&gt;&gt;p;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="type">int</span> lenp=p.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> lens=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lens;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[i+j]=p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[i+j]&amp;&amp;ans[i+j]!=p[j])<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;lenp;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!ans[i+j])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(p[j]==<span class="string">&#x27;a&#x27;</span>)ans[i+j]=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                        <span class="keyword">else</span> ans[i+j]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==lenp)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;No solution\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ans[i])ans[i]=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        cout&lt;&lt;ans[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>感觉还是得多想想特殊情况：<br>1、搜索1的时候：有没有重复占位，也就是$ans[i+j]$存在，并且$ans[i+j]!=p[j]$，如果存在，说明该位已经被占领了，直接$No$ $solution$。<br>2、搜索0的时候：看看有没有$ans[i+j]$存在，并且$ans[i+j]!=p[j]$，如果存在，则该位构造成功，直接$break$，不用做重复的判断。<br>3、如果2的情况没有发生，我们发现这里实际上只有两种情况（与上面相对应）：$ans[i+j]==0$ $or$ $ans[i+j]==p[j]$。第二种情况已经没办法改变了（因为我们在上面的构造时已经确定$ans[i+j]==p[j]$），那么我们只能改变第一种情况，看看$s[j]$是什么，那么$ans[i+j]$构造时只需要注意不等于$s[j]$即可（这里情况一存在的话，可以直接构造后$break$掉，提高一点效率，后面输出时再简单构造即可）。<br>4、如果情况一也没有发生呢？？？很不幸，那就只能$No$ $solution$了。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CF126B</title>
      <link href="/posts/910b6b7b.html"/>
      <url>/posts/910b6b7b.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Password">Password</h1><h2 id="题面翻译">题面翻译</h2><p>Asterix，Obelix 和他们的临时伙伴 Suffix、Prefix 已经最终找到了和谐寺。然而和谐寺大门紧闭，就连 Obelix<br>的运气也没好到能打开它。</p><p>不久他们发现了一个字符串 $S\ (1\leqslant\vert<br>S\vert\leqslant1000000)$，刻在和谐寺大门下面的岩石上。Asterix<br>猜想那一定是打开寺庙大门的密码，于是就大声将字符串朗读了出来，然而并没有什么事发生。于是 Asterix 又猜想密码一定是字符串 $S$<br>的子串 $T$。</p><p>Prefix 认为 $T$ 是 $S$ 的前缀，Suffix 认为 $T$ 是 $S$ 的后缀，Obelix 却认为 $T$ 应该是 $S$<br>中的某一部分，也就是说，$T$ 既不是 $S$ 的前缀，也不是 $S$ 的后缀。</p><p>Asterix 选择子串 $T$ 来满足所有伙伴们的想法。同时，在所有可以被接受的子串变形中，Asterix 选择了最长的一个。当<br>Asterix 大声读出子串 $T$ 时，寺庙的大门开了。（也就是说，你需要找到既是 $S$ 的前缀又是 $S$ 的后缀同时又在 $S$<br>中间出现过的最长子串）</p><p>现在给你字符串 $S$，你需要找到满足上述要求的子串 $T$。</p><h3 id="输入格式">输入格式</h3><p>一行一个只包含小写字母的字符串 $S$。</p><h3 id="输出格式">输出格式</h3><p>输出子串 $T$，如果 $T$ 不存在，输出 <code>Just a legend</code>。</p><h2 id="题目描述">题目描述</h2><p>Asterix, Obelix and their temporary buddies Suffix and Prefix has<br>finally found the Harmony temple. However, its doors were firmly<br>locked and even Obelix had no luck opening them.</p><p>A little later they found a string $ s $ , carved on a rock below the<br>temple’s gates. Asterix supposed that that’s the password that opens<br>the temple and read the string aloud. However, nothing happened. Then<br>Asterix supposed that a password is some substring $ t $ of the string<br>$ s $ .</p><p>Prefix supposed that the substring $ t $ is the beginning of the<br>string $ s $ ; Suffix supposed that the substring $ t $ should be the<br>end of the string $ s $ ; and Obelix supposed that $ t $ should be<br>located somewhere inside the string $ s $ , that is, $ t $ is neither<br>its beginning, nor its end.</p><p>Asterix chose the substring $ t $ so as to please all his companions.<br>Besides, from all acceptable variants Asterix chose the longest one<br>(as Asterix loves long strings). When Asterix read the substring $ t $<br>aloud, the temple doors opened.</p><p>You know the string $ s $ . Find the substring $ t $ or determine that<br>such substring does not exist and all that’s been written above is<br>just a nice legend.</p><h2 id="输入格式-2">输入格式</h2><p>You are given the string $ s $ whose length can vary from $ 1 $ to $<br>10^{6} $ (inclusive), consisting of small Latin letters.</p><h2 id="输出格式-2">输出格式</h2><p>Print the string $ t $ . If a suitable $ t $ string does not exist,<br>then print “Just a legend” without the quotes.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>fixprefixsuffix </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>fix </code></p><h2 id="样例-2">样例 #2</h2><h3 id="样例输入-2">样例输入 #2</h3><p><code>abcdabc </code></p><h3 id="样例输出-2">样例输出 #2</h3><p><code>Just a legend </code></p></blockquote><p>看到这题的第一眼，想到的肯定是KMP（因为需要求最长公共前后缀嘛，将其记作$t$，母串记作$s$）。<br>但是，$t$还需要是$s$的中间部分，这个怎么办？？？<br>我们可以将它转化为熟悉的问题，画个图解释一下：<br><img src="https://img-blog.csdnimg.cn/direct/3fa1ee27e9eb4e6d8580999418d6f7b0.png#pic_center" alt="在这里插入图片描述">这样就一目了然了吧，$t$也是中间的橙色串的最长前后缀，这就转化成了我们熟悉的问题。</p><p>那么我们只要$2$遍历到$n-2$，只要$pmt[i]==pmt[n-1]$，那么我们就找到最长的$t$了。</p><p>但是，实际上可能是找不到的（看题意就知道了），如果$pmt[n-1]$比$max(pmt[i])$还大，所以这时$t$的长度就得缩小了（也就是不断地往回跳：$pmt[pmt[n-1]]$，$pmt[pmt[pmt[n-1]]]······$，直到小于$max(pmt[i])$，注意$i&lt;=n-2$）。</p><p>可能有点混乱，将上述的步骤总结一下：<br>1、先预处理出$max(pmt[i])，i&lt;=n-2$。<br>2、判断$pmt[n-1]$与$max(pmt[i])$的大小关系，如果$pmt[n-1]&gt;=max(pmt[i])$，就得往回跳，直到小于$max(pmt[i])$为止（记作$len$吧)，当然有可能跳到0，那么这时候就无解了。<br>3、如果有解，那么我们只需要输出$0$~$len-1$即可，毕竟$len$是字符串的长度。</p><p>我们可以在第二步开始前加上特判$pmt[n-1]==0$是否成立，如果成立，就说明前后缀不同，肯定无解。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN],maxn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">        <span class="keyword">if</span>(i!=s.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            maxn=<span class="built_in">max</span>(maxn,pmt[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> len=pmt[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len&gt;maxn)&#123;</span><br><span class="line">            len=pmt[len<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Just a legend\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                cout&lt;&lt;s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA1328</title>
      <link href="/posts/f80dab9f.html"/>
      <url>/posts/f80dab9f.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Period">Period</h1><h2 id="题面翻译">题面翻译</h2><p>对于给定字符串 $S$<br>的每个前缀，我们想知道它是否为周期串（周期串定义为由若干最小循环节拼接而成的字符串），若是，输出前缀长度和循环节数量。</p><p><strong>【输入格式】</strong></p><p>多组数据，每组数据第一行一个整数 $n$，表示字符串 $s$ 的长度，若 $n=0$ 则结束输入。</p><p>若 $n\ne0$，则第二行一个字符串 $S$，如题意。</p><p><strong>【输出格式】</strong></p><p>对于第 $i$ 组输出，第一行一个字符串 <code>Test case #i</code>。</p><p>之后若干行一行两个整数，表示如果字符串 $S$ 的一个前缀是周期串，它的长度和循环节数量（注意这里的循环节是指<strong>长度最小的</strong>循环节）。</p><p>之后再空一行。</p><p><strong>【说明】</strong></p><p>$n\leq10^6$，字符串 $S$ 均由小写字母构成。</p><h2 id="题目描述">题目描述</h2><p><a href="https://uva.onlinejudge.org/external/13/p1328.pdf">PDF</a></p><h2 id="输入格式">输入格式</h2><h2 id="输出格式">输出格式</h2><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>3 aaa 12 aabaabaabaab 0 </code></p><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight plaintext"><figcaption><span>case #1 2 2 3 3</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Test case #2 2 2 6 2 9 3 12 4 ```</span><br><span class="line"></span><br><span class="line">还是熟悉的最小循环节问题，需要注意的是，前缀长度需要大于1，所以需要从2开始判断，最大前缀长度就是$S$的长度。</span><br><span class="line"></span><br><span class="line">判断有没有循环节，看$pmt[i-1]$是否存在，计算循环节数量，看$n$%$(n-pmt[n-1])$是否等于0（因为$S$的前缀串$t$需要作为周期串）。</span><br><span class="line"></span><br><span class="line">每个测试点之间的空行特判一下即可，看$i==len$是否成立。</span><br><span class="line"></span><br><span class="line">## AC代码</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using ll=long long;</span><br><span class="line">const int MAXN=1e6+10;</span><br><span class="line">int pmt[MAXN],n,cnt;</span><br><span class="line">string s;</span><br><span class="line">void get_pmt(const string&amp; s)&#123;</span><br><span class="line">   for(int i=1,j=0;i&lt;s.length();i++)&#123;</span><br><span class="line">       while(j&amp;&amp;s[i]!=s[j])j=pmt[j-1];</span><br><span class="line">       if(s[i]==s[j])j++;</span><br><span class="line">       pmt[i]=j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">   ios::sync_with_stdio(0),cin.tie(0);</span><br><span class="line">   while(1)&#123;</span><br><span class="line">       cin&gt;&gt;n;</span><br><span class="line">       if(n==0)break;</span><br><span class="line">       cin&gt;&gt;s;</span><br><span class="line">       int len=s.length();</span><br><span class="line">       memset(pmt,0,sizeof(pmt));</span><br><span class="line">       get_pmt(s);</span><br><span class="line">       cout&lt;&lt;&quot;Test case #&quot;&lt;&lt;++cnt&lt;&lt;&quot;\n&quot;;</span><br><span class="line">       for(int i=2;i&lt;=len;i++)&#123;</span><br><span class="line">           if(pmt[i-1]&amp;&amp;i%(i-pmt[i-1])==0)&#123;</span><br><span class="line">               cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i/(i-pmt[i-1])&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">           if(i==len)&#123;</span><br><span class="line">               cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA10298</title>
      <link href="/posts/91e64ac2.html"/>
      <url>/posts/91e64ac2.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="Power-Strings">Power Strings</h1><h2 id="题面翻译">题面翻译</h2><h3 id="题意简述：">题意简述：</h3><p>求一个字符串由多少个重复的子串连接而成。</p><p>例如 <code>ababab</code> 由三个 <code>ab</code> 连接而成，<code>abcd</code> 由 <code>abcd</code> 由一个 <code>abcd</code> 连接而成。</p><h3 id="输入格式">输入格式</h3><p><strong>本题多组数据</strong>。</p><p>每一组数据仅有一行，这一行仅有一个字符串 $s$。</p><p>输入的结束标志为一个 <code>.</code>。</p><h3 id="输出格式">输出格式</h3><p>对于每一组数据，输出这组字符串由多少个重复的子串连接而成。</p><h3 id="说明-提示">说明/提示</h3><p>$1\le |s|\le 10^6$。</p><h2 id="题目描述">题目描述</h2><p><a href="https://uva.onlinejudge.org/external/102/p10298.pdf">PDF</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5a89b1b5be26ca2d032d51c4fc5e18d2.png" alt=""></p><h2 id="输入格式-2">输入格式</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/aa5c61819fa5b54135f8b7236af00a7e.png" alt=""></p><h2 id="输出格式-2">输出格式</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/795c5ef49846eb46a838271a5812fff1.png" alt=""></p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>abcd aaaa ababab . </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 4 3 </code></p></blockquote><p>其实方法还是一样的，求出最短的循环节(记作$p$)，也就是$n-pmt[n-1]$，然后就是$n/(n-pmt[n-1])$。<br>但是，这里需要注意的是：$s$可能不是由整数个$p$构成的，可能存在最后的$p$被切割的情况。（一开始没考虑到这点，看了题解才反应过来）。<br>那么这里就需要进行特叛了：如果$n$%$(n-pmt[n-1])==0$，说明恰好整除，那么$n/(n-pmt[n-1])$就是答案了。<br>如果$n$%$(n-pmt[n-1])!=0$，那么只能以$s$自身作为循环节了，答案也就是1。<br>具体的证明可以看看评论区的大佬，写的很好：<a href="https://www.luogu.com.cn/blog/hzz/solution-uva10298">https://www.luogu.com.cn/blog/hzz/solution-uva10298</a></p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="built_in">getline</span>(cin,s);</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">length</span>()==<span class="number">1</span>&amp;&amp;s[<span class="number">0</span>]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">get_pmt</span>(s);</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span>(n%(n-pmt[n<span class="number">-1</span>])==<span class="number">0</span>)cout&lt;&lt;n/(n-pmt[n<span class="number">-1</span>])&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项">注意事项</h2><p>因为这道题目是有多个数据输入，且一行一个$s$，所以我们可以用$getlin(cin,s)$，只需要当$s$为&quot;$.$&quot;时结束即可。</p><h2 id="结论总结：">结论总结：</h2><p>设字符串的长度为$n$，最长相同前后缀的长度为$pmt[n-1]$。如果$n$%$(n-pmt[n-1])==0$，则答案为$n/(n-pmt[n-1])$，否则为1。</p>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3375</title>
      <link href="/posts/7da9ce2f.html"/>
      <url>/posts/7da9ce2f.html</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="【模板】KMP">【模板】KMP</h1><h2 id="题目描述">题目描述</h2><p>给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在<br>$s_1$ 中出现了，其出现位置为 $l$。   现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。</p><p>定义一个字符串 $s$ 的 border 为 $s$ 的一个<strong>非 $s$ 本身</strong>的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是<br>$s$ 的后缀。   对于 $s_2$，你还需要求出对于其每个前缀 $s’$ 的最长 border $t’$ 的长度。</p><h2 id="输入格式">输入格式</h2><p>第一行为一个字符串，即为 $s_1$。   第二行为一个字符串，即为 $s_2$。</p><h2 id="输出格式">输出格式</h2><p>首先输出若干行，每行一个整数，<strong>按从小到大的顺序</strong>输出 $s_2$ 在 $s_1$ 中出现的位置。   最后一行输出 $|s_2|$<br>个整数，第 $i$ 个整数表示 $s_2$ 的长度为 $i$ 的前缀的最长 border 长度。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>ABABABC ABA </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>1 3 0 0 1 </code></p><h2 id="提示">提示</h2><h3 id="样例-1-解释">样例 1 解释</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3c98caa2ee905bfada0eb2516ba7b8cc.png" alt="">。<br>对于 $s_2$ 长度为 $3$ 的前缀 <code>ABA</code>，字符串 <code>A</code> 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为<br>$1$。</p><h3 id="数据规模与约定">数据规模与约定</h3><p><strong>本题采用多测试点捆绑测试，共有 3 个子任务</strong>。</p><ul><li>Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。</li><li>Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。</li><li>Subtask 3（30 points）：无特殊约定。</li></ul><p>对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。</p></blockquote><p>这道题就是妥妥的KMP模板题，具体原理可以参考知乎Pecco大佬的文章，链接贴上：<a href="https://zhuanlan.zhihu.com/p/105629613">https://zhuanlan.zhihu.com/p/105629613</a></p><p>需要注意的一点是：Pecco大佬的KMP写法与我所看到的大部分写法有细节上的不同，所以做题的时候，如果打算用Pecco大佬的码作为模板，你需要经常琢磨到底哪一点需要修改，就当是锻炼自己是否真正理解了KMP算法吧。</p><h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span> pmt[MAXN];  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;  </span><br><span class="line">        pmt[i]=j;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">const</span> string &amp;p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=p[j])j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j])j++;  </span><br><span class="line">        <span class="keyword">if</span>(j==p.<span class="built_in">length</span>())&#123;  </span><br><span class="line">            cout&lt;&lt;i-j+<span class="number">2</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">            j=pmt[j<span class="number">-1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);  </span><br><span class="line">    string s,p;  </span><br><span class="line">    cin&gt;&gt;s&gt;&gt;p;  </span><br><span class="line">    <span class="built_in">get_pmt</span>(p);  </span><br><span class="line">    <span class="built_in">kmp</span>(s,p);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">length</span>();i++)&#123;  </span><br><span class="line">        cout&lt;&lt;pmt[i]&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3435</title>
      <link href="/posts/1c8a1dae.html"/>
      <url>/posts/1c8a1dae.html</url>
      
        <content type="html"><![CDATA[<hr><h1 id="POI2006-OKR-Periods-of-Words">[POI2006] OKR-Periods of Words</h1><blockquote><h2 id="题面翻译">题面翻译</h2><p>对于一个仅含小写字母的字符串 $a$，$p$ 为 $a$ 的前缀且 $p\ne a$，那么我们称 $p$ 为 $a$ 的 proper<br>前缀。</p><p>规定字符串 $Q$ 表示 $a$ 的周期，当且仅当 $Q$ 是 $a$ 的 proper 前缀且 $a$ 是 $Q+Q$<br>的前缀。若这样的字符串不存在，则 $a$ 的周期为空串。</p><p>例如 <code>ab</code> 是 <code>abab</code> 的一个周期，因为 <code>ab</code> 是 <code>abab</code> 的 proper 前缀，且 <code>abab</code> 是 <code>ab+ab</code><br>的前缀。</p><p>求给定字符串所有前缀的最大周期长度之和。</p><h2 id="题目描述">题目描述</h2><p>A string is a finite sequence of lower-case (non-capital) letters of<br>the English alphabet. Particularly, it may be an empty sequence, i.e.<br>a sequence of 0 letters. By A=BC we denotes that A is a string<br>obtained by concatenation (joining by writing one immediately after<br>another, i.e. without any space, etc.) of the strings B and C (in this<br>order). A string P is a prefix of the string !, if there is a string<br>B, that A=PB. In other words, prefixes of A are the initial fragments<br>of A. In addition, if P!=A and P is not an empty string, we say, that<br>P is a proper prefix of A.</p><p>A string Q is a period of Q, if Q is a proper prefix of A and A is a<br>prefix (not necessarily a proper one) of the string QQ. For example,<br>the strings abab and ababab are both periods of the string abababa.<br>The maximum period of a string A is the longest of its periods or the<br>empty string, if A doesn’t have any period. For example, the maximum<br>period of ababab is abab. The maximum period of abc is the empty<br>string.</p><p>Task Write a programme that:</p><p>reads from the standard input the string’s length and the string<br>itself,calculates the sum of lengths of maximum periods of all its<br>prefixes,writes the result to the standard output.</p><h2 id="输入格式">输入格式</h2><p>In the first line of the standard input there is one integer $k$<br>($1\le k\le 1\ 000\ 000$) - the length of the string. In the following<br>line a sequence of exactly $k$ lower-case letters of the English<br>alphabet is written - the string.</p><h2 id="输出格式">输出格式</h2><p>In the first and only line of the standard output your programme<br>should write an integer - the sum of lengths of maximum periods of all<br>prefixes of the string given in the input.</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><p><code>8 babababa </code></p><h3 id="样例输出-1">样例输出 #1</h3><p><code>24 </code></p></blockquote><p>先理解清楚题意：proper前缀可以配合下图理解<br><img src="https://img-blog.csdnimg.cn/direct/2c12d9db942e46608af09d0f84a0255d.png#pic_center" alt="在这里插入图片描述"><br>这里我们不难看出：abcabcab的最长proper字串为abcabc，长度是6。<br>记原来的字符串为$s$，proper子串为$t$。<br>想想看，如果是要使得proper字串最长，那么恰好就是$len(s)-min(border)$。<br>我们可以大致感受一下，如果$border$越大，那么对应的$len(t)$越小，可以结合上面的例子。<br>那么我们的问题就变成了怎么求最小的$border$。<br>问题是，在KMP算法中，$pmt$求出来的是$max(border)$。<br>我们可以利用KMP算法的一个性质：$pmt[i]、pmt[pnt[i]]、pmt[pmt[pmt[i]]]······$<br>直到为0，以上这些都是$s$的$border$的长度，并且越来越小。<br>利用这个性质，我们就可以求出来$min(border)$。</p><p>因为题目是求所有前缀的最大周期长度之和，所以我们令$j=i+1$。（因为我个人的KMP写得比较奇怪，题解区的大佬是令$j=i$）。然后在$j&gt;0$的情况下不断令$j=pmt[j-1]$，直到$j$最小为止。此时$ans+=i-j+1$。<br>这里有一个技巧：当$j$求出来后，令$pmt[i]=j$，相当于记忆化，否则可能会T。</p><p>思路参考：<a href="https://www.luogu.com.cn/problem/solution/P3435">https://www.luogu.com.cn/problem/solution/P3435</a></p><p>贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> pmt[MAXN];</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_pmt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&amp;&amp;s[i]!=s[j])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==s[j])j++;</span><br><span class="line">        pmt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    <span class="built_in">get_pmt</span>(s);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">        j=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(pmt[j<span class="number">-1</span>])j=pmt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(pmt[i])pmt[i]=j;</span><br><span class="line">        ans+=i-j+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 蒟蒻的ACM之旅 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
