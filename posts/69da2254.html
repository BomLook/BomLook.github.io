<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>王道计算机数据结构考研——线性表 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="王道计算机数据结构考研——线性表 题目 线性表的定义和基本操作 单项选择题  线性表是具有()的有限序列   A. 数据表 B. 字符 C. 数据元素 D. 邻接表  答案：C。线性表是由具有相同数据类型的有限数据元素组成的，数据元素是由数据项组成的。   以下()是一个线性表   A. 由$n$个实数组成的集合 B. 由100个字符组成的序列 C. 所有整数组成的序列 D. 邻接表  答案：B。">
<meta property="og:type" content="article">
<meta property="og:title" content="王道计算机数据结构考研——线性表">
<meta property="og:url" content="https://www.heavenhold.cn/posts/69da2254.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="王道计算机数据结构考研——线性表 题目 线性表的定义和基本操作 单项选择题  线性表是具有()的有限序列   A. 数据表 B. 字符 C. 数据元素 D. 邻接表  答案：C。线性表是由具有相同数据类型的有限数据元素组成的，数据元素是由数据项组成的。   以下()是一个线性表   A. 由$n$个实数组成的集合 B. 由100个字符组成的序列 C. 所有整数组成的序列 D. 邻接表  答案：B。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410071700168.webp">
<meta property="article:published_time" content="2024-10-07T13:04:00.000Z">
<meta property="article:modified_time" content="2024-10-07T13:07:28.771Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="王道考研">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410071700168.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/69da2254.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '王道计算机数据结构考研——线性表',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-10-07 21:07:28'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">184</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410071700168.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">王道计算机数据结构考研——线性表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-07T13:04:00.000Z" title="发表于 2024-10-07 21:04:00">2024-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-07T13:07:28.771Z" title="更新于 2024-10-07 21:07:28">2024-10-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/">王道考研</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>29分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="王道计算机数据结构考研——线性表"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="王道计算机数据结构考研——线性表">王道计算机数据结构考研——线性表</h1>
<h2 id="题目">题目</h2>
<h3 id="线性表的定义和基本操作">线性表的定义和基本操作</h3>
<h4 id="单项选择题">单项选择题</h4>
<ol>
<li>线性表是具有()的有限序列</li>
</ol>
<ul>
<li>A. 数据表</li>
<li>B. 字符</li>
<li>C. 数据元素</li>
<li>D. 邻接表</li>
</ul>
<p><strong>答案：C</strong>。线性表是由具有相同数据类型的有限数据元素组成的，数据元素是由数据项组成的。</p>
<hr>
<ol start="2">
<li>以下()是一个线性表</li>
</ol>
<ul>
<li>A. 由$n$个实数组成的集合</li>
<li>B. 由100个字符组成的序列</li>
<li>C. 所有整数组成的序列</li>
<li>D. 邻接表</li>
</ul>
<p><strong>答案：B</strong>。线性表定义的要求为：相同数据类型、有限序列。选项C的元素个数是无穷个，错误；选项A集合中的元素没有前后驱关系，错误；选项D属于存储结构，线性表是一种逻辑结构，不要将  二者混为一谈。只有选项B符合线性表定义的要求。</p>
<hr>
<ol start="3">
<li>在线性表中，除开始元素外，每个元素().</li>
</ol>
<ul>
<li>A. 只有唯一的前驱元素</li>
<li>B. 只有唯一的后继元素</li>
<li>C. 有多个前驱元素</li>
<li>D. 有多个后继元素</li>
</ul>
<p><strong>答案：A</strong>。线性表中，除最后一个(或第一不)元素外，每个元素都只有一个后继(或前驱)元素。</p>
<h3 id="线性表的顺序表示">线性表的顺序表示</h3>
<h4 id="单项选择题-2">单项选择题</h4>
<ol>
<li>下述()是顺序存储结构的优点</li>
</ol>
<ul>
<li>A. 存储密度大</li>
<li>B. 插入运算方便</li>
<li>C. 删除运算方便</li>
<li>D. 方便地运用于各种逻辑结构的存储表示</li>
</ul>
<p><strong>答案：A</strong>。顺序表不像链表那样要在结点中存放指针域，因此存储密度较大，A正确。B和C是链表的  优点。D是错误的，比如对于树形结构，顺序表显然不如链表表示起来方便。</p>
<hr>
<ol start="2">
<li>线性表的顺序存储结构是一种()</li>
</ol>
<ul>
<li>A. 随机存取的存储结构</li>
<li>B. 顺序存取的存储结构</li>
<li>C. 索引存取的存储结构</li>
<li>D. 散列存取的存储结构</li>
</ul>
<p><strong>答案：A</strong>。本题易误选B。注意，存取方式是指读写方式。顺序表是一种支持随机存取的存储结构，根据起始地址加上元素的序号，可以很方便地访问任意一个元素，这就是随机存取的概念</p>
<hr>
<ol start="3">
<li>一个顺序表所占用的存储空间大小与()无关</li>
</ol>
<ul>
<li>A. 表的长度</li>
<li>B. 元素的存放顺序</li>
<li>C. 元素的类型</li>
<li>D. 元素中各字段的类型</li>
</ul>
<p><strong>答案：B</strong>。顺序表所占的存储空间=表长*<code>sizeof</code> (元素的类型)，表长和元素的类型显然会影响存储空间的大小。若元素为结构体类型，则元素中各字段的类型也会影响存储空间的大小</p>
<hr>
<ol start="4">
<li>若线性表最常用的操作是存取第$i$个元素及其前驱和后继元素的值，为了提高效率，应采用()的存储方式</li>
</ol>
<ul>
<li>A. 单链表</li>
<li>B. 双向链表</li>
<li>C. 单循环链表</li>
<li>D. 顺序表</li>
</ul>
<p><strong>答案：D</strong>。题干实际要求能最快存取第$i-1$，$i$和$i+1$个元素值。A、B、C都只能从头结点依次顺序查找，时间复杂度为$O(n)$。只有顺序表可以按序号随机存取，时间复杂度为$O(1)$。</p>
<hr>
<ol start="5">
<li>一个线性表最常用的操作是存取任意一个指定序号的元素并在最后进行插入、删除操作，则利用()存储方式可以节省时间。</li>
</ol>
<ul>
<li>A. 顺序表</li>
<li>B. 双链表</li>
<li>C. 带头结点的双循环链表</li>
<li>D. 单循环链表</li>
</ul>
<p><strong>答案：A</strong>。只有顺序表可以按序号随机存取，且在最后进行插入和删除操作时不需要移动任何元素。</p>
<hr>
<ol start="6">
<li>在$n$个元素的线性表的数组表示中，时间复杂度为$O(1)$的操作是()</li>
</ol>
<p>I. 访问第$i (1 \leq i \leq n)$个结点和求第$i (2 \leq i \leq n)$个结点的直接前驱<br>
II. 在最后一个结点后插入一个新的结点<br>
III. 删除第1个结点<br>
IV. 在第$i (1 \leq i \leq n)$个结点后插入一个结点</p>
<ul>
<li>A. I</li>
<li>B. II、III</li>
<li>C. I、II</li>
<li>D. I、II、III</li>
</ul>
<p><strong>答案：C</strong>。 I解析略；II中，在最后位置插入新结点不需要移动元素，时间复杂度为$O(1)$； III中，被删结点后的结点需依次前移，时间复杂度为$O(n)$。(〃)；IV中，需要后移$n-i$个结点，时间复杂度为$O(n)$。</p>
<hr>
<ol start="7">
<li>设线性表有$n$个元素，严格说来，以下操作中，()在顺序表上实现要比在链表上实现的效率高</li>
</ol>
<p>I. 输出第$i (1\leq i \leq n)$个元素值<br>
II. 交换第3个元素与第4个元素的值<br>
III. 顺序输出这$n$个元素的值</p>
<ul>
<li>A. I</li>
<li>B. I、III</li>
<li>C. I、II</li>
<li>D. II、III</li>
</ul>
<p><strong>答案：C</strong>。对于II，顺序表仅需3次交换操作(<code>a=b,b=c,a=c</code>)；链表则需要分别找到两个结点前驱，第4个结点断链后再插入到第2个结点后，效率较低。对于III，需依次顺序访问每个元素，时间复杂度相同。</p>
<hr>
<ol start="8">
<li>在一个长度为$n$的顺序表中删除第$i(1 \leq i \leq n)$个元素时，需向前移动()个元素</li>
</ol>
<ul>
<li>A. $n$</li>
<li>B. $i - 1$</li>
<li>C. $n - i$</li>
<li>D. $n - i + 1$</li>
</ul>
<p><strong>答案：C</strong>。需要将$a_{i+1}-a_n$元素依次前移一位，共移动$n-(i+1)+1=n-i$个元素</p>
<hr>
<ol start="9">
<li>对于顺序表，访问第i个位置的元素和在第i个位置插入一个元素的时间复杂度为()</li>
</ol>
<ul>
<li>A. $O(n), O(n)  $</li>
<li>B. $O(n), O(1)  $</li>
<li>C. $O(1), O(n)  $</li>
<li>D. $O(1), O(1)$</li>
</ul>
<p><strong>答案：C</strong>。在第$i$个位置插入一个元素，需要移动$n-i+1$个元素，时间复杂度为$O(n)$。</p>
<hr>
<ol start="10">
<li>若长度为$n$的非空线性表采用顺序存储结构，在表的第$i$个位置插入一个数据元素，则$i$的合法值应该是()</li>
</ol>
<ul>
<li>A. $1 \leq i \leq n$</li>
<li>B. $1 \leq i \leq n+1$</li>
<li>C. $0 \leq i \leq n-1$</li>
<li>D. $0 \leq i \leq n$</li>
</ul>
<p>**答案：**B。线性表元素的序号是从1开始，而在第$n+1$个位置插入相当于在表尾追加。</p>
<ol start="11">
<li>在顺序表的插入算法中，当n个空间已满时，可再申请增加分配m个空间，若申请失败，则说明系统没有()可分配的存储空间。</li>
</ol>
<ul>
<li>A. $m$个</li>
<li>B. $m$个连续</li>
<li>C. $n + m$个</li>
<li>D. $n + m$个连续</li>
</ul>
<p><strong>答案：D</strong>。顺序存储需要连续的存储空间，在申请时需申请$n + m$个连续的存储空间，然后将线性表原来的$n$个元素复制到新申请的$n + m$个连续的存储空间的前$n$个单元。</p>
<h4 id="综合应用题">综合应用题</h4>
<ol>
<li>
<p>从顺序表中删除具有最小值的元素(假设唯一)并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。</p>
<p><strong>答案：</strong></p>
<p>算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。 本题代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Del_Min</span><span class="params">(SqList &amp;L,ElemType &amp;value)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//删除顺亩表L中最小值元素结点，并通过引用型参数value返回其值</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//若删除成功，则返回true；否则返回false</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span>(L.length==<span class="number">0</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">    	<span class="keyword">return</span> <span class="literal">false</span>;					<span class="comment">//表空，中止操作返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">    value=L.data[<span class="number">0</span>]; 					</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> pos=<span class="number">0</span>;							<span class="comment">//假定0号元素的值最小</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;L.length;i++)			<span class="comment">//循环，寻找具有最小值的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">if</span>(L.data[i]&lt;value){			<span class="comment">//让value记忆当前具有最小值的元素</span></span></span></span><br><span class="line"><span class="params"><span class="function"> 			value-L.data[i];</span></span></span><br><span class="line"><span class="params"><span class="function"> 			pos=i;</span></span></span><br><span class="line"><span class="params"><span class="function">        }</span></span></span><br><span class="line"><span class="params"><span class="function"> 	L.data[pos]=L.data[L.length<span class="number">-1</span>];		<span class="comment">//空出的位置由最后一个元素填补</span></span></span></span><br><span class="line"><span class="params"><span class="function"> 	L.length--; </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> <span class="literal">true</span>;						<span class="comment">//此时，value即为最小值</span></span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br><span class="line"><span class="params"><span class="function"> </span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>设计一个高效算法，将顺序表Z的所有元素逆置，要求算法的空间复杂度为$O(1)$。</p>
<p><strong>答案：</strong></p>
<p>算法思想：扫描顺序表 Z 的前半部分元素，对于元素 <code>L.data[i](0 &lt;= i &lt; L.length / 2)</code>，将其与后半部分的对应元素 <code>L.data[L.length - i - 1]</code> 进行交换。本题代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(Sqlist &amp;L)</span></span>{</span><br><span class="line">    ElemType temp; </span><br><span class="line">    <span class="comment">//辅助变量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length/<span class="number">2</span>;i++){			<span class="comment">//交换 L.data [i]与 L.data [L.length-i-1 ]</span></span><br><span class="line">		temp=L.data [i]; </span><br><span class="line">    	L.data[i]=L.data[L.length-i<span class="number">-1</span>];</span><br><span class="line">    	L.data[L.length-i<span class="number">-1</span>]=temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>对长度为$n$的顺序表L，编写一个时间复杂度为$O(n)$、空间复杂度为$O(1)$的算法，该算法删除线性表中所有值为$x$的数据元素。</p>
<p><strong>答案：</strong></p>
<p>解法1：用$k$记录顺序表$L$中不等于<code>x</code>的元素个数(即需要保存的元素个数)，扫描时将不等于<code>x</code>的元素移动到下标左的位置，并更新<code>k</code>值。扫描结束后修改$L$的长度。本题代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_x_l</span><span class="params">(Sqlist &amp;L,ElemType x)</span></span>{</span><br><span class="line"><span class="comment">//本算法茹潮除顺序表L中所有值为x的数据元</span></span><br><span class="line">	<span class="type">int</span> k=<span class="number">0</span>,i;								<span class="comment">//记录不等于x的元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line"> 		<span class="keyword">if</span>(L.data[i]!=x){</span><br><span class="line"> 			L.data[k]=L.data[i]; </span><br><span class="line">            k++;							<span class="comment">//不等于x的元素增1</span></span><br><span class="line">        }</span><br><span class="line">    L.length=k;								<span class="comment">//顺序表L的长度等于k</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>解法2：用$k$记录顺序表$L$中等于<code>x</code>的元素个数，边扫描$L$边统计$k$，并将不等于<code>x</code>的元素前移$k$个位置。扫描结束后修改$L$的长度。本题代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del_x_2</span><span class="params">(Sqlist &amp;L,ElemType x)</span></span>{</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i=<span class="number">0</span>; 					<span class="comment">//k记录值等于x的元素个数</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;L.length){				</span><br><span class="line">    	<span class="keyword">if</span>(L.data[i]==x) </span><br><span class="line">   			k++;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">    		L.data[i-k]=L.data[i]; 	<span class="comment">//当前元素前移k个位置 </span></span><br><span class="line">    	i++;</span><br><span class="line">    }</span><br><span class="line">    L.length=L.length-k;			<span class="comment">//顺序表L的长度递减</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>此外，本题还可以考虑设头、尾两个指针$i=1,j=n$，从两端向中间移动，在遇到最左端$x$的元素时，直接将最右端值非$x$的元素左移至值为$x$的数据元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。</p>
</li>
<li>
<p>从有序顺序表中删除其值在给定值$s$与$f$之间(要求$s&lt;t$)的所有元素，若$s$或$t$不合理或顺序表为空，则显示出错信息并退出运行。</p>
<p><strong>答案：</strong></p>
<p>在很多教材中(包括本书)指的“有序”，如无特别说明，通常是指"递增有序”。注意本题与上题的区别，因为是有序表，所以删除的元素必然是相连的整体。算法思想：先寻找值大于或等于s的第一个元素(第一个删除的元素)，然后寻找值大于f的第一个元素(最后一个删除  的元素的下一个元素)，要将这段元素删除，只需直接将后面的元素前移。本题代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Del_s__t2</span> <span class="params">(SqList &amp;L,ElemType s,ElemType t)</span> <span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">//删除有序顺序表L中值在给定值s与t之间的所有元素 </span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> j;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span>(s&gt;=t||L.length==<span class="number">0</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">    	<span class="keyword">return</span> <span class="literal">false</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;L. lengths&amp;L.data [i] &lt;s; i++) ; 	<span class="comment">//寻找值大于或等于s的第一个元素</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">if</span>(i&gt;=L.length)</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">return</span> <span class="literal">false</span>; 								<span class="comment">//所有元素值均小于s,返回</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">for</span> (j=i;j&lt;L.lengths &amp;&amp; L.data [j]&lt;=t; j++); 	<span class="comment">//寻找值大于t的第一个元素 </span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">for</span>(;j&lt;L.length;i++,j++)</span></span></span><br><span class="line"><span class="params"><span class="function"> 		L.data[i] =L.data [j];						 <span class="comment">//前移，填补被删元素位置 </span></span></span></span><br><span class="line"><span class="params"><span class="function">	L.length=i; </span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">return</span> <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">}</span></span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>从顺序表中删除其值在给定值$s$与$t$之间(包含$s$和$t$，要求$s&lt;t$）的所有元素，若$s$或$t$不合理或者顺序表为空，则显示出错信息并退出运行。</p>
<p>算法思想：从前向后扫描顺序表$L$,用<code>k</code>记录下元素值在s到t之间元素的个数(初始时<code>k =  0</code>)。对于当前扫描的元素，若其值不在s到t之间，则前移<code>k</code>个位置；否则执行<code>k++</code>。由于这样每个不在s到t之间的元素仅移动一次，因此算法效率高。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Del_s_t</span><span class="params">(SqList &amp;LrElemType s,ElemType t)</span></span>{</span><br><span class="line"><span class="comment">//删除顺序表L中值在给定值s与t (要求s&lt;t)之间的所有元素</span></span><br><span class="line">    <span class="type">int</span> i,k=<span class="number">0</span>;</span><br><span class="line"> 	<span class="keyword">if</span>(L・length==<span class="number">0</span>||s&gt;=t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;. 				<span class="comment">//线性表为空或s、t不合法，返回</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++){</span><br><span class="line"> 		<span class="keyword">if</span>(L.data[i]&gt;=s&amp;&amp;L.data[i]&lt;=t) </span><br><span class="line">			k++；</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			L.data[i-k]=L.data[i]; 	<span class="comment">//当前元素前移k个位置 </span></span><br><span class="line">    }</span><br><span class="line">    L.length-=k;				<span class="comment">//长度减小 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}	</span><br></pre></td></tr></tbody></table></figure>
<p>本题也可从后向前扫描顺序表，每遇到一个值在S到T之间的元素，则删除该元素，其后的所有元素全部前移。但移动次数远大于前者，效率不够高。</p>
</li>
<li>
<p>从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。</p>
<p><strong>答案：</strong><br>
算法思想：注意是有序顺序表，值相同的元素一定在连续的位置上，用类似于直接插入排序的思想，初始时将第一个元素视为非重复的有序表。之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同，则继续向后判断，若不同，则插入前面的非重复有序表的最后，直至判断到表尾为止。<br>
本题代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> Delete <span class="title">Same</span><span class="params">(SeqList&amp; L)</span></span>{</span><br><span class="line">	<span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> i,j;						<span class="comment">//i存储第一个不相同的元素，j为工作指针</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>,j=<span class="number">1</span>;j&lt;L.length;j++)		<span class="comment">//查找下一个与上个元素值不同的元素</span></span><br><span class="line">	<span class="keyword">if</span>(L,datali]!-L.data[j])		<span class="comment">//找到后，将元素前移</span></span><br><span class="line">		L.data[++i]=L.data[j];</span><br><span class="line">    L.length=i+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于本题的算法，请读者用序列 1,2,2,2,2,3,3,3,4,4,5来手动模拟算法的执行过程，在模拟过程中要标注i和i所指示的元素。<br>
思考：如果将本题的有序表改为无序表，你能想到时间复杂度为$O(n)$的方法吗？（提示：使用散列表。）</p>
</li>
<li>
<p>将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。</p>
<p><strong>答案：</strong><br>
算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看哪个表还有剩余，将剩下的部分加到新的顺序表后面。本题代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Merge</span><span class="params">(SeqList A,SeqList B,SeqList &amp;c)</span></span>{</span><br><span class="line">	<span class="comment">//将有序顺序表A与B合并为一个新的有序顺序表c</span></span><br><span class="line">	<span class="keyword">if</span>(A.length+B.length&gt;C.maxsize)<span class="comment">//大于顺序表的最大长度</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   	<span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;A.length&amp;&amp;j&lt;B.length){	<span class="comment">//循环，两两比较，小者存入结果表</span></span><br><span class="line">        <span class="keyword">if</span>(A.data[i]&lt;=B.data[j])</span><br><span class="line">            C.data[k++]=A.data[i++];</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			C.data[k++]-B.data[j++];</span><br><span class="line">	<span class="keyword">while</span>(i&lt;A.length)				<span class="comment">//还剩一个没有比较完的顺序表</span></span><br><span class="line">        C.data[k++]=A.data[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;B.length)</span><br><span class="line">        C.data[k++]=B.data[j++];</span><br><span class="line">    C.length=k;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意:本算法的方法非常典型，需牢固掌握。</p>
</li>
<li>
<p>已知在一维数组$A[m+n]$中依次存放两个线性表$(a_1,a_2,a_3······a_m)$和$(b_1,b_2,b_3······b_n)$。编写一个函数，将数组中两个顺序表的位置互换，即将$(b_1,b_2,b_3······b_n)$放在$(a_1,a_2,a_3······a_m)$的前面。</p>
<p><strong>答案：</strong><br>
算法思想：先将数组$A[m+n]$中的全部元素$(a_1,a_2, a_3,···,a_m, b_1,b_2,b_3,···,b_n,)$原地逆置为$(b_n,b_{n-1},b_{n-2},···,b_1,a_{m},a_{m-1}, a_{m-2},···,a_1)$，$(a_1,a_2, a_3,···,a_m, b_1,b_2,b_3,···,b_n,)$再对前n个元素和后m个元素分别使用逆置算法，即可得到$(b_1,b_2,b_3,···,b_n,a_1,a_2, a_3,···,a_m, )$，从而实现顺序表的位置互换。本题代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(DataType All,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> arraySize)</span></span>{</span><br><span class="line"><span class="comment">//逆转(aleft,aleft+l,aleft+2…,aright)为(aright,aright-l,… aleft)</span></span><br><span class="line">	<span class="keyword">if</span>(left&gt;=right || right&gt;=arraySize)	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mid-left;i++){</span><br><span class="line">        DataType temp=A[left+i];</span><br><span class="line">        A[left+i]=A[right-i];</span><br><span class="line">		A[right-i]=temp;</span><br><span class="line">    }</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">xchange</span><span class="params">(DataType A[],<span class="type">int</span> m,<span class="type">int</span> n,<span class="type">int</span> arraySize)</span></span>{</span><br><span class="line">    <span class="comment">/*数组 A[m+n]中，从0到m-1存放顺序表(a1,a2,a3,…,am)，从m到m+n-1存放顺序表(b1,b2,b3,…,bn)，算法将这两个表的位置互换*/</span></span><br><span class="line">	<span class="built_in">Reverse</span>(A,<span class="number">0</span>,m+n-l,arraySize);</span><br><span class="line">	<span class="built_in">Reverse</span>(A,<span class="number">0</span>,n-l,arraySize);</span><br><span class="line">	<span class="built_in">Reverse</span>(A,n,m+n-l,arraySize);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>线性表$(a_1,a_2,a_3······a_n)$中的元素递增有序且按顺序存储于计算机内。要求设计一个算法，完成用最少时间在表中查找数值为$x$的元素，若找到，则将其与后继元素位置相交换，若找不到，则将其插入表中并使表中元素仍递增有序。</p>
<p><strong>答案：</strong><br>
算法思想：顺序存储的线性表递增有序，可以顺序查找，也可以折半查找。题目要求“用最少的时间在表中查找数值为x的元素”，这里应使用折半查找法。本题代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SearchExchangeInsert</span><span class="params">(ElemType A{],ElemType x)</span></span>{</span><br><span class="line">	<span class="type">int</span> low=<span class="number">0</span>,high=n-l,mid;						<span class="comment">//1ow和high指向顺序表下界和上界的下标</span></span><br><span class="line">	<span class="keyword">while</span>(low&lt;=high){</span><br><span class="line">		mid=(low+high)/<span class="number">2</span>;			<span class="comment">//找中间位置</span></span><br><span class="line">		<span class="keyword">if</span>(A[mid]==x) <span class="keyword">break</span>;		<span class="comment">//找到x，退出while循环</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[mid]&lt;x)low=mid+<span class="number">1</span>;	<span class="comment">//到中点 mid 的右半部去查</span></span><br><span class="line">		<span class="keyword">else</span> high-mid-l;			<span class="comment">//到中点mid的左半部去查</span></span><br><span class="line">	<span class="comment">//下面两个if语句只会执行一个</span></span><br><span class="line">	<span class="keyword">if</span>(A[mid]==x&amp;&amp;mid!=n<span class="number">-1</span>){</span><br><span class="line">	<span class="comment">//若最后一个元素与x相等，则不存在与其后继交换的操作</span></span><br><span class="line">		t=A{mid]; A[mid]=A[mid+l]; A[mid+<span class="number">1</span>]=t;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//查找失败，插入数据元素x</span></span><br><span class="line">	<span class="keyword">if</span>(low&gt;high){</span><br><span class="line">		<span class="keyword">for</span>(i=n<span class="number">-1</span>;i&gt;high;i--)	A[i+<span class="number">1</span>]=A[i];	<span class="comment">//后移元素</span></span><br><span class="line">		<span class="comment">//插入x</span></span><br><span class="line">		A[i+<span class="number">1</span>]=x;</span><br><span class="line">	<span class="comment">//结束插入</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>本题的算法也可写成三个函数:查找函数、交换后继函数与插入函数。写成三个函数的优点是逻辑清晰、易读。</p>
</li>
<li>
<p>【2010统考真题】设将$n$ $(n &gt; 1 )$个整数存放到一维数组R中。设计一个在时间和空间 两方面都尽可能高效的算法。将$R$中保存的序列循环左移$p$ $(0&lt;p&lt;n)$个位置，即将$R$中的数据由$(X_0,X_1,X_2,X_3······X_{n-1})$换为$(X_p,X_{p+1},X_{p+2}······X_{n-1},X_0,X_1······X_{p-1})$，要求：</p>
<ul>
<li>
<p>给出算法的基本设计思想。</p>
</li>
<li>
<p>根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
</li>
<li>
<p>说明你所设计算法的时间复杂度和空间复杂度。</p>
</li>
<li>
<p><strong>答案：</strong><br>
1)算法的基本设计思想:<br>
可将问题视为把数组ab转换成数组 ba(a代表数组的前p个元素，b代表数组中余下的n-p个元素)，先将a逆置得到a’b，再将b逆置得到a’b’，最后将整个a’b’逆置得到(a’b’)’ = ba。设Reverse 函数执行将数组逆置的操作,对 abcdefgh 向左循环移动3(p=3)个位置的过程如下:<br>
Reverse(0,p-1)得到cbadefgh;<br>
Reverse(p,n-1)得到cbahgfed;<br>
Reverse(0,n-1)得到defghabc;<br>
注:在Reverse中，两个参数分别表示数组中待转换元素的始末位置，<br>
2)使用C语言描述算法如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reverse</span><span class="params">(<span class="type">int</span> Rll,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>{</span><br><span class="line">	<span class="type">int</span> i,temp;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>:i&lt;(to-from+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">	{</span><br><span class="line">		temp=R[from+i];</span><br><span class="line">		R[from+i]=R{to-i];R[to-i]=temp;</span><br><span class="line">	}<span class="comment">//Reverse</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Converse</span><span class="params">(<span class="type">int</span> R[]rint n,<span class="type">int</span> p)</span></span>{</span><br><span class="line">	<span class="built_in">Reverse</span>(R,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">Reverse</span>(R,p,n<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">Reverse</span>(R,<span class="number">0</span>,n-l);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3)上述算法中三个 Reverse 函数的时间复杂度分别为 $O(p/2)$、$O((n-p)/2)$和 $O(n/2)$，故所设计的算法的时间复杂度为 $O(n)$，空间复杂度为$O(1)$。</p>
<p>另解，借助辅助数组来实现。算法思想：创建大小为p的辅助数组S，将R中前p个整数依次暂存在S中，同时将R中后n-p个整数左移，然后将S中暂存的p个数依次放回到R中的后续单元。时间复杂度为$O(n)$，空间复杂度为$O(p)$。</p>
</li>
</ul>
</li>
<li>
<p>【2011统考真题】一个长度为$L$ $(L \geq 1)$的升序序列$S$，处在第$\lceil L/2 \rceil$个位置的数称为$S$的中位数。例如，若序列$S = (11, 13, 15, 17, 19)$,则S的中位数是15,两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若$S2 = (2, 4, 6, 8, 20)$,则$S1$和$S2$的中位数是11。现在有两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求：</p>
<ul>
<li>
<p>给出算法的基本设计思想。</p>
</li>
<li>
<p>根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
</li>
<li>
<p>说明你所设计算法的时间复杂度和空间复杂度。</p>
</li>
<li>
<p><strong>答案：</strong><br>
1)算法的基本设计思想如下。<br>
分别求两个升序序列 A、B的中位数，设为a和b，求序列A、B的中位数过程如下：</p>
<ul>
<li>若a=b，则a或b即为所求中位数，算法结束。</li>
<li>若a&lt;b，则舍弃序列A中较小的一半，同时舍弃序列B中较大的一半，要求两次舍弃的长度相等。</li>
<li>若a&gt;b，则舍弃序列A中较大的一半，同时舍弃序列B中较小的一半，要求两次舍弃的长度相等。</li>
</ul>
<p>在保留的两个升序序列中，重复过程1、2、3，直到两个序列中均只含一个元素时为止较小者即为所求的中位数。<br>
2)本题代码如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> M <span class="title">Search</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> Bl],<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="type">int</span> s1=<span class="number">0</span>,d1=n<span class="number">-1</span>,m1,s2=<span class="number">0</span>:d2=n<span class="number">-1</span>,m2;	<span class="comment">//分别表示序列A和B的首位数、末位数和中位数</span></span><br><span class="line">	<span class="keyword">while</span>(s1!=d1||s2!=d2){</span><br><span class="line">		m1=(s1+d1)/<span class="number">2</span>;</span><br><span class="line">		m2=(s2+d2)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(A[m1]==B[m2])				<span class="comment">//满足条件1</span></span><br><span class="line">			<span class="keyword">return</span> A[m1];		</span><br><span class="line">		<span class="keyword">if</span>(A[m1]&lt;B[m2}){				<span class="comment">//满足条件2</span></span><br><span class="line">			<span class="keyword">if</span>((s1+d1)%<span class="number">2</span>==<span class="number">0</span>){			<span class="comment">//若元素个数为奇数</span></span><br><span class="line">				<span class="comment">//舍弃A中间点以前的部分且保留中间点</span></span><br><span class="line">				<span class="comment">//舍弃B中间点以后的部分且保留中间点</span></span><br><span class="line">				s1=ml;		</span><br><span class="line">				d2=m2;</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">else</span>{</span><br><span class="line">				<span class="comment">//元素个数为偶数</span></span><br><span class="line">				<span class="comment">//舍弃A中间点及中间点以前部分</span></span><br><span class="line">				<span class="comment">//舍弃B中间点以后部分且保留中间点</span></span><br><span class="line">				s1=m+<span class="number">1</span>;</span><br><span class="line">				d2=<span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="comment">//满足条件3</span></span><br><span class="line">		<span class="keyword">else</span>{</span><br><span class="line">			<span class="comment">//若元素个数为奇数</span></span><br><span class="line">            <span class="comment">//舍弃A中间点以后的部分且保留中间点</span></span><br><span class="line">            <span class="comment">//舍弃B中间点以前的部分且保留中间点</span></span><br><span class="line">			<span class="keyword">if</span>((s2+d2)%==<span class="number">0</span>){</span><br><span class="line">				d1=l;</span><br><span class="line">				s2=<span class="number">2</span>;</span><br><span class="line">			}</span><br><span class="line">			<span class="comment">//元素个数为偶数</span></span><br><span class="line">			<span class="comment">//舍弃A中间点以后部分且保留中间点</span></span><br><span class="line">			<span class="comment">//舍弃B中间点及中间点以前部分</span></span><br><span class="line">			<span class="keyword">else</span>{</span><br><span class="line">				d1=m1;</span><br><span class="line">				s2=m2+<span class="number">1</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> A[s1]&lt;B[s2]?A[s1]:B{s2];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3)算法的时间复杂度为$O(log_2n)$，空间复杂度为$O(1)$。</p>
</li>
</ul>
</li>
<li>
<p>【2013统考真题】已知一个整数序列$A=(a_0,a_1,···,a_{n-1})$，其中$0 \leq a_i \leq n(0 \leq i &lt;n)$，若存在$a_{p1}=a_{p2}=···=a_{pm}=x$且$m&gt;n/2(0 \leq p_k &lt; n, 1 \leq k \leq m)$，则称$x$为$A$的主元素。例如 $A = (0,5, 5, 3, 5, 7,5,5)$，则5为主元素；又$A=(0, 5, 5, 3, 5, 1, 5, 7)$，则$A$中没有主元素。假设$A$中的$n$个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出$A$的主元素。若存在主元素，则输出该元素；否则输出-1。要求：</p>
<ul>
<li>
<p>给出算法的基本设计思想。</p>
</li>
<li>
<p>根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
</li>
<li>
<p>说明你所设计算法的时间复杂度和空间复杂度。</p>
</li>
<li>
<p><strong>答案：</strong><br>
1)算法的基本设计思想：算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确认Num是否是主元素。算法可分为以下两步:</p>
<ul>
<li>
<p>选取候选的主元素。依次扫描所给数组中的每个整数，将第一个遇到的整数 Num 保存到c中，记录 Num 的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。</p>
</li>
<li>
<p>判断c中元素是否是真正的主元素。再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素；否则，序列中不存在主元素。</p>
</li>
</ul>
<p>2)算法实现如下:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Majority</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span>{</span><br><span class="line">	<span class="comment">//c用来保存候选主元素，count用来计数</span></span><br><span class="line">	<span class="comment">//设置A[0]为候选主元素	</span></span><br><span class="line">    <span class="type">int</span> i，c,count=l;</span><br><span class="line">	c=A[<span class="number">0</span>];</span><br><span class="line">	<span class="comment">//查找候选主元素</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">		<span class="keyword">if</span>(A[i]==c)	count++;		<span class="comment">//对A中的候选主元素计数</span></span><br><span class="line">		<span class="keyword">else</span>						</span><br><span class="line">			<span class="keyword">if</span>(count&gt;<span class="number">0</span>)	count--;	<span class="comment">//处理不是候选主元素的情况</span></span><br><span class="line">			<span class="keyword">else</span>{					<span class="comment">//更换候选主元素，重新计数</span></span><br><span class="line">				c=A{i];</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span>(i=count=<span class="number">0</span>:i&lt;n:i++)		<span class="comment">//统计候选主元素的实际出现次数</span></span><br><span class="line">            <span class="keyword">if</span>(A{i]--c)count++;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;n/<span class="number">2</span>)	<span class="keyword">return</span> c;		<span class="comment">//确认候选主元素</span></span><br><span class="line">    <span class="keyword">else</span>	<span class="keyword">return</span> <span class="number">-1</span>;				<span class="comment">//不存在主元素</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>3)实现的程序的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。<br>
说明:本题如果采用先排好序再统计的方法[时间复杂度可为$O(nlog_2n)$]，只要解答正确,最高可拿 11 分。即便是写出$O(n^2)$的算法，最高也能拿10分，因此对于统考算法题，花费大量时间去思考最优解法是得不偿失的。</p>
</li>
</ul>
</li>
<li>
<p>【2018统考真题】给定一个含$n (n \geq1)$个整数的数组，请设计一个在时间上尽可能高效的算法，找出数组中未出现的最小正整数。</p>
<p>示例：数组 <code>[-5, 3, 2, 3]</code> 中未出现的最小正整数是 1。  数组 <code>[1, 2, 3]</code> 中未出现的最小正整数是 4。要求：</p>
<ul>
<li>
<p>给出算法的基本设计思想。</p>
</li>
<li>
<p>根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
</li>
<li>
<p>说明你所设计算法的时间复杂度和空间复杂度。</p>
</li>
<li>
<p><strong>答案：</strong><br>
1)算法的基本设计思想:<br>
要求在时间上尽可能高效，因此采用空间换时间的办法。分配一个用于标记的数组B[n]，用来记录 A中是否出现了 1~n 中的正整数，B[0]对应正整数1，B[n-1]对应正整数 n，初始化B中全部为 0。由于A中含有n个整数，因此可能返回的值是1 ~ n+1，当A中n个数恰好为1~n 时返回 n+1。当数组A中出现了大于或等于0或大于n的值时，会导致1~n 中出现空余位置，返回结果必然在 1~n 中，因此对于A中出现了大于或等于0或大于n的值，可以不采取任何操作。经过以上分析可以得出算法流程：从A[0]开始遍历A，若0&lt;A[i]&lt;=n,则令<code>B[A[i]-1]=1</code>;否则不做操作。对A遍历结束后，开始遍历数组B，若能查找到第一个满足B[i]==0的下标<code>i</code>，返回 i+1 即为结果，此时说明A中未出现的最小正整数在1~n之间。若B[i]全部不为0，返回i+1(跳出循环时 i=n，i+1 等于 n+1)，此时说明A中未出现的最小正整数是 n+1。</p>
</li>
<li>
<p>2)算法实现:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMissMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">		<span class="type">int</span> i *B</span>;							<span class="comment">//标记数组</span></span><br><span class="line">		B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);		<span class="comment">//分配空间 </span></span><br><span class="line">		<span class="comment">//赋初值为0</span></span><br><span class="line">		<span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">			<span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;=n)				<span class="comment">//若A[i]的值介于1~n，则标记数组B</span></span><br><span class="line">				B[A[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)					<span class="comment">//扫描数组 B，找到目标值</span></span><br><span class="line">			<span class="keyword">if</span>(B[i]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//返回结果</span></span><br><span class="line">		<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3)时间复杂度:遍历A一次，遍历B一次，两次循环内操作步骤为$O(1)$量级，因此时间复杂度为 $O(n)$。空间复杂度:额外分配了B[n]，空间复杂度为$O(n)$。</p>
</li>
</ul>
</li>
<li>
<p>【2020统考真题】定义三元组 $(a, b, c)$（$a, b, c$ 均为整数）的距离 $D = |a - b| + |b - c| + |c - a|$。  给定 3 个非空整数集合 $S1、S2$ 和 $S3$，按升序分别存储在 3 个数组中。请设计一个尽可能高效的算法，计算并输出所有可能的三元组 $(a, b, c) (a ∈ S1, b ∈ S2, c ∈ S3)$ 中的最小距离。</p>
<p>示例：S1 = <code>[-1, 0, 9]</code>  ，S2 = <code>[-25, -10, 10, 11]</code>  ，S3 = <code>[2, 9, 17, 30, 41]</code>，则最小距离为 2，对应的三元组为 (9, 10, 9)。</p>
<p>要求：</p>
<ul>
<li>
<p>给出算法的基本设计思想。</p>
</li>
<li>
<p>根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</p>
</li>
<li>
<p>说明你所设计算法的时间复杂度和空间复杂度。</p>
</li>
<li>
<p><strong>答案：</strong><br>
分析。由$D=|a-b|+|b-c|+|c-a| \geq0$有如下结论。</p>
<ul>
<li>
<p>当a=b=c时，距离最小。</p>
</li>
<li>
<p>其余情况。不失一般性，假设 $a \leq b \leq c$，观察下面的数轴:<br>
$$<br>
L_1=|a-b| \<br>
L_2=|b-c| \<br>
L_3=|c-a| \<br>
D=|a-b|+|b-c|+|c-a|=2L_3<br>
$$<br>
由D的表达式可知，事实上决定D大小的关键是a和c之间的距离，于是问题就可以简化为每次固定c找一个a，使得$L_3=|c-a|$最小。</p>
</li>
</ul>
<p>1)算法的基本设计思想</p>
<ul>
<li>
<p>使用$D_{min}$记录所有已处理的三元组的最小距离，初值为一个足够大的整数。</p>
</li>
<li>
<p>集合 $S_1,S_2,S_3$，分别保存在数组 A、B、C中。数组的下标变量<code>i=j=k=0</code>，当$i&lt;|S_1|,j&lt;|S_2|,k&lt;|S_3|$时($|S|$表示集合$S$中的元素个数)，循环执行下面的 a)~c)。</p>
<p>a)计算(<code>A[i],B[J]],C[k]</code>)的距离D。(计算 D)<br>
b)若$D&lt;D_{min}$，则$D_{min}=D$。(更新 D)</p>
<p>c)将 <code>A[i]、B[j]、C[k]</code>中的最小值的下标+1;	(对照分析:最小值为a，最大值为c，这里c不变而更新a，试图寻找更小的距离 D)</p>
</li>
<li>
<p>输出 $D_{min}$结束。</p>
</li>
</ul>
<p>2)算法实现：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INT MAX 0x7fffffff</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">abs</span><span class="params">(<span class="type">int</span> a)</span></span>{	<span class="comment">//计算绝对值if(a&lt;0)</span></span><br><span class="line">    <span class="keyword">return</span> -a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">xls_min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>{<span class="comment">//a是否是三个数中的最小值</span></span><br><span class="line">    <span class="keyword">if</span>(a&lt;=b&amp;&amp;a&lt;=c)	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMinofTrip</span><span class="params">(<span class="type">int</span> Al,,<span class="type">int</span> n,<span class="type">int</span> Bll,<span class="type">int</span> m,<span class="type">int</span> c{],<span class="type">int</span> p)</span></span>{</span><br><span class="line">    <span class="comment">//D min用于记录三元组的最小距离，初值赋为INT_MAX</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k<span class="number">-0</span>,Dmin=INT_MAX,D;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m&amp;&amp;k&lt;p&amp;&amp;D min&gt;<span class="number">0</span>){</span><br><span class="line">        D=<span class="built_in">abs</span>(A[i]-B[j])+<span class="built_in">abs</span>(B[j]-C[k])+<span class="built_in">abs</span>(c[k]-A[i]);			<span class="comment">//计算D</span></span><br><span class="line">        <span class="keyword">if</span>(D&lt;Dmin)Dmin=D;<span class="comment">//更新Dmin</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">xls_min</span>(A[i],B[j],C[k]))	i++;<span class="comment">//更新a</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(xls+<span class="built_in">min</span>(B{j],Cfk],Ali])) j++;</span><br><span class="line">        <span class="keyword">else</span> k++;</span><br><span class="line">    }</span><br><span class="line">	<span class="keyword">return</span> Dmin;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3)设$n=(|S_1|+|S_2|+|S_3|)$，时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。</p>
</li>
</ul>
</li>
</ol>
<p>​</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/69da2254.html">https://www.heavenhold.cn/posts/69da2254.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94/">王道考研</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410071700168.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/13da47cc.html" title="王道计算机数据机构考研——绪论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072123445.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">王道计算机数据机构考研——绪论</div></div></a></div><div class="next-post pull-right"><a href="/posts/5448a3c9.html" title="离散数学考试复习整理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/20AFf5B569563ef284865fce2aca1F42.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学考试复习整理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/13da47cc.html" title="王道计算机数据机构考研——绪论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072123445.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-07</div><div class="title">王道计算机数据机构考研——绪论</div></div></a></div><div><a href="/posts/c2cbe395.html" title="SCUT Unknown Paper A and B"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031419893.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">SCUT Unknown Paper A and B</div></div></a></div><div><a href="/posts/b560ae6a.html" title="SCUT Unknown Paper"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031420301.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">SCUT Unknown Paper</div></div></a></div><div><a href="/posts/ff2cf009.html" title="SCUT2001 Data Structure"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031418576.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">SCUT2001 Data Structure</div></div></a></div><div><a href="/posts/788cd56a.html" title="SCUT2003 Data Structure"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031418798.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">SCUT2003 Data Structure</div></div></a></div><div><a href="/posts/2d5087c.html" title="SCUT2006 Data Structure"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031418506.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-03</div><div class="title">SCUT2006 Data Structure</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E7%A0%94%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">王道计算机数据结构考研——线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.1.</span> <span class="toc-text">线性表的定义和基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">单项选择题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.2.</span> <span class="toc-text">线性表的顺序表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%A1%B9%E9%80%89%E6%8B%A9%E9%A2%98-2"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">单项选择题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E9%A2%98"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">综合应用题</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>