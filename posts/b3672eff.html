<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CPP复习 第十二章 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="CPP复习 第十二章
 多态的使用条件：父类指针或者引用指向子类对象.
 
 With polymorphism, we can design and implement systems that are
 easily extensible. New classes can be added with little or no
 modification to the general porti">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP复习 第十二章">
<meta property="og:url" content="https://www.heavenhold.cn/posts/b3672eff.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="CPP复习 第十二章
 多态的使用条件：父类指针或者引用指向子类对象.
 
 With polymorphism, we can design and implement systems that are
 easily extensible. New classes can be added with little or no
 modification to the general porti">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.horosama.com/api/image_all/anime/1080p/pc/fb4ddC48481d3eFb8DDdbb310625e308.jpg">
<meta property="article:published_time" content="2024-06-09T11:18:00.000Z">
<meta property="article:modified_time" content="2024-08-11T07:58:44.997Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.horosama.com/api/image_all/anime/1080p/pc/fb4ddC48481d3eFb8DDdbb310625e308.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/b3672eff.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP复习 第十二章',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-08-11 15:58:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">123</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.horosama.com/api/image_all/anime/1080p/pc/fb4ddC48481d3eFb8DDdbb310625e308.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP复习 第十二章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-09T11:18:00.000Z" title="发表于 2024-06-09 19:18:00">2024-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-11T07:58:44.997Z" title="更新于 2024-08-11 15:58:44">2024-08-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP复习 第十二章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="cpp复习-第十二章">CPP复习 第十二章</h1>
<p>多态的使用条件：父类指针或者引用指向子类对象.</p>
<blockquote>
<p>With polymorphism, we can design and implement systems that are
easily extensible. New classes can be added with little or no
modification to the general portions of the program, as long as the new
classes are part of the inheritance hierarchy that the program processes
generally. The only parts of a program that must be altered to
accommodate new classes are those that require direct knowledge of the
new classes that you add to the hierarchy.
使用多态性，我们可以设计和实现易于扩展的系统。
只要新类是程序通常处理的继承层次结构的一部分，就可以在对程序的一般部分进行很少或不进行修改的情况下添加新类。
只有那些需要直接了解添加到层次结构中的新类的部分才需要对程序进行修改以适应新类</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607170206131.png" alt="image-20240607170206131">
<figcaption aria-hidden="true">image-20240607170206131</figcaption>
</figure>
<blockquote>
<p>属于同一个层次的派生类，通过一个共同的基类指针或者引用来访问，可以让不同的派生类对象执行与它们相符合的行为。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607170221385.png" alt="image-20240607170221385">
<figcaption aria-hidden="true">image-20240607170221385</figcaption>
</figure>
<blockquote>
<p>多态可以程序员不用修改原有的系统，只需要把能够响应现有信息的新类型的对象添加到系统即可。</p>
</blockquote>
<blockquote>
<p>The next several sections present a series of examples that
demonstrate how base-class and derived-class pointers can be aimed at
base-class and derived-class objects, and how those pointers can be used
to invoke member functions that manipulate those objects. A key concept
in these examples is to demonstrate that an object of a derived class
can be treated as an object of its base class. Despite the fact that the
derived-class objects are of different types, the compiler allows this
because each derived-class object is an object of its base class.
However, we cannot treat a base-class object as an object of any of its
derived classes. The is-a relationship applies only from a derived class
to its direct and indirect base classes.
接下来的几节将提供一系列示例，演示基类和派生类指针如何指向基类和派生类对象，以及如何使用这些指针调用操作这些对象的成员函数。
这些示例中的一个关键概念是演示派生类的对象可以被视为其基类的对象。
尽管派生类对象具有不同的类型，但编译器允许这样做，因为每个派生类对象都是其基类的对象。
但是，不能将基类对象视为其任何派生类的对象。
is-a关系仅适用于派生类的直接和间接基类。</p>
</blockquote>
<blockquote>
<p>Aiming a Base-Class Pointer at a Derived-Class Object Line 49 assigns
the address of derived-class object base-PlusCommissionEmployee to
base-class pointer commissionEmployeePtr, which line 53 uses to invoke
member function print. This “crossover” is allowed because an object of
a derived class is an object of its base class. Note that despite the
fact that the base class CommissionEmployee pointer points to a derived
class BasePlusCommissionEmployee object, the base class
CommissionEmployee’s print member function is invoked (rather than
BasePlusCommissionEmployee’s print function). The output of each print
member-function invocation in this program reveals that the invoked
functionality depends on the type of the pointer (or reference) used to
invoke the function, not the type of the object for which the member
function is called. 将基类指针指向派生类对象
第49行将派生类对象base-PlusCommissionEmployee的地址赋值给基类指针commissionEmployeePtr，第53行使用该指针调用成员函数print。
这种“交叉”是允许的，因为派生类的对象是其基类的对象。</p>
<p>注意，尽管基类CommissionEmployee指针指向派生类BasePlusCommissionEmployee对象，
但调用的是<strong>基类CommissionEmployee的print成员函数(而不是BasePlusCommissionEmployee的print函数)。</strong></p>
<p>该程序中每个print成员函数调用的输出表明，被调用的功能取决于<strong>用于调用该函数的指针(或引用)的类型，而不是调用该成员函数的对象的类型。</strong></p>
</blockquote>
<blockquote>
<p>Off a base-class pointer, the compiler allows us to invoke only
base-class member functions. If a base-class pointer is aimed at a
derived-class object, and an attempt is made to access a
derived-class-only member function, a compilation error will occur.
Figure 12.3 shows the consequences of attempting to invoke a
derived-class member function off a base-class pointer.
在基类指针之外，编译器只允许调用基类成员函数。
如果基类指针指向派生类对象，并且试图访问仅派生类成员函数，则会发生编译错误。
图12.3显示了试图从基类指针调用派生类成员函数的结果。</p>
</blockquote>
<blockquote>
<p>Downcasting The compiler will allow access to derived-class-only
members from a base-class pointer that is aimed at a derived-class
object if we explicitly cast the base-class pointer to a derived-class
pointer—known as downcasting. Downcasting allows a
derived-class-specific operation on a derived-class object pointed to by
a base-class pointer. After a downcast, the program can invoke
derived-class functions that are not in the base class. Section 12.8
demonstrates how to safely use downcasting. 向下类型转换：
如果显式地将基类指针转换为派生类指针(称为向下转换)，编译器将允许从指向派生类对象的基类指针访问仅派生类成员。
向下转换允许在基类指针指向的派生类对象上执行特定于派生类的操作。向下转换后，程序可以调用不在基类中的派生类函数。
第12.8节演示了如何安全地使用向下转换。</p>
</blockquote>
<p><strong>将一个基类指针强制类型转换为其直接派生类或者间接派生类是允许的
为了发送那些在基类中不出现的派生类对象的信息
这种转换是必要的</strong></p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607193306336.png" alt="image-20240607193306336">
<figcaption aria-hidden="true">image-20240607193306336</figcaption>
</figure>
<blockquote>
<p>Why virtual Functions Are Useful Consider why virtual functions are
useful: Suppose that shape classes such as Circle, Triangle, Rectangle
and Square are all derived from base class Shape. Each of these classes
might be endowed with the ability to draw itself via a member function
draw, but the function for each shape is quite different. In a program
that draws a set of shapes, it would be useful to be able to treat all
the shapes generally as objects of the base class Shape. To draw any
shape, we could simply use a base-class Shape pointer to invoke function
draw and let the program determine dynamically (i.e., at runtime) which
derived-class draw function to use, based on the type of the object to
which the base-class Shape pointer points at any given time. This is
polymorphic behavior.
虚函数为什么有用：考虑一下虚函数有用的原因:假设形状类(如Circle、Triangle、Rectangle和Square)都派生自基类shape。
这些类中的每一个都可以通过成员函数draw来赋予自己绘图的能力，</p>
<p>但是每个形状的函数是完全不同的。</p>
<p>在绘制一组形状的程序中，如果能够将所有形状一般视为Shape基类的对象，这将是很有用的。</p>
<p>要绘制任何形状，我们可以简单地使用一个基类shape指针来调用函数draw，并让程序动态地(即，在运行时)</p>
<p>根据基类shape指针在任何给定时间所指向的对象的类型来决定要使用哪个派生类的绘制函数。这就是多态行为.</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607194403976.png" alt="image-20240607194403976">
<figcaption aria-hidden="true">image-20240607194403976</figcaption>
</figure>
<blockquote>
<p>Declaring virtual Functions To enable this behavior, we declare draw
in the base class as a virtual function, and we override draw in each of
the derived classes to draw the appropriate shape. From an
implementation perspective, overriding a function is no different than
redefining one. An overridden function in a derived class has the same
signature and return type (i.e., prototype) as the function it overrides
in its base class. If we declare the base-class function as virtual, we
can override that function to enable polymorphic behavior. We declare a
virtual function by preceding the function’s prototype with the key-word
virtual in the base class.</p>
<p>声明虚函数
为了启用这种行为，我们在基类中将draw声明为虚函数，并在每个派生类中重写draw以绘制适当的形状。
从实现的角度来看，重写函数与重新定义函数没有什么不同。</p>
<p><strong>派生类中被重写的函数与它在基类中重写的函数具有相同的签名和返回类型(即原型)。</strong></p>
<p><strong>如果将基类函数声明为virtual，则可以重写该函数以启用多态行为。</strong></p>
<p><strong>通过在基类中在函数原型前面加上关键字virtual来声明虚函数。</strong></p>
</blockquote>
<p>一个函数一旦声明为virtual，那么从它开始的所有继承的派生类中，它将始终保持是virtual的。</p>
<p>建议：即使一个函数在层次结构的高层中已经被声明为了virtual（也就是其已经成为了隐式的virtual函数），仍然建议在其前面添加virtual，在类层次结构的每一级中都把它显式声明为virtual。</p>
<p>override关键词：在每一个重载后的函数后面加上，声明是从父类的成员函数重载下来，会迫使编译器检查基类有没有对应的virtual成员函数，如果没有，则编译器会报错。</p>
<p>如果派生类函数不重载virtual函数，那么它会简单继承其父类的virtual函数。</p>
<blockquote>
<p>Invoking a virtual Function Through a Base-Class Pointer or Reference
If a program invokes a virtual function through a base-class pointer to
a derived-class object (e.g., shapePtr-&gt;draw()) or a base-class
reference to a derived-class object (e.g., shapeRef.draw()), the program
will choose the correct derived-class function dynamically (i.e., at
execution time) based on the object type—not the pointer or reference
type. Known as dynamic binding or late binding.
通过基类指针或引用调用虚函数</p>
<p>如果程序通过指向派生类对象的基类指针(例如shapetr
-&gt;draw())或指向派生类对象的基类引用(例如shapeRef.draw())调用虚函数，</p>
<p>程序将根据对象类型(即在执行时)动态地(即在执行时)选择正确的派生类函数，而不是指针或引用类型。</p>
<p>称为动态绑定或延迟绑定。</p>
</blockquote>
<blockquote>
<p>Invoking a virtual Function Through an Object’s Name When a virtual
function is called by referencing a specific object by name and using
the dot member-selection operator (e.g., squareObject.draw()), the
function invocation is re-solved at compile time (this is called static
binding) and the virtual function that is called is the one defined for
(or inherited by) the class of that particular object—this is not
polymorphic behavior. Dynamic binding with virtual functions occurs only
off pointers (and, as we’ll soon see, references).
通过对象的名称调用虚函数</p>
<p>当通过引用特定对象的名称并使用点成员选择操作符(例如，squareObject.draw())调用虚函数时，函数调用在编译时被重新解析(这称为静态绑定)，并且被调用的虚函数是为该特定对象的类定义的(或由该类继承的)虚函数——这不是多态行为。</p>
<p>与虚函数的动态绑定只发生在指针之外(我们很快就会看到，还有引用)。</p>
</blockquote>
<p>静态绑定：virtual函数通过，按名引用特定对象，或者，使用圆点成员运算符，来调用
这个是在编译的时候已经被确定了。
动态绑定：只能通过指针，或者，引用句柄来完成 。</p>
<p>声明成员函数virtual会导致程序根据句柄指向的对象类型(而不是句柄的类型)动态地确定调用哪个函数。</p>
<blockquote>
<p>virtual Destructors A problem can occur when using polymorphism to
process dynamically allocated objects of a class hierarchy. If a
derived-class object with a non-virtual destructor is destroyed by
applying the delete operator to a base-class pointer to the object, the
C++ standard specifies that the behavior is undefined. The simple
solution to this problem is to create a public virtual destructor in the
base class. If a base class destructor is declared virtual, the
destructors of any derived classes are also virtual and they override
the base class destructor.</p>
<p>虚拟析构函数：
当使用多态性处理类层次结构中动态分配的对象时，可能会出现问题。
如果通过对指向该对象的基类指针应用delete操作符来销毁带有非虚析构函数的派生类对象，则c++标准规定该行为未定义。
这个问题的简单解决方案是在基类中创建一个公共虚析构函数。
如果将基类析构函数声明为虚函数，则任何派生类的析构函数也是虚函数，并且它们覆盖基类析构函数。</p>
</blockquote>
<blockquote>
<p>在C++中，当我们使用基类指针指向一个派生类对象，并通过这个基类指针调用派生类对象的方法时，
如果这些方法在基类中被声明为虚函数（virtual），那么会发生动态绑定（或称为多态）。
然而，当涉及到析构函数时，如果基类的析构函数不是虚函数，那么就会有问题。
具体来说，当我们通过基类指针删除派生类对象时，
如果基类的析构函数不是虚函数，只会调用基类的析构函数，而不会调用派生类的析构函数。
这会导致派生类中特有的数据成员没有被正确释放，造成内存泄漏。</p>
</blockquote>
<blockquote>
<p>如果一个类含有一个virtual函数，那么该类就要提供一个virtual析构函数，即使不一定需要。
这样可以保证一个派生类对象通过基类指针删除时，这个派生类对象的析构函数能够被调用
。</p>
<p>但是构造函数不能是virtual函数。</p>
</blockquote>
<blockquote>
<p>C++11: final Member Functions and Classes In C++11, a base-class
virtual function that’s declared final in its prototype, as in virtual
someFunction( parameters ) final; cannot be overridden in any derived
class—this guarantees that the base class’s final member function
definition will be used by all base-class objects and by all objects of
the base class’s direct and indirect derived classes. c++ 11:
final成员函数和类</p>
<p>在c++ 11中，在原型中声明为final的基类虚函数，如</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">someFunction</span><span class="params">( parameters )</span> <span class="keyword">final</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>保证了该函数在任何派生类中都不能被覆盖。</p>
<p>不能在任何派生类中重写——这保证了基类的最终成员函数定义将被所有基类对象以及基类的直接和间接派生类的所有对象使用。</p>
</blockquote>
<blockquote>
<p>As of C++11, you can declare a class as final to prevent it from
being used as a base class, as in</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">final</span> <span class="comment">// this class cannot be a base class</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">// class body</span></span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure>
<p>Attempting to override a final member function or inherit from a
final base class results in a compilation error.</p>
<p>从c++ 11开始，可以将一个类声明为final，以防止它被用作基类，如</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">final</span> <span class="comment">//这个类不能是基类</span></span><br><span class="line">｛</span><br><span class="line"><span class="comment">//类主体</span></span><br><span class="line">}；</span><br></pre></td></tr></tbody></table></figure>
<p>尝试重写final成员函数或从final基类继承将导致编译错误。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607204035143.png" alt="image-20240607204035143">
<figcaption aria-hidden="true">image-20240607204035143</figcaption>
</figure>
<p><strong>使用多态可以避免上述使用switch语句遇到的问题，并且可以完成同样的功能</strong></p>
<blockquote>
<p>There are cases in which it’s useful to define classes from which you
never intend to instantiate any objects. Such classes are called
abstract classes. Because these classes normally are used as base
classes in inheritance hierarchies, we refer to them as abstract base
classes. These classes cannot be used to instantiate objects, because,
as we’ll soon see, abstract classes are incomplete—derived classes must
define the “missing pieces.” An abstract class is a base class from
which other classes can inherit. Classes that can be used to instantiate
objects are called concrete classes. Such classes define every member
function they declare.</p>
<p>在某些情况下，定义您从未打算从中实例化任何对象的类是有用的。
这样的类被称为抽象类。
由于这些类通常用作继承层次结构中的基类，因此我们将它们称为抽象基类。</p>
<p><strong>这些类不能用于实例化对象，因为我们很快就会看到，抽象类是不完整的——派生类必须定义“缺失的部分”。</strong></p>
<p><strong>抽象类是其他类可以继承的基类。</strong></p>
<p><strong>可用于实例化对象的类称为具体类。</strong></p>
<p><strong>这样的类定义了它们声明的每个成员函数。</strong></p>
<p>抽象基类的目的是为其他类提供合适的基类.</p>
</blockquote>
<blockquote>
<p>Pure Virtual Functions A class is made abstract by declaring one or
more of its virtual functions to be “pure.” A pure virtual function is
specified by placing “= 0” in its declaration, as in</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual function</span></span><br></pre></td></tr></tbody></table></figure>
<p>The “= 0” is a pure specifier. Pure virtual functions typically do
not provide implementations, though they can.</p>
<p>纯虚函数：
通过将类的一个或多个虚函数声明为“纯”，使类成为抽象的。纯虚函数通过在其声明中放置"
= 0 "来指定，如</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual function</span></span><br></pre></td></tr></tbody></table></figure>
<p>“= 0”是一个纯说明符。</p>
<p>纯虚函数通常不提供实现，尽管它们可以。</p>
</blockquote>
<blockquote>
<p>Each concrete derived class must override all base-class pure virtual
functions with concrete implementations of those functions; otherwise
the derived class is also abstract. The difference between a virtual
function and a pure virtual function is that a virtual function has an
implementation and gives the derived class the option of overriding the
function. By contrast, a pure virtual function does not have an
implementation and requires the derived class to override the function
for that derived class to be concrete; otherwise the derived class
remains abstract. Pure virtual functions are used when it does not make
sense for the base class to have an implementation of a function, but
you want all concrete derived classes to implement the function.</p>
<p>每个具体的派生类必须用这些函数的具体实现覆盖所有基类的纯虚函数，否则派生类也是抽象的。</p>
<p>虚函数和纯虚函数的区别在于虚函数有一个实现，并为派生类提供了重写函数的选项。</p>
<p>相比之下，纯虚函数没有实现，并且需要派生类重写该函数，以便派生类是具体的，<strong>否则派生类仍然是抽象的。</strong></p>
<p><strong>纯虚函数用于基类没有必要实现某个函数，但希望所有具体派生类都实现该函数的情况。</strong></p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607205018334.png" alt="image-20240607205018334">
<figcaption aria-hidden="true">image-20240607205018334</figcaption>
</figure>
<p><strong>抽象类为各个层次中的类提供了公共的通用函数接口，抽象类包含一个或者多个pure
virtual函数，这些函数在具体的派生类中必须被重写。</strong></p>
<p><strong>如果在派生类没有重写pure
virtual函数，那么这个派生类也会变成抽象类。</strong></p>
<p><strong>抽象类至少有一个pure
virtual函数，也可以有自己的数据成员，具体的成员函数（包括构造和析构），它们被继承时符合继承的一般规则。</strong></p>
<p><strong>注意：虽然不能实例化抽象基类，但是可以使用抽象基类的指针或者引用，指向实例化的具体的派生类，从而实现多态。</strong></p>
<blockquote>
<p>Although we cannot instantiate objects of an abstract base class, we
can use the abstract base class to declare pointers and references that
can refer to objects of any concrete classes derived from the abstract
class. Programs typically use such pointers and references to manipulate
derived-class objects polymorphically.</p>
<p>虽然不能实例化抽象基类的对象，但可以使用抽象基类声明指针和引用，这些指针和引用可以引用从抽象类派生的任何具体类的对象。
程序通常使用这样的指针和引用以多态方式操作派生类对象。</p>
</blockquote>
<p><strong>实现继承：
是指一个类从另一个类派生，并继承其成员变量和成员函数。在C++中，继承可以是public、protected或private三种访问控制方式。实现继承的关键是派生类能够复用基类的代码，派生类可以增加新的功能或重写基类的方法。</strong></p>
<p><strong>接口继承：
是指一个类实现一个接口，接口定义了类必须提供的行为，但不包含任何实现。在C++中，接口通常用纯虚函数来实现，一个包含纯虚函数的类称为抽象类。</strong></p>
<blockquote>
<p>This section discusses how C++ can implement polymorphism, virtual
functions and dynamic binding internally. This will give you a solid
understanding of how these capabilities really work. More importantly,
it will help you appreciate the overhead of polymorphism—in terms of
additional memory consumption and processor time. You’ll see that
polymorphism is accomplished through three levels of pointers (i.e.,
“triple indirection”). Then we’ll show how an executing program uses
these data structures to execute virtual functions and achieve the
dynamic binding associated with polymorphism. Our discussion explains
one possible implementation; this is not a language requirement.
本节讨论c++如何在内部实现多态性、虚函数和动态绑定。
这将使您对这些功能的实际工作方式有一个坚实的理解。
更重要的是，它将帮助您了解多态的开销——就额外的内存消耗和处理器时间而言。
您将看到，多态性是通过三层指针实现的(即“三重间接”)。
然后，我们将展示正在执行的程序如何使用这些数据结构来执行虚函数并实现与多态性相关的动态绑定。
我们的讨论解释了一种可能的实现;这不是语言要求。</p>
</blockquote>
<blockquote>
<p>When C++ compiles a class that has one or more virtual functions, it
builds a virtual function table (vtable) for that class. The vtable
contains pointers to the class’s virtual functions. Just as the name of
a built-in array contains the address in memory of the array’s first
element, a pointer to a function contains the starting address in memory
of the code that performs the function’s task. An executing program uses
the vtable to select the proper function implementation each time a
virtual function of that class is called. The leftmost column of Fig.
12.18 illustrates the vtables for classes Employee, SalariedEmployee,
CommissionEmployee and BasePlusCommissionEmployee.
当c++编译一个具有一个或多个虚函数的类时，它为该类构建一个虚函数表(vtable)。
虚函数表包含指向该类虚函数的指针。
正如内置数组的名称包含该数组第一个元素在内存中的地址一样，</p>
<p>指向函数的指针包含执行该函数任务的代码在内存中的起始地址。</p>
<p>正在执行的程序在每次调用该类的虚函数时使用虚函数表选择适当的函数实现。</p>
<p>图12.18最左边的一列显示了Employee、salarieemployee、CommissionEmployee和BasePlusCommissionEmployee类的变量。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607222304683.png" alt="image-20240607222304683">
<figcaption aria-hidden="true">image-20240607222304683</figcaption>
</figure>
<blockquote>
<p>Employee Class vtable In the Employee class vtable, the first
function pointer is set to 0 (i.e., the nullptr), because function
earnings is a pure virtual function and therefore lacks an
implementation. The second function pointer points to function print,
which displays the employee’s full name and social security number. Any
class that has one or more null pointers in its vtable is an abstract
class. Classes without any null vtable pointers are concrete
classes.</p>
<p>雇员类虚表
在Employee类虚函数表中，第一个函数指针被设置为0(即nullptr)，因为函数earnings是一个纯虚函数，因此缺乏实现。
第二个函数指针指向函数print，该函数显示员工的全名和社会保险号。</p>
<p><strong>任何在虚函数表中有一个或多个空指针的类都是抽象类。</strong></p>
<p><strong>没有空虚参指针的类是具体类。</strong></p>
</blockquote>
<blockquote>
<p>SalariedEmployee Class vtable Class SalariedEmployee overrides
function earnings to return the employee’s weekly salary, so the
function pointer points to the earnings function of class
SalariedEmployee. SalariedEmployee also overrides print, so the
corresponding function pointer points to the SalariedEmployee member
function that prints "salaried employee: " followed by the employee’s
name, social security number and weekly salary.</p>
<p>salarieemployee类变量表
类salariedemploye重写函数earnings以返回员工的周工资，因此函数指针指向类salariedemploye的收益函数。
SalariedEmployee也覆盖了print，因此对应的函数指针指向SalariedEmployee成员函数，该函数打印“salaried
employee:”，后面跟着员工的姓名、社会保险号和周薪。</p>
</blockquote>
<blockquote>
<p>CommissionEmployee Class vtable The earnings function pointer in the
vtable for class CommissionEmployee points to CommissionEmployee’s
earnings function that returns the employee’s gross sales multiplied by
the commission rate. The print function pointer points to the
CommissionEmployee version of the function, which prints the employee’s
type, name, social security number, commission rate and gross sales. As
in class SalariedEmployee, both functions override the functions in
class Employee.</p>
<p>CommissionEmployee类函数表
类CommissionEmployee的实值表中的收益函数指针指向CommissionEmployee的收益函数，该函数返回雇员的销售总额乘以佣金率。
print函数指针指向该函数的CommissionEmployee版本，后者打印员工的类型、姓名、社会保险号、佣金率和销售总额。
与salarieemployee类一样，这两个函数都覆盖了Employee类中的函数。</p>
</blockquote>
<blockquote>
<p>BasePlusCommissionEmployee Class vtable The earnings function pointer
in the vtable for class BasePlusCommissionEmployee points to the
BasePlusCommissionEmployee’s earnings function, which returns the
employee’s base salary plus gross sales multiplied by commission rate.
The print function pointer points to the BasePlusCommissionEmployee
version of the function, which prints the employee’s base salary plus
the type, name, social security number, commission rate and gross sales.
Both functions override the functions in class CommissionEmployee.
BasePlusCommissionEmployee类虚表</p>
<p>类BasePlusCommissionEmployee的实值表中的收益函数指针指向BasePlusCommissionEmployee的收益函数，该函数返回员工的基本工资加上总销售额乘以佣金率。
print函数指针指向该函数的BasePlusCommissionEmployee版本，该版本打印员工的基本工资加上类型、姓名、社会保险号、佣金率和总销售额。
这两个函数都覆盖了CommissionEmployee类中的函数。</p>
</blockquote>
<blockquote>
<p>Three Levels of Pointers to Implement Polymorphism Polymorphism is
accomplished through an elegant data structure involving three levels of
pointers. We’ve discussed one level—the function pointers in the vtable.
These point to the actual functions that execute when a virtual function
is invoked. Now we consider the second level of pointers. Whenever an
object of a class with one or more virtual functions is instantiated,
the compiler attaches to the object a pointer to the vtable for that
class. This pointer is normally at the front of the object, but it isn’t
required to be implemented that way. 实现多态的三层指针
多态是通过包含三层指针的优雅数据结构实现的。</p>
<p>我们已经讨论了一个级别——虚函数表中的函数指针，这些指向在调用虚函数时执行的实际函数。</p>
<p>现在我们考虑第二级指针：每当实例化具有一个或多个虚函数的类的对象时，编译器将指向该类虚函数表的指针附加到该对象上。</p>
<p>该指针通常位于对象的前面，但并不需要以这种方式实现。</p>
</blockquote>
<blockquote>
<p>In Fig. 12.18, these pointers are associated with the objects created
in Fig. 12.17. Notice that the diagram displays each of the object’s
data member values. The third level of pointers simply contains the
handles to the objects that receive the virtual function calls. The
handles in this level may also be references. Fig. 12.18 depicts the
vector employees that contains Employee pointers.</p>
<p>在图12.18中，这些指针与图12.17中创建的对象相关联。
注意，图中显示了对象的每个数据成员值。</p>
<p><strong>第三层指针仅包含接收虚函数调用的对象的句柄。</strong></p>
<p>这个级别的句柄也可以是引用。 图12.18描述了包含Employee指针的vector
employees。</p>
</blockquote>
<blockquote>
<p>Thus, the compiler compiles an offset or displacement of four bytes
(four bytes for each pointer on today’s popular 32-bit machines, and
only one pointer needs to be skipped) into the table of machine-language
object-code pointers to find the code that will execute the virtual
function call.</p>
<p>因此，编译器将四个字节的偏移量或位移(在当今流行的32位机器上每个指针四个字节，只需要跳过一个指针)
编译到机器语言对象代码指针表中，以查找将执行虚函数调用的代码。64位操作系统上是8个字节。</p>
</blockquote>
<blockquote>
<p>The compiler generates code that performs the following operations.
Select the ith entry of employees, and pass it as an argument to
function virtualViaPointer. This sets parameter baseClassPtr to point to
commissionEmployee. Dereference that pointer to get to the
commissionEmployee object. Dereference commissionEmployee’s vtable
pointer to get to the CommissionEmployee vtable. Skip the offset of four
bytes to select the print function pointer. Dereference the print
function pointer to form the “name” of the actual function to execute,
and use the function call operator () to execute the appropriate print
function.</p>
<p>编译器生成执行以下操作的代码。
选择雇员的第i个条目，并将其作为参数传递给函数virtualViaPointer。这将baseClassPtr参数设置为指向commissionEmployee。
解引用该指针以获得commissionEmployee对象。
解引用commissionEmployee的实参表指针，以获得commissionEmployee实参表。
跳过四个字节的偏移量以选择打印函数指针。</p>
<p>取消对打印函数指针的引用，形成要执行的实际函数的“名称”，并使用函数调用operator()来执行相应的打印函数。</p>
</blockquote>
<p>优化后的Cpp编译器生成的多态代码执行效率和switch语句的效率是一样的，但是对于性能要求很高的需要实时更新的应用程序，多态性的消耗就太高了。</p>
<blockquote>
<p>当我们调用<code>delete</code>时，C++会检查指针是否为空。如果指针为空（即指向<code>nullptr</code>），<code>delete</code>操作符会立即返回，而不会尝试释放任何内存。这种行为的设计是为了简化内存管理，使得程序员不必在调用<code>delete</code>之前检查指针是否为空。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 安全地删除空指针</span></span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 重新分配并删除</span></span><br><span class="line"> ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 再次删除空指针</span></span><br><span class="line"> ptr = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">"All delete operations completed successfully."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="重要注意事项">重要注意事项</h3>
<ol type="1">
<li><strong>多次删除同一个指针</strong>：对同一个指针多次调用<code>delete</code>会导致未定义行为。程序员应确保每个指针只调用一次<code>delete</code>，并在删除后将其设置为<code>nullptr</code>以避免重复删除。</li>
<li><strong>指针悬挂（Dangling
Pointer）</strong>：在删除指针后，继续使用这个指针会导致悬挂指针问题。这种情况下指针指向的内存已经被释放，再次访问该内存会导致未定义行为。</li>
</ol>
<h3 id="总结">总结</h3>
<ul>
<li>对空指针调用<code>delete</code>是安全的，不会引发任何问题。</li>
<li>删除指针后，应将指针设置为<code>nullptr</code>以避免悬挂指针和重复删除问题。</li>
<li>多次删除同一个非空指针会导致未定义行为，程序员应避免这种情况。</li>
</ul>
</blockquote>
<blockquote>
<p>This section demonstrates the powerful capabilities of runtime type
information (RTTI) and dynamic casting, which enable a program to
determine an object’s type at execution time and act on that object
accordingly. Figure 12.19 uses the Employee hierarchy developed in
Section 12.6 and increases by 10 percent the base salary of each
BasePlusCommissionEmployee.</p>
<p>本节演示运行时类型信息(RTTI)和动态类型转换的强大功能，它们使程序能够在执行时确定对象的类型，并相应地对该对象进行操作。
图12.19使用第12.6节中开发的Employee层次结构，并将每个BasePlusCommissionEmployee的基本工资增加10%。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607233428216.png" alt="image-20240607233428216">
<figcaption aria-hidden="true">image-20240607233428216</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240607233438656.png" alt="image-20240607233438656">
<figcaption aria-hidden="true">image-20240607233438656</figcaption>
</figure>
<blockquote>
<p>Since we process the Employees polymorphically, we cannot (with the
techniques you’ve learned so far) be certain as to which type of
Employee is being manipulated at any given time.
BasePlusCommissionEmployee employees must be identified when we
encounter them so they can receive the 10 percent salary increase. To
accomplish this, we use operator dynamic_cast (line 39) to determine
whether the current Employee’s type is BasePlusCommissionEmployee. This
is the downcast operation we referred to in Section 12.3.3. Lines 38–39
dynamically downcast employeePtr from type Employee * to type
BasePlusCommissionEmployee *.</p>
<p>由于我们以多态方式处理Employee，</p>
<p>因此我们无法(使用到目前为止学到的技术)确定在任何给定时间正在操作哪种类型的Employee。
当我们遇到员工时，必须确认他们的身份，这样他们才能获得10%的加薪。</p>
<p>为此，我们使用操作符dynamic_cast(第39行)来确定当前Employee的类型是BasePlusCommissionEmployee。</p>
<p>这是我们在12.3.3节中提到的向下转换操作。
第38-39行动态地将employeePtr从Employee
<em>类型向下转换为BasePlusCommissionEmployee </em>类型。</p>
</blockquote>
<p><code>dynamic_cast</code> 是 C++
中用于类型安全的向下转换（downcasting）和横向转换（cross-casting）的运算符。它主要用于带有多态的继承层次中，确保在运行时类型转换的安全性。</p>
<h3 id="使用场景">使用场景</h3>
<ol type="1">
<li><strong>向下转换（Downcasting）</strong>：将基类指针或引用转换为派生类指针或引用。</li>
<li><strong>横向转换（Cross-casting）</strong>：在具有共同基类的不同派生类之间进行转换。</li>
</ol>
<h3 id="语法">语法</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>new_type</code>：目标类型，必须是指针或引用类型。</li>
<li><code>expression</code>：要转换的表达式，必须是指针或引用类型，并且是多态类型（即基类中至少有一个虚函数）。</li>
</ul>
<h3 id="动态类型检查">动态类型检查</h3>
<p><code>dynamic_cast</code>
在运行时进行类型检查，如果转换是安全的，则返回一个指向新类型的指针或引用；如果转换不安全，则返回
<code>nullptr</code>（对于指针）或抛出 <code>std::bad_cast</code>
异常（对于引用）。</p>
<h3 id="示例代码">示例代码</h3>
<h4 id="基本用法">基本用法</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {} <span class="comment">// 必须有一个虚函数，通常是虚析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived1"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived2"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">checkAndCast</span><span class="params">(Base* base)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (Derived1* d1 = <span class="built_in">dynamic_cast</span>&lt;Derived1*&gt;(base)) {</span><br><span class="line">        d1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (Derived2* d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(base)) {</span><br><span class="line">        d2-&gt;<span class="built_in">display</span>();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Unknown type"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* b1 = <span class="keyword">new</span> <span class="built_in">Derived1</span>();</span><br><span class="line">    Base* b2 = <span class="keyword">new</span> <span class="built_in">Derived2</span>();</span><br><span class="line">    Base* b3 = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b1); <span class="comment">// 输出: Derived1</span></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b2); <span class="comment">// 输出: Derived2</span></span><br><span class="line">    <span class="built_in">checkAndCast</span>(b3); <span class="comment">// 输出: Unknown type</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> b1;</span><br><span class="line">    <span class="keyword">delete</span> b2;</span><br><span class="line">    <span class="keyword">delete</span> b3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>checkAndCast</code> 函数使用
<code>dynamic_cast</code>
将基类指针转换为派生类指针，并根据转换结果调用相应的方法。</p>
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong>必须是多态类型</strong>：<code>dynamic_cast</code>
只能用于具有虚函数的类（多态类型）。</li>
<li><strong>性能开销</strong>：由于 <code>dynamic_cast</code>
需要在运行时进行类型检查，所以比 <code>static_cast</code>
有更大的性能开销。</li>
<li><strong>转换失败</strong>：对于指针类型，转换失败会返回
<code>nullptr</code>；对于引用类型，转换失败会抛出
<code>std::bad_cast</code> 异常。</li>
</ol>
<h4 id="失败处理示例">失败处理示例</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Derived&amp; d = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*base);</span><br><span class="line">        d.<span class="built_in">show</span>();</span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> std::bad_cast&amp; e) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Bad cast: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，尝试将基类引用转换为派生类引用失败，<code>dynamic_cast</code>
抛出了 <code>std::bad_cast</code> 异常。</p>
<h3 id="总结-1">总结</h3>
<ul>
<li><code>dynamic_cast</code> 用于类型安全的向下转换和横向转换。</li>
<li>运行时类型检查，确保转换的安全性。</li>
<li>只能用于具有虚函数的多态类型。</li>
<li>转换失败时，对于指针返回 <code>nullptr</code>，对于引用抛出
<code>std::bad_cast</code> 异常。</li>
</ul>
<p>使用 <code>dynamic_cast</code>
可以显著提高代码的类型安全性，尤其是在复杂的继承层次结构中。</p>
<p><strong>能够转化成功的条件是：该基类指向的派生类对象
与dynamic_cast<newtype> 中的 newType相同</newtype></strong></p>
<p><strong>否则，如果是指针：则会赋值为nullptr，另外：则是抛出std::bad_cast异常。</strong></p>
<blockquote>
<p><code>typeid</code>
运算符是C++中的一种运行时类型信息（RTTI）工具，用于获取对象的实际类型。它返回一个
<code>std::type_info</code>
对象，该对象可以用来比较和识别类型。<code>typeid</code>
运算符在编译时和运行时都可以使用，但在运行时更有用，尤其是处理多态对象时。</p>
<h3 id="基本用法-1">基本用法</h3>
<p><code>typeid</code> 运算符的基本语法如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">typeid</span>(expression)</span><br></pre></td></tr></tbody></table></figure>
<p>其中，<code>expression</code> 可以是任何表达式或类型。</p>
<h3 id="示例代码-1">示例代码</h3>
<p>以下是一些示例，展示了 <code>typeid</code> 运算符的用法：</p>
<h4 id="获取基本类型的类型信息">获取基本类型的类型信息</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"> <span class="type">double</span> b = <span class="number">3.14</span>;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">"Type of a: "</span> &lt;&lt; <span class="built_in">typeid</span>(a).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">"Type of b: "</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Type of a: i</span><br><span class="line">Type of b: d</span><br></pre></td></tr></tbody></table></figure>
<p>注意：<code>typeid().name()</code>
返回的类型名是实现定义的（通常是编译器特定的表示形式），在不同的编译器中可能有所不同。</p>
<h4 id="用于多态对象">用于多态对象</h4>
<p>在多态对象的情况下，<code>typeid</code>
可以用来获取对象的实际类型，而不仅仅是基类的类型。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"> std::cout &lt;&lt; <span class="string">"Type of b: "</span> &lt;&lt; <span class="built_in">typeid</span>(b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">"Type of *b: "</span> &lt;&lt; <span class="built_in">typeid</span>(*b).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> b;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Type of b: P4Base</span><br><span class="line">Type of *b: 7Derived</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>typeid(b)</code> 返回的是指针类型
<code>Base*</code>，而 <code>typeid(*b)</code> 返回的是
<code>Derived</code>，因为 <code>b</code> 实际上指向一个
<code>Derived</code> 对象。</p>
<h3 id="比较类型">比较类型</h3>
<p>可以使用 <code>typeid</code> 运算符来比较两个对象的类型是否相同。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> Base* base = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line"> Base* derived = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*base) == <span class="built_in">typeid</span>(*derived)) {</span><br><span class="line">     std::cout &lt;&lt; <span class="string">"base and derived are of the same type."</span> &lt;&lt; std::endl;</span><br><span class="line"> } <span class="keyword">else</span> {</span><br><span class="line">     std::cout &lt;&lt; <span class="string">"base and derived are of different types."</span> &lt;&lt; std::endl;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> base;</span><br><span class="line"> <span class="keyword">delete</span> derived;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">base and derived are of different types.</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>typeid(*base)</code> 和
<code>typeid(*derived)</code>
返回不同的类型信息，因此输出表明它们是不同类型的对象。</p>
<h3 id="注意事项-1">注意事项</h3>
<ol type="1">
<li><strong>必须包含虚函数</strong>：在使用 <code>typeid</code>
进行多态类型检查时，基类必须包含至少一个虚函数，否则 <code>typeid</code>
会返回基类的类型而不是派生类的类型。</li>
<li><strong>类型名的实现依赖</strong>：<code>typeid().name()</code>
返回的类型名是实现定义的，通常在不同的编译器中可能不同。</li>
<li><strong>空指针</strong>：如果对空指针使用 <code>typeid</code>（如
<code>typeid(*p)</code>），会抛出 <code>std::bad_typeid</code>
异常。</li>
</ol>
<h4 id="处理空指针的示例">处理空指针的示例</h4>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Base* p = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Type of *p: "</span> &lt;&lt; <span class="built_in">typeid</span>(*p).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"Caught bad_typeid: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，对空指针使用 <code>typeid</code> 会抛出
<code>std::bad_typeid</code> 异常，并输出错误信息。</p>
<h3 id="总结-2">总结</h3>
<ul>
<li><code>typeid</code> 用于获取对象或类型的类型信息，返回一个
<code>std::type_info</code> 对象。</li>
<li>在多态情况下，<code>typeid</code> 可以用于确定对象的实际类型。</li>
<li>可以使用 <code>typeid</code> 比较两个对象的类型是否相同。</li>
<li>对空指针使用 <code>typeid</code> 会抛出 <code>std::bad_typeid</code>
异常。</li>
<li><code>typeid().name()</code>
返回的类型名是实现定义的，可能因编译器而异。</li>
</ul>
</blockquote>
<p>试图通过基类指针来调用仅在派生类中实现的函数是不允许的，只能调用在基类中实现的函数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/b3672eff.html">https://www.heavenhold.cn/posts/b3672eff.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://www.horosama.com/api/image_all/anime/1080p/pc/fb4ddC48481d3eFb8DDdbb310625e308.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/fe798dad.html" title="CPP复习 第十三章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_166_1000x619_350.011993408203_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPP复习 第十三章</div></div></a></div><div class="next-post pull-right"><a href="/posts/8371c227.html" title="CPP复习 第十一章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_885_750x1000_96_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CPP复习 第十一章</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/c9c3276d.html" title="C++对象模型和this指针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.7/img_72_2039x1274_299.999389648438_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-26</div><div class="title">C++对象模型和this指针</div></div></a></div><div><a href="/posts/84db90ab.html" title="CPP复习 杂项"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.38/img_387_1600x1087_400_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-10</div><div class="title">CPP复习 杂项</div></div></a></div><div><a href="/posts/7f64182b.html" title="CPP复习 第九章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/f0F03b5c42d43DDd976E63d49804062c.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">CPP复习 第九章</div></div></a></div><div><a href="/posts/f2c21137.html" title="CPP复习 第七章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.18/img_184_1600x945_71.9835968017578_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">CPP复习 第七章</div></div></a></div><div><a href="/posts/8371c227.html" title="CPP复习 第十一章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_885_750x1000_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">CPP复习 第十一章</div></div></a></div><div><a href="/posts/20c266a8.html" title="CPP复习 第六章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/2ADE2ea1D9d23858B4406A171C57f65e.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-09</div><div class="title">CPP复习 第六章</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">CPP复习 第十二章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.1.</span> <span class="toc-text">重要注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.0.4.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">1.0.5.</span> <span class="toc-text">动态类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.6.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">基本用法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.7.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">失败处理示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.0.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">1.0.9.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.0.10.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.0.10.1.</span> <span class="toc-text">获取基本类型的类型信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%A4%9A%E6%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.10.2.</span> <span class="toc-text">用于多态对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.11.</span> <span class="toc-text">比较类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">1.0.12.</span> <span class="toc-text">注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">处理空指针的示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.0.13.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>