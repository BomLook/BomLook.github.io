<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Ch8 Part2 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="Ch8 part2
 Memory Hierarchy
 为什么要有存储层次结构？
 
 理想存储的特点：理想的存储应该具有零访问时间（即没有延迟）、无限的存储容量和零成本这三个特点。
 理想存储面临的问题：然而，这些要求之间是相互矛盾的。一般来说，存储容量越大，速度往往越慢，因为容量增大意味着需要更长的时间来确定存储位置；而且速度越快的存储设备通常价格也越昂贵，例如静态随机存取存储器（SRAM）">
<meta property="og:type" content="article">
<meta property="og:title" content="Ch8 Part2">
<meta property="og:url" content="https://www.heavenhold.cn/posts/f1407080.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="Ch8 part2
 Memory Hierarchy
 为什么要有存储层次结构？
 
 理想存储的特点：理想的存储应该具有零访问时间（即没有延迟）、无限的存储容量和零成本这三个特点。
 理想存储面临的问题：然而，这些要求之间是相互矛盾的。一般来说，存储容量越大，速度往往越慢，因为容量增大意味着需要更长的时间来确定存储位置；而且速度越快的存储设备通常价格也越昂贵，例如静态随机存取存储器（SRAM）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132848.webp">
<meta property="article:published_time" content="2024-12-07T13:35:00.000Z">
<meta property="article:modified_time" content="2024-12-07T13:39:12.079Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="计算机组成原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132848.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/f1407080.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Ch8 Part2',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-12-07 21:39:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">184</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132848.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Ch8 Part2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-12-07T13:35:00.000Z" title="发表于 2024-12-07 21:35:00">2024-12-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-12-07T13:39:12.079Z" title="更新于 2024-12-07 21:39:12">2024-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Ch8 Part2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ch8-part2">Ch8 part2</h1>
<h3 id="memory-hierarchy">Memory Hierarchy</h3>
<p><strong>为什么要有存储层次结构？</strong></p>
<ul>
<li><p><strong>理想存储的特点</strong>：理想的存储应该具有<strong>零访问时间（即没有延迟）、无限的存储容量和零成本</strong>这三个特点。</p></li>
<li><p><strong>理想存储面临的问题</strong>：然而，这些要求之间是相互矛盾的。一般来说，存储容量越大，速度往往越慢，因为容量增大意味着需要更长的时间来确定存储位置；而且速度越快的存储设备通常价格也越昂贵，例如静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）在技术和成本上就体现了这种差异。</p></li>
<li><p><strong>总结问题</strong>：我们期望存储设备能够同时具备<strong>速度快、容量大、价格便宜</strong>的特点，但仅靠单一层次的存储是无法实现这些要求的。</p></li>
<li><p><strong>解决思路</strong>：为了营造出一种“<strong>速度快且容量大</strong>”的主存储器的假象，我们采用<strong>多级存储</strong>的方式。这些<strong>存储级别离处理器越远，存储容量越大，但速度越慢</strong>。并且要确保处理器所需的大部分数据都存储在速度较快的存储级别中。</p></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071106887.webp"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071117098.webp"></p>
<p><strong>缓冲区（Buffer）的概念</strong></p>
<ul>
<li><strong>定义</strong>：缓冲区是一种<strong>相对较小但速度更快</strong>的存储设备，它充当着<strong>较大且速度较慢设备中部分数据的暂存区域。</strong></li>
<li><strong>层级关系体现</strong>：对于每一个层级 k
而言，处于该层级的<strong>速度更快、尺寸更小</strong>的设备会作为层级 k
+ 1
中更大、更慢设备的缓冲区。所有的数据最终都是存储在最低层级上，并且数据会在相邻的两个层级之间进行复制。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071122644.webp"></p>
<p><strong>通用缓冲概念</strong></p>
<ul>
<li><strong>命中（Hit）情况</strong>：当程序需要某个对象
d（该对象存储在某个数据块 b 中）时，如果程序能在层级 k
的缓冲区中找到数据块 b（例如找到块 14），这种情况就被称作“命中”。</li>
<li><strong>未命中（Miss）情况</strong>：要是数据块 b 不在层级 k
的缓冲区中，那么层级 k 的缓冲区就必须从层级 k + 1
去获取该数据块（例如需要获取块 12
这种情况），这就是“未命中”的情况。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071123372.webp"></p>
<p><strong>存储层次结构的工作原理——利用局部性原理</strong></p>
<ul>
<li><strong>程序与局部性的关系</strong>：编写良好的程序往往会呈现出较好的局部性特点，也就是说在任意时刻，程序通常只会访问地址空间中相对较小的一部分区域。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071129622.webp"></p>
<p><strong>局部性原理的具体内容</strong></p>
<ul>
<li><strong>时间局部性（Temporal
Locality）</strong>：体现的是时间上的局部性，如果某个数据项在近期被引用过，那么它很有可能在不久之后会再次被引用。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071129050.webp"></p>
<ul>
<li><strong>空间局部性（Spatial
Locality）</strong>：反映的是空间上的局部性，当一个数据项被引用时，与其相邻的数据项很可能也会很快被引用。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071129312.webp"></p>
<p><strong>局部性原理在存储层次结构中的体现</strong></p>
<ul>
<li><strong>时间局部性方面</strong>：基于时间局部性，要将最近被访问的数据项放置在更靠近处理器的位置，这样便于处理器能更快速地再次访问它们。</li>
<li><strong>空间局部性方面</strong>：根据空间局部性，会把由连续字组成的数据块移到存储层次结构中较高的层级，以提高访问效率。</li>
</ul>
<p><strong>存储层次结构工作原理总结</strong></p>
<ul>
<li><p><strong>访问频率差异</strong>：程序访问层级 k
的数据往往要比访问层级 k + 1 的数据更为频繁。</p></li>
<li><p><strong>层级特性差异</strong>：正因为如此，层级 k + 1
的存储设备可以速度更慢些，相应地其每比特的成本也会更低，而且容量可以更大。</p></li>
<li><p><strong>最终效果呈现</strong>：通过这样的存储层次结构，最终能形成一个大容量的存储池，其成本和位于底层的廉价存储相当，但向程序提供数据的速率却能达到靠近顶层的快速存储的水平，从而在成本和性能上实现较好的平衡。</p></li>
</ul>
<p><strong>存储层次结构设计者面临的四个问题</strong></p>
<ul>
<li><strong>问题 1：块在高层级中可以放置在哪里？（块放置）</strong>
<ul>
<li>这涉及到在存储层次结构的高层级中，如何确定一个数据块的存储位置。例如，是可以随意放置在空闲位置，还是有特定的规则，如按照某种顺序或者映射关系来放置数据块。</li>
</ul></li>
<li><strong>问题 2：如果块在高层级中，如何找到它？（块识别）</strong>
<ul>
<li>当需要访问一个数据块，并且已知它可能存储在高层级中时，就需要一种有效的方法来识别它的具体位置。这可能涉及到使用索引、标签或者其他标识机制来快速定位数据块。</li>
</ul></li>
<li><strong>问题
3：在未命中（miss）的情况下，应该替换哪个块？（块替换）</strong>
<ul>
<li>当在高层级中没有找到所需的数据块（未命中），需要从下一层级获取数据块放入高层级时，就需要决定替换高层级中的哪个现有数据块。这可能需要考虑数据块的使用频率、最近使用时间等因素来选择合适的替换策略。</li>
</ul></li>
<li><strong>问题 4：写入操作时会发生什么？（写入策略）</strong>
<ul>
<li>当需要对存储在层次结构中的数据进行写入操作时，需要确定具体的写入方式。例如，是只写入高层级，还是同时更新高层级和下一层级，或者有其他的写入规则来确保数据的一致性和存储效率。</li>
</ul></li>
</ul>
<p>这些问题将在下一节解决。</p>
<h3 id="cache-memories">Cache Memories</h3>
<p><strong>存在的问题</strong></p>
<p>处理器的性能提升速度远比动态随机存取存储器（DRAM）的速度提升速度要快得多，这就导致了两者之间在速度匹配上出现了差距。</p>
<p><strong>高速缓存（Cache）的相关情况</strong></p>
<ul>
<li><strong>基本特性</strong>：高速缓存是基于静态随机存取存储器（SRAM）构建的<strong>小型且速度很快</strong>的存储器，它由硬件自动进行管理。</li>
<li><strong>所处位置与作用</strong>：它充当着<strong>CPU
和主存储器之间的缓冲区</strong>，主要功能是<strong>存放主存储器中那些被频繁访问的数据块。</strong></li>
</ul>
<p><strong>高速缓存的目的</strong></p>
<p>其目的在于<strong>让主存储器的访问速度能够接近当前可获取到的速度最快的存储器的速度</strong>，与此同时，还能以相对较为廉价的半导体存储器的成本，来提供大容量的存储功能，从而在一定程度上缓解处理器与主存储器之间因速度差异带来的性能影响。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071142243.webp"></p>
<p><strong>Cache and Main Memory Organization Figure</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071143062.webp"></p>
<p><strong>命中（Hit）与未命中（Miss）的概念</strong></p>
<ul>
<li><strong>命中（Hit）</strong>：当对高速缓存（Cache）进行访问时，能够在缓存存储器中找到所需的数据，这种情况就称为命中。</li>
<li><strong>未命中（Miss）</strong>：如果对高速缓存进行访问，却没能在其中找到所需的数据，那就不得不转而访问主存储器，这种情况就是未命中。</li>
</ul>
<p><strong>命中率（Hit Rate）相关</strong></p>
<ul>
<li><strong>命中率定义</strong>：它指的是能够通过高速缓存满足的内存访问次数所占的百分比。对于高性能计算机而言，很高的命中率（远远超过
0.9）是至关重要的。</li>
<li><strong>未命中率计算</strong>：未命中率等于 1 减去命中率（Miss Rate
= 1 - (Hit Rate)）。</li>
</ul>
<p><strong>处理器与高速缓存的交互特点</strong></p>
<p>处理器不需要明确知晓<strong>高速缓存的存在情况</strong>。它只是简单地使用<strong>指向内存中相应位置的地址来发出读（Read）和写（Write）请求。</strong>然后由<strong>高速缓存控制电路来判断所请求的字当前是否存在于高速缓存之中</strong>。</p>
<p><strong>处理器读请求的不同情况</strong></p>
<ul>
<li><strong>高速缓存读命中（Cache Read
Hit）</strong>：此时会直接将所请求的字转发给处理器。</li>
<li><strong>高速缓存读未命中（Cache Read Miss）的两种处理方式</strong>：
<ul>
<li><strong>常规方式</strong>：先从主存储器中将包含所请求字的整个数据块复制到高速缓存中，然后再将特定的所请求字转发给处理器。</li>
<li><strong>加载穿透/提前重启（Load Through/Early
Restart）方式</strong>：在将所请求的字转发给处理器的同时，从主存储器中将包含该请求字的整个数据块复制到高速缓存中。</li>
</ul></li>
<li><strong>高速缓存读未命中在当代缓存组织中的情况（Cache Read Miss -
Contemporary Cache Organization）</strong>：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071152270.webp"></p>
<p><strong>高速缓存映射方案相关问题概述</strong></p>
<ul>
<li><strong>块放置问题（Cache Mapping
Schemes）</strong>：在高速缓存中，一个数据块可以放置在哪里，这是由映射方案来确定的。</li>
<li><strong>块识别问题（Block
Identification）</strong>：如果一个数据块已经在高速缓存中了，那么要通过怎样的方式去找到它，这也是需要考虑的方面。</li>
<li><strong>替换算法问题（Replacement
Algorithms）</strong>：当发生高速缓存未命中的情况时，应该替换掉高速缓存中的哪个数据块，这就需要相应的替换算法来决定。</li>
<li><strong>写入策略问题（Write
Policy）</strong>：在写入操作时，若遇到写入命中（write
hit）情况会怎样处理，遇到写入未命中（write
miss）情况又该如何应对，这些都属于写入策略需要涵盖的内容。</li>
</ul>
<p><strong>映射方案的基本作用（Mapping Scheme (1)）</strong></p>
<ul>
<li><strong>确定块放置位置</strong>：映射方案决定了数据块最初被复制到高速缓存时将会被放置的位置。</li>
<li><strong>地址转换功能</strong>：同时，它还需要<strong>将生成的主存储器地址转换为高速缓存中的相应位置地址</strong>。因为当
CPU
为主存储器中某个特定字生成地址，且该数据恰好就在高速缓存中时，原来的主存储器地址是不能直接用来访问高速缓存的，需要进行相应的转换。</li>
</ul>
<p><strong>具体的映射方案及相关假设</strong></p>
<ul>
<li><strong>三种映射方案</strong>：主要有直接映射（Direct
Mapping）、关联映射（Associative Mapping）和组关联映射（Set Associative
Mapping）这三种方案。</li>
<li><strong>相关假设说明</strong>：
<ul>
<li>假设存在高速缓存行（Cache line）用<span class="math inline">\(L_i\)</span>表示，内存块（Memory block）用<span class="math inline">\(B_j\)</span>表示，其中<span class="math inline">\(i = 0, 1, \ldots, m - 1\)</span>，<span class="math inline">\(j = 0, 1, \ldots, n - 1\)</span>，这里<span class="math inline">\(m = 2^r\)</span>，<span class="math inline">\(n =
2^s\)</span>。</li>
<li>每个缓存行或者内存块都由<span class="math inline">\(k =
2^w\)</span>个连续的字组成。</li>
<li>主存储器地址是由<span class="math inline">\(s +
w\)</span>位来表示的。 (<strong><span class="math inline">\(s\)</span>确定是哪一块内存块，<span class="math inline">\(w\)</span>确定是哪一个字</strong>)。</li>
</ul></li>
</ul>
<p><strong>直接映射法</strong></p>
<p><strong>主存块与缓存行的映射关系</strong></p>
<ul>
<li>在直接映射方式下，主存储器的每一个数据块都只会映射到唯一的一个高速缓存行上。也就是说，如果某个主存块存在于高速缓存当中，那它必然处于某一个特定的位置上。</li>
</ul>
<p><strong>映射函数说明</strong></p>
<ul>
<li>其映射函数为<span class="math inline">\(i = j \bmod
m\)</span>。在这个函数里，<span class="math inline">\(i\)</span>代表的是高速缓存行的编号，<span class="math inline">\(j\)</span>表示的是主存储器数据块的编号，而<span class="math inline">\(m\)</span>则是高速缓存中所包含的缓存行的数量。通过这样的计算方式，就能确定主存块具体映射到哪个高速缓存行上。</li>
</ul>
<p><strong>直接映射（Direct
Mapping）的缓存行表与主存地址结构</strong></p>
<ul>
<li><strong>缓存行表</strong>：在直接映射方式下，有相应的缓存行表用于记录相关信息。</li>
<li><strong>主存地址结构</strong>：主存地址由不同部分构成，其中最低有效
w 位用于标识唯一的字，而最高有效 s 位用来指定一个内存块。并且，最高有效
s 位又会被拆分成一个缓存行字段 r 位以及一个标记（tag）字段（共 s - r
位，且是最高有效部分）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071211739.webp"></p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./../../source/images/Ch2%20part2/image-20241207121327368.png" alt="image-20241207121327368">
<figcaption aria-hidden="true">image-20241207121327368</figcaption>
</figure>
<p>描述一下这个图：Main memory 按照 Cache 进行重新编排，Tag 表示 Main
memory 划分为了多少个整<strong>个 Cache 大小规模的块</strong>，Line
是对一个 Cache 中每一个块的标识，最后 Word 是 Cache
中一个块中的某一个特定的字。</p>
<p><strong>注意：Cache 不同块的 Tag 可能是不同的</strong>。</p>
<p><strong>示例说明</strong></p>
<ul>
<li>假设有一个高速缓存，它包含 128 个缓存行，每个缓存行有 16
个字。主存储器有 64K 个字，同时假设主存储器是通过 16
位地址进行寻址的，并且连续的地址指向连续的字。那么，总的主存储器块数量为
64K / 16 = 4K（也就是 4096 个），并且满足关系<span class="math inline">\(i = j \mod 128\)</span>（即内存块序号 j
对缓存行数量 128 取模等于缓存行序号 i）。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071409756.webp"></p>
<p>如何将 16 位的地址划分为 Tag, line, word 字段。</p>
<ul>
<li>word：<span class="math inline">\(log_2{16}=4\)</span>。</li>
<li>line：<span class="math inline">\(log_2{128}=7\)</span>。</li>
<li>tag：<span class="math inline">\(log_2{32}=5\)</span>或者<span class="math inline">\(16-7-4=5\)</span>。</li>
</ul>
<p><strong>直接映射的优缺点</strong></p>
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>简单易实现</strong>：其原理和实现机制相对比较直观、简单，不需要复杂的逻辑和算法，易于硬件电路去实现这种映射方式。</li>
<li><strong>成本低廉</strong>：由于结构简单，在硬件设计和制造方面花费的成本相对较低，有助于降低整个系统的成本。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>块位置固定</strong>：对于给定的内存块，它在高速缓存中的映射位置是固定的。</li>
<li><strong>易产生高未命中率</strong>：如果一个程序频繁地访问两个映射到同一个缓存行的不同内存块，那么就会反复出现缓存未命中的情况，导致缓存的利用效率降低，影响系统性能。</li>
</ul></li>
</ul>
<p><strong>关联映射（Associative Mapping）的基本特点</strong></p>
<ul>
<li><strong>无映射函数</strong>：关联映射不存在像直接映射那样特定的映射函数。主存储器中的一个数据块可以被加载到高速缓存的任意一行当中。</li>
<li><strong>主存地址结构</strong>：主存地址被解读为标记（Tag）和字（Word）两部分。其中，标记部分占<span class="math inline">\(s\)</span>位，字部分占<span class="math inline">\(w\)</span>位，<strong>标记能够唯一地标识主存中的数据块</strong>。在查找数据时，需要对高速缓存每一行的标记进行检查，看是否与之匹配，不过这样一来，高速缓存的查找操作在硬件实现上成本就比较高了。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071416506.webp"></p>
<p>直接比较是主存中的哪一个数据块(Line)，随后找字(word)。</p>
<p><strong>示例情况</strong></p>
<ul>
<li>例如，假设有一个包含 128 行的高速缓存，而对应的主存储器有 4096
个数据块。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071417815.webp"></p>
<p><strong>关联映射的优缺点</strong></p>
<ul>
<li><strong>优点</strong>：它赋予了<strong>将主存数据块放置到高速缓存位置时完全的自由度</strong>，也就是可以根据实际情况灵活选择把数据块存放在高速缓存的哪一行，不受固定映射规则限制。</li>
<li><strong>缺点</strong>：需要<strong>复杂的电路来并行地检查高速缓存中所有数据块的标记，以确定是否命中</strong>，这种复杂的硬件电路设计会增加成本，也使得硬件实现的难度提高了。</li>
</ul>
<p><strong>组关联映射（Set Associative Mapping）的基本概念</strong></p>
<ul>
<li><strong>融合两种映射技术</strong>：组关联映射是直接映射和关联映射技术的结合体。</li>
<li><strong>缓存分组情况</strong>：高速缓存会被划分成若干个组，每个组中包含了一定数量的缓存行。</li>
<li><strong>块的映射规则</strong>：给定的一个主存数据块会映射到某一个给定组内的任意一行中。例如，数据块<span class="math inline">\(B_j\)</span>可以位于组<span class="math inline">\(i\)</span>中的任意一行；像每组有 2 行的情况，就是
2-way 组关联映射，意味着一个给定的数据块只能在唯一的一个组内的 2
行之中选择一行进行存放。</li>
</ul>
<p><strong>组、行数量及映射关系相关说明</strong></p>
<ul>
<li>高速缓存被划分成<span class="math inline">\(v\)</span>（<span class="math inline">\(=2^d\)</span>）个组，每个组由<span class="math inline">\(k\)</span>条缓存行组成（也就是<span class="math inline">\(k\)</span>-way 组关联映射），并且满足<span class="math inline">\(m = v×k\)</span>。其映射关系通过<span class="math inline">\(i = j \bmod v\)</span>来确定，这里<span class="math inline">\(i\)</span>表示高速缓存的组编号，<span class="math inline">\(j\)</span>表示主存储器数据块的编号，<span class="math inline">\(v\)</span>就是高速缓存中组的数量。同时还列举了一些特殊情况，比如当<span class="math inline">\(v = m\)</span>，<span class="math inline">\(k =
1\)</span>时是直接映射；当<span class="math inline">\(v =
1\)</span>，<span class="math inline">\(k =
m\)</span>时是关联映射；当<span class="math inline">\(v =
m/2\)</span>，<span class="math inline">\(k = 2\)</span>时是 2-way
组关联映射；当<span class="math inline">\(v = m/4\)</span>，<span class="math inline">\(k = 4\)</span>时是 4-way 组关联映射。</li>
</ul>
<p><strong>主存地址结构说明</strong></p>
<ul>
<li>主存地址结构由标记（Tag）、组（Set）和字（Word）这几部分构成。标记部分占<span class="math inline">\((s - d)\)</span>位，组字段占<span class="math inline">\(d\)</span>位，字部分占<span class="math inline">\(w\)</span>位。其中组字段用于确定高速缓存中的哪个组可能包含所需的数据块。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071423035.webp"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071434723.webp"></p>
<p><strong>示例情况说明——2-way 组关联映射</strong></p>
<p>在 2-way 组关联映射的示例中，存在映射关系<span class="math inline">\(i = j \bmod 64\)</span></p>
<p>如何将 16
位的主存地址划分成标记（Tag）、组（Set）以及字（Word）字段？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071439576.webp"></p>
<ul>
<li>word：<span class="math inline">\(log_2{16}=4\)</span></li>
<li>set：<span class="math inline">\(log_2{64}=6\)</span></li>
<li>Tag：<span class="math inline">\(16-4-6=6\)</span>。</li>
</ul>
<p><strong>组关联映射的优缺点</strong></p>
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>缓解块替换的竞争问题</strong>：相较于直接映射方法，由于一个数据块在组内有几种可选择的存放位置，在进行块替换时有了更多选择，从而缓解了直接映射中因块位置固定而产生的竞争问题。</li>
<li><strong>降低硬件成本</strong>：相比于完全关联映射需要对所有缓存行进行关联搜索，组关联映射通过缩小关联搜索的范围（只在组内进行关联搜索），降低了硬件实现上的成本。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>需要并行匹配标记</strong>：为了判断数据是否存在于高速缓存中，<strong>需要对一个组内每个数据块的标记进行并行匹配（需要<span class="math inline">\(k\)</span>个比较器）</strong>。虽然其匹配所需的硬件成本比完全关联映射（需要<span class="math inline">\(n\)</span>个比较器，<span class="math inline">\(n\)</span>为数据块数量）要低，但还是比直接映射（只需要一个比较器）要高。</li>
</ul></li>
</ul>
<p><strong>有效位（Valid Bit）</strong></p>
<ul>
<li><strong>初始状态及作用</strong>：当系统初次上电时，高速缓存中并不包含有效数据。为此，需要为每个高速缓存块设置一个通常被称作“有效位”的控制位，<strong>用它来指示该缓存块中的数据是否有效</strong>。</li>
<li><strong>有效位取值含义</strong>：当有效位取值为<strong>0</strong>时，表示对应缓存块中的<strong>数据无效</strong>；取值为<strong>1</strong>时，则表示数据是<strong>有效的</strong>。</li>
<li><strong>初始设置及更新情况</strong>：在系统刚开始通电时，所有高速缓存块的有效位都会被初始设置为
0。而当把主存储器中某个特定块的数据加载到高速缓存相应块后，该缓存块对应的有效位就会被置为
1。下面是一个例子。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071445956.webp"></p>
<p><strong>替换算法（Replacement Algorithms）</strong></p>
<ul>
<li><strong>直接映射高速缓存（Direct Mapped Cache）</strong>：
<ul>
<li><strong>替换规则特点</strong>：在直接映射高速缓存中<strong>没有可选择的余地</strong>，因为<strong>每个主存储器数据块只映射到唯一的一个高速缓存行</strong>。所以当需要替换时，就只能替换掉这个对应的高速缓存行。</li>
</ul></li>
<li><strong>关联映射和组关联映射高速缓存（Associative and Set
Associative Mapped Cache）</strong>：
<ul>
<li><strong>算法选择考虑因素</strong>：这类高速缓存的替换算法通常由硬件来实现，主要考虑的因素是速度，要能快速地确定替换哪个缓存块。</li>
<li><strong>常见替换算法</strong>：
<ul>
<li><strong>LRU（Least Recently
Used，最近最少使用）算法</strong>：其核心原则是<strong>替换掉长时间未被访问的缓存块</strong>，也就是选择那个距离上次被访问时间间隔最长的缓存块进行替换。</li>
<li><strong>FIFO（First In First
Out，先进先出）算法</strong>：当一个缓存块被访问时，就把它压入队列，而在需要选择替换块时，则通过弹出队列头部的块来确定要替换的缓存块，遵循先进入队列的先被替换的规则。</li>
<li><strong>随机（Random）算法</strong>：就是随机选择一个缓存块进行替换，没有特定的规律或依据数据的访问历史等来选择。</li>
</ul></li>
</ul></li>
</ul>
<p><strong>映射技术示例</strong></p>
<ul>
<li><p><strong>缓存情况假设</strong>：假设处理器具备独立的<strong>指令缓存和数据缓存</strong>，并且数据缓存仅有能容纳
8 个数据块的空间。每个数据块仅包含一个 16
位的数据字，同时内存是以字为单位进行寻址的，寻址地址为 16 位。</p></li>
<li><p><strong>替换算法假设</strong>：在该数据缓存中，采用
LRU（最近最少使用）替换算法来进行缓存块的替换操作。</p></li>
<li><p><strong>数据存储情况</strong>：有一个 4×10
的数字数组，数组中的每个元素都占据一个字的存储空间，这些元素被存储在内存地址从
7A00 到 7A27 的位置。而且该数组 A
的元素是<strong>按照列顺序进行存储的</strong>。</p></li>
<li><p><strong>应用操作情况</strong>：相应的应用程序要对数组 A
的第一行元素依据该行元素的平均值进行归一化处理：</p></li>
</ul>
<p><span class="math display">\[
A(0,i) \larr \frac{A(0,i)}{\sum_\limits{j=0}^{9}A(0,j)/10}, for\ i = 0,
1,2·······9
\]</span></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071451495.webp"></p>
<p>解释一下各种方法的 Tag：</p>
<ul>
<li>直接映射：因为一个块中只有一个字，所以 word 为 0，line 对应的是 8
块数据块，所以是<span class="math inline">\(16-log_2{8}-0=13\)</span>。</li>
<li>关联映射：因为一个块中只有一个字，所以<span class="math inline">\(word\)</span>为 0，<span class="math inline">\(16-0=16\)</span>。</li>
<li>组相联映射：因为缓存中有 8 块，4
块为一组，所以是两组，有因为一个块中只有一个字，所以<span class="math inline">\(16-log_2{2}-0=15\)</span>。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">sum: = 0</span><br><span class="line">for j: = 0 to 9 do</span><br><span class="line">	sum: = sum + A(0,j)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ave: = sum / 10</span><br><span class="line">for i: = 9 down to 0</span><br><span class="line">	A(0,i): = A(0,i) / ave</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure>
<p><strong>直接映射法</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071524746.webp"></p>
<p><strong>关联映射法</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071527861.webp"></p>
<p><strong>组相联映射：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071528522.webp"></p>
<p><strong>写策略</strong></p>
<p>写入命中（Write Hit）——直写（Write Through）方式</p>
<ul>
<li><strong>更新机制</strong>：当出现写入命中情况时，采用直写策略意味着会同时更新高速缓存中的相应位置以及主存储器中的对应位置。</li>
<li><strong>优点</strong>：能够确保高速缓存与主存储器的数据<strong>始终保持一致</strong>，方便后续的数据访问与操作，维护了数据在不同存储层级间的一致性。</li>
<li><strong>缺点</strong>：
<ul>
<li><strong>增加主存访问次数</strong>：所有的写入操作都需要访问主存储器（涉及总线事务），这无疑增加了对主存的操作频率，也会占用一定的总线资源。</li>
<li><strong>拖慢系统速度</strong>：倘若因为高速缓存未命中而产生了另一个对主存储器的读请求，那么这个读请求就必须等待之前的写入操作完成后才能进行，从而使得系统整体的运行效率受到影响，出现延迟情况。</li>
</ul></li>
</ul>
<p>写入命中（Write Hit）——回写（Write Back）方式</p>
<ul>
<li><strong>更新机制</strong>：在回写策略下，当发生写入命中时，只会更新高速缓存中的相应位置，并且通过设置一个关联的标志位（脏位或修改位）来标记该位置的数据已被更新。<strong>只有当包含被标记字的缓存块要从高速缓存中移除时，才会去更新主存储器中对应字的位置。</strong></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071603176.webp"></p>
<ul>
<li><strong>优点</strong>：
<ul>
<li><strong>速度更快</strong>：相比直写方式，它不需要花费时间去立即访问主存储器，减少了写入操作时等待主存响应的时间，能提高写入效率，进而提升系统整体的运行速度。</li>
<li><strong>减少主存写入次数</strong>：如果是对一个缓存块内的多个字进行写入操作，只需要最后在缓存块移出缓存时对主存储器进行一次写入即可，避免了多次重复写入主存的情况。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>主存数据有效性问题</strong>：会导致主存储器中的部分数据处于无效状态，这样一来，I/O
模块对主存储器的访问就只能通过高速缓存来进行，增加了访问的复杂性和对缓存的依赖程度。</li>
<li><strong>增加缓存空间占用</strong>：需要在高速缓存中额外设置一个位来指示哪个缓存块已经被修改过，这无疑会增大高速缓存的空间占用量。</li>
</ul></li>
</ul>
<p>写入未命中（Write Miss）——非写分配（No-Write Allocate）方式</p>
<ul>
<li><strong>处理机制</strong>：在采用直写式高速缓存时，如果出现写入未命中的情况，新的信息会直接被写入主存储器中，而不会将相应的数据块加载到高速缓存里面。</li>
</ul>
<p>写入未命中（Write Miss）——写分配（Write Allocate）方式</p>
<ul>
<li><strong>处理机制</strong>：对于回写式高速缓存，当出现写入未命中时，<strong>首先会把包含被寻址字的那个数据块先调入高速缓存中，然后再用新的信息覆盖高速缓存中对应的那个字，以此完成写入未命中情况下的操作流程。</strong></li>
</ul>
<p><strong>命中率与未命中率的定义及计算公式</strong></p>
<ul>
<li><strong>命中率定义及公式</strong>：命中次数占所有尝试访问次数的比例被称作命中率。其计算公式为$H
= ×100% <span class="math inline">\(，这里\)</span>H<span class="math inline">\(表示高速缓存的命中率，\)</span>N_c<span class="math inline">\(是对高速缓存中数据的成功访问次数，\)</span>N_m<span class="math inline">\(是对主存储器中数据的访问次数，\)</span>N_c +
N_m$则为所有尝试访问的总次数。</li>
<li><strong>未命中率</strong>：相应地，高速缓存的未命中率就是<span class="math inline">\(1 - H\)</span>。</li>
</ul>
<p><strong>平均访问时间的计算公式及示例</strong></p>
<ul>
<li><strong>平均访问时间计算公式</strong>：平均访问时间<span class="math inline">\(t_{ave} = Ht_c + (1 - H)t_m\)</span>，其中<span class="math inline">\(t_{ave}\)</span>代表处理器所经历的平均访问时间，<span class="math inline">\(H\)</span>为高速缓存的命中率，<span class="math inline">\(t_c\)</span>是访问高速缓存中信息所需的时间，<span class="math inline">\(t_m\)</span>是访问主存储器中信息所需的时间。</li>
<li><strong>示例计算</strong>：例如，有访问时间为<span class="math inline">\(70nsec\)</span>的主存储器以及访问时间为<span class="math inline">\(10nsec\)</span>的高速缓存，命中率为<span class="math inline">\(90\%\)</span>。按照公式计算平均访问时间为<span class="math inline">\(0.9×10 + (1 - 0.9)×70 = 9 + 7 =
16ns\)</span>，可以看出这个平均访问时间相比于直接访问主存储器要好得多。</li>
</ul>
<p><strong>特定计算机的相关参数及未命中惩罚时间计算示例</strong></p>
<ul>
<li><strong>相关参数说明</strong>：考虑一台计算机，其高速缓存和主存储器的访问时间分别为<span class="math inline">\(\tau\)</span>和<span class="math inline">\(10\tau\)</span>。当发生高速缓存未命中情况时，会有一个包含
8
个字的数据块被传输到高速缓存中。传输这个数据块时，传输第一个字需要花费<span class="math inline">\(10\tau\)</span>，而传输其余 7 个字每个字需要<span class="math inline">\(\tau\)</span>的时间。并且未命中惩罚还包括最初访问高速缓存（缓存未命中时）的延迟<span class="math inline">\(\tau\)</span>，以及在数据块加载到高速缓存后将字传输给处理器的延迟<span class="math inline">\(\tau\)</span>。</li>
<li><strong>未命中惩罚时间计算</strong>：综合上述各项，未命中惩罚时间<span class="math inline">\(M = \tau + 10\tau + 7\tau + \tau =
19\tau\)</span>。</li>
</ul>
<p><strong>基于程序指令操作及命中率的缓存作用示例</strong></p>
<ul>
<li><strong>程序相关假设</strong>：假设在一个程序中，有<span class="math inline">\(30\%\)</span>的指令会执行读或写操作（也就是每<span class="math inline">\(100\)</span>条指令会有<span class="math inline">\(130\)</span>次内存访问），并且高速缓存中指令的命中率是<span class="math inline">\(0.95\)</span>，数据的命中率是<span class="math inline">\(0.9\)</span>。</li>
<li><strong>缓存作用体现（时间对比）</strong>：通过计算<span class="math inline">\(\frac{time\ without\ cache}{time\ with\
cache}\)</span>来体现使用缓存带来的改进，按照所给参数计算可得<span class="math inline">\(\frac{130×10\tau}{100(0.95\tau +
0.05×19\tau)+30(0.9\tau + 0.1×19\tau)} =
4.7\)</span>，说明使用缓存后在时间方面有较为显著的改善效果。</li>
</ul>
<p><strong>多级缓存层次结构概述</strong></p>
<ul>
<li><strong>多级缓存情况</strong>：如今大多数系统都采用多级缓存层次结构，各级缓存自身形成了一个小型的存储层次体系。</li>
<li><strong>指令和数据缓存</strong>：
<ul>
<li><strong>统一缓存（Unified
Cache）</strong>：是一种将指令和数据都进行缓存的方式，但这种方式容易导致过多的缓存未命中情况出现。</li>
<li><strong>分离缓存（Separate
Caches）</strong>：许多现代系统会为数据和指令分别设置缓存，其优势在于能够让访问变得不那么随机，更具聚集性，而且通常比统一缓存的访问时间更短（一般分离缓存的容量会更大些）。</li>
</ul></li>
</ul>
<p>一级缓存（L1）和二级缓存（L2）的特点</p>
<ul>
<li><strong>一级缓存（L1）</strong>：
<ul>
<li><strong>位置及组成</strong>：通常位于 CPU
核心内部，一般是分开设置的（即分为指令缓存和数据缓存）。</li>
<li><strong>容量大小</strong>：相对比较小，大概在 8KB 到 128KB
之间。</li>
<li><strong>访问时间</strong>：典型的访问时间大约为 4ns 左右。</li>
</ul></li>
<li><strong>二级缓存（L2）</strong>：
<ul>
<li><strong>位置关系</strong>：位于 CPU 核心外部。</li>
<li><strong>容量特性</strong>：比一级缓存大，可能在 256KB 到数 MB
之间。</li>
<li><strong>连接与访问时间</strong>：通过高速总线与 CPU
相连，访问时间通常在 15 - 20ns 左右，并且一般是统一缓存的形式。</li>
</ul></li>
</ul>
<p><strong>一级缓存和二级缓存的平均访问时间计算公式</strong></p>
<p>平均访问时间<span class="math inline">\(t_{ave} = h_1C_1 + (1 -
h_1)h_2C_2 + (1 - h_2)M\)</span>，其中：</p>
<ul>
<li><span class="math inline">\(h_1\)</span>表示在一级缓存（L1）中的命中率；</li>
<li><span class="math inline">\(h_2\)</span>表示在二级缓存（L2）中的命中率；</li>
<li><span class="math inline">\(C_1\)</span>是访问一级缓存（L1）中信息所需的时间；</li>
<li><span class="math inline">\(C_2\)</span>是将信息从二级缓存（L2）传输到一级缓存（L1）的未命中惩罚时间（即未命中时额外花费的时间）；</li>
<li><span class="math inline">\(M\)</span>是将信息从主存储器传输到二级缓存（L2）的未命中惩罚时间。</li>
</ul>
<p><strong>商业处理器中缓存的示例——英特尔缓存</strong></p>
<ul>
<li><strong>80386 处理器</strong>：没有片上缓存，只有外部缓存。</li>
<li><strong>80486 处理器</strong>：具有片上的一级缓存（L1），容量为
8K，采用 16 字节的缓存行以及 4-way
组关联组织方式；同时还有外部的二级缓存（L2）。</li>
<li><strong>奔腾（所有版本）系列处理器</strong>：有两个片上的一级缓存（L1），分别用于缓存数据和指令。</li>
<li><strong>奔腾 II 处理器</strong>：二级缓存（L2）集成在芯片上。</li>
<li><strong>奔腾 III
处理器</strong>：在芯片外增加了三级缓存（L3）。</li>
</ul>
<p><strong>商业处理器中缓存的示例（续）——英特尔缓存（续）</strong></p>
<ul>
<li><strong>奔腾 4 处理器</strong>：
<ul>
<li><strong>一级缓存（L1）</strong>：容量在 8K 到 16K
字节之间，缓存行大小为 64 字节，采用 4-way 组关联方式。</li>
<li><strong>二级缓存（L2）</strong>：为两个一级缓存（L1）提供数据支持，容量在
256K 到 512K 字节之间，缓存行大小为 128 字节，采用 8-way
组关联方式，并且还有片上的三级缓存（L3）。</li>
</ul></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071618250.webp"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202412071618854.webp"></p>
<h2 id="练习">练习</h2>
<h3 id="a-memory-hierarchy-_.">A memory hierarchy
<strong>_</strong>.</h3>
<p>A. limits programs' size but allows them to execute more quickly
存储器层次结构不会限制程序大小</p>
<p>B. is a way of structuring memory allocation decisions
存储器层次结构不是一种存储器分配方式</p>
<p>C. takes advantage of the speed of SRAM and the capacity of disk
存储器层次结构利用了 SRAM
的速度和磁盘的容量，给用户造成存储器速度快、容量大的假象</p>
<p>D. makes programs execute more slowly but allows them to be bigger
存储器层次结构使得程序执行得更快</p>
<p><strong>答案：C</strong>。</p>
<h3 id="by-mapping-technique-a-main-memory-block-can-be-placed-into-any-cache-block-position.">By
mapping technique, a main memory block can be placed into any cache
block position.</h3>
<p>A. direct B. associative C. set associative D. sequential</p>
<p><strong>答案：B</strong>。</p>
<blockquote>
<h3 id="答案b.-associative">答案：<strong>B. associative</strong></h3>
<h4 id="解析">解析：</h4>
<ol type="1">
<li><strong>直接映射（Direct Mapping）：</strong>
<ul>
<li>主存块只能映射到缓存中的一个固定块位置。</li>
<li>优点是简单高效，但限制较多。</li>
</ul></li>
<li><strong>全相联映射（Associative Mapping）：</strong>
<ul>
<li>主存块可以映射到缓存中的<strong>任何位置</strong>，即<strong>灵活性最高</strong>。</li>
<li>缓存需要比较所有块的标记位，硬件实现复杂。</li>
</ul></li>
<li><strong>组相联映射（Set Associative Mapping）：</strong>
<ul>
<li>主存块只能映射到一个<strong>特定组</strong>中的<strong>任意缓存块</strong>。</li>
<li>结合了直接映射和全相联映射的优点。</li>
</ul></li>
<li><strong>顺序映射（Sequential Mapping）：</strong>
<ul>
<li>此选项并不属于常见的缓存映射技术类型。</li>
</ul></li>
</ol>
<h4 id="正确选项">正确选项：</h4>
<p>根据题意，“主存块可以被放入缓存的任意块位置”，这正是<strong>全相联映射（Associative
Mapping）</strong>的特征。因此，答案是 <strong>B.
associative</strong>。</p>
</blockquote>
<h3 id="if-a-cache-has-a-capacity-of-16kb-and-a-line-length-of-128-bytes-how-many-sets-does-the-cache-have-if-it-is-2-way-4-way-or-8-way-set-associative">If
a cache has a capacity of 16KB and a line length of 128 bytes, how many
sets does the cache have if it is 2-way, 4-way, or 8-way set
associative?</h3>
<p>A. 64,32,16</p>
<p>B. 64,16,8</p>
<p>C. 32,16,8</p>
<p>D. 128,64,32</p>
<p><strong>答案：A。</strong></p>
<p>cache 包含 16KB/128B=128 个 line</p>
<blockquote>
<h3 id="解析-1">解析：</h3>
<p><strong>已知信息：</strong></p>
<ul>
<li><p><strong>Cache 总容量</strong>：16 KB (<span class="math inline">\(16 \times 1024 = 16,384\)</span> 字节)</p></li>
<li><p><strong>行长度</strong>：128 字节</p></li>
<li><p><strong>缓存行总数</strong>： <span class="math display">\[
\text{缓存行总数} = \frac{\text{总容量}}{\text{行长度}} =
\frac{16,384}{128} = 128 \text{ 行}
\]</span></p></li>
</ul>
<p><strong>组相联映射：</strong><br>
在组相联缓存中，缓存行被划分为若干组，每组内的缓存行数量称为
<strong>相联度（Associativity）</strong>。组数（Sets）可以通过以下公式计算：</p>
<p><span class="math display">\[
\text{组数} = \frac{\text{缓存行总数}}{\text{相联度}}
\]</span></p>
<h4 id="路组相联2-way-set-associative">1. 2 路组相联（2-way set
associative）：</h4>
<p><span class="math display">\[
\text{组数} = \frac{128}{2} = 64
\]</span></p>
<h4 id="路组相联4-way-set-associative">2. 4 路组相联（4-way set
associative）：</h4>
<p><span class="math display">\[
\text{组数} = \frac{128}{4} = 32
\]</span></p>
<h4 id="路组相联8-way-set-associative">3. 8 路组相联（8-way set
associative）：</h4>
<p><span class="math display">\[
\text{组数} = \frac{128}{8} = 16
\]</span></p>
<h3 id="答案">答案：</h3>
<p><strong>A. 64, 32, 16</strong></p>
<h3 id="验证">验证：</h3>
<ul>
<li>缓存总容量不变，分组数量和相联度关系正确，因此计算合理。</li>
</ul>
</blockquote>
<h3 id="a-set-associative-cache-consists-of-a-total-of-64-blocks-divided-into-4-block-sets.-the-main-memory-contains-4096-blocks-each-consisting-of-128-words.-how-many-bits-are-there-in-a-main-memory-address">A
set-associative cache consists of a total of 64 blocks divided into
4-block sets. The main memory contains 4096 blocks, each consisting of
128 words. How many bits are there in a main memory address?</h3>
<p>A. 21 B. 24 C. 19 D. 32</p>
<p><strong>答案：C。</strong></p>
<p>主存有 4096 个块，所以需要 12 位指定块地址；每个块中有 128
个字，所以需要 7 位指定字地址。12+7=19，所以主存地址是 19
位。（无论是哪一种映射法，<strong>都是相同的位数</strong>）</p>
<h3 id="a-set-associative-cache-consists-of-a-total-of-64-blocks-divided-into-4-block-sets.-the-main-memory-contains-4096-blocks-each-consisting-of-128-words.-how-many-bits-are-there-in-each-of-the-tag-set-and-word-fields">A
set-associative cache consists of a total of 64 blocks divided into
4-block sets. The main memory contains 4096 blocks, each consisting of
128 words. How many bits are there in each of the TAG, SET, and WORD
fields?</h3>
<p>A. 2,5,12 B. 12,2,5 C. 4,8,7 D. 8,4,7</p>
<p><strong>答案：D。</strong></p>
<p>主存地址总共 19 位，word 部分 7 位，cache 划分为 16 个 set，故 set
部分 4 位，剩下 19-7-4=8 位是 tag 部分。</p>
<h3 id="what-are-advantages-and-disadvantages-of-direct-mapping">What
are advantages and disadvantages of direct mapping?</h3>
<p>Its advantages are:</p>
<ul>
<li><ol type="1">
<li>Simple, easy to implement</li>
</ol></li>
<li><ol start="2" type="1">
<li>Inexpensive</li>
</ol></li>
</ul>
<p>Its disadvantage is:</p>
<ul>
<li>fixed location for given block</li>
</ul>
<h3 id="what-are-advantage-and-disadvantage-of-associative-mapping">What
are advantage and disadvantage of associative mapping?</h3>
<ul>
<li>Its advantage is that it gives complete freedom in choosing the
cache location in which to place the memory blocks.</li>
<li>Its disadvantage is that it requires complex circuitry to examine
the tags of all cache blocks in parallel.</li>
</ul>
<h3 id="the-effectiveness-of-the-cache-mechanism-is-based-on-a-property-of-computer-programs-called-_.">The
effectiveness of the cache mechanism is based on a property of computer
programs called <strong>_</strong>.</h3>
<p>A. parallelism</p>
<p>C. make the common case fast</p>
<p>B. locality of reference</p>
<p>D. forwarding</p>
<p><strong>答案：B。</strong>基于缓存的局部性原理。</p>
<blockquote>
<h3 id="中文解释">中文解释：</h3>
<p><strong>答案：B. 局部性原理（locality of reference）</strong></p>
<h4 id="解析-2"><strong>解析：</strong></h4>
<p>缓存机制的高效性是基于程序的 <strong>局部性原理（Locality of
Reference）</strong>。局部性是指程序在访问内存时，通常会表现出以下两种特性：</p>
<ol type="1">
<li><strong>时间局部性（Temporal Locality）：</strong>
如果一个数据在某个时间点被访问过，那么在<strong>不久的将来</strong>可能会再次被访问。
（例如：循环变量或频繁使用的指令）</li>
<li><strong>空间局部性（Spatial Locality）：</strong>
如果一个数据被访问，那么与其相邻的数据在<strong>不久的将来</strong>可能会被访问。
（例如：顺序执行的指令或连续的数组元素）</li>
</ol>
<h4 id="其他选项分析"><strong>其他选项分析：</strong></h4>
<ul>
<li><strong>A. 并行性（Parallelism）：</strong>
与缓存的核心原理无关，更多用于多核处理器的性能提升。</li>
<li><strong>C. 提高常见情况的效率（Make the common case
fast）：</strong> 虽然是优化原则，但不是缓存机制的直接理论基础。</li>
<li><strong>D. 转发（Forwarding）：</strong>
通常是指流水线中的数据转发技术，与缓存机制无关。</li>
</ul>
<h3 id="结论">结论：</h3>
<p>缓存机制的高效性主要依赖程序的
<strong>局部性原理</strong>，因此答案是 <strong>B. locality of
reference</strong>。</p>
</blockquote>
<h3 id="which-of-the-following-manages-the-transfer-of-data-between-the-cache-and-main-memory">Which
of the following manages the transfer of data between the cache and main
memory?</h3>
<p>A. compiler B. registry C. operating system D. hardware</p>
<p>Cache-主存系统完全由硬件管理</p>
<p><strong>答案：D</strong>。</p>
<h3 id="if-a-cache-has-64-byte-cache-lines-it-takes-cycles-to-fetch-a-cache-line-if-the-main-memory-takes-20-cycles-to-respond-to-each-memory-request-and-returns-2-bytes-of-data-in-response-to-each-request.">If
a cache has 64-byte cache lines, it takes cycles to fetch a cache line
if the main memory takes 20 cycles to respond to each memory request and
returns 2 bytes of data in response to each request.</h3>
<p>A. 128 B. 320 C. 640 D. 256</p>
<p><strong>答案：C。</strong></p>
<p>（64/2）*20=640</p>
<h3 id="in-cache-system-when-a-block-is-to-be-overwritten-it-is-sensible-to-overwrite-the-one-that-has-gone-the-longest-time-without-being-referenced.-this-technique-is-called-the-replacement-algorithm.">In
cache system, when a block is to be overwritten, it is sensible to
overwrite the one that has gone the longest time without being
referenced. This technique is called the replacement algorithm.</h3>
<p>A. FIFO B. Random C. LFU D. LRU</p>
<p><strong>答案：D。</strong>。</p>
<p>替换掉最长时间没有被访问过的块，是最近最少使用算法（LRU）的替换原则</p>
<h3 id="true-or-false-in-a-direct-mapped-cache-it-is-sensible-to-use-random-replacement-policy-when-a-line-must-be-evicted-from-the-cache-to-make-room-for-incoming-data.">True
or False? In a direct-mapped cache, it is sensible to use Random
replacement policy when a line must be evicted from the cache to make
room for incoming data.</h3>
<p>In direct-mapped caches, there is no choice about which line to
evict, since the incoming line can only be placed in one location in the
cache.</p>
<h3 id="true-or-false-for-a-write-operation-the-cache-location-and-the-main-memory-are-updated-simultaneously.-this-technique-is-called-the-write-through-protocol.">True
or False? For a Write operation, the cache location and the main memory
are updated simultaneously. This technique is called the write-through
protocol.</h3>
<blockquote>
<h3 id="答案true">答案：<strong>True</strong></h3>
<h4 id="解析-3"><strong>解析：</strong></h4>
<p>在<strong>写操作（Write
Operation）</strong>中，如果缓存中的数据和主存的数据同时更新，这种技术被称为
<strong>写直达协议（Write-Through Protocol）</strong>。</p>
<h4 id="特点"><strong>特点：</strong></h4>
<ol type="1">
<li><strong>数据一致性：</strong>
<ul>
<li>写操作立即将数据写入主存，保证主存和缓存中的数据始终一致。</li>
<li>不容易出现主存与缓存不同步的情况。</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>每次写操作都会访问主存，写操作的延迟会比较高，因此性能较低。</li>
</ul></li>
</ol>
<h4 id="对比write-back-protocol"><strong>对比：Write-Back
Protocol</strong></h4>
<ul>
<li>写操作只更新缓存，而主存只有在缓存行被替换（evicted）时才更新。性能较高，但需要更多的管理机制以保证一致性。</li>
</ul>
<h3 id="结论-1">结论：</h3>
<p>该描述是正确的，<strong>写直达协议</strong>的定义符合题意，因此答案是
<strong>True</strong>。</p>
</blockquote>
<h3 id="what-are-advantages-and-disadvantages-of-write-through-policy">What
are advantages and disadvantages of write through policy?</h3>
<p><strong>Advantage</strong>: Keeps cache main memory consistent at the
same time.</p>
<p><strong>Disadvantages</strong>:</p>
<ul>
<li><ol type="1">
<li>All writes require main memory access (bus transaction).</li>
</ol></li>
<li><ol start="2" type="1">
<li>Slows down the system - If the there is another read request for
main memory due to miss in cache, the read request has to wait until the
earlier write was serviced.</li>
</ol></li>
</ul>
<h3 id="what-are-advantages-and-disadvantages-of-write-back-policy">What
are advantages and disadvantages of write back policy?</h3>
<p><strong>Advantages:</strong></p>
<ul>
<li>(1)Faster than write-through, time is not spent accessing main
memory.</li>
<li>(2)Writes to multiple words within a block require only one write to
the main-memory.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li>(1)Portions of main memory are invalid, and hence accesses by I/O
modules can be allowed only through the cache.</li>
<li>(2)Need extra bit in cache to indicate which block has been
modified. Adds to size of the cache.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/f1407080.html">https://www.heavenhold.cn/posts/f1407080.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132848.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/86474016.html" title="Ch8 Part3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132211.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Ch8 Part3</div></div></a></div><div class="next-post pull-right"><a href="/posts/8bbb3ba.html" title="Ch8"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132490.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Ch8</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6cc3adc6.html" title="Ch0 and Ch1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/5891b38CFe3f381b9dfeE0718f37ca92.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-04</div><div class="title">Ch0 and Ch1</div></div></a></div><div><a href="/posts/9f696a32.html" title="Ch3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031421115.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-07</div><div class="title">Ch3</div></div></a></div><div><a href="/posts/e86e5aa4.html" title="Ch2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031419294.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-05</div><div class="title">Ch2</div></div></a></div><div><a href="/posts/ef039ebd.html" title="Ch6"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031421169.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-07</div><div class="title">Ch6</div></div></a></div><div><a href="/posts/86474016.html" title="Ch8 Part3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412072132211.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-07</div><div class="title">Ch8 Part3</div></div></a></div><div><a href="/posts/760acf07.html" title="Ch5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202412031420351.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-05</div><div class="title">Ch5</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ch8-part2"><span class="toc-number">1.</span> <span class="toc-text">Ch8 part2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#memory-hierarchy"><span class="toc-number">1.0.1.</span> <span class="toc-text">Memory Hierarchy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-memories"><span class="toc-number">1.0.2.</span> <span class="toc-text">Cache Memories</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.1.</span> <span class="toc-text">练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-memory-hierarchy-_."><span class="toc-number">1.1.1.</span> <span class="toc-text">A memory hierarchy
_.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#by-mapping-technique-a-main-memory-block-can-be-placed-into-any-cache-block-position."><span class="toc-number">1.1.2.</span> <span class="toc-text">By
mapping technique, a main memory block can be placed into any cache
block position.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88b.-associative"><span class="toc-number">1.1.3.</span> <span class="toc-text">答案：B. associative</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">正确选项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a-cache-has-a-capacity-of-16kb-and-a-line-length-of-128-bytes-how-many-sets-does-the-cache-have-if-it-is-2-way-4-way-or-8-way-set-associative"><span class="toc-number">1.1.4.</span> <span class="toc-text">If
a cache has a capacity of 16KB and a line length of 128 bytes, how many
sets does the cache have if it is 2-way, 4-way, or 8-way set
associative?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="toc-number">1.1.5.</span> <span class="toc-text">解析：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%BB%84%E7%9B%B8%E8%81%942-way-set-associative"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 2 路组相联（2-way set
associative）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%BB%84%E7%9B%B8%E8%81%944-way-set-associative"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. 4 路组相联（4-way set
associative）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E7%BB%84%E7%9B%B8%E8%81%948-way-set-associative"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3. 8 路组相联（8-way set
associative）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88"><span class="toc-number">1.1.6.</span> <span class="toc-text">答案：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">1.1.7.</span> <span class="toc-text">验证：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-set-associative-cache-consists-of-a-total-of-64-blocks-divided-into-4-block-sets.-the-main-memory-contains-4096-blocks-each-consisting-of-128-words.-how-many-bits-are-there-in-a-main-memory-address"><span class="toc-number">1.1.8.</span> <span class="toc-text">A
set-associative cache consists of a total of 64 blocks divided into
4-block sets. The main memory contains 4096 blocks, each consisting of
128 words. How many bits are there in a main memory address?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#a-set-associative-cache-consists-of-a-total-of-64-blocks-divided-into-4-block-sets.-the-main-memory-contains-4096-blocks-each-consisting-of-128-words.-how-many-bits-are-there-in-each-of-the-tag-set-and-word-fields"><span class="toc-number">1.1.9.</span> <span class="toc-text">A
set-associative cache consists of a total of 64 blocks divided into
4-block sets. The main memory contains 4096 blocks, each consisting of
128 words. How many bits are there in each of the TAG, SET, and WORD
fields?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-are-advantages-and-disadvantages-of-direct-mapping"><span class="toc-number">1.1.10.</span> <span class="toc-text">What
are advantages and disadvantages of direct mapping?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-are-advantage-and-disadvantage-of-associative-mapping"><span class="toc-number">1.1.11.</span> <span class="toc-text">What
are advantage and disadvantage of associative mapping?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-effectiveness-of-the-cache-mechanism-is-based-on-a-property-of-computer-programs-called-_."><span class="toc-number">1.1.12.</span> <span class="toc-text">The
effectiveness of the cache mechanism is based on a property of computer
programs called _.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.13.</span> <span class="toc-text">中文解释：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-2"><span class="toc-number">1.1.13.1.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.1.13.2.</span> <span class="toc-text">其他选项分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.1.14.</span> <span class="toc-text">结论：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#which-of-the-following-manages-the-transfer-of-data-between-the-cache-and-main-memory"><span class="toc-number">1.1.15.</span> <span class="toc-text">Which
of the following manages the transfer of data between the cache and main
memory?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-a-cache-has-64-byte-cache-lines-it-takes-cycles-to-fetch-a-cache-line-if-the-main-memory-takes-20-cycles-to-respond-to-each-memory-request-and-returns-2-bytes-of-data-in-response-to-each-request."><span class="toc-number">1.1.16.</span> <span class="toc-text">If
a cache has 64-byte cache lines, it takes cycles to fetch a cache line
if the main memory takes 20 cycles to respond to each memory request and
returns 2 bytes of data in response to each request.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-cache-system-when-a-block-is-to-be-overwritten-it-is-sensible-to-overwrite-the-one-that-has-gone-the-longest-time-without-being-referenced.-this-technique-is-called-the-replacement-algorithm."><span class="toc-number">1.1.17.</span> <span class="toc-text">In
cache system, when a block is to be overwritten, it is sensible to
overwrite the one that has gone the longest time without being
referenced. This technique is called the replacement algorithm.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#true-or-false-in-a-direct-mapped-cache-it-is-sensible-to-use-random-replacement-policy-when-a-line-must-be-evicted-from-the-cache-to-make-room-for-incoming-data."><span class="toc-number">1.1.18.</span> <span class="toc-text">True
or False? In a direct-mapped cache, it is sensible to use Random
replacement policy when a line must be evicted from the cache to make
room for incoming data.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#true-or-false-for-a-write-operation-the-cache-location-and-the-main-memory-are-updated-simultaneously.-this-technique-is-called-the-write-through-protocol."><span class="toc-number">1.1.19.</span> <span class="toc-text">True
or False? For a Write operation, the cache location and the main memory
are updated simultaneously. This technique is called the write-through
protocol.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88true"><span class="toc-number">1.1.20.</span> <span class="toc-text">答案：True</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-3"><span class="toc-number">1.1.20.1.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.20.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94write-back-protocol"><span class="toc-number">1.1.20.3.</span> <span class="toc-text">对比：Write-Back
Protocol</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">1.1.21.</span> <span class="toc-text">结论：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-are-advantages-and-disadvantages-of-write-through-policy"><span class="toc-number">1.1.22.</span> <span class="toc-text">What
are advantages and disadvantages of write through policy?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#what-are-advantages-and-disadvantages-of-write-back-policy"><span class="toc-number">1.1.23.</span> <span class="toc-text">What
are advantages and disadvantages of write back policy?</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>