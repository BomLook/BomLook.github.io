<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS61A Summary | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="Summary 没有太多充足的时间看Textbook，先暂时用GPT进行一些总结。 第一章：用函数构建抽象 1.1   入门 计算机科学是一个广泛的学科领域，涉及分布式系统、人工智能、机器人技术、图形学、安全性、科学计算等多个领域。计算机科学的迅速进步对人类生活的许多方面都产生了深远的影响，如商业、通信、科学、艺术、娱乐和政治。 计算机科学的高效生产力得益于一组优雅且强大的基本思想。所有计算都始于">
<meta property="og:type" content="article">
<meta property="og:title" content="CS61A Summary">
<meta property="og:url" content="https://www.heavenhold.cn/posts/af5eaed1.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="Summary 没有太多充足的时间看Textbook，先暂时用GPT进行一些总结。 第一章：用函数构建抽象 1.1   入门 计算机科学是一个广泛的学科领域，涉及分布式系统、人工智能、机器人技术、图形学、安全性、科学计算等多个领域。计算机科学的迅速进步对人类生活的许多方面都产生了深远的影响，如商业、通信、科学、艺术、娱乐和政治。 计算机科学的高效生产力得益于一组优雅且强大的基本思想。所有计算都始于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124299.webp">
<meta property="article:published_time" content="2024-10-07T16:12:00.000Z">
<meta property="article:modified_time" content="2024-10-09T06:42:49.244Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="Computer Science">
<meta property="article:tag" content="CS61A">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124299.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/af5eaed1.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS61A Summary',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-10-09 14:42:49'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">164</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124299.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS61A Summary</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-07T16:12:00.000Z" title="发表于 2024-10-08 00:12:00">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-09T06:42:49.244Z" title="更新于 2024-10-09 14:42:49">2024-10-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/">Computer Science</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Science/CS61A/">CS61A</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>115分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS61A Summary"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Summary">Summary</h1>
<p>没有太多充足的时间看Textbook，先暂时用GPT进行一些总结。</p>
<h2 id="第一章：用函数构建抽象">第一章：用函数构建抽象</h2>
<h3 id="1-1-入门">1.1   入门</h3>
<p>计算机科学是一个广泛的学科领域，涉及分布式系统、人工智能、机器人技术、图形学、安全性、科学计算等多个领域。计算机科学的迅速进步对人类生活的许多方面都产生了深远的影响，如商业、通信、科学、艺术、娱乐和政治。</p>
<p>计算机科学的高效生产力得益于一组优雅且强大的基本思想。所有计算都始于信息表示、处理逻辑的定义，以及用于管理这些逻辑复杂性的抽象设计。掌握这些基础知识要求我们精确理解计算机如何解释程序并执行计算过程。</p>
<h4 id="1-1-1-使用-Python-编程">1.1.1   使用 Python 编程</h4>
<p>编程语言不仅是学习工具，更是让人融入开发者社区的桥梁。Python 是一种广泛使用的编程语言，拥有庞大的用户群。它的代码强调可读性、美观性和简洁性，因此非常适合作为教学语言。本书将通过 Python 来引入抽象和计算模型。</p>
<h4 id="1-1-2-安装-Python-3">1.1.2   安装 Python 3</h4>
<p>建议安装 Python 3 的最新稳定版本。本书不会使用 Python 2.7，因此确保下载 Python 3。</p>
<h4 id="1-1-3-交互式会话">1.1.3   交互式会话</h4>
<p>通过 Python 交互式会话，用户可以在提示符 <code>&gt;&gt;&gt;</code> 后输入 Python 代码，并立即得到结果。这是一种与 Python 解释器互动的方式，可以帮助用户迅速了解代码的执行结果。</p>
<h4 id="1-1-4-第一个示例">1.1.4   第一个示例</h4>
<p>Python 具备广泛的功能支持，比如处理文本、显示图形以及网络通信。通过一个简单的例子展示了 Python 的多种功能，如使用 <code>urlopen</code> 函数从互联网获取数据，处理莎士比亚全集，并找出反转后依然是单词的六个字母的词。</p>
<h4 id="1-1-5-错误处理">1.1.5   错误处理</h4>
<p>计算机强大但“愚蠢”，它们严格执行指令，但也容易因为细小错误而产生意外结果。程序员需要通过调试（debugging）来解决这些问题。调试的几个原则包括：增量测试、隔离错误、检查假设、以及寻求他人帮助。</p>
<p>本书将通过这些调试技巧帮助读者克服编程中的挑战，并培养在整个计算机科学生涯中的调试能力。</p>
<hr>
<h3 id="1-2-编程的元素">1.2 编程的元素</h3>
<p>编程语言不仅是指令计算机执行任务的工具，还用于表达和交流关于计算过程的想法。编程不仅为了机器执行，也为了让人理解，因此编写的程序需要清晰易读。每种强大的编程语言都提供了三种机制来构建复杂的计算：</p>
<ol>
<li><strong>原始表达式和语句</strong>：最基本的构建模块。</li>
<li><strong>组合方法</strong>：通过简单元素组合成更复杂的元素。</li>
<li><strong>抽象方法</strong>：将复合元素命名并作为一个单元进行操作。</li>
</ol>
<p>编程中的两大核心要素是<strong>函数</strong>和<strong>数据</strong>。数据是我们想要操作的内容，而函数是操作数据的规则。强大的编程语言应该能够描述原始数据、原始函数，并提供组合和抽象的方法。</p>
<h4 id="1-2-1-表达式">1.2.1 表达式</h4>
<p><strong>表达式</strong>是程序的基本构件。最简单的表达式是数字，比如 <code>42</code>。通过数学运算符（如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），可以将简单表达式组合成复杂表达式。</p>
<h4 id="1-2-2-调用表达式">1.2.2 调用表达式</h4>
<p><strong>调用表达式</strong>是最重要的复合表达式，用于调用函数并传入参数。比如 <code>max(7.5, 9.5)</code> 调用了 <code>max</code> 函数，传入了两个参数。函数调用的优点包括能够接收任意数量的参数、支持嵌套表达式，以及统一表示不同的操作符（如 <code>pow</code>、<code>add</code>）。</p>
<h4 id="1-2-3-导入库函数">1.2.3 导入库函数</h4>
<p>Python 提供了大量的内置函数和模块，但并非所有函数都默认可用。通过 <code>import</code> 语句可以引入模块中的函数。例如，<code>math</code> 模块提供数学函数，<code>operator</code> 模块提供对应运算符的函数。</p>
<h4 id="1-2-4-名称与环境">1.2.4 名称与环境</h4>
<p>Python 中的名称通过<strong>赋值语句</strong>绑定到值。比如，<code>radius = 10</code> 将名称 <code>radius</code> 绑定到值 <code>10</code>。赋值是最简单的抽象形式，允许通过名称引用复杂计算的结果。<strong>环境</strong>是解释器跟踪名称和值的绑定关系的内存。</p>
<h4 id="1-2-5-嵌套表达式的求值">1.2.5 嵌套表达式的求值</h4>
<p>Python 对调用表达式的求值过程是递归的。Python 先求值操作符和操作数，再应用函数。该过程可以用<strong>表达式树</strong>表示，树的叶子节点表示原始表达式（如数字或函数），内部节点表示调用表达式及其结果。</p>
<h4 id="1-2-6-非纯粹的-print-函数">1.2.6 非纯粹的 <code>print</code> 函数</h4>
<p>Python 中有两类函数：<strong>纯函数</strong>和<strong>非纯函数</strong>。纯函数只返回值，不会产生副作用；而非纯函数（如 <code>print</code>）则会产生副作用，如输出结果。纯函数的优势包括更易于组合、测试和并发执行。</p>
<hr>
<p>在 Python 中，函数定义是一个非常重要的抽象技术，它使我们可以把一组操作封装在一个函数中，然后通过函数名来引用和使用这些操作。以下是 Python 中定义和使用函数的核心概念和步骤：</p>
<h3 id="1-3-定义新的功能">1.3 定义新的功能</h3>
<h4 id="1-3-1-定义一个新函数">1.3.1 定义一个新函数</h4>
<p>定义一个函数的语法格式如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">参数</span>):</span><br><span class="line">    <span class="keyword">return</span> 返回值</span><br></pre></td></tr></tbody></table></figure>
<p>示例：定义一个平方函数</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，<code>square</code> 是函数名，<code>x</code> 是参数，<code>return x * x</code> 是函数的返回值，它会返回参数 <code>x</code> 的平方。</p>
<h4 id="1-3-2-函数调用">1.3.2 函数调用</h4>
<p>定义函数后，我们可以通过函数名来调用它，并传递适当的参数。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>square(<span class="number">4</span>)</span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个调用返回 <code>16</code>，因为 <code>4 * 4</code> 等于 <code>16</code>。</p>
<h4 id="1-3-3-函数的参数">1.3.3 函数的参数</h4>
<p>函数可以接收一个或多个参数。比如，我们可以定义一个函数来计算两个数的平方和：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_squares</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> square(x) + square(y)</span><br></pre></td></tr></tbody></table></figure>
<p>在这个函数中，<code>x</code> 和 <code>y</code> 是两个参数，返回的结果是 <code>x</code> 的平方加上 <code>y</code> 的平方。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_squares(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">25</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个调用返回 <code>25</code>，因为 <code>3 * 3 + 4 * 4 = 9 + 16 = 25</code>。</p>
<h4 id="1-3-4-局部变量与全局变量">1.3.4 局部变量与全局变量</h4>
<p>在函数内部定义的参数和变量只在该函数的作用域内有效，我们称之为<strong>局部变量</strong>。外部的全局变量和函数内的局部变量是相互独立的，即使它们的名字相同也不会混淆。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="number">10</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">5</span>  <span class="comment"># 这里的 x 是局部变量，与全局变量 x 无关</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">3</span>)</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></tbody></table></figure>
<p>调用 <code>foo(3)</code> 返回 <code>8</code>，因为函数内的 <code>x</code> 是局部变量，取值为 <code>3</code>，而不是全局的 <code>x = 10</code>。</p>
<h4 id="1-3-5-函数的作用域与环境">1.3.5 函数的作用域与环境</h4>
<p>在 Python 中，每当调用函数时，都会创建一个新的<strong>局部作用域</strong>，即一个独立的环境，用来存储函数参数和函数内定义的变量。Python 解释器通过这种方式确保变量不会相互混淆。</p>
<p>例如，调用 <code>sum_squares(5, 12)</code> 时，Python 会创建一个局部环境，其中 <code>x = 5</code> 和 <code>y = 12</code>，然后依次计算它们的平方并返回结果。</p>
<h4 id="1-3-6-抽象的作用">1.3.6 抽象的作用</h4>
<p>函数是非常有用的抽象工具，因为它们可以隐藏复杂的实现细节。你可以使用函数，而不需要知道它内部是如何实现的。对于使用者来说，函数更像是一个“黑箱”，他们只需要知道如何调用函数，以及函数的输入和输出是什么即可。</p>
<p>这种抽象特性使得编写和维护代码更加简单和高效。</p>
<hr>
<h3 id="1-4-设计函数">1.4 设计函数</h3>
<p>函数是所有程序的重要组成部分，无论大小，它们是我们在编程语言中表达计算过程的主要媒介。本文将讨论什么是良好函数的特征，这些特征本质上都强化了函数的抽象性。</p>
<h4 id="1-4-1-函数的特点">1.4.1 函数的特点</h4>
<ol>
<li>
<p><strong>单一职责</strong>：每个函数应该只有一个明确的任务，并且可以用简短的名称和一行文字描述。执行多个任务的函数应拆分为多个函数。</p>
</li>
<li>
<p><strong>遵循DRY原则</strong>：不要重复自己（DRY原则）是软件工程的核心原则，意味着多个代码片段不应描述冗余的逻辑，而应将逻辑实现一次、命名并多次应用。如果发现自己在复制粘贴代码块，可能是抽象化的机会。</p>
</li>
<li>
<p><strong>通用性</strong>：函数应通用。例如，平方操作不在Python库中，因为它是<code>pow</code>函数（可以将数字提升到任意幂）的特殊情况。</p>
</li>
</ol>
<p>这些指导方针提高了代码的可读性，减少了错误数量，并通常最小化了书写的总代码量。将复杂任务分解为简洁函数的技能需要经验来掌握。幸运的是，Python提供了多种功能来支持这一努力。</p>
<h4 id="1-4-2-文档说明">1.4.2 文档说明</h4>
<p>函数定义通常包括文档说明，称为文档字符串（docstring），它必须与函数体缩进对齐。文档字符串通常用三重引号括起来。第一行描述函数的任务，后续行可以描述参数并阐明函数的行为。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n</span>):</span><br><span class="line">    <span class="string">"""计算理想气体的压力（单位：帕斯卡）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    应用理想气体法则：http://en.wikipedia.org/wiki/Ideal_gas_law</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    v -- 气体体积（单位：立方米）</span></span><br><span class="line"><span class="string">    t -- 绝对温度（单位：开尔文）</span></span><br><span class="line"><span class="string">    n -- 气体颗粒数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    k = <span class="number">1.38e-23</span>  <span class="comment"># 玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>help</code>函数并传入函数名作为参数，可以查看其文档字符串。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">help</span>(pressure)</span><br></pre></td></tr></tbody></table></figure>
<p>在编写Python程序时，建议为所有但最简单的函数包含文档字符串。记住，代码只写一次，但常常被阅读多次。Python文档包括文档字符串的指导方针，以保持不同Python项目之间的一致性。</p>
<h4 id="1-4-3-注释">1.4.3 注释</h4>
<p>在Python中，可以在行尾使用<code>#</code>符号附加注释。例如，上述关于玻尔兹曼常数的注释描述了<code>k</code>。这些注释不会出现在Python的帮助信息中，解释器也会忽略它们。它们仅供人类参考。</p>
<h4 id="1-4-4-默认参数值">1.4.4 默认参数值</h4>
<p>定义通用函数的一个结果是引入额外的参数。具有多个参数的函数可能调用起来显得笨拙且难以阅读。</p>
<p>在Python中，可以为函数的参数提供默认值。调用函数时，带有默认值的参数是可选的。如果不提供，则将默认值绑定到形式参数名。例如，如果应用程序通常计算一摩尔颗粒的压力，则可以将该值作为默认值提供：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pressure</span>(<span class="params">v, t, n=<span class="number">6.022e23</span></span>):</span><br><span class="line">    <span class="string">"""计算理想气体的压力（单位：帕斯卡）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    v -- 气体体积（单位：立方米）</span></span><br><span class="line"><span class="string">    t -- 绝对温度（单位：开尔文）</span></span><br><span class="line"><span class="string">    n -- 气体颗粒数（默认：一摩尔）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    k = <span class="number">1.38e-23</span>  <span class="comment"># 玻尔兹曼常数</span></span><br><span class="line">    <span class="keyword">return</span> n * k * t / v</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>=</code>符号在不同的上下文中有不同的含义。在<code>def</code>语句头中，<code>=</code>并不是赋值，而是指示调用函数时使用的默认值。相比之下，在函数体中对<code>k</code>的赋值语句将名称<code>k</code>绑定到玻尔兹曼常数的近似值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pressure(<span class="number">1</span>, <span class="number">273.15</span>)  <span class="comment"># 输出：2269.974834</span></span><br><span class="line">pressure(<span class="number">1</span>, <span class="number">273.15</span>, <span class="number">3</span> * <span class="number">6.022e23</span>)  <span class="comment"># 输出：6809.924502</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>pressure</code>函数被定义为接受三个参数，但在第一个调用表达式中只提供了两个。在这种情况下，<code>n</code>的值取自<code>def</code>语句中的默认值。如果提供了第三个参数，则忽略默认值。</p>
<p>作为指导原则，大多数在函数体中使用的数据值应表示为命名参数的默认值，以便于检查并可以由函数调用者更改。某些不会改变的值（例如基本常量<code>k</code>）可以在函数体内或全局框架中绑定。</p>
<p>当然可以，下面是更详细的学习笔记，包括一些适当的示例。</p>
<hr>
<h3 id="1-5-控制语句">1.5 控制语句</h3>
<p>控制语句赋予程序根据逻辑比较的结果执行不同操作的能力，从而控制程序的执行流。</p>
<h4 id="1-5-1-语句">1.5.1 语句</h4>
<ul>
<li>
<p><strong>定义</strong>：语句是解释器执行的命令，而不是计算值。执行语句会改变解释器的状态。</p>
</li>
<li>
<p><strong>类型</strong>：</p>
<ul>
<li>
<p><strong>赋值语句</strong>：将值绑定到变量。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>函数定义（def）</strong>：定义函数的过程。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>返回语句（return）</strong>：在函数中返回值。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>执行与表达式</strong>：</p>
<ul>
<li>
<p>表达式可以被执行为语句，但它们的值会被丢弃。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(square(<span class="number">4</span>))  <span class="comment"># 输出：16，但没有存储返回值</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-2-复合语句">1.5.2 复合语句</h4>
<ul>
<li>
<p><strong>定义</strong>：复合语句由多个简单语句组成，通常包括以冒号结尾的头部和缩进的代码块。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="string">"""打印问候信息"""</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, "</span> + name + <span class="string">"!"</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>执行顺序</strong>：在复合语句中，执行是有序的，直到遇到控制语句（如返回或条件语句）为止。</p>
</li>
</ul>
<h4 id="1-5-3-定义函数-II：局部赋值">1.5.3 定义函数 II：局部赋值</h4>
<ul>
<li>
<p><strong>功能</strong>：局部赋值允许在函数内部定义变量，这些变量只在该函数的局部环境中有效。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">percent_difference</span>(<span class="params">x, y</span>):</span><br><span class="line">    difference = <span class="built_in">abs</span>(x - y)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span> * difference / x</span><br><span class="line"></span><br><span class="line">result = percent_difference(<span class="number">40</span>, <span class="number">50</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：25.0</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这里，<code>difference</code>是局部变量，不会影响全局命名空间。</li>
</ul>
</li>
<li>
<p><strong>复杂表达式</strong>：使用局部赋值可以使复杂的计算更易于理解。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">length, width</span>):</span><br><span class="line">    area = length * width</span><br><span class="line">    <span class="keyword">return</span> area</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="1-5-4-条件语句">1.5.4 条件语句</h4>
<ul>
<li>
<p><strong>定义</strong>：条件语句使用<code>if</code>、<code>elif</code>和<code>else</code>结构来选择执行不同的代码块。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="string">"""计算绝对值"""</span></span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">elif</span> x == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(absolute_value(-<span class="number">2</span>))  <span class="comment"># 输出：2</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>布尔上下文</strong>：条件表达式在布尔上下文中计算，返回<code>True</code>或<code>False</code>。</p>
</li>
<li>
<p><strong>布尔值和操作符</strong>：</p>
<ul>
<li>
<p><strong>布尔值</strong>：<code>True</code>和<code>False</code>是Python中的布尔值。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">4</span> &lt; <span class="number">2</span>)  <span class="comment"># 输出：False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> &gt;= <span class="number">5</span>)  <span class="comment"># 输出：True</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>布尔操作符</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>)  <span class="comment"># 输出：False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>)   <span class="comment"># 输出：True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">False</span>)       <span class="comment"># 输出：True</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="1-5-5-迭代">1.5.5 迭代</h4>
<ul>
<li>
<p><strong>定义</strong>：控制语句也用于表示重复操作，允许在满足条件时重复执行相同的语句。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""计算第n个斐波那契数"""</span></span><br><span class="line">    pred, curr = <span class="number">0</span>, <span class="number">1</span>  <span class="comment"># 第1和第2个斐波那契数</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):  <span class="comment"># 从第3个开始</span></span><br><span class="line">        pred, curr = curr, pred + curr</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fib(<span class="number">8</span>))  <span class="comment"># 输出：21</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>while循环</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_down</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        n -= <span class="number">1</span>  <span class="comment"># 减少n的值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Blast off!"</span>)</span><br><span class="line"></span><br><span class="line">count_down(<span class="number">5</span>)  <span class="comment"># 输出：5 4 3 2 1 Blast off!</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>注意</strong>：确保每次迭代都能改变某些绑定，避免出现无限循环。</p>
</li>
</ul>
<h4 id="1-5-6-测试">1.5.6 测试</h4>
<ul>
<li>
<p><strong>定义</strong>：测试是验证函数行为是否符合预期的过程，通常通过断言语句进行验证。</p>
</li>
<li>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_fib</span>():</span><br><span class="line">    <span class="keyword">assert</span> fib(<span class="number">2</span>) == <span class="number">1</span>, <span class="string">'The 2nd Fibonacci number should be 1'</span></span><br><span class="line">    <span class="keyword">assert</span> fib(<span class="number">3</span>) == <span class="number">2</span>, <span class="string">'The 3rd Fibonacci number should be 2'</span></span><br><span class="line">    <span class="keyword">assert</span> fib(<span class="number">8</span>) == <span class="number">21</span>, <span class="string">'The 8th Fibonacci number should be 21'</span></span><br><span class="line"></span><br><span class="line">test_fib()  <span class="comment"># 如果所有断言通过，什么也不输出</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>文档测试（doctest）</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""返回前n个自然数的和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string">    55</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string">    5050</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>这段代码可以直接在文档字符串中进行测试，提供了简洁的测试方式。</li>
</ul>
</li>
</ul>
<h4 id="实用建议">实用建议</h4>
<ul>
<li><strong>缩进规范</strong>：确保所有代码块的缩进一致，以避免IndentationError。</li>
<li><strong>测试习惯</strong>：在实现新功能后立即编写和运行测试，以确保其行为符合预期。良好的测试习惯有助于快速发现和修复错误。</li>
</ul>
<p>通过以上内容，我们可以更清晰地理解控制语句如何在程序中起到核心作用，从而使编程更具表达力和可维护性。</p>
<hr>
<p>这里补充介绍一下文档测试：</p>
<blockquote>
<p>文档测试（doctest）是一种在 Python 中用于测试代码的技术。它的主要思想是将代码的使用示例写入文档字符串（docstring）中，然后 <code>doctest</code> 模块会自动执行这些示例并检查它们的输出是否与期望的结果一致。这样，你不仅可以提供代码的使用说明，还可以确保代码的行为符合预期。</p>
<h3 id="代码解释">代码解释</h3>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line"> <span class="string">"""返回前n个自然数的和。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> &gt;&gt;&gt; sum_naturals(10)</span></span><br><span class="line"><span class="string"> 55</span></span><br><span class="line"><span class="string"> &gt;&gt;&gt; sum_naturals(100)</span></span><br><span class="line"><span class="string"> 5050</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"> total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"> <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">     total, k = total + k, k + <span class="number">1</span></span><br><span class="line"> <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<h4 id="函数-sum-naturals-n">函数 <code>sum_naturals(n)</code></h4>
<p>这个函数用于计算前 <code>n</code> 个自然数的和。</p>
<ol>
<li>
<p><strong>参数：</strong></p>
<ul>
<li><code>n</code>：要计算的前 <code>n</code> 个自然数。</li>
</ul>
</li>
<li>
<p><strong>实现逻辑：</strong></p>
<ul>
<li><code>total, k = 0, 1</code>：初始化两个变量，<code>total</code> 用于存储总和，<code>k</code> 用于从 1 开始计数。</li>
<li><code>while k &lt;= n:</code>：循环从 <code>k = 1</code> 开始，逐步将 <code>k</code> 累加到 <code>total</code>，并每次将 <code>k</code> 增加 1，直到 <code>k &gt; n</code> 为止。</li>
<li><code>return total</code>：返回最终累加得到的总和。</li>
</ul>
</li>
<li>
<p><strong>文档字符串（docstring）：</strong></p>
<ul>
<li>
<p>文档字符串中包含了两个使用示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">10</span>)</span><br><span class="line"><span class="number">55</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum_naturals(<span class="number">100</span>)</span><br><span class="line"><span class="number">5050</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><code>&gt;&gt;&gt;</code> 表示 Python 交互式解释器中的命令，<code>doctest</code> 将执行这些命令并验证它们的输出是否与文档中给出的结果一致。</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line">    doctest.testmod()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="主程序部分">主程序部分</h4>
<p>这部分代码会在脚本作为主程序运行时执行：</p>
<ul>
<li><code>import doctest</code>：导入 <code>doctest</code> 模块。</li>
<li><code>doctest.testmod()</code>：运行当前模块中的文档测试。它会检查所有函数的 docstring 中的测试用例，自动执行它们，并验证输出是否与预期结果匹配。</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li><strong>文档测试的优势</strong>：它将代码示例嵌入文档中，可以直接运行这些示例进行测试，非常适合用于快速验证代码的正确性，尤其在编写教程或提供使用说明时。</li>
<li><strong>这段代码的作用</strong>：计算前 <code>n</code> 个自然数的和，并使用 <code>doctest</code> 来验证 <code>sum_naturals</code> 函数是否正确通过了文档中提供的测试用例。</li>
</ul>
</blockquote>
<hr>
<p>下面是关于<strong>高阶函数</strong>的学习笔记，包含示例和要点，以帮助理解这一概念。</p>
<hr>
<h3 id="1-6-高阶函数">1.6 高阶函数</h3>
<p>在计算机科学中，高阶函数是指接受其他函数作为参数或者返回一个函数的函数。高阶函数可以帮助我们抽象出常见的编程模式，从而提高代码的可读性和可复用性。</p>
<h4 id="1-6-1-函数作为参数">1.6.1 函数作为参数</h4>
<p>高阶函数允许我们将一个函数作为参数传递给另一个函数，从而抽象出通用的计算模式。</p>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><strong>求自然数的和</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum_naturals(<span class="number">100</span>))  <span class="comment"># 输出：5050</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>求立方数的和</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + k*k*k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum_cubes(<span class="number">100</span>))  <span class="comment"># 输出：25502500</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>使用通用的求和函数</strong>：<br>
我们可以定义一个通用的<code>summation</code>函数，并将计算每个项的函数作为参数传递：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">summation</span>(<span class="params">n, term</span>):</span><br><span class="line">    total, k = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total + term(k), k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cube</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x*x*x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_cubes</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, cube)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum_cubes(<span class="number">3</span>))  <span class="comment"># 输出：36</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>求自然数的和</strong>：<br>
我们可以使用<code>identity</code>函数来求自然数的和：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">identity</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sum_naturals</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, identity)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sum_naturals(<span class="number">10</span>))  <span class="comment"># 输出：55</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>直接调用<code>sumation</code>函数</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(summation(<span class="number">10</span>, square))  <span class="comment"># 输出：385</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>使用<code>summation</code>计算π</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pi_term</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span> / ((<span class="number">4</span>*x-<span class="number">3</span>) * (<span class="number">4</span>*x-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pi_sum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> summation(n, pi_term)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pi_sum(<span class="number">1e6</span>))  <span class="comment"># 输出：接近 π 的值</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h4 id="1-6-2-函数作为通用方法">1.6.2 函数作为通用方法</h4>
<p>高阶函数不仅可以简化特定计算，还可以创建通用的计算方法。</p>
<p><strong>示例</strong>：</p>
<ol>
<li>
<p><strong>改进算法</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, close, guess=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> close(guess):</span><br><span class="line">        guess = update(guess)</span><br><span class="line">    <span class="keyword">return</span> guess</span><br></pre></td></tr></tbody></table></figure>
<p>这个<code>improve</code>函数是一个通用的重复改进方法。</p>
</li>
<li>
<p><strong>计算黄金比例</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">golden_update</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/guess + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_close_to_successor</span>(<span class="params">guess</span>):</span><br><span class="line">    <span class="keyword">return</span> approx_eq(guess * guess, guess + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">approx_eq</span>(<span class="params">x, y, tolerance=<span class="number">1e-15</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x - y) &lt; tolerance</span><br><span class="line"></span><br><span class="line">phi = improve(golden_update, square_close_to_successor)</span><br><span class="line"><span class="built_in">print</span>(phi)  <span class="comment"># 输出接近黄金比例</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>测试<code>improve</code>函数的正确性</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">phi_exact = <span class="number">1</span>/<span class="number">2</span> + sqrt(<span class="number">5</span>)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">improve_test</span>():</span><br><span class="line">    approx_phi = improve(golden_update, square_close_to_successor)</span><br><span class="line">    <span class="keyword">assert</span> approx_eq(phi_exact, approx_phi), <span class="string">'phi differs from its approximation'</span></span><br><span class="line"></span><br><span class="line">improve_test()  <span class="comment"># 如果通过测试，则没有输出</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h4 id="总结-2">总结</h4>
<ul>
<li><strong>抽象能力</strong>：高阶函数提供了一种强大的抽象机制，使得我们可以通过函数来表达通用的计算模式，而不仅仅是特定的计算。</li>
<li><strong>代码复用</strong>：通过将函数作为参数传递，我们可以编写更加通用和可复用的代码。</li>
<li><strong>简化复杂性</strong>：高阶函数可以帮助我们简化复杂的逻辑，使代码更易于理解和维护。</li>
</ul>
<p>高阶函数在实际编程中具有重要意义，能显著提高程序的表达能力和灵活性。</p>
<h4 id="1-6-3-嵌套函数定义">1.6.3 嵌套函数定义</h4>
<p>嵌套函数定义使得在函数内部定义其他函数成为可能，这有助于简化全局命名空间并避免函数签名的限制。</p>
<p><strong>示例：计算平方根</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">average</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> (x + y) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqrt</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> average(x, a / x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sqrt_close</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(x * x, a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> improve(sqrt_update, sqrt_close)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>sqrt_update</code>和<code>sqrt_close</code>函数仅在<code>sqrt</code>函数内部可用，利用了词法作用域（lexical scoping）。</li>
</ul>
<h5 id="词法作用域">词法作用域</h5>
<ul>
<li>嵌套函数能够访问其定义环境中的变量，而不是调用环境中的变量。</li>
<li>这意味着在调用内嵌函数时，可以访问包含它的函数的参数。</li>
</ul>
<h4 id="1-6-4-函数作为返回值">1.6.4 函数作为返回值</h4>
<p>通过创建返回函数的函数，可以实现更强大的功能，例如函数组合。</p>
<p><strong>示例：函数组合</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> f(g(x))</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">successor</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">square_successor = compose1(square, successor)</span><br><span class="line">result = square_successor(<span class="number">12</span>)  <span class="comment"># 返回169</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>compose1</code>返回一个新的函数<code>h</code>，该函数执行<code>f(g(x))</code>。</li>
</ul>
<h4 id="1-6-5-牛顿法（Newton’s-Method）">1.6.5 牛顿法（Newton’s Method）</h4>
<p>牛顿法是一种用于寻找函数零点的迭代改进算法，适用于可微分函数。</p>
<p><strong>示例：实现牛顿法</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">newton_update</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x - f(x) / df(x)</span><br><span class="line">    <span class="keyword">return</span> update</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, df</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">near_zero</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> approx_eq(f(x), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> improve(newton_update(f, df), near_zero)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>通过使用牛顿更新方法，可以计算平方根和任意次数的根。</li>
</ul>
<p><strong>示例：平方根</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_root_newton</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> x * x - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * x</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br><span class="line"></span><br><span class="line">result = square_root_newton(<span class="number">64</span>)  <span class="comment"># 返回8.0</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="一般化至任意次数的根">一般化至任意次数的根</h5>
<p>通过定义相应的函数和导数，可以计算任意次数的根。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nth_root_of_a</span>(<span class="params">n, a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> power(x, n) - a</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">df</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">return</span> n * power(x, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> find_zero(f, df)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>示例调用：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">nth_root_of_a(<span class="number">2</span>, <span class="number">64</span>)  <span class="comment"># 返回8.0</span></span><br><span class="line">nth_root_of_a(<span class="number">3</span>, <span class="number">64</span>)  <span class="comment"># 返回4.0</span></span><br><span class="line">nth_root_of_a(<span class="number">6</span>, <span class="number">64</span>)  <span class="comment"># 返回2.0</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="总结-3">总结</h4>
<ul>
<li>嵌套函数和函数作为返回值极大增强了编程语言的表达能力。</li>
<li>词法作用域允许内嵌函数访问其定义环境中的变量。</li>
<li>牛顿法提供了一种通用的迭代方法，用于求解可微分函数的零点。尽管牛顿法并不总是收敛，但它在计算机科学中的应用非常广泛。</li>
</ul>
<h4 id="1-6-6-柯里化-Currying">1.6.6 柯里化 (Currying)</h4>
<p>柯里化是将一个多参数的函数转换为一系列单参数函数的过程。给定一个函数 <code>f(x, y)</code>，我们可以定义一个高阶函数 <code>g</code>，使得 <code>g(x)(y)</code> 等价于 <code>f(x, y)</code>。</p>
<p><strong>示例：定义幂函数的柯里化版本</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curried_pow</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(x, y)</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line"></span><br><span class="line">curried_pow(<span class="number">2</span>)(<span class="number">3</span>)  <span class="comment"># 输出 8</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 Python 中，柯里化可以用于需要单参数函数的场景，如 <code>map</code> 模式。可以通过 <code>map_to_range</code> 函数结合 <code>curried_pow</code> 来计算二的前十个幂：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_to_range</span>(<span class="params">start, end, f</span>):</span><br><span class="line">    <span class="keyword">while</span> start &lt; end:</span><br><span class="line">        <span class="built_in">print</span>(f(start))</span><br><span class="line">        start = start + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">map_to_range(<span class="number">0</span>, <span class="number">10</span>, curried_pow(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># 输出：1, 2, 4, 8, 16, 32, 64, 128, 256, 512</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>自动化柯里化与反柯里化</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">curry2</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">g</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">h</span>(<span class="params">y</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x, y)</span><br><span class="line">        <span class="keyword">return</span> h</span><br><span class="line">    <span class="keyword">return</span> g</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uncurry2</span>(<span class="params">g</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> g(x)(y)</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">pow_curried = curry2(<span class="built_in">pow</span>)</span><br><span class="line">pow_curried(<span class="number">2</span>)(<span class="number">5</span>)  <span class="comment"># 输出 32</span></span><br><span class="line">uncurry2(pow_curried)(<span class="number">2</span>, <span class="number">5</span>)  <span class="comment"># 输出 32</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-6-7-Lambda-表达式">1.6.7 Lambda 表达式</h4>
<p>Lambda 表达式用于创建匿名函数，具有单一返回表达式。其语法如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> 参数: 表达式</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例：使用 lambda 表达式定义复合函数</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">compose1</span>(<span class="params">f, g</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: f(g(x))</span><br><span class="line"></span><br><span class="line">f = compose1(<span class="keyword">lambda</span> x: x * x, <span class="keyword">lambda</span> y: y + <span class="number">1</span>)</span><br><span class="line">result = f(<span class="number">12</span>)  <span class="comment"># 输出 169</span></span><br></pre></td></tr></tbody></table></figure>
<p>尽管 lambda 表达式简洁，但复合表达式可能难以阅读，因此在复杂情况下推荐使用 <code>def</code> 语句。</p>
<h4 id="1-6-8-抽象与一等函数">1.6.8 抽象与一等函数</h4>
<p>用户定义函数是重要的抽象机制，使我们能够以明确的方式表达通用计算方法。一等函数具有以下特性：</p>
<ul>
<li>可以绑定到名字</li>
<li>可以作为参数传递给函数</li>
<li>可以作为函数的返回值</li>
<li>可以包含在数据结构中</li>
</ul>
<p>Python 中的函数具备完全的一等地位，显著提升了表达能力。</p>
<h4 id="1-6-9-函数装饰器-Function-Decorators">1.6.9 函数装饰器 (Function Decorators)</h4>
<p>装饰器是 Python 中用于高阶函数的一种特殊语法，可以在定义函数时应用。常见的例子是跟踪函数调用的装饰器：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trace</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapped</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'-&gt; '</span>, fn, <span class="string">'('</span>, x, <span class="string">')'</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(x)</span><br><span class="line">    <span class="keyword">return</span> wrapped</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line"></span><br><span class="line">triple(<span class="number">12</span>)  <span class="comment"># 输出: -&gt; &lt;function triple at ...&gt; ( 12 ), 36</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用装饰器的语法相当于：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">triple</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * x</span><br><span class="line">triple = trace(triple)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="总结-4">总结</h4>
<p>通过柯里化、lambda 表达式、函数的一等地位以及装饰器，Python 允许更灵活和强大的函数式编程。这些概念使得程序员能够构建更高效和抽象的代码结构。</p>
<hr>
<h3 id="1-7-递归函数的定义">1. 7 递归函数的定义</h3>
<p>递归函数是指函数的主体调用自身，无论是直接还是间接。递归函数在 Python 中没有特殊的语法，但理解和创建递归函数需要一定的努力。</p>
<h4 id="1-7-0-示例：求自然数的数字和">1.7.0 示例：求自然数的数字和</h4>
<ul>
<li>通过 % 和 // 操作符将一个数字分解为其最后一位和其余部分。算法步骤为：求数字 n 的最后一位 n % 10，加上去掉最后一位后的数字的数字和 sum_digits(n // 10)。</li>
<li>特殊情况：如果 n 只有一位数，则返回 n 本身。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_digits</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""返回正整数 n 的数字和。"""</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        all_but_last, last = n // <span class="number">10</span>, n % <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> sum_digits(all_but_last) + last</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-1-递归函数的结构">1.7.1 递归函数的结构</h4>
<ul>
<li><strong>基本情况</strong>：函数体开始部分的条件语句，定义了函数对最简单输入的行为。</li>
<li><strong>递归调用</strong>：后续的递归调用逐步简化原问题。</li>
</ul>
<h5 id="例子：计算阶乘">例子：计算阶乘</h5>
<ul>
<li>迭代实现：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact_iter</span>(<span class="params">n</span>):</span><br><span class="line">    total, k = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> k &lt;= n:</span><br><span class="line">        total, k = total * k, k + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>递归实现：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-2-互递归">1.7.2 互递归</h4>
<ul>
<li>两个相互调用的函数称为互递归。例如，定义偶数和奇数的函数。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_even</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> is_odd(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_odd</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> is_even(n - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-3-打印递归函数中的信息">1.7.3 打印递归函数中的信息</h4>
<ul>
<li>可以使用打印语句可视化递归函数的计算过程。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cascade</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">"""打印 n 的所有前缀，从大到小再从小到大。"""</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">10</span>:</span><br><span class="line">        cascade(n // <span class="number">10</span>)</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-4-树形递归">1.7.4 树形递归</h4>
<ul>
<li>树形递归指一个函数多次调用自身的情况，例如计算斐波那契数列。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n - <span class="number">2</span>) + fib(n - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="1-7-5-示例：整数的划分">1.7.5 示例：整数的划分</h4>
<ul>
<li>使用部分的划分问题的树形递归函数示例。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="string">"""计算使用部分不超过 m 的 n 的不同划分方式的数量。"""</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> count_partitions(n - m, m) + count_partitions(n, m - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="结论">结论</h4>
<ul>
<li>递归函数提供了一种通过简化问题逐步构造解决方案的方法。通过对简单情况的处理和递归调用的组合，能够以较少的代码实现复杂的计算任务。然而，理解递归函数的调用过程和返回值的构建需要一定的实践和思考。</li>
</ul>
<hr>
<h2 id="第二章：通过数据构建抽象">第二章：通过数据构建抽象</h2>
<h3 id="2-1-引言">2.1  引言</h3>
<p>在第一章中，我们重点讨论了计算过程以及函数在程序设计中的作用。我们学习了如何使用原始数据（如数字）和原始操作（如算术运算），如何通过组合和控制构建复合函数，以及如何通过为过程命名来创建函数抽象。我们还了解到，高阶函数增强了语言的能力，使我们能够操作并推理一般的计算方法。这些是编程的本质。</p>
<p>本章将重点关注数据。我们将在这里探讨的技术将使我们能够表示和操作来自不同领域的信息。由于互联网的快速发展，海量的结构化信息可供我们在线获取，计算可以应用于各种不同的问题。有效使用内置和用户定义的数据类型是数据处理应用程序的基础。</p>
<h4 id="2-1-1-原生数据类型">2.1.1  原生数据类型</h4>
<p>在 Python 中，每个值都有一个类来决定其数据类型。具有相同类的值共享相同行为。例如，整数 1 和 2 都是 <code>int</code> 类的实例，它们可以执行相同的操作，如取反或加另一个整数。Python 中的 <code>type</code> 函数可以用于查看任意值的类型。</p>
<p>Python 中常用的一些原生数据类型包括整数（<code>int</code>）、浮点数（<code>float</code>）和复数（<code>complex</code>）。</p>
<ul>
<li><strong>整数（int）</strong> 可以精确表示，不存在大小限制。</li>
<li><strong>浮点数（float）</strong> 则是近似值，表示范围广，但会有精度损失，尤其是在执行多次浮点数运算时，可能会产生舍入误差。</li>
<li><strong>复数（complex）</strong> 用于表示具有实部和虚部的复数。</li>
</ul>
<p>浮点数的近似特性在进行等值比较时可能会引发问题，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">3</span> == <span class="number">0.333333333333333312345</span>  <span class="comment"># 注意浮点数近似</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>除此之外，Python 还包含其他非数值类型，如布尔值（<code>bool</code>），用来表示 <code>True</code> 和 <code>False</code>。然而，大多数值的类型需要程序员自行定义，后续章节将介绍如何通过组合和抽象来创建有用的数据抽象。</p>
<p>总之，原生数据类型的数量有限，记住这些差异可以帮助编程。许多编程语言都遵循类似的标准，例如 IEEE 754 浮点数标准，使这些细节在不同语言中一致。</p>
<hr>
<h3 id="2-2-数据抽象">2.2 数据抽象</h3>
<p>当我们考虑想在程序中表示的广泛事物时，发现大多数事物具有复合结构。例如，地理位置由纬度和经度组成。我们希望编程语言能够将纬度和经度结合起来，形成一个复合数据值。使用复合数据可以提高程序的模块化，使计算过程中不必关心数据的具体表示方式。这种隔离数据表示与操作的设计方法称为<strong>数据抽象</strong>，它能使程序更容易设计、维护和修改。</p>
<p>数据抽象类似于<strong>函数抽象</strong>。函数抽象隐藏了函数的实现细节，而数据抽象则隔离了数据的使用与其表示细节。</p>
<p><strong>基本思路</strong>：</p>
<ul>
<li>程序操作抽象数据，尽量少假设数据的具体细节。</li>
<li>数据的具体表示作为程序独立部分进行定义。</li>
<li>抽象数据和具体表示通过少量函数连接。</li>
</ul>
<h4 id="2-2-1-例子：有理数">2.2.1 例子：有理数</h4>
<p>有理数是整数比值，如 <code>1/3</code> 或 <code>17/29</code>。直接计算这些数的比值会产生浮点数近似，导致精度丢失。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">3</span></span><br><span class="line"><span class="number">0.3333333333333333</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> / <span class="number">3</span> == <span class="number">0.333333333333333300000</span>  <span class="comment"># 近似值比较</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以通过将分子和分母组合，创建精确的有理数表示。</p>
<p>通过构造函数和选择器函数实现有理数的抽象：</p>
<ul>
<li><code>rational(n, d)</code> 构造有理数。</li>
<li><code>numer(x)</code> 获取有理数的分子。</li>
<li><code>denom(x)</code> 获取有理数的分母。</li>
</ul>
<p>使用这些函数，可以定义加法、乘法、打印和相等性测试操作，而无需关心有理数的具体表示：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_rationals</span>(<span class="params">x, y</span>):</span><br><span class="line">    nx, dx = numer(x), denom(x)</span><br><span class="line">    ny, dy = numer(y), denom(y)</span><br><span class="line">    <span class="keyword">return</span> rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="built_in">print</span>(numer(x), <span class="string">'/'</span>, denom(x))</span><br><span class="line"></span><br><span class="line">half = rational(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print_rational(half)  <span class="comment"># 输出：1 / 2</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-2-复合数据：对">2.2.2 复合数据：对</h4>
<p>Python 提供了<strong>列表</strong>作为一种复合结构，可以用于实现对（pair）。通过列表，我们可以将分子和分母组合为有理数。列表可以通过索引访问元素，或通过多重赋值解构：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pair = [<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line">x, y = pair</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：10</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出：20</span></span><br></pre></td></tr></tbody></table></figure>
<p>为了使有理数保持最简形式，可以在构造函数中使用最大公约数（GCD）简化分子和分母：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rational</span>(<span class="params">n, d</span>):</span><br><span class="line">    g = gcd(n, d)</span><br><span class="line">    <span class="keyword">return</span> (n // g, d // g)</span><br><span class="line"></span><br><span class="line">print_rational(add_rationals(rational(<span class="number">1</span>, <span class="number">3</span>), rational(<span class="number">1</span>, <span class="number">3</span>)))  <span class="comment"># 输出：2 / 3</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-3-抽象屏障">2.2.3 抽象屏障</h4>
<p><strong>抽象屏障</strong>的概念：</p>
<ul>
<li>数据抽象通过一组基本操作来屏蔽底层数据的具体表示。</li>
<li>在操作数据时，只能使用这些基本操作，不能直接访问数据的具体表示。</li>
<li>如果打破抽象屏障，程序的可维护性和灵活性会下降。</li>
</ul>
<p>例如，实现有理数平方时，应该使用 <code>mul_rational</code> 函数，而不是直接操作分子和分母：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_rational</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> mul_rational(x, x)  <span class="comment"># 正确实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square_rational_violating_once</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> rational(numer(x) * numer(x), denom(x) * denom(x))  <span class="comment"># 违反一次抽象屏障</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-2-4-数据的性质">2.2.4 数据的性质</h4>
<p>抽象屏障不仅适用于有理数，也适用于我们之前使用的对。实际上，列表并不是创建对的唯一方法。我们可以通过高阶函数创建一个同样能够表示对的实现，满足数据抽象的要求即可：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pair</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">"""返回表示对的函数。"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">index</span>):</span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> get</span><br><span class="line"></span><br><span class="line">p = pair(<span class="number">20</span>, <span class="number">14</span>)</span><br><span class="line"><span class="built_in">print</span>(select(p, <span class="number">0</span>))  <span class="comment"># 输出：20</span></span><br><span class="line"><span class="built_in">print</span>(select(p, <span class="number">1</span>))  <span class="comment"># 输出：14</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过数据抽象，可以轻松切换数据的表示方式，确保程序的灵活性和正确性。</p>
<hr>
<h3 id="2-3-序列">2.3 序列</h3>
<p>序列是有序的值集合，是计算机科学中的一种重要抽象。序列不是特定的内置类型或抽象数据表示，而是一组共享特定行为的不同数据类型。所有序列都有以下共同特性：</p>
<ul>
<li><strong>长度</strong>：序列具有有限长度。空序列的长度为 0。</li>
<li><strong>元素选择</strong>：序列中每个元素都有对应的非负整数索引，索引从 0 开始。</li>
</ul>
<p>在 Python 中，多个内置数据类型都是序列，最重要的是列表。</p>
<h4 id="2-3-1-列表">2.3.1 列表</h4>
<p>列表是可以具有任意长度的序列。列表有丰富的内置行为以及特定的语法来表达这些行为。我们已经见过列表字面量（literal），它评估为列表实例，还有元素选择表达式，用于获取列表中的值。内置的 <code>len</code> 函数返回序列的长度。以下是一个示例，<code>digits</code> 是一个包含四个元素的列表，索引 3 的元素是 8。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">len</span>(digits)  <span class="comment"># 输出：4</span></span><br><span class="line">digits[<span class="number">3</span>]    <span class="comment"># 输出：8</span></span><br></pre></td></tr></tbody></table></figure>
<p>此外，列表可以相加和乘以整数。对于序列来说，加法和乘法并不是对元素的加法或乘法，而是组合和重复序列本身。<code>+</code> 运算符（和 <code>add</code> 函数）返回两个序列的连接，<code>*</code> 运算符（和 <code>mul</code> 函数）将返回一个包含原列表 k 次重复的列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">7</span>] + digits * <span class="number">2</span>  <span class="comment"># 输出：[2, 7, 1, 8, 2, 8, 1, 8, 2, 8]</span></span><br></pre></td></tr></tbody></table></figure>
<p>任何值都可以包含在列表中，包括另一个列表。可以多次应用元素选择以选择嵌套在列表中的深层元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pairs = [[<span class="number">10</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">pairs[<span class="number">1</span>]     <span class="comment"># 输出：[30, 40]</span></span><br><span class="line">pairs[<span class="number">1</span>][<span class="number">0</span>]  <span class="comment"># 输出：30</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-3-2-序列迭代">2.3.2 序列迭代</h4>
<p>在许多情况下，我们希望遍历序列中的元素，并对每个元素执行某些计算。这种模式如此常见，以至于 Python 提供了额外的控制语句来处理顺序数据：<code>for</code> 语句。</p>
<p>考虑计算一个值在序列中出现多少次的问题。我们可以使用 <code>while</code> 循环实现此计数的函数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s, value</span>):</span><br><span class="line">    <span class="string">"""计算值在序列 s 中出现的次数。"""</span></span><br><span class="line">    total, index = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> s[index] == value:</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">count(digits, <span class="number">8</span>)  <span class="comment"># 输出：2</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>for</code> 语句可以简化这个函数体，直接遍历元素值，而不需要引入索引名称。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">s, value</span>):</span><br><span class="line">    <span class="string">"""计算值在序列 s 中出现的次数。"""</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> elem == value:</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">count(digits, <span class="number">8</span>)  <span class="comment"># 输出：2</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>for</code> 语句的结构为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &lt;name&gt; <span class="keyword">in</span> &lt;expression&gt;:</span><br><span class="line">    &lt;suite&gt;</span><br></pre></td></tr></tbody></table></figure>
<p><code>for</code> 语句的执行过程如下：</p>
<ol>
<li>评估头部 <code>&lt;expression&gt;</code>，该表达式必须返回一个可迭代值。</li>
<li>对于该可迭代值中的每个元素值，按顺序：
<ul>
<li>将 <code>&lt;name&gt;</code> 绑定到当前值。</li>
<li>执行 <code>&lt;suite&gt;</code>。</li>
</ul>
</li>
</ol>
<p>这个执行过程提到了可迭代值。列表是一种序列类型，而序列是可迭代值。它们的元素按顺序处理。Python 还包括其他可迭代类型，但我们暂时将重点放在序列上；关于“可迭代”的一般定义将在第四章的迭代器部分中讨论。</p>
<p>重要的是，执行完 <code>for</code> 语句后，<code>&lt;name&gt;</code> 将绑定到序列的最后一个元素，这意味着 <code>for</code> 循环又为更新环境引入了一种新方式。</p>
<h5 id="序列解包">序列解包</h5>
<p>程序中常见的一种模式是拥有元素序列，而这些元素自身也是固定长度的序列。<code>for</code> 语句的头部可以包含多个名称，以“解包”每个元素序列。例如，我们可能有一个包含二元列表的列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">pairs = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">4</span>]]</span><br></pre></td></tr></tbody></table></figure>
<p>我们希望找出这些对中有多少对具有相同的第一个和第二个元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">same_count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> pairs:</span><br><span class="line">    <span class="keyword">if</span> x == y:</span><br><span class="line">        same_count += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p>此时，<code>same_count</code> 的值为 2。</p>
<p>这种将多个名称绑定到多个值的模式称为序列解包；它与赋值语句中将多个名称绑定到多个值的模式相同。</p>
<h5 id="范围">范围</h5>
<p>范围是 Python 中的另一种内置序列类型，表示一系列整数。范围是通过 <code>range</code> 创建的，它接受两个整数参数：第一个数字和想要的范围的最后一个数字的下一个数字。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># 包含 1，但不包含 10</span></span><br></pre></td></tr></tbody></table></figure>
<p>调用 <code>list</code> 构造函数来评估范围将返回一个与范围相同元素的列表，以便可以轻松检查这些元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>, <span class="number">8</span>))  <span class="comment"># 输出：[5, 6, 7]</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果只给出一个参数，它被解释为从 0 开始到最后值的下一个值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>))  <span class="comment"># 输出：[0, 1, 2, 3]</span></span><br></pre></td></tr></tbody></table></figure>
<p>范围通常作为 <code>for</code> 头部中的表达式出现，以指定套件应执行的次数：通常约定如果名称在套件中未使用，则在 <code>for</code> 头部使用单个下划线字符：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Go Bears!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Go Bears!</span></span><br><span class="line"><span class="comment"># Go Bears!</span></span><br><span class="line"><span class="comment"># Go Bears!</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个下划线在解释器看来只是环境中的另一个名称，但在程序员中有一个约定的含义，表示该名称在未来的表达式中不会出现。</p>
<h4 id="2-3-3-序列处理">2.3.3 序列处理</h4>
<p>序列是复合数据的一种常见形式，整个程序通常围绕这一抽象进行组织。可以通过模块化组件混合处理具有序列作为输入和输出的功能。常见的序列处理操作包括：</p>
<p><strong>列表推导式</strong>（List Comprehensions）是用于执行序列处理操作的一种简洁表达方式。例如，增加每个奇数的 1：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">odds = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="built_in">print</span>([x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds])  <span class="comment"># 输出: [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以选择满足某些条件的值的子集，例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([x <span class="keyword">for</span> x <span class="keyword">in</span> odds <span class="keyword">if</span> <span class="number">25</span> % x == <span class="number">0</span>])  <span class="comment"># 输出: [1, 5]</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>聚合</strong>（Aggregation）是将序列中的所有值合并为单个值的操作。例如，计算一个数的所有因子的和：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divisors</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>] + [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n) <span class="keyword">if</span> n % x == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divisors(<span class="number">12</span>))  <span class="comment"># 输出: [1, 2, 3, 4, 6]</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用列表推导式可以计算 1 到 1000 的所有完美数：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>([n <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">1000</span>) <span class="keyword">if</span> <span class="built_in">sum</span>(divisors(n)) == n])  <span class="comment"># 输出: [6, 28, 496]</span></span><br></pre></td></tr></tbody></table></figure>
<p>还可以使用更复杂的函数处理，例如计算给定面积的矩形的最小周长：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">width</span>(<span class="params">area, height</span>):</span><br><span class="line">    <span class="keyword">assert</span> area % height == <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> area // height</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perimeter</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * width + <span class="number">2</span> * height</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minimum_perimeter</span>(<span class="params">area</span>):</span><br><span class="line">    heights = divisors(area)</span><br><span class="line">    perimeters = [perimeter(width(area, h), h) <span class="keyword">for</span> h <span class="keyword">in</span> heights]</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(perimeters)</span><br><span class="line"></span><br><span class="line">area = <span class="number">80</span></span><br><span class="line"><span class="built_in">print</span>(minimum_perimeter(area))  <span class="comment"># 输出: 36</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>高阶函数</strong>。序列处理的常见模式可以通过高阶函数来表达，例如 <code>map</code> 和 <code>filter</code>。以下是一些示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all</span>(<span class="params">map_fn, s</span>):</span><br><span class="line">    <span class="keyword">return</span> [map_fn(x) <span class="keyword">for</span> x <span class="keyword">in</span> s]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if</span>(<span class="params">filter_fn, s</span>):</span><br><span class="line">    <span class="keyword">return</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> filter_fn(x)]</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>reduce</code> 函数可以聚合序列中的元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(mul, s)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(product([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))  <span class="comment"># 输出: 120</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 Python 程序中，通常直接使用列表推导式而不是高阶函数。</p>
<h4 id="2-3-4-序列抽象">2.3.4 序列抽象</h4>
<p>我们已经介绍了两种符合序列抽象的原生数据类型：列表和范围。Python 还包括满足序列抽象的两个其他行为：</p>
<ol>
<li><strong>成员资格</strong>：可以使用 <code>in</code> 和 <code>not in</code> 操作符来测试一个值是否在序列中。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> <span class="keyword">in</span> digits)          <span class="comment"># 输出: True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1828</span> <span class="keyword">not</span> <span class="keyword">in</span> digits)   <span class="comment"># 输出: True</span></span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li><strong>切片</strong>（Slicing）：序列可以包含更小的子序列。切片是原始序列的任何连续范围，使用两个整数表示。</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(digits[<span class="number">0</span>:<span class="number">2</span>])  <span class="comment"># 输出: [1, 8]</span></span><br><span class="line"><span class="built_in">print</span>(digits[<span class="number">1</span>:])   <span class="comment"># 输出: [8, 2, 8]</span></span><br></pre></td></tr></tbody></table></figure>
<p>序列的丰富抽象在计算中是非常普遍的，因此学习一些复杂的行为是合理的。在定义用户自定义抽象时，通常应该尽量保持简单。</p>
<h4 id="2-3-5-字符串">2.3.5 字符串</h4>
<p>字符串是计算机科学中非常基础的文本值类型，Python 程序本身就是以文本形式编写和存储的。Python 中的字符串数据类型由构造函数 <code>str</code> 表示。</p>
<p>这一部分将介绍字符串的基本行为，包括如何表示、表达和操作字符串。</p>
<h5 id="字符串字面量">字符串字面量</h5>
<p>字符串字面量可以用单引号或双引号包围，表示任意文本：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'I am string!'</span>)           <span class="comment"># 输出: I am string!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"I've got an apostrophe"</span>)  <span class="comment"># 输出: I've got an apostrophe</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'您好'</span>)                     <span class="comment"># 输出: 您好</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="字符串的特性">字符串的特性</h5>
<p>字符串满足序列的两个基本条件：具有长度和支持元素选择。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">city = <span class="string">'Berkeley'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(city))  <span class="comment"># 输出: 8</span></span><br><span class="line"><span class="built_in">print</span>(city[<span class="number">3</span>])    <span class="comment"># 输出: k</span></span><br></pre></td></tr></tbody></table></figure>
<p>字符串的元素本身是长度为 1 的字符串，表示单个字符。字符可以是字母、标点符号或其他符号。与许多其他编程语言不同，Python 没有单独的字符类型，任何文本都是字符串。</p>
<h5 id="字符串的组合">字符串的组合</h5>
<p>字符串可以通过加法和乘法进行组合：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'Berkeley'</span> + <span class="string">', CA'</span>)  <span class="comment"># 输出: Berkeley, CA</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Shabu '</span> * <span class="number">2</span>)         <span class="comment"># 输出: Shabu Shabu </span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="成员资格">成员资格</h5>
<p>字符串的行为与其他序列类型有所不同。字符串的成员资格操作符 <code>in</code> 适用于字符串，但它的行为与在序列上使用时完全不同。它匹配的是子字符串，而不是单个元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">'here'</span> <span class="keyword">in</span> <span class="string">"Where's Waldo?"</span>)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="多行字面量">多行字面量</h5>
<p>字符串不仅限于单行。三重引号可以定义跨越多行的字符串字面量。我们已经在文档字符串中广泛使用了三重引号。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"""The Zen of Python</span></span><br><span class="line"><span class="string">claims, Readability counts.</span></span><br><span class="line"><span class="string">Read more: import this."""</span>)</span><br><span class="line"><span class="comment"># 输出: The Zen of Python</span></span><br><span class="line"><span class="comment"># claims, "Readability counts."</span></span><br><span class="line"><span class="comment"># Read more: import this.</span></span><br></pre></td></tr></tbody></table></figure>
<p>在上述输出中，<code>\n</code> 被视为一个单一元素，表示新行。</p>
<h5 id="字符串强制转换">字符串强制转换</h5>
<p>可以通过调用 <code>str</code> 构造函数将任何对象转换为字符串，这对于构建描述性字符串非常有用：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(<span class="number">2</span>) + <span class="string">' is an element of '</span> + <span class="built_in">str</span>(digits))  <span class="comment"># 输出: 2 is an element of [1, 8, 2, 8]</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="深入阅读">深入阅读</h5>
<p>文本编码在计算机中是一个复杂的话题。本节中我们抽象掉了字符串的具体表示细节，但了解字符串在计算机中的编码方式对许多应用来说是至关重要的。关于字符编码和 Unicode 的描述可以参考《Dive Into Python 3》的字符串章节。</p>
<h4 id="2-3-6-树">2.3.6 树</h4>
<p>我们可以将列表作为其他列表的元素，这种组合能力是数据类型的<strong>闭包属性</strong>。闭包属性意味着，数据组合的结果仍然可以使用相同的方法继续组合。这一属性是组合方法强大之处的关键，因为它允许我们创建<strong>层次结构</strong>——由部分组成的结构，这些部分本身又由更小的部分组成，依此类推。</p>
<p>树是一个基本的数据抽象，能使我们以规则的方式构建和操作层次结构的值。树有一个<strong>根标签</strong>和一系列<strong>分支</strong>。每个分支也是一棵树。没有分支的树称为<strong>叶子</strong>。树中的每一棵子树称为这棵树的<strong>子树</strong>，而子树的根称为该树的一个<strong>节点</strong>。</p>
<h5 id="树的基本实现">树的基本实现</h5>
<p>树的构造函数是 <code>tree</code>，选择器是 <code>label</code> 和 <code>branches</code>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tree</span>(<span class="params">root_label, branches=[]</span>):</span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">        <span class="keyword">assert</span> is_tree(branch), <span class="string">'branches must be trees'</span></span><br><span class="line">    <span class="keyword">return</span> [root_label] + <span class="built_in">list</span>(branches)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">label</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">branches</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> tree[<span class="number">1</span>:]</span><br></pre></td></tr></tbody></table></figure>
<h5 id="树的验证和叶子的判断">树的验证和叶子的判断</h5>
<p><code>is_tree</code> 函数用于验证树的结构是否正确：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_tree</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(tree) != <span class="built_in">list</span> <span class="keyword">or</span> <span class="built_in">len</span>(tree) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> branch <span class="keyword">in</span> branches(tree):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_tree(branch):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>is_leaf</code> 函数用于判断一棵树是否为叶子：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> branches(tree)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="构建和操作树">构建和操作树</h5>
<p>我们可以通过嵌套表达式构建树：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">t = tree(<span class="number">3</span>, [tree(<span class="number">1</span>), tree(<span class="number">2</span>, [tree(<span class="number">1</span>), tree(<span class="number">1</span>)])])</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># 输出: [3, [1], [2, [1], [1]]]</span></span><br></pre></td></tr></tbody></table></figure>
<p>树递归函数可以用来构造树，例如，<strong>Fibonacci 树</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = fib_tree(n-<span class="number">2</span>), fib_tree(n-<span class="number">1</span>)</span><br><span class="line">        fib_n = label(left) + label(right)</span><br><span class="line">        <span class="keyword">return</span> tree(fib_n, [left, right])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fib_tree(<span class="number">5</span>))</span><br><span class="line"><span class="comment"># 输出: [5, [2, [1], [1, [0], [1]]], [3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]]</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="计算叶子的数量">计算叶子的数量</h5>
<p>树递归函数还可以用来处理树，例如 <code>count_leaves</code> 函数用于计算树的叶子数量：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_leaves</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        branch_counts = [count_leaves(b) <span class="keyword">for</span> b <span class="keyword">in</span> branches(tree)]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(branch_counts)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(count_leaves(fib_tree(<span class="number">5</span>)))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="分割树">分割树</h5>
<p>树还可以用来表示整数的<strong>分割</strong>。例如，<code>partition_tree</code> 函数构建分割树：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition_tree</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> tree(<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = partition_tree(n-m, m)</span><br><span class="line">        right = partition_tree(n, m-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> tree(m, [left, right])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(partition_tree(<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 输出: [2, [True], [1, [1, [True], [False]], [False]]]</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们还可以通过递归遍历分割树打印分割结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_parts</span>(<span class="params">tree, partition=[]</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">if</span> label(tree):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">' + '</span>.join(partition))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left, right = branches(tree)</span><br><span class="line">        m = <span class="built_in">str</span>(label(tree))</span><br><span class="line">        print_parts(left, partition + [m])</span><br><span class="line">        print_parts(right, partition)</span><br><span class="line"></span><br><span class="line">print_parts(partition_tree(<span class="number">6</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 4 + 2</span></span><br><span class="line"><span class="comment"># 4 + 1 + 1</span></span><br><span class="line"><span class="comment"># 3 + 3</span></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="二叉化树">二叉化树</h5>
<p><code>right_binarize</code> 函数将树二叉化，转换成右分支结构：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">right_binarize</span>(<span class="params">tree</span>):</span><br><span class="line">    <span class="keyword">if</span> is_leaf(tree):</span><br><span class="line">        <span class="keyword">return</span> tree</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tree) &gt; <span class="number">2</span>:</span><br><span class="line">        tree = [tree[<span class="number">0</span>], tree[<span class="number">1</span>:]]</span><br><span class="line">    <span class="keyword">return</span> [right_binarize(b) <span class="keyword">for</span> b <span class="keyword">in</span> tree]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(right_binarize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]))</span><br><span class="line"><span class="comment"># 输出: [1, [2, [3, [4, [5, [6, 7]]]]]]</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-3-7-链表">2.3.7 链表</h4>
<h5 id="链表简介">链表简介</h5>
<p>链表（Linked List）是一种序列结构，它由嵌套的成对元素表示。链表的每一个节点包含两个部分：一个是序列的第一个元素，另一个是指向剩余部分的链接。</p>
<p>例如，四个元素 <code>1, 2, 3, 4</code> 的链表表示为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">four = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="string">'empty'</span>]]]]</span><br></pre></td></tr></tbody></table></figure>
<p>这里，<code>'empty'</code> 表示链表的结束，<code>[1, [2, [3, [4, 'empty']]]]</code> 是一个递归结构。</p>
<h5 id="链表的构造与选择器">链表的构造与选择器</h5>
<p>我们可以定义一些函数来构造和操作链表：</p>
<ul>
<li>
<p><strong>构造器</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">link</span>(<span class="params">first, rest</span>):</span><br><span class="line">    <span class="string">"""从第一个元素和剩余部分构造一个链表"""</span></span><br><span class="line">    <span class="keyword">assert</span> is_link(rest), <span class="string">"rest 必须是一个链表"</span></span><br><span class="line">    <span class="keyword">return</span> [first, rest]</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>选择器</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">first</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""返回链表的第一个元素"""</span></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rest</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""返回链表的其余部分"""</span></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="链表的验证与基本操作">链表的验证与基本操作</h5>
<ul>
<li>
<p><strong>验证链表</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_link</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""验证是否为链表"""</span></span><br><span class="line">    <span class="keyword">return</span> s == <span class="string">'empty'</span> <span class="keyword">or</span> (<span class="built_in">len</span>(s) == <span class="number">2</span> <span class="keyword">and</span> is_link(s[<span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>长度计算</strong>：<br>
计算链表的长度可以使用迭代或递归：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">len_link</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""返回链表的长度（迭代版）"""</span></span><br><span class="line">    length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s != <span class="string">'empty'</span>:</span><br><span class="line">        s, length = rest(s), length + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> length</span><br></pre></td></tr></tbody></table></figure>
<p>递归版：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">len_link_recursive</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""返回链表的长度（递归版）"""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + len_link_recursive(rest(s))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>元素访问</strong>：<br>
可以根据索引访问链表中的元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getitem_link</span>(<span class="params">s, i</span>):</span><br><span class="line">    <span class="string">"""返回链表中索引为 i 的元素"""</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">        s, i = rest(s), i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> first(s)</span><br></pre></td></tr></tbody></table></figure>
<p>递归版：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getitem_link_recursive</span>(<span class="params">s, i</span>):</span><br><span class="line">    <span class="string">"""返回索引为 i 的元素（递归版）"""</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> first(s)</span><br><span class="line">    <span class="keyword">return</span> getitem_link_recursive(rest(s), i - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="递归操作">递归操作</h5>
<p>链表的递归结构使得递归操作十分方便。</p>
<ul>
<li>
<p><strong>扩展链表</strong>：<br>
我们可以将两个链表连接起来：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="string">"""将链表 s 和链表 t 连接"""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">return</span> link(first(s), extend_link(rest(s), t))</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>对链表中每个元素应用函数</strong>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">apply_to_all_link</span>(<span class="params">f, s</span>):</span><br><span class="line">    <span class="string">"""对链表 s 中的每个元素应用函数 f"""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> link(f(first(s)), apply_to_all_link(f, rest(s)))</span><br></pre></td></tr></tbody></table></figure>
<p>例如，对链表中每个元素求平方：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">apply_to_all_link(<span class="keyword">lambda</span> x: x*x, four)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>筛选链表中的元素</strong>：<br>
我们可以保留链表中满足特定条件的元素：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">keep_if_link</span>(<span class="params">f, s</span>):</span><br><span class="line">    <span class="string">"""返回一个只包含满足条件 f 的元素的链表"""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    kept = keep_if_link(f, rest(s))</span><br><span class="line">    <span class="keyword">if</span> f(first(s)):</span><br><span class="line">        <span class="keyword">return</span> link(first(s), kept)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> kept</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>拼接链表中的元素</strong>：<br>
使用指定的分隔符，将链表的元素转换为字符串并拼接：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s, separator</span>):</span><br><span class="line">    <span class="string">"""返回由 s 中的所有元素组成的字符串，元素间由 separator 分隔"""</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    <span class="keyword">elif</span> rest(s) == <span class="string">'empty'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(first(s))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(first(s)) + separator + join_link(rest(s), separator)</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="递归构造与组合">递归构造与组合</h5>
<p>链表特别适用于递归构造序列的场景。例如，可以用递归的方式构造所有整数划分的链表：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="string">"""返回一个包含所有划分的链表，每个划分由链表表示"""</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> link(<span class="string">'empty'</span>, <span class="string">'empty'</span>)</span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span> <span class="keyword">or</span> m == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'empty'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        using_m = partitions(n - m, m)</span><br><span class="line">        with_m = apply_to_all_link(<span class="keyword">lambda</span> s: link(m, s), using_m)</span><br><span class="line">        without_m = partitions(n, m - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> extend_link(with_m, without_m)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="输出划分">输出划分</h5>
<p>可以将划分的结果转换为可读格式：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">    lists = partitions(n, m)</span><br><span class="line">    strings = apply_to_all_link(<span class="keyword">lambda</span> s: join_link(s, <span class="string">" + "</span>), lists)</span><br><span class="line">    <span class="built_in">print</span>(join_link(strings, <span class="string">"\n"</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">print_partitions(<span class="number">6</span>, <span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">4 + 2</span><br><span class="line">4 + 1 + 1</span><br><span class="line">3 + 3</span><br><span class="line">3 + 2 + 1</span><br><span class="line">3 + 1 + 1 + 1</span><br><span class="line">2 + 2 + 2</span><br><span class="line">2 + 2 + 1 + 1</span><br><span class="line">2 + 1 + 1 + 1 + 1</span><br><span class="line">1 + 1 + 1 + 1 + 1 + 1</span><br></pre></td></tr></tbody></table></figure>
<h5 id="总结-5">总结</h5>
<p>链表是一种具有递归结构的序列类型，可以通过迭代或递归进行操作。它提供了构建复杂数据结构的基础，并且适合于增量地构造和处理序列。</p>
<hr>
<h3 id="2-4-可变数据">2.4 可变数据</h3>
<p>在大型系统中，抽象对帮助我们应对复杂性至关重要。为了有效编写程序，我们还需要组织原则，帮助我们设计模块化的程序。模块化程序分成独立开发和维护的部分，其中一种强有力的技术是使用可以随时间变化状态的数据。</p>
<p>添加状态到数据中是面向对象编程（OOP）中的核心思想。通过这种方式，数据对象可以独立于程序的其他部分，表现出随历史变化的行为。</p>
<h4 id="2-4-1-对象的隐喻">2.4.1 对象的隐喻</h4>
<p>最开始，我们区分了函数和数据：函数执行操作，而数据是被操作的对象。当函数值也被视为数据后，数据就开始拥有了行为。<strong>对象</strong>结合了数据和行为，既代表信息，又像它们所代表的事物一样有行为。</p>
<p>例如，日期对象结合了日期信息和相关的行为。在Python中，<code>datetime</code>模块的<code>date</code>类就是一个例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line">tues = date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">13</span>)</span><br><span class="line"><span class="built_in">print</span>(date(<span class="number">2014</span>, <span class="number">5</span>, <span class="number">19</span>) - tues)  <span class="comment"># 输出：6天</span></span><br><span class="line">tues.year  <span class="comment"># 输出：2014</span></span><br><span class="line">tues.strftime(<span class="string">'%A, %B %d'</span>)  <span class="comment"># 输出：Tuesday, May 13</span></span><br></pre></td></tr></tbody></table></figure>
<p>对象不仅有属性，还拥有方法（行为）。方法是函数，它们通过使用对象自身和传入的参数来进行计算。例如，<code>strftime</code>方法格式化日期输出。</p>
<h4 id="2-4-2-序列对象">2.4.2 序列对象</h4>
<p>Python中，所有的值都是对象。某些对象是不可变的（例如数字和字符串），而列表是可变的。这意味着它们可以随时间改变。可变对象的行为类似于现实世界中的事物，例如一个人虽然每天都在改变，但仍然是同一个人。</p>
<h5 id="列表的可变性">列表的可变性</h5>
<p>列表是可变的，我们可以对其进行增删操作。例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">chinese = [<span class="string">'coin'</span>, <span class="string">'string'</span>, <span class="string">'myriad'</span>]</span><br><span class="line">suits = chinese  <span class="comment"># 两个变量指向同一个列表</span></span><br><span class="line">suits.pop()  <span class="comment"># 删除最后一个元素</span></span><br><span class="line">suits.append(<span class="string">'cup'</span>)  <span class="comment"># 添加元素到列表末尾</span></span><br><span class="line">suits[<span class="number">2</span>] = <span class="string">'spade'</span>  <span class="comment"># 替换指定位置的元素</span></span><br></pre></td></tr></tbody></table></figure>
<p>修改列表的操作会影响引用同一列表的所有变量。例如，修改<code>suits</code>列表时，<code>chinese</code>列表也会随之改变，因为它们引用的是同一个列表对象。</p>
<p>我们可以通过<code>list()</code>函数复制列表，从而避免这种情况：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">nest = <span class="built_in">list</span>(suits)  <span class="comment"># 创建一个新列表，内容相同</span></span><br><span class="line">nest[<span class="number">0</span>] = suits  <span class="comment"># 创建嵌套列表</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="列表的身份与相等性">列表的身份与相等性</h5>
<p>Python中使用<code>is</code>和<code>is not</code>判断两个对象是否是同一个，而使用<code>==</code>判断两个对象的内容是否相等：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">suits <span class="keyword">is</span> nest[<span class="number">0</span>]  <span class="comment"># 输出：True</span></span><br><span class="line">suits == [<span class="string">'heart'</span>, <span class="string">'diamond'</span>, <span class="string">'spade'</span>, <span class="string">'club'</span>]  <span class="comment"># 输出：True</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="列表推导式">列表推导式</h5>
<p>列表推导式创建新列表，并不会修改原有列表。例如，使用<code>unicodedata</code>模块来查找扑克牌花色符号：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> unicodedata <span class="keyword">import</span> lookup</span><br><span class="line">[lookup(<span class="string">'WHITE '</span> + s.upper() + <span class="string">' SUIT'</span>) <span class="keyword">for</span> s <span class="keyword">in</span> suits]  <span class="comment"># 输出：['♡', '♢', '♤', '♧']</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="元组">元组</h5>
<p>元组（<code>tuple</code>）是不可变的序列对象。它们的创建方式与列表类似，但不能修改其内容：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">code = (<span class="string">"up"</span>, <span class="string">"down"</span>, <span class="string">"left"</span>, <span class="string">"right"</span>)</span><br><span class="line">code[<span class="number">0</span>]  <span class="comment"># 输出："up"</span></span><br></pre></td></tr></tbody></table></figure>
<p>元组常用于多值赋值：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">2</span>  <span class="comment"># 相当于 a = (1, 2)</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然元组不可变，但其内部包含的可变元素（如列表）仍可以改变：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">nest = (<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line">nest[<span class="number">2</span>].pop()  <span class="comment"># 修改了元组中的列表元素</span></span><br></pre></td></tr></tbody></table></figure>
<p>总结：Python中的所有值都是对象，有些对象是不可变的（如元组），而有些是可变的（如列表）。对于可变对象，修改它们会影响所有引用该对象的变量。</p>
<h4 id="2-4-3-字典">2.4.3 字典</h4>
<p>字典是 Python 中内置的数据类型，用于存储和操作键值对。字典中的键和值都是对象，通常用于存储非连续整数索引的对应关系。</p>
<ul>
<li>
<p><strong>键-值对</strong>：字典由键值对组成，例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">numerals = {<span class="string">'I'</span>: <span class="number">1.0</span>, <span class="string">'V'</span>: <span class="number">5</span>, <span class="string">'X'</span>: <span class="number">10</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>通过键来查找对应的值：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">numerals[<span class="string">'X'</span>]  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>字典无序性</strong>：字典是无序集合，键值对的顺序无法预知，不同运行结果可能不一样。</p>
</li>
<li>
<p><strong>修改和添加键值对</strong>：可以通过赋值来添加或修改键值对。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">numerals[<span class="string">'I'</span>] = <span class="number">1</span></span><br><span class="line">numerals[<span class="string">'L'</span>] = <span class="number">50</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>键的要求</strong>：字典的键必须是不可变类型，例如字符串、元组，不能是列表等可变类型。</p>
</li>
<li>
<p><strong><code>get</code> 方法</strong>：<code>get</code> 方法可用于返回键对应的值，若键不存在则返回默认值：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">numerals.get(<span class="string">'A'</span>, <span class="number">0</span>)  <span class="comment"># 输出: 0</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>字典推导式</strong>：可以使用字典推导式快速创建字典：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">{x: x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>,<span class="number">6</span>)}  <span class="comment"># 输出: {3: 9, 4: 16, 5: 25}</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-4-4-局部状态">2.4.4 局部状态</h4>
<p>字典和列表有局部状态，即它们的值会随着程序的执行而变化。函数也可以具有局部状态，例如模拟银行账户的取款操作。</p>
<ul>
<li>
<p><strong>函数的局部状态</strong>：定义一个 <code>withdraw</code> 函数，模拟取款操作。取款会减少账户余额，每次调用的结果依赖于之前的操作：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance -= amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>nonlocal</code> 关键字，可以在函数中修改父作用域中的变量 <code>balance</code>。当调用 <code>withdraw</code> 函数时，<code>balance</code> 会被更新，影响下一次调用的结果。</p>
</li>
<li>
<p><strong><code>nonlocal</code> 声明</strong>：<code>nonlocal</code> 允许在局部作用域中修改外部变量，而不再局限于仅查找变量。它的作用是使得变量的赋值影响整个闭包作用域，而非仅限于局部作用域。</p>
</li>
<li>
<p><strong>错误示例</strong>：如果没有 <code>nonlocal</code> 声明，Python 会认为 <code>balance</code> 是局部变量，并抛出 <code>UnboundLocalError</code>：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">UnboundLocalError: local variable <span class="string">'balance'</span> referenced before assignment</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>通过使用 <code>nonlocal</code> 语句，允许函数在多个调用间共享状态，管理复杂的数据流和逻辑。</p>
<h4 id="2-4-5-非本地赋值的好处">2.4.5 非本地赋值的好处</h4>
<p>非本地赋值为我们提供了一种管理局部状态的方法，这个状态随着函数的多次调用而变化。每个 <code>withdraw</code> 函数的 <code>balance</code> 是独立的，并且不可被程序中的其他部分直接访问。通过调用 <code>make_withdraw</code> 创建了不同的 <code>withdraw</code> 实例，每个实例都管理自己的余额，并且它们不会互相影响。</p>
<p>示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_withdraw</span>(<span class="params">balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> balance</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        balance -= amount</span><br><span class="line">        <span class="keyword">return</span> balance</span><br><span class="line">    <span class="keyword">return</span> withdraw</span><br><span class="line"></span><br><span class="line">wd = make_withdraw(<span class="number">20</span>)</span><br><span class="line">wd2 = make_withdraw(<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(wd2(<span class="number">6</span>))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(wd(<span class="number">8</span>))   <span class="comment"># 输出: 12</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-6-非本地赋值的代价">2.4.6 非本地赋值的代价</h4>
<p>非本地赋值引入了复杂性。特别是当两个变量指向同一个函数实例时，它们的状态会互相影响。例如，<code>wd</code> 和 <code>wd2</code> 指向同一个函数时，改变 <code>wd2</code> 的状态会影响 <code>wd</code> 的状态。</p>
<p>示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">wd = make_withdraw(<span class="number">12</span>)</span><br><span class="line">wd2 = wd</span><br><span class="line"><span class="built_in">print</span>(wd2(<span class="number">1</span>))  <span class="comment"># 输出: 11</span></span><br><span class="line"><span class="built_in">print</span>(wd(<span class="number">1</span>))   <span class="comment"># 输出: 10</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-7-实现可变链表和字典">2.4.7 实现可变链表和字典</h4>
<p>可以通过函数实现可变链表。链表使用一个函数来表示，它接受不同的消息进行操作。如下的链表支持 <code>len</code>、<code>getitem</code>、<code>push_first</code>、<code>pop_first</code> 和 <code>str</code> 操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mutable_link</span>():</span><br><span class="line">    contents = empty</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> contents</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">'len'</span>:</span><br><span class="line">            <span class="keyword">return</span> len_link(contents)</span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">'getitem'</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem_link(contents, value)</span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">'push_first'</span>:</span><br><span class="line">            contents = link(value, contents)</span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">'pop_first'</span>:</span><br><span class="line">            first_item = first(contents)</span><br><span class="line">            contents = rest(contents)</span><br><span class="line">            <span class="keyword">return</span> first_item</span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">'str'</span>:</span><br><span class="line">            <span class="keyword">return</span> join_link(contents, <span class="string">", "</span>)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br></pre></td></tr></tbody></table></figure>
<p>通过消息传递的方式，也可以实现一个简单的字典。字典存储键值对，并通过 <code>setitem</code> 和 <code>getitem</code> 消息进行插入和查询操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dictionary</span>():</span><br><span class="line">    records = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getitem</span>(<span class="params">key</span>):</span><br><span class="line">        matches = [r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>] == key]</span><br><span class="line">        <span class="keyword">if</span> matches:</span><br><span class="line">            <span class="keyword">return</span> matches[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setitem</span>(<span class="params">key, value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> records</span><br><span class="line">        non_matches = [r <span class="keyword">for</span> r <span class="keyword">in</span> records <span class="keyword">if</span> r[<span class="number">0</span>] != key]</span><br><span class="line">        records = non_matches + [[key, value]]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">message, key=<span class="literal">None</span>, value=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> message == <span class="string">'getitem'</span>:</span><br><span class="line">            <span class="keyword">return</span> getitem(key)</span><br><span class="line">        <span class="keyword">elif</span> message == <span class="string">'setitem'</span>:</span><br><span class="line">            setitem(key, value)</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br></pre></td></tr></tbody></table></figure>
<p>非本地赋值虽然增加了程序的复杂性，但它为实现模块化程序提供了重要的工具。通过函数和局部状态的组合，我们能够模拟许多内置的可变数据类型，如列表和字典。</p>
<h4 id="2-4-8-消息传递系统和字典">2.4.8 <strong>消息传递系统和字典</strong></h4>
<p>我们可以使用字典来实现消息传递接口，避免使用条件语句来处理不同消息。字典的键可以是字符串，用于查找对应的值或函数。</p>
<p><strong>示例：银行账户的消息传递系统</strong><br>
在下面的银行账户实现中，我们通过字典存储账户状态（余额）和操作（存款、取款函数）。通过消息传递的方式，使用字典中的函数实现操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">account</span>(<span class="params">initial_balance</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">amount</span>):</span><br><span class="line">        dispatch[<span class="string">'balance'</span>] += amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">'balance'</span>]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">amount</span>):</span><br><span class="line">        <span class="keyword">if</span> amount &gt; dispatch[<span class="string">'balance'</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        dispatch[<span class="string">'balance'</span>] -= amount</span><br><span class="line">        <span class="keyword">return</span> dispatch[<span class="string">'balance'</span>]</span><br><span class="line">    </span><br><span class="line">    dispatch = {</span><br><span class="line">        <span class="string">'deposit'</span>: deposit,</span><br><span class="line">        <span class="string">'withdraw'</span>: withdraw,</span><br><span class="line">        <span class="string">'balance'</span>: initial_balance</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'withdraw'</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">account, amount</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'deposit'</span>](amount)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_balance</span>(<span class="params">account</span>):</span><br><span class="line">    <span class="keyword">return</span> account[<span class="string">'balance'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例使用</span></span><br><span class="line">a = account(<span class="number">20</span>)</span><br><span class="line">deposit(a, <span class="number">5</span>)</span><br><span class="line">withdraw(a, <span class="number">17</span>)</span><br><span class="line">check_balance(a)</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-4-9-约束传播系统">2.4.9 <strong>约束传播系统</strong></h4>
<p>约束传播系统模拟了变量之间的关系和约束，允许双向计算。它是一种声明式编程，其中程序员声明变量的关系，而不指定具体的计算过程。</p>
<p><strong>理想气体定律：</strong><br>
$p * v = n * k * t$<br>
传统程序语言中，通常我们只能将一个变量表示为其他变量的函数。例如，计算压力 p 需要给定 v、n、k、t。但在约束传播系统中，我们可以实现双向计算，任意一个未知量都可以通过其他已知量来计算。</p>
<h5 id="摄氏温度与华氏温度的转换网络"><strong>摄氏温度与华氏温度的转换网络</strong></h5>
<p>通过定义基本约束（例如加法器、乘法器）和连接器，我们可以构建一个转换摄氏温度和华氏温度的网络。</p>
<p><strong>摄氏温度与华氏温度的关系式：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">9</span> * c = <span class="number">5</span> * (f - <span class="number">32</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>该系统会在任何连接器的值发生变化时，自动更新其他受影响的连接器。以下是如何使用约束系统计算温度转换：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建连接器</span></span><br><span class="line">celsius = connector(<span class="string">'Celsius'</span>)</span><br><span class="line">fahrenheit = connector(<span class="string">'Fahrenheit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义转换网络</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">converter</span>(<span class="params">c, f</span>):</span><br><span class="line">    u, v, w, x, y = [connector() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">    multiplier(c, w, u)</span><br><span class="line">    multiplier(v, x, u)</span><br><span class="line">    adder(v, y, f)</span><br><span class="line">    constant(w, <span class="number">9</span>)</span><br><span class="line">    constant(x, <span class="number">5</span>)</span><br><span class="line">    constant(y, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">converter(celsius, fahrenheit)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置摄氏温度，自动更新华氏温度</span></span><br><span class="line">celsius[<span class="string">'set_val'</span>](<span class="string">'user'</span>, <span class="number">25</span>)  <span class="comment"># 输出: Celsius = 25, Fahrenheit = 77.0</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="实现约束和连接器"><strong>实现约束和连接器</strong></h5>
<p>在约束传播系统中，约束和连接器都是字典，它们通过消息进行通信。</p>
<ul>
<li><strong>约束（Constraints）</strong>：接收连接器的消息，更新其他连接器的值。</li>
<li><strong>连接器（Connectors）</strong>：保存当前的值，并在值更新时通知约束。</li>
</ul>
<p><strong>加法器的实现：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> add, sub</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adder</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="string">"""约束：a + b = c"""</span></span><br><span class="line">    <span class="keyword">return</span> make_ternary_constraint(a, b, c, add, sub, sub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_ternary_constraint</span>(<span class="params">a, b, c, ab, ca, cb</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new_value</span>():</span><br><span class="line">        av, bv, cv = [connector[<span class="string">'has_val'</span>]() <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c)]</span><br><span class="line">        <span class="keyword">if</span> av <span class="keyword">and</span> bv:</span><br><span class="line">            c[<span class="string">'set_val'</span>](constraint, ab(a[<span class="string">'val'</span>], b[<span class="string">'val'</span>]))</span><br><span class="line">        <span class="keyword">elif</span> av <span class="keyword">and</span> cv:</span><br><span class="line">            b[<span class="string">'set_val'</span>](constraint, ca(c[<span class="string">'val'</span>], a[<span class="string">'val'</span>]))</span><br><span class="line">        <span class="keyword">elif</span> bv <span class="keyword">and</span> cv:</span><br><span class="line">            a[<span class="string">'set_val'</span>](constraint, cb(c[<span class="string">'val'</span>], b[<span class="string">'val'</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forget_value</span>():</span><br><span class="line">        <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c):</span><br><span class="line">            connector[<span class="string">'forget'</span>](constraint)</span><br><span class="line"></span><br><span class="line">    constraint = {<span class="string">'new_val'</span>: new_value, <span class="string">'forget'</span>: forget_value}</span><br><span class="line">    <span class="keyword">for</span> connector <span class="keyword">in</span> (a, b, c):</span><br><span class="line">        connector[<span class="string">'connect'</span>](constraint)</span><br><span class="line">    <span class="keyword">return</span> constraint</span><br></pre></td></tr></tbody></table></figure>
<p><strong>连接器的实现：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">connector</span>(<span class="params">name=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""连接器的构造函数"""</span></span><br><span class="line">    informant = <span class="literal">None</span></span><br><span class="line">    constraints = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">source, value</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        <span class="keyword">if</span> connector[<span class="string">'val'</span>] <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            informant, connector[<span class="string">'val'</span>] = source, value</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name, <span class="string">'='</span>, value)</span><br><span class="line">            inform_all_except(source, <span class="string">'new_val'</span>, constraints)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> connector[<span class="string">'val'</span>] != value:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'Contradiction detected:'</span>, connector[<span class="string">'val'</span>], <span class="string">'vs'</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forget_value</span>(<span class="params">source</span>):</span><br><span class="line">        <span class="keyword">nonlocal</span> informant</span><br><span class="line">        <span class="keyword">if</span> informant == source:</span><br><span class="line">            informant, connector[<span class="string">'val'</span>] = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="built_in">print</span>(name, <span class="string">'is forgotten'</span>)</span><br><span class="line">            inform_all_except(source, <span class="string">'forget'</span>, constraints)</span><br><span class="line">    </span><br><span class="line">    connector = {</span><br><span class="line">        <span class="string">'val'</span>: <span class="literal">None</span>,</span><br><span class="line">        <span class="string">'set_val'</span>: set_value,</span><br><span class="line">        <span class="string">'forget'</span>: forget_value,</span><br><span class="line">        <span class="string">'has_val'</span>: <span class="keyword">lambda</span>: connector[<span class="string">'val'</span>] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>,</span><br><span class="line">        <span class="string">'connect'</span>: <span class="keyword">lambda</span> source: constraints.append(source)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> connector</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inform_all_except</span>(<span class="params">source, message, constraints</span>):</span><br><span class="line">    <span class="string">"""通知所有连接的约束，除了指定的 source"""</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> constraints:</span><br><span class="line">        <span class="keyword">if</span> c != source:</span><br><span class="line">            c[message]()</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>字典是实现消息传递和存储状态的有效方式。</li>
<li>约束系统可以建立变量间复杂的关系，并实现多方向的计算。</li>
<li>使用字典和消息传递的方式可以模拟对象的行为，这为后续的面向对象编程奠定了基础。</li>
</ul>
<hr>
<h3 id="2-5-面向对象编程学习笔记">2.5 面向对象编程学习笔记</h3>
<h4 id="2-5-1-面向对象编程（OOP）概述">2.5.1 面向对象编程（OOP）概述</h4>
<ul>
<li><strong>OOP简介</strong>：面向对象编程是一种通过对象与方法来组织程序的编程范式。对象结合了数据（状态）和行为（方法），能够抽象复杂性，并且通过交互产生有用的结果。</li>
<li><strong>核心概念</strong>：
<ul>
<li><strong>对象</strong>：拥有属性和方法的数据类型。</li>
<li><strong>类</strong>：定义对象的模板。</li>
<li><strong>继承</strong>：对象可以从其他对象继承特性和行为。</li>
</ul>
</li>
</ul>
<h4 id="2-5-2-定义类和对象">2.5.2 定义类和对象</h4>
<ul>
<li>
<p><strong>类定义</strong>：使用 <code>class</code> 关键字定义类。类通常包含属性（实例属性）和方法。</p>
</li>
<li>
<p><strong>实例化对象</strong>：类通过调用生成具体的对象实例。实例化是通过调用类名，并传入参数来完成的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">        self.balance = <span class="number">0</span>  <span class="comment"># 实例属性</span></span><br><span class="line">        self.holder = account_holder  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line">a = Account(<span class="string">'Kirk'</span>)</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>实例属性</strong>：对象的属性，例如账户的余额和持有人。它们是通过 <code>self</code> 来绑定到对象实例的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">a.holder  <span class="comment"># 'Kirk'</span></span><br><span class="line">a.balance  <span class="comment"># 0</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="方法定义与调用">方法定义与调用</h5>
<ul>
<li>
<p><strong>方法</strong>：类内定义的函数，用于操作对象的属性。例如，<code>deposit</code> 方法用于给账户存钱，<code>withdraw</code> 方法用于取钱。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.balance += amount</span><br><span class="line">        <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>方法调用</strong>：对象方法的调用通过点号表示法，例如 <code>spock_account.deposit(100)</code>。</p>
</li>
</ul>
<h4 id="2-5-3-消息传递与点号表示法">2.5.3 消息传递与点号表示法</h4>
<ul>
<li>
<p><strong>消息传递</strong>：对象通过点号表示法接收消息，访问其方法和属性。例如，<code>spock_account.deposit</code> 是一个点表达式，它返回 <code>spock_account</code> 对象上的 <code>deposit</code> 方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">spock_account.deposit(<span class="number">100</span>)  <span class="comment"># 存款100</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong><code>getattr</code> 和 <code>hasattr</code></strong>：可以使用 <code>getattr</code> 来动态访问对象的属性或方法，使用 <code>hasattr</code> 检查对象是否具有某个属性或方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(spock_account, <span class="string">'balance'</span>)  <span class="comment"># 返回余额</span></span><br><span class="line"><span class="built_in">hasattr</span>(spock_account, <span class="string">'deposit'</span>)  <span class="comment"># True</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="2-5-4-类属性">2.5.4 类属性</h4>
<ul>
<li>
<p><strong>类属性</strong>：类属性是与类关联的值，而非对象实例。例如，银行的利率是所有账户共享的，可以通过类属性定义。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    interest = <span class="number">0.02</span>  <span class="comment"># 类属性</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>类属性访问与修改</strong>：类属性可以通过类或实例访问，但修改时需要特别注意。如果修改类属性，将影响所有实例；而如果修改实例的同名属性，实例将拥有独立的属性值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Account.interest = <span class="number">0.04</span>  <span class="comment"># 修改类属性</span></span><br><span class="line">spock_account.interest  <span class="comment"># 0.04</span></span><br><span class="line">kirk_account.interest = <span class="number">0.08</span>  <span class="comment"># kirk的独立实例属性</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="方法与函数的区别">方法与函数的区别</h5>
<ul>
<li>
<p><strong>方法绑定</strong>：在类中定义的方法在实例化时会自动绑定到对象，传入的第一个参数默认为对象本身 (<code>self</code>)。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Account.deposit(spock_account, <span class="number">1000</span>)  <span class="comment"># 直接调用函数</span></span><br><span class="line">spock_account.deposit(<span class="number">1000</span>)  <span class="comment"># 调用绑定的方法</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="总结-6">总结</h5>
<ul>
<li>面向对象编程通过对象、方法和类将数据与行为整合在一起。类定义了对象的属性和行为，实例化后可以对每个对象进行操作。点号表示法用于访问对象的属性和方法，类属性为所有实例共享的值，方法通过自动绑定 <code>self</code> 来实现对象的操作。</li>
</ul>
<h4 id="2-5-5-继承">2.5.5 继承</h4>
<p>在面向对象编程中，类之间常常有某种关联性。某些类可能代表另一个类的特例。比如，<code>CheckingAccount</code>（支票账户）是 <code>Account</code>（账户）的一个特例。支票账户每次取款时收取额外费用，利率也更低。</p>
<p><strong>例子：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch = CheckingAccount(<span class="string">'Spock'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.interest     <span class="comment"># 支票账户的较低利率</span></span><br><span class="line"><span class="number">0.01</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.deposit(<span class="number">20</span>)  <span class="comment"># 存款操作与普通账户相同</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ch.withdraw(<span class="number">5</span>)  <span class="comment"># 取款时收取额外费用</span></span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>CheckingAccount</code> 继承了 <code>Account</code> 类的所有属性和方法，但可以覆盖某些方法，比如 <code>withdraw</code> 方法。这样可以只编写不同的部分，其余行为由基类 <code>Account</code> 继承。</p>
<h4 id="2-5-6-使用继承">2.5.6 使用继承</h4>
<p>下面是完整的 <code>Account</code> 类实现，包含了存款和取款操作的定义：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="string">"""一个具有非负余额的银行账户。"""</span></span><br><span class="line">    interest = <span class="number">0.02</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">        self.balance = <span class="number">0</span></span><br><span class="line">        self.holder = account_holder</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">"""存款并返回新余额。"""</span></span><br><span class="line">        self.balance += amount</span><br><span class="line">        <span class="keyword">return</span> self.balance</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">"""取款并返回新余额，如果余额不足返回‘Insufficient funds’。"""</span></span><br><span class="line">        <span class="keyword">if</span> amount &gt; self.balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Insufficient funds'</span></span><br><span class="line">        self.balance -= amount</span><br><span class="line">        <span class="keyword">return</span> self.balance</span><br></pre></td></tr></tbody></table></figure>
<p>支票账户是对普通账户的特例，继承了 <code>Account</code> 的基本功能，但修改了 <code>withdraw</code> 方法，增加了取款费用：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CheckingAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">    <span class="string">"""一个对取款收取费用的银行账户。"""</span></span><br><span class="line">    withdraw_charge = <span class="number">1</span></span><br><span class="line">    interest = <span class="number">0.01</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">return</span> Account.withdraw(self, amount + self.withdraw_charge)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>例子：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking = CheckingAccount(<span class="string">'Sam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.deposit(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>checking.withdraw(<span class="number">5</span>)</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-5-7-多重继承">2.5.7 多重继承</h4>
<p>Python 支持多重继承，即子类可以继承多个父类。假设有一个 <code>SavingsAccount</code> 类（储蓄账户），对每次存款收取费用：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SavingsAccount</span>(<span class="title class_ inherited__">Account</span>):</span><br><span class="line">    deposit_charge = <span class="number">2</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="keyword">return</span> Account.deposit(self, amount - self.deposit_charge)</span><br></pre></td></tr></tbody></table></figure>
<p>我们还可以创建一个既有 <code>CheckingAccount</code> 又有 <code>SavingsAccount</code> 特性的账户：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AsSeenOnTVAccount</span>(CheckingAccount, SavingsAccount):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">        self.holder = account_holder</span><br><span class="line">        self.balance = <span class="number">1</span>  <span class="comment"># 赠送1美元</span></span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>AsSeenOnTVAccount</code> 中，取款和存款操作都会收取费用：</p>
<p><strong>例子：</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal = AsSeenOnTVAccount(<span class="string">"John"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.balance</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.deposit(<span class="number">20</span>)  <span class="comment"># 储蓄账户的存款费用</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>such_a_deal.withdraw(<span class="number">5</span>)  <span class="comment"># 支票账户的取款费用</span></span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></tbody></table></figure>
<p>在多重继承中，Python 采用 C3 方法解析顺序来处理属性或方法的查找。</p>
<h4 id="2-5-8-对象的角色">2.5.8 对象的角色</h4>
<p>Python 的对象系统提供了方便且灵活的数据抽象和消息传递机制。类、方法、继承、点表达式等语法特性帮助我们在程序中实现对象模型，使得编写和管理大型程序变得更加有条理。</p>
<hr>
<h3 id="2-6-实现类和对象">2.6 实现类和对象</h3>
<p>在面向对象编程范式中，我们使用对象隐喻来指导程序的组织。大多数关于如何表示和操作数据的逻辑都在类声明中表达。在这一节中，我们看到类和对象本身可以仅用函数和字典来表示。通过这种方式实现对象系统的目的是为了说明，使用对象隐喻并不需要特定的编程语言。即使在没有内置对象系统的编程语言中，程序也可以是面向对象的。</p>
<p>为了实现对象，我们将放弃点符号（这需要内置语言支持），而创建调度字典，行为与内置对象系统的元素非常相似。我们已经看到如何通过调度字典实现消息传递行为。为了完整实现对象系统，我们将在实例、类和基类之间发送消息，所有这些都作为包含属性的字典。</p>
<p>我们不会实现整个Python对象系统，因为它包括一些在本书中未覆盖的特性（例如，元类和静态方法）。相反，我们将专注于用户定义的类，不使用多重继承，也不使用反射行为（例如返回实例的类）。我们的实现并不打算遵循Python类型系统的精确规范，而是旨在实现支持对象隐喻的核心功能。</p>
<h4 id="2-6-1-实例">2.6.1 实例</h4>
<p>实例具有命名属性，例如账户的余额，可以设置和获取。我们使用调度字典来实现实例，该字典响应“获取”和“设置”属性值的消息。属性本身存储在名为 <code>attributes</code> 的局部字典中。</p>
<p><strong>示例：创建实例</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_instance</span>(<span class="params">cls</span>):</span><br><span class="line">    <span class="string">"""返回一个新的对象实例，即一个调度字典。"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> attributes:</span><br><span class="line">            <span class="keyword">return</span> attributes[name]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            value = cls[<span class="string">'get'</span>](name)</span><br><span class="line">            <span class="keyword">return</span> bind_method(value, instance)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">name, value</span>):</span><br><span class="line">        attributes[name] = value</span><br><span class="line">    </span><br><span class="line">    attributes = {}</span><br><span class="line">    instance = {<span class="string">'get'</span>: get_value, <span class="string">'set'</span>: set_value}</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></tbody></table></figure>
<p>在这个实现中，<code>make_instance</code> 函数返回一个调度字典 <code>instance</code>，它响应 <code>get</code> 和 <code>set</code> 消息。</p>
<p><strong>绑定方法</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bind_method</span>(<span class="params">value, instance</span>):</span><br><span class="line">    <span class="string">"""如果值是可调用的，返回一个绑定的方法，否则返回值本身。"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">callable</span>(value):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">method</span>(<span class="params">*args</span>):</span><br><span class="line">            <span class="keyword">return</span> value(instance, *args)</span><br><span class="line">        <span class="keyword">return</span> method</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> value</span><br></pre></td></tr></tbody></table></figure>
<p>当调用方法时，第一个参数 <code>self</code> 将绑定到 <code>instance</code> 的值。</p>
<h4 id="2-6-2-类">2.6.2 类</h4>
<p>类也是对象，既在Python的对象系统中，也在我们实现的系统中。为了简化起见，我们假设类本身没有类（在Python中，类确实有类；几乎所有类都共享同一个类，称为 <code>type</code>）。类可以响应 <code>get</code> 和 <code>set</code> 消息，以及 <code>new</code> 消息。</p>
<p><strong>示例：创建类</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_class</span>(<span class="params">attributes, base_class=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">"""返回一个新的类，即一个调度字典。"""</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_value</span>(<span class="params">name</span>):</span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> attributes:</span><br><span class="line">            <span class="keyword">return</span> attributes[name]</span><br><span class="line">        <span class="keyword">elif</span> base_class <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> base_class[<span class="string">'get'</span>](name)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_value</span>(<span class="params">name, value</span>):</span><br><span class="line">        attributes[name] = value</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">new</span>(<span class="params">*args</span>):</span><br><span class="line">        <span class="keyword">return</span> init_instance(cls, *args)</span><br><span class="line">    </span><br><span class="line">    cls = {<span class="string">'get'</span>: get_value, <span class="string">'set'</span>: set_value, <span class="string">'new'</span>: new}</span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></tbody></table></figure>
<p><strong>初始化</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_instance</span>(<span class="params">cls, *args</span>):</span><br><span class="line">    <span class="string">"""返回一个类型为cls的新对象，用args初始化。"""</span></span><br><span class="line">    instance = make_instance(cls)</span><br><span class="line">    init = cls[<span class="string">'get'</span>](<span class="string">'__init__'</span>)</span><br><span class="line">    <span class="keyword">if</span> init:</span><br><span class="line">        init(instance, *args)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-6-3-使用实现的对象">2.6.3 使用实现的对象</h4>
<p>现在我们使用之前的银行账户示例，创建 <code>Account</code> 类、<code>CheckingAccount</code> 子类，以及每个类的实例。</p>
<p><strong>示例：创建账户类</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_account_class</span>():</span><br><span class="line">    <span class="string">"""返回Account类，具有存款和取款方法。"""</span></span><br><span class="line">    interest = <span class="number">0.02</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, account_holder</span>):</span><br><span class="line">        self[<span class="string">'set'</span>](<span class="string">'holder'</span>, account_holder)</span><br><span class="line">        self[<span class="string">'set'</span>](<span class="string">'balance'</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">"""增加账户余额并返回新余额。"""</span></span><br><span class="line">        new_balance = self[<span class="string">'get'</span>](<span class="string">'balance'</span>) + amount</span><br><span class="line">        self[<span class="string">'set'</span>](<span class="string">'balance'</span>, new_balance)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">"""减少账户余额并返回新余额。"""</span></span><br><span class="line">        balance = self[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line">        <span class="keyword">if</span> amount &gt; balance:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'资金不足'</span></span><br><span class="line">        self[<span class="string">'set'</span>](<span class="string">'balance'</span>, balance - amount)</span><br><span class="line">        <span class="keyword">return</span> self[<span class="string">'get'</span>](<span class="string">'balance'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> make_class(<span class="built_in">locals</span>())</span><br></pre></td></tr></tbody></table></figure>
<p><strong>创建账户实例</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Account = make_account_class()  <span class="comment"># 创建Account类</span></span><br><span class="line">kirk_account = Account[<span class="string">'new'</span>](<span class="string">'Kirk'</span>)  <span class="comment"># 创建账户实例</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用 <code>get</code> 消息传递给 <code>kirk_account</code>，可以检索属性和方法。可以调用方法来更新账户余额。</p>
<p><strong>获取账户持有者</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">kirk_account[<span class="string">'get'</span>](<span class="string">'holder'</span>)  <span class="comment"># 获取账户持有者</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="小结">小结</h4>
<p>本节展示了如何在不依赖内置对象系统的情况下实现面向对象编程，通过调度字典模拟实例和类的行为。通过这种方法，我们能够创建和管理对象，同时理解类的继承和属性的设置与获取机制。</p>
<hr>
<h3 id="2-7-对象抽象">2.7 对象抽象</h3>
<p>对象系统允许程序员高效地构建和使用抽象数据表示。它的设计允许多种抽象数据表示在同一程序中共存。</p>
<p>对象抽象的一个核心概念是<strong>泛型函数</strong>，即可以接受多种不同类型值的函数。我们将考虑三种实现泛型函数的不同技术：共享接口、类型调度和类型强制。在构建这些概念的过程中，我们还将发现支持创建泛型函数的Python对象系统特性。</p>
<h4 id="2-7-1-字符串转换">2.7.1 字符串转换</h4>
<p>为了有效地表示数据，对象值应表现出它所代表的数据类型，包括生成自身的字符串表示。数据值的字符串表示在交互式语言（如Python）中尤为重要，因为在交互式会话中，Python会自动显示表达式值的字符串表示。</p>
<p><strong>示例：基本字符串表示</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">12e12</span></span><br><span class="line"><span class="number">12000000000000.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">repr</span>(<span class="number">12e12</span>))  <span class="comment"># repr返回可被eval评估为相同对象的字符串</span></span><br><span class="line"><span class="number">12000000000000.0</span></span><br></pre></td></tr></tbody></table></figure>
<p>在没有有效的字符串表示可以评估为原始值的情况下，Python通常会生成一个用尖括号括起来的描述。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(<span class="built_in">min</span>)</span><br><span class="line"><span class="string">'&lt;built-in function min&gt;'</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>人类可读和Python可读的字符串表示</strong></p>
<p>字符串的构造函数<code>str</code>通常与<code>repr</code>相吻合，但在某些情况下提供更易理解的文本表示。例如，对于日期，我们看到 <code>str</code> 和 <code>repr</code> 的区别：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line">tues = date(<span class="number">2011</span>, <span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">repr</span>(tues)</span><br><span class="line"><span class="string">'datetime.date(2011, 9, 12)'</span>  <span class="comment"># Python可读表示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span>(tues)</span><br><span class="line"><span class="string">'2011-09-12'</span>  <span class="comment"># 更易理解的人类可读表示</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>实现<code>__repr__</code>和<code>__str__</code>方法</strong></p>
<p>我们希望<code>repr</code>函数能适用于所有数据类型，包括那些在实现时不存在的数据类型。我们希望它是一个泛型或多态函数，能应用于多种（poly）不同形式（morph）的数据。对象系统在这种情况下提供了优雅的解决方案：<code>repr</code>函数总是调用其参数的<code>__repr__</code>方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__repr__()</span><br><span class="line"><span class="string">'datetime.date(2011, 9, 12)'</span>  <span class="comment"># 调用__repr__方法</span></span><br></pre></td></tr></tbody></table></figure>
<p>同样，<code>str</code>构造函数通过调用其参数的<code>__str__</code>方法实现：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tues.__str__()</span><br><span class="line"><span class="string">'2011-09-12'</span>  <span class="comment"># 调用__str__方法</span></span><br></pre></td></tr></tbody></table></figure>
<p>这些多态函数是一个更一般原则的例子：某些函数应该适用于多种数据类型。创建这样的函数的一种方法是使用共享属性名，并在每个类中定义不同的实现。</p>
<h4 id="2-7-2-特殊方法">2.7.2 特殊方法</h4>
<p>在Python中，某些特殊名称在特定情况下由Python解释器自动调用。例如，类的<code>__init__</code>方法在构造对象时自动调用；<code>__str__</code>方法在打印时自动调用，<code>__repr__</code>方法在交互式会话中显示值时调用。</p>
<p><strong>布尔值</strong></p>
<p>所有Python对象都有一个布尔值。默认情况下，用户定义类的对象被认为是True，但可以使用特殊的<code>__bool__</code>方法覆盖此行为。例如，我们可以让余额为0的银行账户被视为False：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Account.__bool__ = <span class="keyword">lambda</span> self: self[<span class="string">'get'</span>](<span class="string">'balance'</span>) != <span class="number">0</span>  <span class="comment"># 定义__bool__方法</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以通过调用<code>bool</code>构造函数来查看对象的布尔值，并在布尔上下文中使用任何对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(Account(<span class="string">'Jack'</span>))  <span class="comment"># 查看账户的布尔值</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> <span class="keyword">not</span> Account(<span class="string">'Jack'</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Jack has nothing'</span>)  <span class="comment"># 输出: Jack has nothing</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>序列操作</strong></p>
<p>我们可以使用<code>len</code>函数确定序列的长度，该函数调用其参数的<code>__len__</code>方法。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">'Go Bears!'</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Go Bears!'</span>.__len__()  <span class="comment"># 直接调用__len__方法</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果序列未提供<code>__bool__</code>方法，Python会使用序列的长度来确定其布尔值。空序列为False，而非空序列为True。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">''</span>)  <span class="comment"># 空字符串</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bool</span>(<span class="string">'Go Bears!'</span>)  <span class="comment"># 非空字符串</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>可调用对象</strong></p>
<p>在Python中，函数是第一类对象，可以像数据一样传递，并具有与其他对象相同的属性。Python还允许我们通过包含<code>__call__</code>方法来定义可以像函数一样“调用”的对象。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, k</span>):</span><br><span class="line">        <span class="keyword">return</span> self.n + k</span><br><span class="line"></span><br><span class="line">add_three_obj = Adder(<span class="number">3</span>)  <span class="comment"># 创建一个Adder对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_three_obj(<span class="number">4</span>)  <span class="comment"># 调用对象</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>算术运算</strong></p>
<p>特殊方法还可以定义应用于用户定义对象的内置运算符的行为。为了提供这种通用性，Python遵循特定协议来应用每个运算符。例如，为了评估包含<code>+</code>运算符的表达式，Python首先检查左操作数的<code>__add__</code>方法，然后检查右操作数的<code>__radd__</code>方法。</p>
<h4 id="2-7-3-多重表示法">2.7.3 多重表示法</h4>
<p><strong>抽象屏障</strong> 允许我们分离数据的使用与表示。然而，在大型程序中，可能并不总是能谈论“数据类型的底层表示”。可能会有多个有用的表示方式，我们希望设计能处理多重表示的系统。</p>
<h5 id="示例：复数的表示">示例：复数的表示</h5>
<p>复数可以用两种方式表示：矩形形式（实部和虚部）和极坐标形式（幅度和角度）。在不同情况下，两种形式可能都更合适。例如，矩形形式便于加法，而极坐标形式更适合于乘法。</p>
<p>以下是复数类的定义：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.add(other)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.mul(other)</span><br></pre></td></tr></tbody></table></figure>
<p>这里的 <code>Number</code> 类需要实现 <code>add</code> 和 <code>mul</code> 方法，但没有定义它们。这意味着 <code>Number</code> 不是直接实例化的，而是作为具体数字类的超类。</p>
<h5 id="复数类的实现">复数类的实现</h5>
<p>复数类 <code>Complex</code> 继承自 <code>Number</code>，并定义了复数的加法和乘法：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> ComplexRI(self.real + other.real, self.imag + other.imag)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self, other</span>):</span><br><span class="line">        magnitude = self.magnitude * other.magnitude</span><br><span class="line">        <span class="keyword">return</span> ComplexMA(magnitude, self.angle + other.angle)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="复数的矩形表示">复数的矩形表示</h5>
<p><code>ComplexRI</code> 类使用实部和虚部表示复数，并通过 <code>@property</code> 装饰器计算幅度和角度：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> atan2</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexRI</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, real, imag</span>):</span><br><span class="line">        self.real = real</span><br><span class="line">        self.imag = imag</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">magnitude</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> (self.real ** <span class="number">2</span> + self.imag ** <span class="number">2</span>) ** <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">angle</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> atan2(self.imag, self.real)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ComplexRI({0:g}, {1:g})'</span>.<span class="built_in">format</span>(self.real, self.imag)</span><br></pre></td></tr></tbody></table></figure>
<p>使用示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ri = ComplexRI(<span class="number">5</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">print</span>(ri.real)        <span class="comment"># 输出：5</span></span><br><span class="line"><span class="built_in">print</span>(ri.magnitude)   <span class="comment"># 输出：13.0</span></span><br><span class="line">ri.real = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(ri.magnitude)   <span class="comment"># 输出：15.0</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="复数的极坐标表示">复数的极坐标表示</h5>
<p><code>ComplexMA</code> 类使用幅度和角度表示复数：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sin, cos, pi</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComplexMA</span>(<span class="title class_ inherited__">Complex</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, magnitude, angle</span>):</span><br><span class="line">        self.magnitude = magnitude</span><br><span class="line">        self.angle = angle</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">real</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.magnitude * cos(self.angle)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">imag</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.magnitude * sin(self.angle)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ComplexMA({0:g}, {1:g} * pi)'</span>.<span class="built_in">format</span>(self.magnitude, self.angle/pi)</span><br></pre></td></tr></tbody></table></figure>
<p>使用示例：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">ma = ComplexMA(<span class="number">2</span>, pi/<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(ma.imag)       <span class="comment"># 输出：2.0</span></span><br><span class="line">ma.angle = pi</span><br><span class="line"><span class="built_in">print</span>(ma.real)       <span class="comment"># 输出：-2.0</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-7-4-泛型函数">2.7.4 泛型函数</h4>
<p><strong>泛型函数</strong> 是适用于不同类型参数的方法或函数。例如，<code>Complex.add</code> 方法可以接受 <code>ComplexRI</code> 或 <code>ComplexMA</code> 作为参数。</p>
<h5 id="示例：有理数类">示例：有理数类</h5>
<p>为了实现复数与有理数的混合操作，我们可以定义 <code>Rational</code> 类：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> gcd</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>(<span class="title class_ inherited__">Number</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, numer, denom</span>):</span><br><span class="line">        g = gcd(numer, denom)</span><br><span class="line">        self.numer = numer // g</span><br><span class="line">        self.denom = denom // g</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, other</span>):</span><br><span class="line">        nx, dx = self.numer, self.denom</span><br><span class="line">        ny, dy = other.numer, other.denom</span><br><span class="line">        <span class="keyword">return</span> Rational(nx * dy + ny * dx, dx * dy)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self, other</span>):</span><br><span class="line">        numer = self.numer * other.numer</span><br><span class="line">        denom = self.denom * other.denom</span><br><span class="line">        <span class="keyword">return</span> Rational(numer, denom)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="类型调度">类型调度</h5>
<p>通过<strong>类型调度</strong>，我们可以基于参数的类型选择行为：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_real</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="string">"""判断复数c是否为实数（没有虚部）"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(c, ComplexRI):</span><br><span class="line">        <span class="keyword">return</span> c.imag == <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(c, ComplexMA):</span><br><span class="line">        <span class="keyword">return</span> c.angle % pi == <span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="结论-2">结论</h5>
<p>通过抽象屏障和接口，我们可以在同一个程序中实现多种不同的数据表示。泛型函数允许我们在不改变程序意义的情况下，灵活处理不同类型的数据。</p>
<h5 id="注意事项">注意事项</h5>
<ul>
<li><strong>多重表示法</strong> 有助于应对复杂系统中不同的设计选择。</li>
<li><strong>泛型函数</strong> 提供了对不同类型的操作能力，增强了代码的灵活性与可维护性。</li>
<li><strong>类型调度</strong> 和 <strong>类型强制</strong> 是实现泛型函数的两种重要方法。</li>
</ul>
<hr>
<h3 id="2-8-效率">2.8 效率</h3>
<h4 id="2-8-1-测量效率">2.8.1 测量效率</h4>
<p>效率通常是由表示和处理数据的方式决定的。效率指的是某个表示或过程所需的计算资源，比如计算某个函数的结果所需的时间和内存。这些资源的使用情况可能因实现的细节而有所不同。</p>
<h5 id="斐波那契函数">斐波那契函数</h5>
<p>我们用计算斐波那契数列的树递归函数 <code>fib</code> 作为例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">2</span>) + fib(n-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>例如，调用 <code>fib(5)</code> 时，计算过程呈现树状结构。每个蓝点表示完成的斐波那契数计算。该函数效率低下，因为存在大量重复计算，特别是计算 <code>fib(3)</code> 的过程会被重复多次。</p>
<h5 id="计算调用次数">计算调用次数</h5>
<p>为了测量这个效率，可以使用高阶函数 <code>count</code> 来记录调用次数：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counted</span>(<span class="params">*args</span>):</span><br><span class="line">        counted.call_count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f(*args)</span><br><span class="line">    counted.call_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> counted</span><br><span class="line"></span><br><span class="line">fib = count(fib)</span><br><span class="line">fib(<span class="number">19</span>)</span><br><span class="line"><span class="built_in">print</span>(fib.call_count)  <span class="comment"># 输出：13529</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="空间复杂度">空间复杂度</h5>
<p>在评估函数的空间需求时，我们需要了解在计算环境中如何使用、保留和回收内存。评估表达式时，解释器会保留所有活动环境及其引用的值。树递归函数的空间需求通常与树的最大深度成正比。</p>
<p>例如，调用 <code>fib(3)</code> 的环境结构显示如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">fib(3)</span><br><span class="line"> ├─ fib(1)  # 完成后可回收</span><br><span class="line"> └─ fib(2)</span><br><span class="line">     ├─ fib(0)  # 完成后可回收</span><br><span class="line">     └─ fib(1)  # 活跃状态</span><br></pre></td></tr></tbody></table></figure>
<h5 id="使用帧计数器">使用帧计数器</h5>
<p>使用 <code>count_frames</code> 函数来跟踪活动帧的数量：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_frames</span>(<span class="params">f</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">counted</span>(<span class="params">*args</span>):</span><br><span class="line">        counted.open_count += <span class="number">1</span></span><br><span class="line">        counted.max_count = <span class="built_in">max</span>(counted.max_count, counted.open_count)</span><br><span class="line">        result = f(*args)</span><br><span class="line">        counted.open_count -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    counted.open_count = <span class="number">0</span></span><br><span class="line">    counted.max_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> counted</span><br><span class="line"></span><br><span class="line">fib = count_frames(fib)</span><br><span class="line">fib(<span class="number">19</span>)</span><br><span class="line"><span class="built_in">print</span>(fib.open_count)  <span class="comment"># 输出：0</span></span><br><span class="line"><span class="built_in">print</span>(fib.max_count)   <span class="comment"># 输出：19</span></span><br></pre></td></tr></tbody></table></figure>
<p>总结一下，<code>fib</code> 函数的空间需求与输入大小 <code>n</code> 的关系是 $\Theta(n)$，而时间需求则是 $\Theta(\phi^n)$，其中 $\phi$ 是黄金比例。</p>
<h4 id="2-8-2-备忘录化">2.8.2 备忘录化</h4>
<p>树递归计算过程可以通过备忘录化技术提高效率。备忘录化会存储任何先前接收参数的返回值，以避免重复计算。</p>
<h5 id="备忘录化的实现">备忘录化的实现</h5>
<p>以下定义创建了一个缓存来存储之前计算的结果：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">memo</span>(<span class="params">f</span>):</span><br><span class="line">    cache = {}</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">memoized</span>(<span class="params">n</span>):</span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[n] = f(n)</span><br><span class="line">        <span class="keyword">return</span> cache[n]</span><br><span class="line">    <span class="keyword">return</span> memoized</span><br></pre></td></tr></tbody></table></figure>
<p>将备忘录化应用于斐波那契函数，计算过程的模式如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">counted_fib = count(fib)</span><br><span class="line">fib = memo(counted_fib)</span><br><span class="line">fib(<span class="number">19</span>)</span><br><span class="line"><span class="built_in">print</span>(counted_fib.call_count)  <span class="comment"># 输出：20</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-8-3-增长阶数">2.8.3 增长阶数</h4>
<p>计算过程中消耗空间和时间的速度可能相差很大。通过增长阶数来分析过程，可以有效地描述资源需求如何随输入增长。</p>
<h5 id="示例：因数计数">示例：因数计数</h5>
<p>以下函数计算输入 <code>n</code> 的因数数量：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count_factors</span>(<span class="params">n</span>):</span><br><span class="line">    sqrt_n = sqrt(n)</span><br><span class="line">    k, factors = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> k &lt; sqrt_n:</span><br><span class="line">        <span class="keyword">if</span> n % k == <span class="number">0</span>:</span><br><span class="line">            factors += <span class="number">2</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k * k == n:</span><br><span class="line">        factors += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> factors</span><br><span class="line"></span><br><span class="line">result = count_factors(<span class="number">576</span>)  <span class="comment"># 输出：21</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="复杂度分析">复杂度分析</h5>
<p><code>count_factors(n)</code> 的执行时间为 $\Theta(\sqrt{n})$。这意味着总的计算步骤与输入的平方根成正比。</p>
<h4 id="2-8-4-示例：指数计算">2.8.4 示例：指数计算</h4>
<p>计算给定数字的指数可以通过以下递归实现：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>(<span class="params">b, n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> b * exp(b, n-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>这种线性递归过程的时间复杂度为 $\Theta(n)$，空间复杂度也为 $\Theta(n)$。</p>
<h5 id="使用快速幂法">使用快速幂法</h5>
<p>通过快速幂法，我们可以减少所需的步骤，例如：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fast_exp</span>(<span class="params">b, n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> square(fast_exp(b, n//<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b * fast_exp(b, n-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>在此实现中，所需的步骤和空间复杂度均为 $\Theta(\log n)$。</p>
<h4 id="2-8-5-增长类别">2.8.5 增长类别</h4>
<p>增长阶数帮助简化分析和比较计算过程，许多不同的过程可能具有相同的增长阶数。</p>
<h5 id="常见类别">常见类别</h5>
<table>
<thead>
<tr>
<th>类别</th>
<th>Theta 表示</th>
<th>增长描述</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>常数</td>
<td>$\Theta(1)$</td>
<td>增长与输入无关</td>
<td><code>abs</code></td>
</tr>
<tr>
<td>对数</td>
<td>$\Theta(\log n)$</td>
<td>输入增加资源增加</td>
<td><code>fast_exp</code></td>
</tr>
<tr>
<td>线性</td>
<td>$\Theta(n)$</td>
<td>输入增加资源线性增加</td>
<td><code>exp</code></td>
</tr>
<tr>
<td>二次</td>
<td>$\Theta(n^2)$</td>
<td>输入增加资源以平方速度增加</td>
<td><code>one_more</code></td>
</tr>
<tr>
<td>指数</td>
<td>$\Theta(b^n)$</td>
<td>输入增加资源以指数速度增加</td>
<td><code>fib</code></td>
</tr>
</tbody>
</table>
<p>对于快速增长的过程，变化的基数会影响增长阶数。</p>
<p>通过以上内容，可以更好地理解时间和空间复杂度，以及如何通过不同的技术提高效率。</p>
<hr>
<h3 id="2-9-递归对象">2.9 递归对象</h3>
<p>对象可以具有其他对象作为属性值。当一个类的对象具有该类的属性值时，它就是一个递归对象。这种结构在编程中非常有用，特别是在处理复杂数据结构时，如链表、树等。</p>
<h4 id="2-9-1-链表类">2.9.1 链表类</h4>
<p>链表是一种递归定义的数据结构，由一个首元素和其余部分组成。链表的其余部分本身也是一个链表。这种定义是递归的，因而形成了链表的特性。空链表是一个特殊的链表，它没有首元素或其余部分。</p>
<p>链表的特点包括：</p>
<ul>
<li><strong>有限长度</strong>：链表的长度是有限的，可以通过递归方法计算。</li>
<li><strong>元素选择</strong>：支持通过索引选择元素。</li>
</ul>
<h5 id="实现链表类">实现链表类</h5>
<p>下面我们实现一个链表类 <code>Link</code>，以便能够使用内置的 <code>len</code> 函数和元素选择操作符（如方括号或 <code>operator.getitem</code>）进行操作。这些内置函数会调用类的特殊方法名：</p>
<ul>
<li><code>__len__</code>：计算链表的长度。</li>
<li><code>__getitem__</code>：获取链表中的元素。</li>
</ul>
<p>在实现中，空链表用一个空元组表示，它的长度为 0，并且没有元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link</span>:</span><br><span class="line">    <span class="string">"""一个具有首元素和其余部分的链表。"""</span></span><br><span class="line">    empty = ()  <span class="comment"># 定义空链表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, rest=empty</span>):</span><br><span class="line">        <span class="comment"># 确保 rest 是空元组或 Link 的实例</span></span><br><span class="line">        <span class="keyword">assert</span> rest <span class="keyword">is</span> Link.empty <span class="keyword">or</span> <span class="built_in">isinstance</span>(rest, Link)</span><br><span class="line">        self.first = first  <span class="comment"># 首元素</span></span><br><span class="line">        self.rest = rest  <span class="comment"># 其余部分</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="comment"># 通过索引获取元素</span></span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.first</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.rest[i - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 计算链表的长度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">len</span>(self.rest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个链表实例</span></span><br><span class="line">s = Link(<span class="number">3</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(s))  <span class="comment"># 输出：3，表示链表的长度</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])    <span class="comment"># 输出：4，获取索引为 1 的元素</span></span><br></pre></td></tr></tbody></table></figure>
<p>在上述代码中，<code>__len__</code> 和 <code>__getitem__</code> 的定义实际上是递归的。当调用 <code>len(s)</code> 时，Python 内置函数 <code>len</code> 会调用 <code>s</code> 的 <code>__len__</code> 方法。在这个方法中，我们递归地调用 <code>len(self.rest)</code>，直到 <code>self.rest</code> 为 <code>Link.empty</code>，这时返回 0。类似地，<code>__getitem__</code> 方法也会递归地调用自身，以获取所需的元素。</p>
<h5 id="调试和字符串表示">调试和字符串表示</h5>
<p>为了方便调试，我们可以定义一个函数将链表转换为字符串表达式，以便查看链表的内容。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">link_expression</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="string">"""返回一个字符串，该字符串可以求值为 s。"""</span></span><br><span class="line">    <span class="keyword">if</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">        rest = <span class="string">''</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rest = <span class="string">', '</span> + link_expression(s.rest)  <span class="comment"># 递归获取剩余部分的表达式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Link({0}{1})'</span>.<span class="built_in">format</span>(s.first, rest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示链表的字符串表示</span></span><br><span class="line"><span class="built_in">print</span>(link_expression(s))  <span class="comment"># 输出：'Link(3, Link(4, Link(5)))'</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们希望在每次显示 <code>Link</code> 实例时都使用这个字符串表示。为此，可以将 <code>link_expression</code> 函数设置为特殊类属性 <code>__repr__</code> 的值，Python 将通过调用该方法来显示 <code>Link</code> 实例。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">Link.__repr__ = link_expression</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出：Link(3, Link(4, Link(5)))</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="链表的嵌套">链表的嵌套</h5>
<p><code>Link</code> 类具有闭包属性。就像一个列表的元素本身可以是一个列表一样，一个 <code>Link</code> 可以将另一个 <code>Link</code> 作为其首元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个嵌套的链表</span></span><br><span class="line">s_first = Link(s, Link(<span class="number">6</span>))</span><br><span class="line"><span class="built_in">print</span>(s_first)  <span class="comment"># 输出：Link(Link(3, Link(4, Link(5))), Link(6))</span></span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>s_first</code> 链表有两个元素，其中第一个元素是一个链表，包含三个元素，第二个元素是数字 6。</p>
<h5 id="递归处理链表">递归处理链表</h5>
<p>递归函数特别适合处理链表。例如，递归 <code>extend_link</code> 函数构建一个包含 <code>Link</code> 实例 <code>s</code> 的元素后跟 <code>Link</code> 实例 <code>t</code> 的链表。将此函数安装为 <code>Link</code> 类的 <code>__add__</code> 方法可以模拟内置列表的加法行为。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_link</span>(<span class="params">s, t</span>):</span><br><span class="line">    <span class="string">"""将两个链表 s 和 t 连接起来。"""</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> t  <span class="comment"># 如果 s 为空，返回 t</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Link(s.first, extend_link(s.rest, t))  <span class="comment"># 递归连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行链表加法</span></span><br><span class="line"><span class="built_in">print</span>(extend_link(s, s))  <span class="comment"># 输出：Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span></span><br><span class="line">Link.__add__ = extend_link</span><br><span class="line"><span class="built_in">print</span>(s + s)  <span class="comment"># 输出：Link(3, Link(4, Link(5, Link(3, Link(4, Link(5))))))</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="使用高阶函数处理链表">使用高阶函数处理链表</h5>
<p>而不是使用列表推导式，可以使用两个高阶函数：<code>map_link</code> 和 <code>filter_link</code> 从一个链表生成另一个链表。以下定义的 <code>map_link</code> 函数将函数 <code>f</code> 应用到链表 <code>s</code> 的每个元素，并构建一个包含结果的链表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">map_link</span>(<span class="params">f, s</span>):</span><br><span class="line">    <span class="string">"""将函数 f 应用到链表 s 的每个元素。"""</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> s  <span class="comment"># 如果链表为空，返回空链表</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归构建新的链表</span></span><br><span class="line">        <span class="keyword">return</span> Link(f(s.first), map_link(f, s.rest))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个平方函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 map_link 函数</span></span><br><span class="line"><span class="built_in">print</span>(map_link(square, s))  <span class="comment"># 输出：Link(9, Link(16, Link(25)))，每个元素平方</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>filter_link</code> 函数返回一个链表，包含链表 <code>s</code> 中所有 <code>f</code> 返回真值的元素。可以使用 <code>map_link</code> 和 <code>filter_link</code> 的组合来表达与列表推导式相同的逻辑。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">filter_link</span>(<span class="params">f, s</span>):</span><br><span class="line">    <span class="string">"""返回链表 s 中所有满足条件 f 的元素。"""</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> s  <span class="comment"># 如果链表为空，返回空链表</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        filtered = filter_link(f, s.rest)  <span class="comment"># 递归过滤</span></span><br><span class="line">        <span class="keyword">if</span> f(s.first):</span><br><span class="line">            <span class="keyword">return</span> Link(s.first, filtered)  <span class="comment"># 如果满足条件，加入链表</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> filtered  <span class="comment"># 否则直接返回过滤后的链表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个判断奇数的函数</span></span><br><span class="line">odd = <span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 map 和 filter 组合</span></span><br><span class="line"><span class="built_in">print</span>(map_link(square, filter_link(odd, s)))  <span class="comment"># 输出：Link(9, Link(25))</span></span><br><span class="line"><span class="built_in">print</span>([square(x) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>] <span class="keyword">if</span> odd(x)])  <span class="comment"># 输出：[9, 25]</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="连接链表的元素">连接链表的元素</h5>
<p><code>join_link</code> 函数递归构建一个包含链表元素的字符串，并以某个分隔符字符串分隔。结果比 <code>link_expression</code> 的输出更紧凑。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">join_link</span>(<span class="params">s, separator</span>):</span><br><span class="line">    <span class="string">"""返回一个由链表元素构成的字符串，元素之间用 separator 分隔。"""</span></span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>  <span class="comment"># 如果链表为空，返回空字符串</span></span><br><span class="line">    <span class="keyword">elif</span> s.rest <span class="keyword">is</span> Link.empty:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(s.first)  <span class="comment"># 如果只有一个元素，返回该元素</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(s.first) + separator + join_link(s.rest, separator)  <span class="comment"># 递归连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接链表元素</span></span><br><span class="line"><span class="built_in">print</span>(join_link(s, <span class="string">", "</span>))  <span class="comment"># 输出：'3, 4, 5'</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="递归构造示例">递归构造示例</h5>
<p>链表在递归计算时非常有用，尤其是在逐步构建序列时，这种情况经常发生。例如，我们可以使用递归方法来列举划分。</p>
<p>在第 1 章中，<code>count_partitions</code> 函数计算了使用不大于 <code>m</code> 的部分来划分整数 <code>n</code> 的方式。我们还可以使用类似的过程明确列举这些划分。</p>
<p>划分 <code>n</code> 使用不大于 <code>m</code> 的整数主要有两种方式：</p>
<ol>
<li>使用 <code>m</code> 的划分：划分 <code>n-m</code> 使用不大于 <code>m</code> 的整数。</li>
<li>不使用 <code>m</code> 的划分：划分 <code>n</code> 使用不大于 <code>m-1</code> 的整数。</li>
</ol>
<p>以下是关于树类和集合的学习笔记，包含适当的例子及时间复杂度的分析，使用了LaTeX格式。</p>
<h4 id="2-9-2-树类">2.9.2 树类</h4>
<p>树可以通过用户定义的类表示，而不是嵌套的内置序列类型。树是任何数据结构，其属性是一个分支序列，这些分支也是树。</p>
<h5 id="内部值"><strong>内部值</strong></h5>
<p>我们之前定义的树使所有值出现在树的叶子上。现在，我们定义树，使每个子树的根也有内部值。内部值在树中被称为标签。下面的 <code>Tree</code> 类表示这样的树，每棵树有一系列分支，分支也是树。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, label, branches=(<span class="params"></span>)</span>):</span><br><span class="line">        self.label = label</span><br><span class="line">        <span class="keyword">for</span> branch <span class="keyword">in</span> branches:</span><br><span class="line">            <span class="keyword">assert</span> <span class="built_in">isinstance</span>(branch, Tree)</span><br><span class="line">        self.branches = branches</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.branches:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Tree({0}, {1})'</span>.<span class="built_in">format</span>(self.label, <span class="built_in">repr</span>(self.branches))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Tree({0})'</span>.<span class="built_in">format</span>(<span class="built_in">repr</span>(self.label))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self.branches</span><br></pre></td></tr></tbody></table></figure>
<h5 id="例子：斐波那契树">例子：斐波那契树</h5>
<p><code>fib_tree(n)</code> 函数返回一个 <code>Tree</code>，其中包含第 <code>n</code> 个斐波那契数作为标签，并在其分支中追踪之前计算的所有斐波那契数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib_tree</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> Tree(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> Tree(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        left = fib_tree(n-<span class="number">2</span>)</span><br><span class="line">        right = fib_tree(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Tree(left.label + right.label, (left, right))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">fib_tree(<span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Tree(3, (Tree(1, (Tree(0), Tree(1))), Tree(2, (Tree(1), Tree(1, (Tree(0), Tree(1)))))))</span><br></pre></td></tr></tbody></table></figure>
<h5 id="递归处理">递归处理</h5>
<p>我们可以使用递归函数来计算树的标签之和。作为基例，返回空分支的标签和为0。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_labels</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="string">"""计算树实例的标签之和，可以是None。"""</span></span><br><span class="line">    <span class="keyword">return</span> t.label + <span class="built_in">sum</span>([sum_labels(b) <span class="keyword">for</span> b <span class="keyword">in</span> t.branches])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">sum_labels(fib_tree(<span class="number">5</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-9-3-集合">2.9.3 集合</h4>
<p>Python 还有一种内置的容器类型叫做集合（set）。集合文字遵循数学符号的表示方式，元素用大括号括起来。重复元素在构造时被移除。集合是无序的，因此打印顺序可能与集合文字中的元素顺序不同。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">s = {<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>}</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 输出 {1, 2, 3, 4}</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="集合操作">集合操作</h5>
<p>集合支持多种操作，包括成员测试、长度计算以及并集和交集等标准集合操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> s  <span class="comment"># 输出 True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算长度</span></span><br><span class="line"><span class="built_in">len</span>(s)  <span class="comment"># 输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 并集</span></span><br><span class="line">s.union({<span class="number">1</span>, <span class="number">5</span>})  <span class="comment"># 输出 {1, 2, 3, 4, 5}</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交集</span></span><br><span class="line">s.intersection({<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>})  <span class="comment"># 输出 {3, 4}</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="集合的实现">集合的实现</h5>
<h6 id="作为无序序列的集合">作为无序序列的集合</h6>
<p>一种表示集合的方法是将其视为一个不包含重复元素的序列。空集合由空序列表示。成员测试通过递归遍历列表。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">is</span> Link.empty</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">    <span class="string">"""如果集合 s 包含 v，则返回 True。"""</span></span><br><span class="line">    <span class="keyword">if</span> empty(s):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> s.first == v:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"></span><br><span class="line">s = Link(<span class="number">4</span>, Link(<span class="number">1</span>, Link(<span class="number">5</span>)))</span><br><span class="line">set_contains(s, <span class="number">2</span>)  <span class="comment"># 输出 False</span></span><br><span class="line">set_contains(s, <span class="number">5</span>)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></tbody></table></figure>
<p>此实现的 <code>set_contains</code> 在平均情况下需要 $\Theta(n)$ 时间，$n$ 是集合 s 的大小。</p>
<h6 id="作为有序序列的集合">作为有序序列的集合</h6>
<p>通过将集合元素按升序列出，可以加速集合操作。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">    <span class="keyword">if</span> empty(s) <span class="keyword">or</span> s.first &gt; v:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> s.first == v:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> set_contains(s.rest, v)</span><br><span class="line"></span><br><span class="line">u = Link(<span class="number">1</span>, Link(<span class="number">4</span>, Link(<span class="number">5</span>)))</span><br><span class="line">set_contains(u, <span class="number">0</span>)  <span class="comment"># 输出 False</span></span><br><span class="line">set_contains(u, <span class="number">4</span>)  <span class="comment"># 输出 True</span></span><br></pre></td></tr></tbody></table></figure>
<p>在最坏情况下，查找的步骤与无序表示相同，但在平均情况下，预计需要检查约一半的元素，因此平均所需的步骤为 $\Theta(n)$。</p>
<h6 id="作为二叉搜索树的集合">作为二叉搜索树的集合</h6>
<p>我们可以使用二叉树来表示集合，树的根节点包含一个元素，左分支包含所有小于根的元素，右分支包含所有大于根的元素。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">set_contains</span>(<span class="params">s, v</span>):</span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">        <span class="keyword">return</span> set_contains(s.right, v)</span><br><span class="line">    <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">        <span class="keyword">return</span> set_contains(s.left, v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结合前面的 adjoin_set 函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">adjoin_set</span>(<span class="params">s, v</span>):</span><br><span class="line">    <span class="keyword">if</span> s <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> Tree(v)</span><br><span class="line">    <span class="keyword">elif</span> s.entry == v:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">elif</span> s.entry &lt; v:</span><br><span class="line">        <span class="keyword">return</span> Tree(s.entry, s.left, adjoin_set(s.right, v))</span><br><span class="line">    <span class="keyword">elif</span> s.entry &gt; v:</span><br><span class="line">        <span class="keyword">return</span> Tree(s.entry, adjoin_set(s.left, v), s.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">adjoin_set(adjoin_set(adjoin_set(<span class="literal">None</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Tree(2, Tree(1), Tree(3))</span><br></pre></td></tr></tbody></table></figure>
<h5 id="时间复杂度">时间复杂度</h5>
<ul>
<li>在无序集合中，集合操作的时间复杂度为 $\Theta(n^2)$。</li>
<li>在有序集合中，查找的时间复杂度为 $\Theta(n)$，而交集操作可以优化为 $\Theta(n)$。</li>
<li>在平衡的二叉搜索树中，查找和添加元素的时间复杂度为 $\Theta(\log n)$，这对大集合的性能有显著提升。</li>
</ul>
<h5 id="Python-集合实现">Python 集合实现</h5>
<p>Python 内置的集合类型使用了一种基于哈希的技术实现，提供常数时间的成员测试和添加操作。由于哈希的性质，内置的 Python 集合不能包含可变数据类型，例如列表和字典。为允许嵌套集合，Python 还包括一个内置的不可变类 <code>frozenset</code>。</p>
<hr>
<h2 id="第三章：解释计算机程序">第三章：解释计算机程序</h2>
<h3 id="3-1-介绍">3.1 介绍</h3>
<p>第一、二章探讨了编程中两个基本要素——函数与数据之间的紧密联系。我们看到如何使用高阶函数将函数视为数据来操作，也了解了通过消息传递和面向对象系统赋予数据行为。此外，还学习了组织大型程序的技术，如函数抽象、数据抽象、类继承和泛型函数。这些核心概念为构建模块化、可维护、可扩展的程序奠定了坚实的基础。</p>
<p>本章重点介绍编程的第三个基本要素：程序本身。Python程序仅仅是一段文本，只有通过解释过程，才能基于该文本进行有意义的计算。像Python这样的编程语言之所以有用，是因为我们可以定义一个解释器——这个程序执行Python的求值和执行过程。可以说，解释器是编程中最基本的思想，它决定了编程语言中的表达式意义，而解释器本身也只是一个程序。</p>
<p>理解这一点会改变我们作为程序员的自我认知：我们不仅仅是使用他人设计语言的用户，而是语言的设计者。</p>
<h4 id="3-1-1-编程语言">3.1.1 编程语言</h4>
<p>编程语言在其语法结构、功能和应用领域方面有很大差异。在通用编程语言中，函数定义和函数应用是普遍存在的构造。然而，有些强大的语言不包含面向对象系统、高阶函数、赋值操作，甚至不包含控制结构（如while和for循环）。作为一个具有最小特性集合的强大语言的例子，文中引入了Scheme编程语言。本书介绍的Scheme子集完全不允许可变值。</p>
<p>本章我们研究解释器的设计以及其在执行程序时创建的计算过程。设计一个通用编程语言的解释器似乎是一项艰巨的任务，毕竟解释器是根据输入执行任何可能计算的程序。然而，许多解释器具有一种优雅的共同结构：两个相互递归的函数。第一个在环境中求值表达式，第二个将函数应用于参数。</p>
<p>这些函数是递归的，因为它们是基于彼此定义的：应用一个函数需要对其主体中的表达式进行求值，而求值表达式可能涉及应用一个或多个函数。</p>
<p>通过这一学习笔记，我们可以更好地理解程序设计中的解释器设计思想，并将程序员的角色从语言的使用者转变为语言的设计者。</p>
<hr>
<h3 id="3-2-函数式编程">3.2 函数式编程</h3>
<p>现代计算机上的软件使用多种编程语言编写。有物理语言，如特定计算机的机器语言。这些语言关注数据的表示和控制，涉及存储的位数和原始的机器指令。机器语言程序员专注于使用现有硬件构建系统和工具，以高效实现资源受限的计算。高层语言建立在机器语言的基础上，隐藏了关于数据作为位集合表示以及程序作为原始指令序列表示的关切。这些语言具有组合和抽象手段，如函数定义，适用于软件系统的大规模组织。</p>
<p>本节我们将介绍一种鼓励使用函数式编程风格的高级编程语言——Scheme语言的一个子集。它与Python有类似的计算模型，但只使用表达式（没有语句）、专注于符号计算，并只使用不可变的值。</p>
<h4 id="3-2-1-表达式">3.2.1 表达式</h4>
<p>Scheme程序由表达式组成，这些表达式要么是调用表达式，要么是特殊形式。调用表达式由操作符表达式和零个或多个操作数子表达式组成，类似于Python。操作符和操作数都包含在括号内：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">quotient</span></span> <span class="number">10</span> <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>结果是 <code>5</code>。Scheme完全使用前缀表示法，运算符通常是符号，如<code>+</code> 和 <code>*</code>。调用表达式可以嵌套，并且可以跨越多行：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">3</span> <span class="number">5</span>) (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> <span class="number">6</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>结果是 <code>19</code>。</p>
<p>再来看一个复杂的嵌套表达式：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">3</span></span><br><span class="line">      (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">2</span> <span class="number">4</span>)</span><br><span class="line">         (<span class="name"><span class="built_in">+</span></span> <span class="number">3</span> <span class="number">5</span>)))</span><br><span class="line">   (<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> <span class="number">7</span>)</span><br><span class="line">      <span class="number">6</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>结果是 <code>57</code>。</p>
<p>在Scheme中，表达式可以是原始的或组合的。数字字面量是原始的，而调用表达式是组合形式，包含任意的子表达式。Scheme的调用表达式的求值过程与Python类似：首先求值操作符和操作数表达式，然后将操作符的值（函数）应用于操作数的值（参数）。</p>
<h4 id="3-2-2-定义">3.2.2 定义</h4>
<p>值可以使用<code>define</code>特殊形式命名，例如：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> pi <span class="number">3.14</span>)</span><br><span class="line">(<span class="name"><span class="built_in">*</span></span> pi <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>结果是 <code>6.28</code>。</p>
<p>可以使用<code>define</code>定义新的函数（Scheme中称为过程）：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">square</span> x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们可以通过以下方式调用它：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name">square</span> <span class="number">21</span>)  <span class="comment">; 441</span></span><br><span class="line">(<span class="name">square</span> (<span class="name"><span class="built_in">+</span></span> <span class="number">2</span> <span class="number">5</span>))  <span class="comment">; 49</span></span><br><span class="line">(<span class="name">square</span> (<span class="name">square</span> <span class="number">3</span>))  <span class="comment">; 81</span></span><br></pre></td></tr></tbody></table></figure>
<p>匿名函数可以使用<code>lambda</code>表达式创建：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">*</span></span> x x))</span><br></pre></td></tr></tbody></table></figure>
<p>这一表达式与定义了函数的<code>define</code>相同，唯一的区别是它没有与任何名称关联。</p>
<h4 id="3-2-3-复合值">3.2.3 复合值</h4>
<p>Scheme中内置了对“对”（pair）的支持，使用<code>cons</code>函数创建，使用<code>car</code>和<code>cdr</code>函数访问对的元素：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> x (<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">(<span class="name"><span class="built_in">car</span></span> x)  <span class="comment">; 1</span></span><br><span class="line">(<span class="name"><span class="built_in">cdr</span></span> x)  <span class="comment">; 2</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以使用递归定义列表，例如：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cons</span></span> <span class="number">1</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">2</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">3</span> (<span class="name"><span class="built_in">cons</span></span> <span class="number">4</span> nil))))</span><br><span class="line"><span class="comment">; (1 2 3 4)</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="3-2-4-符号数据">3.2.4 符号数据</h4>
<p>Scheme中的一个优势是可以操作任意符号。使用单引号<code>'</code>可以构造符号列表，例如：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">list</span></span> <span class="symbol">'a</span> <span class="symbol">'b</span>)  <span class="comment">; (a b)</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个单引号类似于引用操作，用来表示不进行求值，而是直接使用符号本身。</p>
<h4 id="3-2-5-乌龟图形绘制（Turtle-Graphics）">3.2.5 乌龟图形绘制（Turtle Graphics）</h4>
<p>本节所介绍的Scheme实现中包含了Turtle图形绘制，这是一个源自Logo语言（另一种Lisp方言）的图形环境。乌龟图形绘制是通过让“乌龟”在画布上移动并绘制线条来实现的，最初旨在引导儿童学习编程，但它同样也是一个非常适合高级程序员的可视化工具。</p>
<p>在Scheme程序执行过程中，乌龟始终有一个位置和朝向。通过调用单参数过程，如<code>forward</code>和<code>right</code>，可以改变乌龟的当前位置和朝向。常用的指令有缩写，例如<code>forward</code>可以简写为<code>fd</code>。</p>
<h5 id="多重命令">多重命令</h5>
<p>Scheme中的<code>begin</code>特殊形式允许在一个表达式中包含多个子表达式，适合用于发出多个命令，例如：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">repeat</span> k fn) </span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> k <span class="number">0</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">begin</span></span> (<span class="name">fn</span>) (<span class="name">repeat</span> (<span class="name"><span class="built_in">-</span></span> k <span class="number">1</span>) fn))</span><br><span class="line">      nil))</span><br></pre></td></tr></tbody></table></figure>
<p>这个定义了一个<code>repeat</code>函数，可以多次重复执行某个函数。</p>
<h5 id="绘制五角星示例">绘制五角星示例</h5>
<p>可以使用<code>repeat</code>函数绘制复杂的图形，例如五角星：</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name">repeat</span> <span class="number">5</span></span><br><span class="line">        (<span class="name"><span class="built_in">lambda</span></span> () (<span class="name">fd</span> <span class="number">100</span>)</span><br><span class="line">                   (<span class="name">repeat</span> <span class="number">5</span></span><br><span class="line">                           (<span class="name"><span class="built_in">lambda</span></span> () (<span class="name">fd</span> <span class="number">20</span>) (<span class="name">rt</span> <span class="number">144</span>)))</span><br><span class="line">                   (<span class="name">rt</span> <span class="number">144</span>)))</span><br></pre></td></tr></tbody></table></figure>
<h5 id="递归绘制Sierpinski三角形">递归绘制Sierpinski三角形</h5>
<p>乌龟图形绘制还可以用于递归图形，例如Sierpinski三角形。以下是递归定义的Sierpinski三角形绘制过程：</p>
<ul>
<li><code>triangle</code>：重复绘制三次，并在每次绘制后左转。</li>
<li><code>sier</code>：接受一个边长<code>d</code>和递归深度<code>k</code>的参数。如果深度为1，则绘制普通三角形；否则通过调用<code>leg</code>来递归绘制。</li>
<li><code>leg</code>：绘制Sierpinski三角形的一条边，包含对<code>sier</code>的递归调用，先绘制一半边长，然后乌龟移动到下一个顶点。</li>
</ul>
<p>为了防止在乌龟移动时绘制多余的线条，可以使用<code>penup</code>和<code>pendown</code>过程抬起和放下乌龟的画笔。通过<code>sier</code>和<code>leg</code>的互相递归调用，可以绘制出完整的Sierpinski三角形。</p>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name">sier</span> <span class="number">400</span> <span class="number">6</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-3-异常处理（Exceptions）">3.3 异常处理（Exceptions）</h3>
<p>程序员在编写程序时，必须时刻注意可能出现的错误。常见的错误场景包括：函数接收到不符合要求的参数、所需资源缺失、或网络连接丢失。在设计程序时，应考虑可能出现的异常情况，并采取适当的措施进行处理。</p>
<p>没有统一的错误处理方法。对于提供持续服务的程序（如Web服务器），应在记录错误日志的同时尽可能继续提供服务。而对于解释型语言（如Python），解释器会立即终止程序并打印错误信息，方便程序员及时解决问题。无论如何，程序员都需要做出明确选择，决定程序在遇到异常时的反应。</p>
<h5 id="异常的引发（Raising-Exceptions）">异常的引发（Raising Exceptions）</h5>
<p>异常（Exception）是一个从<code>BaseException</code>类继承的对象。当Python解释器检测到表达式或语句中的错误时，会自动引发异常。用户也可以使用<code>raise</code>或<code>assert</code>语句手动引发异常。</p>
<ul>
<li>
<p><strong>示例1：引发异常</strong></p>
<p>在下面的例子中，我们引发了一个基本的异常<code>Exception</code>，并输出了自定义的错误信息 <code>"An error occurred"</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">raise</span> Exception(<span class="string">'An error occurred'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">Exception: an error occurred</span><br></pre></td></tr></tbody></table></figure>
<p>当引发异常后，当前代码块中的其他语句将不再执行。如果异常未被捕获和处理，解释器会直接返回到交互式会话或终止整个程序，并输出一个堆栈跟踪（stack backtrace），即展示异常发生时调用的嵌套函数。</p>
</li>
</ul>
<h5 id="异常的处理（Handling-Exceptions）">异常的处理（Handling Exceptions）</h5>
<p>可以通过<code>try</code>语句处理异常。<code>try</code>语句由多个子句组成，首先是<code>try</code>子句，后面是一个或多个<code>except</code>子句，用于捕获和处理不同类型的异常。</p>
<ul>
<li>
<p><strong>示例2：处理<code>ZeroDivisionError</code>异常</strong></p>
<p>在下面的例子中，尝试执行除法 <code>1/0</code> 时会引发 <code>ZeroDivisionError</code>。<code>except</code> 子句捕获到该异常，并输出处理信息，同时将 <code>x</code> 设置为 <code>0</code>。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">try</span>:</span><br><span class="line">        x = <span class="number">1</span> / <span class="number">0</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'handling a'</span>, <span class="built_in">type</span>(e))  <span class="comment"># 输出异常类型</span></span><br><span class="line">        x = <span class="number">0</span>  <span class="comment"># 设置 x 为 0</span></span><br><span class="line">handling a &lt;<span class="keyword">class</span> <span class="string">'ZeroDivisionError'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>当<code>1 / 0</code>导致<code>ZeroDivisionError</code>时，程序不会崩溃，而是跳转到<code>except</code>子句进行处理。在这个例子中，异常对象<code>e</code>被捕获并绑定到异常类<code>ZeroDivisionError</code>。</p>
</li>
<li>
<p><strong>示例3：处理函数中的异常</strong></p>
<p>下面的示例演示了如何在函数中处理异常。我们定义了两个函数：<code>invert</code> 和 <code>invert_safe</code>。在 <code>invert</code> 函数中，除数为 <code>0</code> 时会引发 <code>ZeroDivisionError</code>；而在 <code>invert_safe</code> 中，我们通过 <code>try-except</code> 结构捕获该异常，并返回错误信息。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">invert</span>(<span class="params">x</span>):</span><br><span class="line">        result = <span class="number">1</span> / x  <span class="comment"># 如果 x 为 0，会引发 ZeroDivisionError</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'This will not print if x is 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">invert_safe</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> invert(x)</span><br><span class="line">        <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(e)  <span class="comment"># 返回异常描述信息</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invert_safe(<span class="number">2</span>)</span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>invert_safe(<span class="number">0</span>)</span><br><span class="line"><span class="string">'division by zero'</span></span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，当 <code>invert(0)</code> 引发<code>ZeroDivisionError</code>时，<code>invert_safe(0)</code>捕获到异常并返回错误信息<code>'division by zero'</code>，而不是让程序崩溃。</p>
</li>
</ul>
<h4 id="3-3-1-异常对象（Exception-Objects）">3.3.1 异常对象（Exception Objects）</h4>
<p>异常对象可以拥有属性，如错误信息或异常发生的位置。用户还可以定义自己的异常类，并添加自定义属性。</p>
<ul>
<li>
<p><strong>示例4：定义自定义异常类</strong></p>
<p>在此例中，我们创建了一个名为<code>IterImproveError</code>的自定义异常类，继承自<code>Exception</code>，并增加了一个<code>last_guess</code>属性，用于存储迭代过程中的最后一个猜测值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">IterImproveError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, last_guess</span>):</span><br><span class="line">            self.last_guess = last_guess</span><br></pre></td></tr></tbody></table></figure>
<p>该异常类可在迭代改进算法中使用，当迭代过程中发生异常时，我们可以将最新的猜测值保存下来。</p>
</li>
<li>
<p><strong>示例5：在改进的牛顿法中使用自定义异常</strong></p>
<p>在这个示例中，改进的牛顿法使用了自定义的异常处理。<code>improve</code> 函数在发生 <code>ValueError</code> 时，会引发一个 <code>IterImproveError</code> 并存储当前猜测的值。<code>find_zero</code> 函数会捕获该异常并返回最后的猜测值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">improve</span>(<span class="params">update, done, guess=<span class="number">1</span>, max_updates=<span class="number">1000</span></span>):</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> done(guess) <span class="keyword">and</span> k &lt; max_updates:</span><br><span class="line">                guess = update(guess)</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> guess</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">raise</span> IterImproveError(guess)  <span class="comment"># 引发自定义异常并保存最后的猜测值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">f, guess=<span class="number">1</span></span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">done</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> f(x) == <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> improve(newton_update(f), done, guess)</span><br><span class="line">        <span class="keyword">except</span> IterImproveError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">return</span> e.last_guess  <span class="comment"># 返回最后的猜测值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>find_zero(<span class="keyword">lambda</span> x: <span class="number">2</span> * x * x + sqrt(x))</span><br><span class="line">-<span class="number">0.030211203830201594</span></span><br></pre></td></tr></tbody></table></figure>
<p>尽管这个结果距离正确答案 $0$ 仍有较大误差，但在某些应用中，能够返回一个粗略的近似值比抛出异常更有用。</p>
</li>
</ul>
<h5 id="时空复杂度分析（Time-and-Space-Complexity-Analysis）">时空复杂度分析（Time and Space Complexity Analysis）</h5>
<ol>
<li>
<p><strong>引发异常的时空复杂度</strong>：</p>
<p>当程序执行<code>raise</code>语句引发异常时，程序的控制流会立刻跳转到最近的异常处理器。因此，<code>raise</code>语句的时间复杂度为 $ O(1) $，因为它的执行时间与异常处理逻辑的复杂度无关。空间复杂度也为 $ O(1) $，因为引发异常本身只涉及常量空间。</p>
</li>
<li>
<p><strong>异常处理的时空复杂度</strong>：</p>
<p>对于<code>try-except</code>结构，<code>try</code>块中的代码的时间复杂度取决于其包含的代码逻辑。如果发生异常，程序会跳转到最近的<code>except</code>子句。这个跳转过程是常数时间的，因此异常处理的时间复杂度也是 $ O(1) $。在处理异常时，通常只绑定异常对象并执行一些处理逻辑，因此空间复杂度为 $ O(1) $。</p>
</li>
<li>
<p><strong>自定义异常类的时空复杂度</strong>：</p>
<p>创建自定义异常类的时间复杂度主要体现在实例化操作上，这通常是常数时间 $ O(1) $。自定义异常对象的空间复杂度取决于其存储的属性，在示例4中，<code>IterImproveError</code>类只存储了一个<code>last_guess</code>属性，因此其空间复杂度也是 $ O(1) $。</p>
</li>
<li>
<p><strong>改进的牛顿法中的时空复杂度</strong>：</p>
<p>在使用自定义异常的改进牛顿法中，假设最大迭代次数为 $ k $，则<code>improve</code>函数的时间复杂度为 $ O(k) $，因为它最多进行 $ k $ 次迭代。当发生异常时，异常处理器会保存最后的猜测值并返回，因此处理过程的时间复杂度为 $ O(1) $。同样，保存最后的猜测值只需常量空间，因此空间复杂度也是 $ O(1) $。</p>
</li>
</ol>
<hr>
<h3 id="3-4-解释器与组合语言">3.4 解释器与组合语言</h3>
<h4 id="概述">概述</h4>
<p>本节介绍了如何通过编写解释器（Interpreter）来定义新语言。解释器是一种函数，负责接受并执行一种编程语言的表达式。我们通过一个名为<strong>Calculator</strong>的Scheme子集语言来学习构建解释器的基本原理，最终将其扩展为Scheme的一个完整实现。</p>
<h4 id="3-4-1-Scheme语法的计算器（Calculator）">3.4.1 Scheme语法的计算器（Calculator）</h4>
<p>Calculator是一种基于Scheme的简单语言，支持基本的四则运算（加、减、乘、除）。它的语法和运算符行为与Scheme类似。每个表达式都是一个列表，运算符是第一个元素，后面跟随参数。</p>
<h5 id="示例">示例</h5>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>) <span class="comment">; 结果为 10</span></span><br><span class="line">(<span class="name"><span class="built_in">*</span></span>)         <span class="comment">; 结果为 1</span></span><br><span class="line">(<span class="name"><span class="built_in">-</span></span> <span class="number">10</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) <span class="comment">; 结果为 4</span></span><br><span class="line">(<span class="name"><span class="built_in">/</span></span> <span class="number">30</span> <span class="number">5</span> <span class="number">2</span>)  <span class="comment">; 结果为 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：</p>
<ul>
<li><code>(+ 1 2 3 4)</code> 代表求和运算，输出 10。</li>
<li><code>(*)</code> 表示乘法的空操作，返回 1。</li>
<li><code>(- 10 1 2 3)</code> 计算结果为 10 - 1 - 2 - 3，输出 4。</li>
<li><code>(/ 30 5 2)</code> 表示 30 除以 5 再除以 2，输出 3。</li>
</ul>
<h4 id="3-4-2-表达式树（Expression-Trees）">3.4.2 表达式树（Expression Trees）</h4>
<p>要编写解释器，我们需要将输入的表达式作为数据进行操作。一个基本表达式可以是数字或符号，而组合表达式通常是一个嵌套的Scheme列表。我们通过Python的<code>Pair</code>类模拟Scheme中的列表结构。</p>
<h5 id="示例-2">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Pair类用于构建表达式树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, first, second</span>):</span><br><span class="line">        self.first = first  <span class="comment"># 表示列表中的第一个元素</span></span><br><span class="line">        self.second = second  <span class="comment"># 表示剩余的部分（即列表的尾部）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建列表 (1 2) 对应于 Scheme 中的 (1 2)</span></span><br><span class="line">s = Pair(<span class="number">1</span>, Pair(<span class="number">2</span>, nil))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建表达式 (+ (* 3 4) 5)</span></span><br><span class="line">expr = Pair(<span class="string">'+'</span>, Pair(Pair(<span class="string">'*'</span>, Pair(<span class="number">3</span>, Pair(<span class="number">4</span>, nil))), Pair(<span class="number">5</span>, nil)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出嵌套表达式树：(+ (* 3 4) 5)</span></span><br><span class="line"><span class="built_in">print</span>(expr)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个例子中，<code>Pair</code> 类的实例用于构建表达式树，表达式树的结构体现了嵌套的操作，例如 <code>( + (* 3 4) 5)</code>。最终的计算结果是 <code>17</code>。</li>
</ul>
<h4 id="3-4-3-解析表达式（Parsing-Expressions）">3.4.3 解析表达式（Parsing Expressions）</h4>
<p>表达式解析的第一步是将输入的字符串解析成语法单元（Token）。然后，语法单元再进一步解析为嵌套的表达式树。</p>
<p><strong>词法分析</strong>：将输入字符串切割成符号（Token），如数字和运算符。</p>
<p><strong>语法分析</strong>：将Token序列转换为嵌套的表达式树。</p>
<h5 id="示例-3">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Scheme读取函数：将输入的字符串解析为表达式树</span></span><br><span class="line">lines = [<span class="string">'(+ 1'</span>, <span class="string">'   (* 2.3 45))'</span>]</span><br><span class="line">expression = scheme_read(Buffer(tokenize_lines(lines)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析结果：表达式树 (+ 1 (* 2.3 45))</span></span><br><span class="line"><span class="built_in">print</span>(expression)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>scheme_read</code> 函数使用递归的方法将语法单元（Token）序列解析为嵌套的表达式树，类似于解析嵌套的Scheme列表。</li>
</ul>
<h4 id="3-4-4-计算器的求值（Evaluation-of-Expressions）">3.4.4 计算器的求值（Evaluation of Expressions）</h4>
<p>计算器解释器的核心是一个递归的求值函数 <code>calc_eval</code>。这个函数的基本思路是：</p>
<ul>
<li>如果表达式是数字，直接返回该数字。</li>
<li>如果表达式是组合表达式（列表），则递归地对每个操作数求值，然后将结果传递给相应的运算符进行计算。</li>
</ul>
<h5 id="代码与注释">代码与注释</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_eval</span>(<span class="params">exp</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对表达式进行求值。</span></span><br><span class="line"><span class="string">    - 如果exp是数字，直接返回其值。</span></span><br><span class="line"><span class="string">    - 如果exp是一个组合表达式（列表），对每个操作数递归求值，然后调用calc_apply处理操作符。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(exp) <span class="keyword">in</span> (<span class="built_in">int</span>, <span class="built_in">float</span>):  <span class="comment"># 如果表达式是数字类型</span></span><br><span class="line">        <span class="keyword">return</span> simplify(exp)  <span class="comment"># 直接返回</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(exp, Pair):  <span class="comment"># 如果表达式是一个Pair，即组合表达式</span></span><br><span class="line">        <span class="comment"># 递归地求解参数部分，并将结果存入arguments列表</span></span><br><span class="line">        arguments = exp.second.<span class="built_in">map</span>(calc_eval)</span><br><span class="line">        <span class="comment"># 调用calc_apply函数根据操作符执行运算</span></span><br><span class="line">        <span class="keyword">return</span> simplify(calc_apply(exp.first, arguments))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f'<span class="subst">{exp}</span> is not a number or call expression'</span>)  <span class="comment"># 如果表达式既不是数字也不是组合表达式，则报错</span></span><br></pre></td></tr></tbody></table></figure>
<p>**<code>calc_apply</code>**函数负责应用操作符，它根据传入的操作符和参数执行相应的运算。</p>
<h5 id="示例-4">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc_apply</span>(<span class="params">operator, args</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    根据operator对args进行相应的计算。</span></span><br><span class="line"><span class="string">    支持的操作符包括 +, -, *, /。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> operator == <span class="string">'+'</span>:  <span class="comment"># 加法</span></span><br><span class="line">        <span class="keyword">return</span> reduce(add, args, <span class="number">0</span>)  <span class="comment"># 使用add函数将所有参数相加</span></span><br><span class="line">    <span class="keyword">elif</span> operator == <span class="string">'-'</span>:  <span class="comment"># 减法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -args.first  <span class="comment"># 单一参数时返回其相反数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(sub, args.second, args.first)  <span class="comment"># 多个参数时依次相减</span></span><br><span class="line">    <span class="keyword">elif</span> operator == <span class="string">'*'</span>:  <span class="comment"># 乘法</span></span><br><span class="line">        <span class="keyword">return</span> reduce(mul, args, <span class="number">1</span>)  <span class="comment"># 使用mul函数将所有参数相乘</span></span><br><span class="line">    <span class="keyword">elif</span> operator == <span class="string">'/'</span>:  <span class="comment"># 除法</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(args) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / args.first  <span class="comment"># 单一参数时返回其倒数</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> reduce(truediv, args.second, args.first)  <span class="comment"># 多个参数时依次相除</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(<span class="string">f'Unknown operator: <span class="subst">{operator}</span>'</span>)  <span class="comment"># 如果操作符未知，抛出异常</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="示例-5">示例</h5>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">+</span></span> (<span class="name"><span class="built_in">*</span></span> <span class="number">3</span> <span class="number">4</span>) <span class="number">5</span>)  <span class="comment">; 输出为17</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>(+ (* 3 4) 5)</code> 的求值过程首先计算内层表达式 <code>(* 3 4)</code>，其结果为 <code>12</code>。然后计算外层表达式 <code>( + 12 5)</code>，结果为 <code>17</code>。</li>
</ul>
<h4 id="3-4-5-交互式求值循环（REPL）">3.4.5 交互式求值循环（REPL）</h4>
<p>交互式解释器的经典实现是<strong>REPL</strong>（Read-Eval-Print Loop），它不断地读取用户输入、对表达式进行求值并打印结果。以下是一个简单的REPL实现，它能够处理用户的输入并返回相应的计算结果。</p>
<h5 id="示例-6">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_eval_print_loop</span>():</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    REPL 循环：</span></span><br><span class="line"><span class="string">    1. 读取用户输入的表达式。</span></span><br><span class="line"><span class="string">    2. 解析并求值。</span></span><br><span class="line"><span class="string">    3. 打印结果。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 读取输入行，并解析为表达式</span></span><br><span class="line">            src = buffer_input()</span><br><span class="line">            <span class="keyword">while</span> src.more_on_line:</span><br><span class="line">                expression = scheme_read(src)</span><br><span class="line">                <span class="built_in">print</span>(calc_eval(expression))  <span class="comment"># 对表达式求值并打印结果</span></span><br><span class="line">        <span class="keyword">except</span> (SyntaxError, TypeError, ValueError, ZeroDivisionError) <span class="keyword">as</span> err:</span><br><span class="line">            <span class="comment"># 处理各种错误并打印错误信息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">type</span>(err).__name__ + <span class="string">':'</span>, err)</span><br><span class="line">        <span class="keyword">except</span> (KeyboardInterrupt, EOFError):</span><br><span class="line">            <span class="comment"># 捕获退出命令（Ctrl+C 或 Ctrl+D）</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'Calculation completed.'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个函数实现了REPL的基本功能：</p>
<ul>
<li><strong>读取用户输入</strong>，并通过<code>scheme_read</code>解析为表达式树。</li>
<li><strong>求值</strong>表达式，并通过<code>calc_eval</code>函数计算其结果。</li>
<li><strong>打印</strong>求值结果，并在发生错误时捕捉并处理异常。</li>
</ul>
<h5 id="总结-7">总结</h5>
<p>通过编写一个简单的解释器，我们学习了如何解析表达式树、递归求值以及处理错误。这些是解释器和编译器设计中的基本概念。</p>
<hr>
<h3 id="3-5-支持抽象的语言解释器">3.5 支持抽象的语言解释器</h3>
<h4 id="概述-2">概述</h4>
<p>在这一节中，我们从简单的计算器语言（Calculator）转向更为通用的Scheme语言，该语言支持抽象，通过绑定名称到值，并定义新的操作来实现更复杂的计算。我们将描述如何构建一个支持抽象的解释器，并探讨环境模型及其在计算中的作用。</p>
<h4 id="3-5-1-解释器的结构">3.5.1 解释器的结构</h4>
<p>Scheme解释器的结构与之前的计算器解释器类似。它的基本流程包括解析表达式并通过求值器（Evaluator）执行表达式。不同之处在于Scheme语言支持用户定义的函数、特殊形式（Special Forms），并且依赖环境模型进行计算。</p>
<p><strong>解析（Parsing）：</strong><br>
解析过程由<code>scheme_reader</code>模块实现，该模块可以将Scheme表达式解析为嵌套的数据结构。然而，目前它还不支持点对列表（dotted lists）和引用（quotation）。要实现一个完整的Scheme解释器，我们需要扩展该模块。</p>
<h5 id="示例-7">示例</h5>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">car</span></span> '(<span class="number">1</span> . <span class="number">2</span>))  <span class="comment">; 解析为 (car (quote (1 . 2)))</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：<br>
<code>(car '(1 . 2))</code> 是一个调用表达式，<code>quote</code> 引用了一个点对列表 <code>(1 . 2)</code>。我们需要能够正确地解析这些语法结构。</p>
<p><strong>求值（Evaluation）：</strong><br>
求值是逐个表达式进行的。<code>scheme_eval</code>函数负责在当前环境下求值每个表达式。求值的主要内容包括三种形式：</p>
<ol>
<li>原子表达式（Primitive）</li>
<li>特殊形式（Special Forms）</li>
<li>调用表达式（Call Expressions）</li>
</ol>
<p><code>scheme_eval</code>函数会根据表达式的第一部分来决定如何处理。每种特殊形式都有其独特的求值规则。以下是一个简化的<code>scheme_eval</code>实现：</p>
<h5 id="示例-8">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scheme_eval</span>(<span class="params">expr, env</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在环境env中求值Scheme表达式expr。</span></span><br><span class="line"><span class="string">    - 如果expr是符号，返回其在环境中的值。</span></span><br><span class="line"><span class="string">    - 如果expr是原子，直接返回。</span></span><br><span class="line"><span class="string">    - 如果是组合表达式，根据其第一部分判断操作类型。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> scheme_symbolp(expr):</span><br><span class="line">        <span class="keyword">return</span> env[expr]  <span class="comment"># 查找符号在环境中的值</span></span><br><span class="line">    <span class="keyword">elif</span> scheme_atomp(expr):</span><br><span class="line">        <span class="keyword">return</span> expr  <span class="comment"># 返回原子值</span></span><br><span class="line">    first, rest = expr.first, expr.second</span><br><span class="line">    <span class="keyword">if</span> first == <span class="string">"lambda"</span>:</span><br><span class="line">        <span class="keyword">return</span> do_lambda_form(rest, env)  <span class="comment"># 处理lambda表达式</span></span><br><span class="line">    <span class="keyword">elif</span> first == <span class="string">"define"</span>:</span><br><span class="line">        do_define_form(rest, env)  <span class="comment"># 处理define表达式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 求值函数调用表达式</span></span><br><span class="line">        procedure = scheme_eval(first, env)</span><br><span class="line">        args = rest.<span class="built_in">map</span>(<span class="keyword">lambda</span> operand: scheme_eval(operand, env))</span><br><span class="line">        <span class="keyword">return</span> scheme_apply(procedure, args, env)  <span class="comment"># 应用函数</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：<br>
这个函数首先检查表达式类型，如果是符号则在当前环境中查找其绑定的值。如果是组合表达式（列表），则根据其第一部分来决定是特殊形式还是普通的函数调用。</p>
<p><strong>函数调用（Procedure Application）：</strong><br>
<code>scheme_apply</code>函数负责函数调用的实际执行。Scheme支持两种函数类型：</p>
<ol>
<li><strong>原生函数（PrimitiveProcedure）</strong>：用Python实现的函数。</li>
<li><strong>Lambda函数（LambdaProcedure）</strong>：用Scheme实现的函数。</li>
</ol>
<p>每个<code>LambdaProcedure</code>都包含一个<code>body</code>，该<code>body</code>是在一个新的环境中求值的。新的环境通过扩展当前环境来构造，参数列表中的符号与实际传入的参数值绑定。</p>
<h5 id="示例：">示例：</h5>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">1</span>))  <span class="comment">; 一个简单的Lambda表达式</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：<br>
在调用<code>LambdaProcedure</code>时，会为参数<code>x</code>创建一个新的环境，将传入的实际值绑定到<code>x</code>，然后对<code>(+ x 1)</code>进行求值。</p>
<p><strong>求值/应用的递归关系：</strong><br>
<code>scheme_eval</code>和<code>scheme_apply</code>是相互递归的。求值函数在遇到调用表达式时调用<code>scheme_apply</code>，而函数应用则依赖求值来解析操作数。这种互相递归的结构在解释器中非常常见，它是解释器求值过程的核心。</p>
<h4 id="3-5-2-环境（Environments）">3.5.2 环境（Environments）</h4>
<p><strong>环境的作用：</strong><br>
解释器中的环境模型由<code>Frame</code>类实现。每个<code>Frame</code>实例代表一个符号绑定到值的环境，并且有一个指向父环境的引用。通过这种方式，可以支持嵌套作用域。</p>
<p>环境的主要操作有两个：</p>
<ol>
<li><strong>lookup（查找）：</strong> 查找符号在环境中的值。如果当前环境没有找到，会递归查找父环境。</li>
<li><strong>define（定义）：</strong> 在当前环境中绑定符号到值。</li>
</ol>
<h5 id="示例-9">示例</h5>
<figure class="highlight scheme"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">factorial</span> n)</span><br><span class="line">  (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="number">1</span> (<span class="name"><span class="built_in">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line">(<span class="name">factorial</span> <span class="number">5</span>)  <span class="comment">; 计算结果为120</span></span><br></pre></td></tr></tbody></table></figure>
<p>解释：<br>
<code>define</code>创建了一个<code>LambdaProcedure</code>，其参数为<code>n</code>，在调用<code>factorial</code>时，会为<code>n</code>创建一个新的环境并绑定其值为5。接下来，解释器在这个新的环境中对<code>factorial</code>的主体进行求值，最终计算得到<code>120</code>。</p>
<p><strong>环境模型的实现：</strong><br>
<code>Frame</code>类的<code>lookup</code>和<code>define</code>方法是实现环境模型的关键。定义函数时，解释器需要创建一个新的<code>LambdaProcedure</code>并绑定到当前环境中。当调用该函数时，需要在一个新的环境中对其主体进行求值。</p>
<h5 id="示例-10">示例</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Frame</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent</span>):</span><br><span class="line">        self.bindings = {}  <span class="comment"># 当前环境的符号绑定</span></span><br><span class="line">        self.parent = parent  <span class="comment"># 父环境</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lookup</span>(<span class="params">self, symbol</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找符号symbol在当前或父环境中的值。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> symbol <span class="keyword">in</span> self.bindings:</span><br><span class="line">            <span class="keyword">return</span> self.bindings[symbol]</span><br><span class="line">        <span class="keyword">elif</span> self.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.parent.lookup(symbol)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">f"undefined symbol: <span class="subst">{symbol}</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">define</span>(<span class="params">self, symbol, value</span>):</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        在当前环境中定义symbol，并绑定其值为value。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.bindings[symbol] = value</span><br></pre></td></tr></tbody></table></figure>
<h4 id="总结-8">总结</h4>
<p>通过引入抽象机制，我们的Scheme解释器支持用户定义函数、局部变量和递归等复杂操作。环境模型通过作用域链实现了符号的绑定与查找。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/af5eaed1.html">https://www.heavenhold.cn/posts/af5eaed1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Computer-Science/">Computer Science</a><a class="post-meta__tags" href="/tags/CS61A/">CS61A</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124299.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/dd3f69da.html" title="hw整理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072127465.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hw整理</div></div></a></div><div class="next-post pull-right"><a href="/posts/13da47cc.html" title="王道计算机数据机构考研——绪论"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072123445.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">王道计算机数据机构考研——绪论</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/dd3f69da.html" title="hw整理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072127465.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="title">hw整理</div></div></a></div><div><a href="/posts/ceea78ef.html" title="lab整理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072125538.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-08</div><div class="title">lab整理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Summary"><span class="toc-number">1.</span> <span class="toc-text">Summary</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%94%A8%E5%87%BD%E6%95%B0%E6%9E%84%E5%BB%BA%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.1.</span> <span class="toc-text">第一章：用函数构建抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%85%A5%E9%97%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1   入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E4%BD%BF%E7%94%A8-Python-%E7%BC%96%E7%A8%8B"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1.1   使用 Python 编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%AE%89%E8%A3%85-Python-3"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.1.2   安装 Python 3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.1.3   交互式会话</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">1.1.4   第一个示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">1.1.5   错误处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 编程的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">1.2.1 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E8%B0%83%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">1.2.2 调用表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%AF%BC%E5%85%A5%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">1.2.3 导入库函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%90%8D%E7%A7%B0%E4%B8%8E%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">1.2.4 名称与环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E5%B5%8C%E5%A5%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B1%82%E5%80%BC"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">1.2.5 嵌套表达式的求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-6-%E9%9D%9E%E7%BA%AF%E7%B2%B9%E7%9A%84-print-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">1.2.6 非纯粹的 print 函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 定义新的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%96%B0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">1.3.1 定义一个新函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">1.3.2 函数调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">1.3.3 函数的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">1.3.4 局部变量与全局变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%8E%AF%E5%A2%83"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">1.3.5 函数的作用域与环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-%E6%8A%BD%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">1.3.6 抽象的作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E8%AE%BE%E8%AE%A1%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 设计函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E5%87%BD%E6%95%B0%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">1.4.1 函数的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E6%96%87%E6%A1%A3%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">1.4.2 文档说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">1.4.3 注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">1.4.4 默认参数值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1.5.1 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%A4%8D%E5%90%88%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">1.5.2 复合语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-II%EF%BC%9A%E5%B1%80%E9%83%A8%E8%B5%8B%E5%80%BC"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">1.5.3 定义函数 II：局部赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">1.5.4 条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-5-%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">1.5.5 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-6-%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.5.6.</span> <span class="toc-text">1.5.6 测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.5.7.</span> <span class="toc-text">实用建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.6.</span> <span class="toc-text">代码解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-sum-naturals-n"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">函数 sum_naturals(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E9%83%A8%E5%88%86"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">主程序部分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.8.</span> <span class="toc-text">1.6 高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">1.6.1 函数作为参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E9%80%9A%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">1.6.2 函数作为通用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-3-%E5%B5%8C%E5%A5%97%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.8.4.</span> <span class="toc-text">1.6.3 嵌套函数定义</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.8.4.1.</span> <span class="toc-text">词法作用域</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-4-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.8.5.</span> <span class="toc-text">1.6.4 函数作为返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-5-%E7%89%9B%E9%A1%BF%E6%B3%95%EF%BC%88Newton%E2%80%99s-Method%EF%BC%89"><span class="toc-number">1.1.8.6.</span> <span class="toc-text">1.6.5 牛顿法（Newton’s Method）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%8C%96%E8%87%B3%E4%BB%BB%E6%84%8F%E6%AC%A1%E6%95%B0%E7%9A%84%E6%A0%B9"><span class="toc-number">1.1.8.6.1.</span> <span class="toc-text">一般化至任意次数的根</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.1.8.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-6-%E6%9F%AF%E9%87%8C%E5%8C%96-Currying"><span class="toc-number">1.1.8.8.</span> <span class="toc-text">1.6.6 柯里化 (Currying)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-7-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.1.8.9.</span> <span class="toc-text">1.6.7 Lambda 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-8-%E6%8A%BD%E8%B1%A1%E4%B8%8E%E4%B8%80%E7%AD%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.8.10.</span> <span class="toc-text">1.6.8 抽象与一等函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-9-%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8-Function-Decorators"><span class="toc-number">1.1.8.11.</span> <span class="toc-text">1.6.9 函数装饰器 (Function Decorators)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">1.1.8.12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.9.</span> <span class="toc-text">1. 7 递归函数的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-0-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%B1%82%E8%87%AA%E7%84%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">1.7.0 示例：求自然数的数字和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">1.7.1 递归函数的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98"><span class="toc-number">1.1.9.2.1.</span> <span class="toc-text">例子：计算阶乘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E4%BA%92%E9%80%92%E5%BD%92"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">1.7.2 互递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E6%89%93%E5%8D%B0%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.9.4.</span> <span class="toc-text">1.7.3 打印递归函数中的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-4-%E6%A0%91%E5%BD%A2%E9%80%92%E5%BD%92"><span class="toc-number">1.1.9.5.</span> <span class="toc-text">1.7.4 树形递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-5-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%95%B4%E6%95%B0%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">1.1.9.6.</span> <span class="toc-text">1.7.5 示例：整数的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.1.9.7.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E6%9E%84%E5%BB%BA%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">第二章：通过数据构建抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%BC%95%E8%A8%80"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1  引言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">2.1.1  原生数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 数据抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%9C%89%E7%90%86%E6%95%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">2.2.1 例子：有理数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%EF%BC%9A%E5%AF%B9"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.2.2 复合数据：对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E6%8A%BD%E8%B1%A1%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">2.2.3 抽象屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-%E6%95%B0%E6%8D%AE%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">2.2.4 数据的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">2.3.1 列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%BA%8F%E5%88%97%E8%BF%AD%E4%BB%A3"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.3.2 序列迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E8%A7%A3%E5%8C%85"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">序列解包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-%E5%BA%8F%E5%88%97%E5%A4%84%E7%90%86"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2.3.3 序列处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%BA%8F%E5%88%97%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">2.3.4 序列抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">2.3.5 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">字符串的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-number">1.2.3.5.3.</span> <span class="toc-text">字符串的组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98%E8%B5%84%E6%A0%BC"><span class="toc-number">1.2.3.5.4.</span> <span class="toc-text">成员资格</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.2.3.5.5.</span> <span class="toc-text">多行字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.3.5.6.</span> <span class="toc-text">字符串强制转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E9%98%85%E8%AF%BB"><span class="toc-number">1.2.3.5.7.</span> <span class="toc-text">深入阅读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-6-%E6%A0%91"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">2.3.6 树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.3.6.1.</span> <span class="toc-text">树的基本实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%AA%8C%E8%AF%81%E5%92%8C%E5%8F%B6%E5%AD%90%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-number">1.2.3.6.2.</span> <span class="toc-text">树的验证和叶子的判断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%92%8C%E6%93%8D%E4%BD%9C%E6%A0%91"><span class="toc-number">1.2.3.6.3.</span> <span class="toc-text">构建和操作树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%8F%B6%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.3.6.4.</span> <span class="toc-text">计算叶子的数量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%A0%91"><span class="toc-number">1.2.3.6.5.</span> <span class="toc-text">分割树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%8C%96%E6%A0%91"><span class="toc-number">1.2.3.6.6.</span> <span class="toc-text">二叉化树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-7-%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">2.3.7 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.3.7.1.</span> <span class="toc-text">链表简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">1.2.3.7.2.</span> <span class="toc-text">链表的构造与选择器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.7.3.</span> <span class="toc-text">链表的验证与基本操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.3.7.4.</span> <span class="toc-text">递归操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0%E4%B8%8E%E7%BB%84%E5%90%88"><span class="toc-number">1.2.3.7.5.</span> <span class="toc-text">递归构造与组合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%88%92%E5%88%86"><span class="toc-number">1.2.3.7.6.</span> <span class="toc-text">输出划分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">1.2.3.7.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 可变数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9A%90%E5%96%BB"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1 对象的隐喻</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%BA%8F%E5%88%97%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2 序列对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.2.4.2.1.</span> <span class="toc-text">列表的可变性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E7%9A%84%E8%BA%AB%E4%BB%BD%E4%B8%8E%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">1.2.4.2.2.</span> <span class="toc-text">列表的身份与相等性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-number">1.2.4.2.3.</span> <span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-number">1.2.4.2.4.</span> <span class="toc-text">元组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%AD%97%E5%85%B8"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3 字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4 局部状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">2.4.5 非本地赋值的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6-%E9%9D%9E%E6%9C%AC%E5%9C%B0%E8%B5%8B%E5%80%BC%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">2.4.6 非本地赋值的代价</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7-%E5%AE%9E%E7%8E%B0%E5%8F%AF%E5%8F%98%E9%93%BE%E8%A1%A8%E5%92%8C%E5%AD%97%E5%85%B8"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">2.4.7 实现可变链表和字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-8-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F%E5%92%8C%E5%AD%97%E5%85%B8"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">2.4.8 消息传递系统和字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-9-%E7%BA%A6%E6%9D%9F%E4%BC%A0%E6%92%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">2.4.9 约束传播系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%91%84%E6%B0%8F%E6%B8%A9%E5%BA%A6%E4%B8%8E%E5%8D%8E%E6%B0%8F%E6%B8%A9%E5%BA%A6%E7%9A%84%E8%BD%AC%E6%8D%A2%E7%BD%91%E7%BB%9C"><span class="toc-number">1.2.4.9.1.</span> <span class="toc-text">摄氏温度与华氏温度的转换网络</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%A6%E6%9D%9F%E5%92%8C%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="toc-number">1.2.4.9.2.</span> <span class="toc-text">实现约束和连接器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 面向对象编程学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88OOP%EF%BC%89%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">2.5.1 面向对象编程（OOP）概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">2.5.2 定义类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.5.2.1.</span> <span class="toc-text">方法定义与调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E4%B8%8E%E7%82%B9%E5%8F%B7%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">2.5.3 消息传递与点号表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-4-%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">2.5.4 类属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.4.1.</span> <span class="toc-text">方法与函数的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">1.2.5.4.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-5-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">2.5.5 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-6-%E4%BD%BF%E7%94%A8%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">2.5.6 使用继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-7-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.5.7.</span> <span class="toc-text">2.5.7 多重继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-8-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">1.2.5.8.</span> <span class="toc-text">2.5.8 对象的角色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6 实现类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1-%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">2.6.1 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2-%E7%B1%BB"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">2.6.2 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-3-%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">2.6.3 使用实现的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%AF%B9%E8%B1%A1%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.7.</span> <span class="toc-text">2.7 对象抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">2.7.1 字符串转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">2.7.2 特殊方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E5%A4%9A%E9%87%8D%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">2.7.3 多重表示法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%A4%8D%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.7.3.1.</span> <span class="toc-text">示例：复数的表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.7.3.2.</span> <span class="toc-text">复数类的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E7%9A%84%E7%9F%A9%E5%BD%A2%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.7.3.3.</span> <span class="toc-text">复数的矩形表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%95%B0%E7%9A%84%E6%9E%81%E5%9D%90%E6%A0%87%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.7.3.4.</span> <span class="toc-text">复数的极坐标表示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-4-%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">2.7.4 泛型函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%9C%89%E7%90%86%E6%95%B0%E7%B1%BB"><span class="toc-number">1.2.7.4.1.</span> <span class="toc-text">示例：有理数类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.7.4.2.</span> <span class="toc-text">类型调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">1.2.7.4.3.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.7.4.4.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E6%95%88%E7%8E%87"><span class="toc-number">1.2.8.</span> <span class="toc-text">2.8 效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-1-%E6%B5%8B%E9%87%8F%E6%95%88%E7%8E%87"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">2.8.1 测量效率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.8.1.1.</span> <span class="toc-text">斐波那契函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">1.2.8.1.2.</span> <span class="toc-text">计算调用次数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.8.1.3.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%A7%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.2.8.1.4.</span> <span class="toc-text">使用帧计数器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-2-%E5%A4%87%E5%BF%98%E5%BD%95%E5%8C%96"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">2.8.2 备忘录化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.8.2.1.</span> <span class="toc-text">备忘录化的实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-3-%E5%A2%9E%E9%95%BF%E9%98%B6%E6%95%B0"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">2.8.3 增长阶数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%9B%A0%E6%95%B0%E8%AE%A1%E6%95%B0"><span class="toc-number">1.2.8.3.1.</span> <span class="toc-text">示例：因数计数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.8.3.2.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-4-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8C%87%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">2.8.4 示例：指数计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B3%95"><span class="toc-number">1.2.8.4.1.</span> <span class="toc-text">使用快速幂法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-8-5-%E5%A2%9E%E9%95%BF%E7%B1%BB%E5%88%AB"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">2.8.5 增长类别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%88%AB"><span class="toc-number">1.2.8.5.1.</span> <span class="toc-text">常见类别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E9%80%92%E5%BD%92%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.9.</span> <span class="toc-text">2.9 递归对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-1-%E9%93%BE%E8%A1%A8%E7%B1%BB"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">2.9.1 链表类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%93%BE%E8%A1%A8%E7%B1%BB"><span class="toc-number">1.2.9.1.1.</span> <span class="toc-text">实现链表类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.2.9.1.2.</span> <span class="toc-text">调试和字符串表示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">1.2.9.1.3.</span> <span class="toc-text">链表的嵌套</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.9.1.4.</span> <span class="toc-text">递归处理链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.9.1.5.</span> <span class="toc-text">使用高阶函数处理链表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.9.1.6.</span> <span class="toc-text">连接链表的元素</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%9E%84%E9%80%A0%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.9.1.7.</span> <span class="toc-text">递归构造示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-2-%E6%A0%91%E7%B1%BB"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">2.9.2 树类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%80%BC"><span class="toc-number">1.2.9.2.1.</span> <span class="toc-text">内部值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%A0%91"><span class="toc-number">1.2.9.2.2.</span> <span class="toc-text">例子：斐波那契树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86"><span class="toc-number">1.2.9.2.3.</span> <span class="toc-text">递归处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-9-3-%E9%9B%86%E5%90%88"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">2.9.3 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.9.3.1.</span> <span class="toc-text">集合操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.9.3.2.</span> <span class="toc-text">集合的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%97%A0%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.2.9.3.2.1.</span> <span class="toc-text">作为无序序列的集合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.2.9.3.2.2.</span> <span class="toc-text">作为有序序列的集合</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.2.9.3.2.3.</span> <span class="toc-text">作为二叉搜索树的集合</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.9.3.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Python-%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.9.3.4.</span> <span class="toc-text">Python 集合实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E8%A7%A3%E9%87%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">第三章：解释计算机程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 编程语言</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">3.2.2 定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%A4%8D%E5%90%88%E5%80%BC"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">3.2.3 复合值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">3.2.4 符号数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E4%B9%8C%E9%BE%9F%E5%9B%BE%E5%BD%A2%E7%BB%98%E5%88%B6%EF%BC%88Turtle-Graphics%EF%BC%89"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">3.2.5 乌龟图形绘制（Turtle Graphics）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%91%BD%E4%BB%A4"><span class="toc-number">1.3.2.5.1.</span> <span class="toc-text">多重命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E4%BA%94%E8%A7%92%E6%98%9F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.2.5.2.</span> <span class="toc-text">绘制五角星示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%BB%98%E5%88%B6Sierpinski%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">1.3.2.5.3.</span> <span class="toc-text">递归绘制Sierpinski三角形</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88Exceptions%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 异常处理（Exceptions）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%BC%95%E5%8F%91%EF%BC%88Raising-Exceptions%EF%BC%89"><span class="toc-number">1.3.3.0.1.</span> <span class="toc-text">异常的引发（Raising Exceptions）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%88Handling-Exceptions%EF%BC%89"><span class="toc-number">1.3.3.0.2.</span> <span class="toc-text">异常的处理（Handling Exceptions）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1%EF%BC%88Exception-Objects%EF%BC%89"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1 异常对象（Exception Objects）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88Time-and-Space-Complexity-Analysis%EF%BC%89"><span class="toc-number">1.3.3.1.1.</span> <span class="toc-text">时空复杂度分析（Time and Space Complexity Analysis）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BB%84%E5%90%88%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 解释器与组合语言</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-Scheme%E8%AF%AD%E6%B3%95%E7%9A%84%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88Calculator%EF%BC%89"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">3.4.1 Scheme语法的计算器（Calculator）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.4.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%EF%BC%88Expression-Trees%EF%BC%89"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3.4.2 表达式树（Expression Trees）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E8%A7%A3%E6%9E%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Parsing-Expressions%EF%BC%89"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">3.4.3 解析表达式（Parsing Expressions）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.3.4.4.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E8%AE%A1%E7%AE%97%E5%99%A8%E7%9A%84%E6%B1%82%E5%80%BC%EF%BC%88Evaluation-of-Expressions%EF%BC%89"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">3.4.4 计算器的求值（Evaluation of Expressions）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.4.5.1.</span> <span class="toc-text">代码与注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.3.4.5.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.3.4.5.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%B1%82%E5%80%BC%E5%BE%AA%E7%8E%AF%EF%BC%88REPL%EF%BC%89"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">3.4.5 交互式求值循环（REPL）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.3.4.6.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">1.3.4.6.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E6%94%AF%E6%8C%81%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%AF%AD%E8%A8%80%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 支持抽象的语言解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">3.5.1 解释器的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E7%8E%AF%E5%A2%83%EF%BC%88Environments%EF%BC%89"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3.5.2 环境（Environments）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-10"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>