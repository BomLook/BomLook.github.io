<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chapter3 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="Chapter 3
 3.1
 Knowledge checks 知识检查
 Where is transport-layer functionality primarily implemented?
 传输层功能主要在哪里实现？
 
 Transport layer functions are implemented primarily at the hosts at
 the “edge” o">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter3">
<meta property="og:url" content="https://www.heavenhold.cn/posts/488b60b7.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="Chapter 3
 3.1
 Knowledge checks 知识检查
 Where is transport-layer functionality primarily implemented?
 传输层功能主要在哪里实现？
 
 Transport layer functions are implemented primarily at the hosts at
 the “edge” o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072128477.webp">
<meta property="article:published_time" content="2024-11-05T02:53:00.000Z">
<meta property="article:modified_time" content="2024-11-05T02:58:24.856Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072128477.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/488b60b7.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chapter3',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-05 10:58:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">176</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072128477.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chapter3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-05T02:53:00.000Z" title="发表于 2024-11-05 10:53:00">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-05T02:58:24.856Z" title="更新于 2024-11-05 10:58:24">2024-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>114分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chapter3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="chapter-3">Chapter 3</h1>
<h2 id="section">3.1</h2>
<h3 id="knowledge-checks-知识检查">Knowledge checks 知识检查</h3>
<p>Where is transport-layer functionality primarily implemented?
传输层功能主要在哪里实现？</p>
<ul>
<li>Transport layer functions are implemented primarily at the hosts at
the “edge” of the network. 传输层功能主要在网络“边缘”的主机上实现。</li>
<li>Transport layer functions are implemented primarily at each end of a
physical link connecting one host/router/switch to another one
host/router/switch.
传输层功能主要在将一台主机/路由器/交换机连接到另一台主机/路由器/交换机的物理链路的每一端实现。</li>
<li>Transport layer functions are implemented primarily at the routers
and switches in the network.
传输层功能主要在网络中的路由器和交换机上实现。</li>
</ul>
<blockquote>
<p>传输层功能主要在网络“边缘”的主机上实现。这是因为传输层负责端到端的通信，包括数据流控制、可靠性、错误检测和修复等，主要涉及源主机和目标主机之间的数据传输。</p>
<p>因此，<strong>正确选项是：</strong></p>
<ul>
<li><strong>Transport layer functions are implemented primarily at the
hosts at the “edge” of the network.</strong></li>
</ul>
</blockquote>
<hr>
<p>True or False: The transport layer provides for host-to-host delivery
service? 对还是错：传输层提供主机到主机的传送服务？</p>
<ul>
<li>False 错误的</li>
<li>True. 真的</li>
</ul>
<blockquote>
<p><strong>True. 真的</strong></p>
<p>传输层确实提供主机到主机的传送服务，它负责在源主机和目标主机之间的通信和数据传输。</p>
</blockquote>
<hr>
<p>Check all of the services below that are provided by the TCP
protocol. 检查 TCP 协议提供的以下所有服务。</p>
<ul>
<li>A guarantee on the <em>minimum</em> amount of throughput that will
be provided between sender and receiver.
保证发送方和接收方之间提供的<em>最小</em>吞吐量。</li>
<li>A message abstraction, that preserves boundaries between message
data sent in different socket send calls at the sender.
消息抽象，保留发送者处不同套接字发送调用中发送的消息数据之间的边界。</li>
<li>A byte stream abstraction, that does not preserve boundaries between
message data sent in different socket send calls at the sender.
字节流抽象，不保留在发送方的不同套接字发送调用中发送的消息数据之间的边界。</li>
<li>Reliable data delivery. 可靠的数据传输。</li>
<li>A flow-control service that ensures that a sender will not send at
such a high rate so as to overflow receiving host buffers.
一种流量控制服务，可确保发送方不会以如此高的速率发送以致溢出接收主机缓冲区。</li>
<li>A guarantee on the maximum amount of time needed to deliver data
from sender to receiver.
保证将数据从发送方传送到接收方所需的最大时间。</li>
<li>In-order data delivery 按顺序传送数据</li>
<li>A congestion control service to ensure that multiple senders do not
overload network links.
拥塞控制服务可确保多个发送方不会使网络链路过载。</li>
</ul>
<blockquote>
<p>TCP 协议提供的服务包括：</p>
<ul>
<li><p><strong>A byte stream abstraction, that does not preserve
boundaries between message data sent in different socket send calls at
the sender.</strong></p></li>
<li><p><strong>Reliable data delivery.
可靠的数据传输。</strong></p></li>
<li><p><strong>A flow-control service that ensures that a sender will
not send at such a high rate so as to overflow receiving host
buffers.</strong></p></li>
<li><p><strong>In-order data delivery 按顺序传送数据</strong></p></li>
<li><p><strong>A congestion control service to ensure that multiple
senders do not overload network links.</strong></p></li>
</ul>
<p><strong>不包括的服务：</strong></p>
<ul>
<li><p><strong>A guarantee on the minimum amount of throughput that will
be provided between sender and receiver.</strong>（TCP
不提供最小吞吐量的保证）</p></li>
<li><p><strong>A message abstraction, that preserves boundaries between
message data sent in different socket send calls at the
sender.</strong></p></li>
<li><p><strong>A guarantee on the maximum amount of time needed to
deliver data from sender to receiver.</strong>（TCP
不提供最大传输时间的保证）</p></li>
</ul>
</blockquote>
<hr>
<p>Check all of the services below that are provided by the UDP
protocol. 检查以下由 UDP 协议提供的所有服务。</p>
<ul>
<li>A guarantee on the maximum amount of time needed to deliver data
from sender to receiver.
保证将数据从发送方传送到接收方所需的最大时间。</li>
<li>A guarantee on the <em>minimum</em> amount of throughput that will
be provided between sender and receiver.
保证发送方和接收方之间提供的<em>最小</em>吞吐量。</li>
<li>A flow-control service that ensures that a sender will not send at
such a high rate so as to overflow receiving host buffers.
一种流量控制服务，可确保发送方不会以如此高的速率发送以致溢出接收主机缓冲区。</li>
<li>A byte stream abstraction, that does not preserve boundaries between
message data sent in different socket send calls at the sender.
字节流抽象，不保留在发送方的不同套接字发送调用中发送的消息数据之间的边界。</li>
<li>A message abstraction, that preserves boundaries between message
data sent in different socket send calls at the sender.
消息抽象，保留发送者处不同套接字发送调用中发送的消息数据之间的边界。</li>
<li>Reliable data delivery. 可靠的数据传输。</li>
<li>In-order data delivery 按顺序传送数据</li>
<li>A congestion control service to ensure that multiple senders do not
overload network links.
拥塞控制服务可确保多个发送方不会使网络链路过载。</li>
</ul>
<blockquote>
<p>UDP
协议提供的服务主要是<strong>消息抽象</strong>，允许在发送者的不同套接字发送调用中保留消息数据之间的边界。它不提供其他服务，如可靠数据传输、顺序传输或流量控制。</p>
</blockquote>
<hr>
<p>The transport layer sits on top of the network layer, and provides
its services using the services provided to it by the network layer.
Thus it’s important that we know what is meant by the network layer’s
“best effort” delivery service. True or False:
传输层位于网络层之上，并使用网络层提供给它的服务来提供其服务。因此，了解网络层的“尽力而为”交付服务的含义非常重要。对或错：</p>
<p><em>The network layer’s best-effort delivery service means that IP
makes its “best effort” to deliver segments between communicating hosts,
but it makes no guarantees. In particular, it does not guarantee segment
delivery, it does not guarantee orderly delivery of segments, and it
does not guarantee the integrity of the data in the segments.
网络层的尽力传送服务意味着 IP
尽最大努力在通信主机之间传送数据段，但它不做任何保证。特别是，它不保证段交付，不保证段的有序交付，也不保证段中数据的完整性。</em></p>
<ul>
<li>Correct! The network layer’s best effort service doesn’t really
provide much service at all, does it?
正确的！网络层的尽力服务并没有真正提供太多服务，不是吗？、</li>
<li>Nope. The network layer’s best effort service doesn’t really provide
much service at all, does it?
没有。网络层的尽力服务并没有真正提供太多服务，不是吗？</li>
</ul>
<blockquote>
<p>正确的！网络层的尽力而为服务确实没有提供太多的保障。它尽最大努力将数据包传递到目标主机，但不保证数据包的到达、顺序或完整性。因此，传输层必须建立在此基础之上，提供更可靠的服务。</p>
<h2 id="解释">解释：</h2>
<p>网络层的“尽力而为”交付服务主要体现在以下几个方面：</p>
<ol type="1">
<li><p><strong>无保证交付</strong>：网络层（例如，IP
协议）会尽力将数据包（称为分段）传送到目标主机，但并不保证这些数据包一定会到达。例如，数据包可能会因为网络拥堵、路由器故障或目标主机不可达而丢失。</p></li>
<li><p><strong>无序交付</strong>：即使数据包成功到达，它们的到达顺序也可能与发送顺序不一致。网络中的路由器可能会根据网络条件选择不同的路径传送数据包，从而导致顺序颠倒。</p></li>
<li><p><strong>数据完整性不保证</strong>：网络层不负责检查数据包中的数据是否在传输过程中发生了损坏。虽然
IP
协议中有简单的校验和（checksum）机制来检测错误，但这并不等同于保证数据的完整性。</p></li>
</ol>
<p>由于这些原因，传输层（如
TCP）需要提供更高层次的服务，确保数据的可靠性和有序性。它通过实现重传机制、序列号和流量控制等技术来弥补网络层的不足，从而为应用层提供可靠的通信服务。</p>
</blockquote>
<h2 id="section-1">3.2</h2>
<h3 id="knowledge-checks-知识检查-1">Knowledge checks 知识检查</h3>
<p>What is meant by transport-layer demultiplexing?
传输层解复用是什么意思？</p>
<ul>
<li><p>Taking data from one socket (one of possibly many sockets),
encapsulating a data chuck with header information – thereby creating a
transport layer segment – and eventually passing this segment to the
network layer.
从一个套接字（可能是多个套接字之一）获取数据，用标头信息封装数据块 -
从而创建传输层段 - 并最终将该段传递到网络层。</p></li>
<li><p>Receiving a transport-layer segment from the network layer,
extracting the payload (data) and delivering the data to the correct
socket.
从网络层接收传输层报文段，提取有效负载（数据）并将数据传递到正确的套接字。</p></li>
<li><p>Taking data from multiple sockets, all associated with the same
destination IP address, adding destination port numbers to each piece of
data, and then concatenating these to form a transport-layer segment,
and eventually passing this segment to the network layer.
从多个套接字获取数据，所有数据都与相同的目标 IP
地址相关联，为每条数据添加目标端口号，然后将它们连接起来形成传输层段，并最终将该段传递到网络层。</p></li>
<li><p>Receiving a transport-layer segment from the network layer,
extracting the payload, determining the destination IP address for the
data, and then passing the segment and the IP address back down to the
network layer. 从网络层接收传输层数据段，提取有效负载，确定数据的目标 IP
地址，然后将该数据段和 IP 地址传回网络层。</p></li>
</ul>
<blockquote>
<p>传输层解复用（demultiplexing）是指将接收到的传输层数据段（segment）中的有效负载（payload）分发到正确的套接字的过程。这一过程的关键步骤如下：</p>
<ol type="1">
<li><p><strong>接收传输层段</strong>：传输层首先从网络层接收数据段，这些数据段包含了多个信息，包括源端口号、目标端口号和有效负载。</p></li>
<li><p><strong>提取有效负载</strong>：解复用过程提取数据段中的有效负载部分。这是实际需要传递给应用程序的数据。</p></li>
<li><p><strong>确定目标套接字</strong>：解复用过程中，传输层使用目标端口号来确定将有效负载传递给哪个套接字。每个套接字都对应于一个特定的端口，因此，通过匹配目标端口号，传输层可以识别出正确的接收应用程序。</p></li>
<li><p><strong>传递给正确的套接字</strong>：最后，解复用过程将提取到的有效负载交给对应的套接字，使得应用层能够处理接收到的数据。</p></li>
</ol>
<p>所以，正确的描述是：<br>
<strong>Receiving a transport-layer segment from the network layer,
extracting the payload (data), and delivering the data to the correct
socket.</strong><br>
这体现了如何将传输层的段中的数据分发到相应的应用程序，这就是解复用的核心概念。</p>
</blockquote>
<hr>
<p>What is meant by transport-layer multiplexing?
传输层复用是什么意思？</p>
<ul>
<li><p>Receiving a transport-layer segment from the network layer,
extracting the payload, determining the destination IP address for the
data, and then passing the segment and the IP address back down to the
network layer. 从网络层接收传输层数据段，提取有效负载，确定数据的目标 IP
地址，然后将该数据段和 IP 地址传回网络层。</p></li>
<li><p>Receiving a transport-layer segment from the network layer,
extracting the payload (data) and delivering the data to the correct
socket.
从网络层接收传输层报文段，提取有效负载（数据）并将数据传递到正确的套接字。</p></li>
<li><p>Taking data from multiple sockets, all associated with the same
destination IP address, adding destination port numbers to each piece of
data, and then concatenating these to form a transport-layer segment,
and eventually passing this segment to the network layer.
从多个套接字获取数据，所有数据都与相同的目标 IP
地址相关联，为每条数据添加目标端口号，然后将它们连接起来形成传输层段，并最终将该段传递到网络层。</p></li>
<li><p>Taking data from one socket (one of possibly many sockets),
encapsulating a data chuck with header information – thereby creating a
transport layer segment – and eventually passing this segment to the
network layer.
从一个套接字（可能是多个套接字之一）获取数据，用标头信息封装数据块 -
从而创建传输层段 - 并最终将该段传递到网络层。</p></li>
</ul>
<blockquote>
<p>传输层复用（multiplexing）是指将来自多个应用程序或套接字的数据组合在一起，以便通过网络层发送的过程。具体来说，这个过程包括以下几个关键步骤：</p>
<ol type="1">
<li><p><strong>数据聚合</strong>：传输层从多个套接字（可能来自不同的应用程序）接收数据。这些套接字可能都与同一个目的地
IP 地址相关联，但每个套接字都有其独特的端口号。</p></li>
<li><p><strong>封装数据</strong>：在复用的过程中，传输层会将每个套接字的数据段封装（encapsulate）在一个传输层段中，并添加必要的头部信息。头部信息通常包括源端口号和目标端口号，这些信息帮助识别数据的来源和去向。</p></li>
<li><p><strong>传递给网络层</strong>：最后，组合后的传输层段被传递到网络层，以便通过网络发送到目标主机。这样，多个应用程序的传输数据可以在一个网络连接中有效地发送。</p></li>
</ol>
<p>因此，<strong>Taking data from one socket (one of possibly many
sockets), encapsulating a data chunk with header information – thereby
creating a transport layer segment – and eventually passing this segment
to the network layer</strong>
是对传输层复用过程的正确描述。这个选项强调了从多个套接字获取数据并进行封装的关键操作，正是这一过程使得传输层能够有效地管理多个应用程序的数据流。</p>
</blockquote>
<hr>
<p>True or False: When multiple UDP clients send UDP segments to the
same destination port number at a receiving host, those segments (from
different senders) will always be directed to the same socket at the
receiving host. 对或错：当多个 UDP 客户端将 UDP
数据段发送到接收主机上的同一目标端口号时，这些数据段（来自不同的发送方）将始终定向到接收主机上的同一套接字。</p>
<ul>
<li>False 错误的</li>
<li>True 真的</li>
</ul>
<blockquote>
<p><strong>True. 真的</strong></p>
<p>当多个 UDP 客户端将 UDP
数据段发送到接收主机上的同一目标端口号时，这些数据段将始终定向到接收主机上的同一套接字。UDP
协议是无连接的，接收主机根据目标端口号将接收到的数据段分发到对应的套接字。因此，所有发送到同一目标端口的
UDP 数据段都会被定向到与该端口关联的同一套接字。</p>
</blockquote>
<hr>
<p>True or False: When multiple TCP clients send TCP segments to the
same destination port number at a receiving host, those segments (from
different senders) will always be directed to the same socket at the
receiving host. 对或错：当多个 TCP 客户端将 TCP
段发送到接收主机上的同一目标端口号时，这些段（来自不同的发送方）将始终定向到接收主机上的同一套接字。</p>
<ul>
<li>False 错误的</li>
<li>True 真的</li>
</ul>
<blockquote>
<p><strong>False. 错误的</strong></p>
<p>当多个 TCP 客户端将 TCP
段发送到接收主机上的同一目标端口号时，这些段（来自不同的发送方）不会始终定向到接收主机上的同一套接字。每个
TCP 连接由源 IP 地址、源端口号、目标 IP
地址和目标端口号唯一标识。因此，即使目标端口相同，不同源 IP
地址和端口号的 TCP 段会被定向到不同的套接字。这意味着对于每个独立的 TCP
连接，接收主机会创建不同的套接字来处理这些连接。</p>
</blockquote>
<hr>
<p>True or False: It is possible for two UDP segments to be sent from
the same socket with source port 5723 at a server to two different
clients. 对或错：两个 UDP 段可以从服务器上源端口 5723
的同一套接字发送到两个不同的客户端。</p>
<ul>
<li>False 错误的</li>
<li>True 真的</li>
</ul>
<blockquote>
<p><strong>True. 真的</strong></p>
<p>两个 UDP 段确实可以从服务器上源端口 5723
的同一套接字发送到两个不同的客户端。UDP
是无连接的协议，允许从同一源端口的套接字向多个目的地址发送数据。因此，服务器可以使用同一套接字（源端口
5723）同时向不同的客户端（不同的目标 IP 地址和目标端口）发送多个 UDP
段。这种特性使得 UDP 非常适合需要广播或多播的应用场景。</p>
</blockquote>
<hr>
<p>True or False: It is possible for two TCP segments with source port
80 to be sent by the sending host to different clients. 对或错：源端口为
80 的两个 TCP 段有可能由发送主机发送到不同的客户端。</p>
<ul>
<li>True 真的</li>
<li>False 错误的</li>
</ul>
<blockquote>
<p><strong>True. 真的</strong></p>
<p>源端口为 80 的两个 TCP 段确实可以由发送主机发送到不同的客户端。TCP
是面向连接的协议，允许同一源端口与多个目的端口之间建立独立的连接。因此，尽管源端口相同（在这种情况下为
80），发送主机仍然可以同时与多个客户端（不同的目标 IP
地址和目标端口）建立连接并发送 TCP 段。这种能力使得 Web
服务器能够同时处理来自多个客户端的请求。</p>
</blockquote>
<h2 id="section-2">3.3</h2>
<h3 id="knowledge-checks-知识检查-2">Knowledge checks 知识检查</h3>
<p>True or False: On the sending side, the UDP sender will take each
application-layer chunk of data written into a UDP socket and send it in
a distinct UDP datagram. And then on the receiving side, UDP will
deliver a segment’s payload into the appropriate socket, preserving the
application-defined message boundary. 对或错：在发送端，UDP
发送方会将每个应用层数据块写入 UDP 套接字，并以不同的 UDP
数据报形式发送。然后在接收端，UDP
会将数据段的有效负载传送到适当的套接字，从而保留应用程序定义的消息边界。</p>
<ul>
<li>False 错误的</li>
<li>True 真的</li>
</ul>
<blockquote>
<p><strong>True. 真的</strong></p>
<p>在 UDP 协议中，发送方确实会将每个应用层数据块（chunk）写入 UDP
套接字，并以不同的 UDP 数据报形式发送。UDP
是一个无连接的协议，它允许应用程序在发送数据时保留消息的边界。每个通过
UDP
发送的消息都与一个独立的数据报相对应，因此接收方可以准确地获取每个数据块而不需要进一步的处理。</p>
<p>在接收端，UDP
会将每个接收到的数据报的有效负载传递到适当的套接字，并保持应用程序定义的消息边界。这意味着接收方能够识别并处理每个单独的消息，而不会混淆来自不同发送的消息。这种特性使得
UDP
特别适合需要快速传输且不需要复杂连接管理的应用程序，如实时音频和视频流。</p>
</blockquote>
<hr>
<p>Which of the fields below are in a UDP segment header? <em>[Hint:
note the use of the word "header" in this question statement.]</em>
以下哪些字段位于 UDP 段标头中？
[提示：请注意此问题陈述中使用的“标题”一词。]</p>
<ul>
<li>Source IP address 源 IP 地址</li>
<li>Upper layer protocol 上层协议</li>
<li>Internet checksum 互联网校验和</li>
<li>Source port number 源端口号</li>
<li>Data (payload) 数据（有效负载）</li>
<li>Destination port number 目的端口号</li>
<li>Length (of UDP header plus payload) 长度（UDP 标头加负载）</li>
<li>Sequence number 序号</li>
</ul>
<blockquote>
<p>在 UDP 段标头中包含以下字段：</p>
<ol type="1">
<li><strong>Source port number 源端口号</strong></li>
<li><strong>Destination port number 目的端口号</strong></li>
<li><strong>Length (of UDP header plus payload) 长度（UDP
标头加负载）</strong></li>
<li><strong>Internet checksum 互联网校验和</strong></li>
</ol>
<p>其他字段如下所述：</p>
<ul>
<li><strong>Source IP address 源 IP 地址</strong>：不在 UDP
段标头中，而是位于 IP 标头中。</li>
<li><strong>Upper layer protocol 上层协议</strong>：UDP
标头中没有直接指明，而是在 IP 标头中指定的协议字段（如 TCP 或
UDP）。</li>
<li><strong>Data (payload) 数据（有效负载）</strong>：虽然有效负载是 UDP
段的一部分，但它不在标头中，而是附加在标头之后。</li>
<li><strong>Sequence number 序号</strong>：此字段属于 TCP 标头而不是 UDP
标头，UDP 不提供序列号功能。</li>
</ul>
</blockquote>
<hr>
<p>Why is the UDP header length field needed? 为什么需要 UDP
头长度字段？</p>
<ul>
<li><ol type="a">
<li>and (b) above 上述(a)和(b)</li>
</ol></li>
<li><p>Because this field is needed in TCP as well. 因为 TCP
中也需要这个字段。</p></li>
<li><p>Because the payload section can be of variable length, and this
lets UDP know where the segment ends.
因为有效负载部分的长度可以是可变的，这让 UDP
知道该段的结束位置。</p></li>
<li><p>To make the header and even number of bytes
使头部和字节数为偶数</p></li>
</ul>
<blockquote>
<p>UDP 头长度字段的必要性是：</p>
<p><strong>因为有效负载部分的长度可以是可变的，这让 UDP
知道该段的结束位置。</strong></p>
<p>这个字段允许接收方确定 UDP
数据报的总长度，从而正确地解析出有效负载的边界。这在网络通信中非常重要，因为不同的
UDP 数据报可能携带不同长度的数据。</p>
</blockquote>
<hr>
<p>Over what set of bytes is the checksum field in the UDP header
computed over? UDP 标头中的校验和字段是根据哪一组字节计算的？</p>
<ul>
<li>The entire UDP segment, except the checksum field itself. 整个 UDP
段，除了校验和字段本身。</li>
<li>Just the UDP header but not the payload. 只有 UDP
标头，但没有有效负载。</li>
<li>The entire UDP segment, except the checksum field itself, and the IP
sender and receive address fields 整个 UDP 段，除了校验和字段本身以及 IP
发送方和接收地址字段</li>
</ul>
<blockquote>
<p>UDP 头中的校验和字段是根据：</p>
<p><strong>整个 UDP 段，除了校验和字段本身以及 IP
发送方和接收地址字段</strong> 计算的。</p>
<p>校验和计算包括 UDP 头和有效负载，但不包括校验和字段自身和 IP
地址字段。这样做是为了确保传输的数据完整性，能够检测到在传输过程中发生的错误。</p>
</blockquote>
<hr>
<p>Which of the following statements are true about a checksum? Hint:
more than one statement is true.
以下关于校验和的哪些说法是正确的？提示：不止一个陈述是正确的。</p>
<ul>
<li><p>The sender-computed checksum value is often included in a
checksum field within a packet header.
发送方计算的校验和值通常包含在数据包标头内的校验和字段中。</p></li>
<li><p>The receiver of a packet with a checksum will add up the received
bytes, just as the sender did, and compare this locally-computed
checksum with the checksum value in the packet header. If these two
values are the <em>same</em> then the receiver <em>knows</em>that all of
the bits in the received packet are correct, i.e., that no bits have
been changed during transmission from sender to receiver.
带有校验和的数据包的接收方将像发送方一样将接收到的字节相加，并将本地计算的校验和与数据包标头中的校验和值进行比较。如果这两个值<em>相同</em>，则接收器<em>知道</em>接收到的数据包中的所有位都是正确的，即在从发送器到接收器的传输期间没有改变任何位。</p></li>
<li><p>The receiver of a packet with a checksum field will add up the
received bytes, just as the sender did, and compare this
locally-computed checksum with the checksum value in the packet header.
If these two values are <em>different</em> then the
receiver<em>knows</em> that one of the bits in the received packet has
been changed during transmission from sender to receiver.
带有校验和字段的数据包的接收方将像发送方一样将接收到的字节相加，并将本地计算的校验和与数据包标头中的校验和值进行比较。如果这两个值<em>不同</em>，则接收方<em>知道</em>接收到的数据包中的一位在从发送方传输到接收方的过程中已发生更改。</p></li>
<li><p>A checksum is computed at a sender by considering each byte
within a packet as a number, and then adding these numbers (each number
representing a bytes) together to compute a sum (which is known as a
checksum).
发送方通过将数据包中的每个字节视为一个数字，然后将这些数字（每个数字代表一个字节）相加来计算总和（称为校验和），从而在发送方计算校验和。</p></li>
</ul>
<blockquote>
<p>以下关于校验和的说法是正确的：</p>
<ol type="1">
<li><p><strong>发送方计算的校验和值通常包含在数据包标头内的校验和字段中。</strong></p></li>
<li><p><strong>带有校验和字段的数据包的接收方将像发送方一样将接收到的字节相加，并将本地计算的校验和与数据包标头中的校验和值进行比较。如果这两个值不同，则接收方知道接收到的数据包中的一位在从发送方传输到接收方的过程中已发生更改。</strong></p></li>
<li><p><strong>发送方通过将数据包中的每个字节视为一个数字，然后将这些数字（每个数字代表一个字节）相加来计算总和（称为校验和），从而在发送方计算校验和。</strong></p></li>
</ol>
<p>第一个和第二个选项描述了校验和在数据传输中的基本功能和验证过程，而第三个选项说明了校验和的计算方法。</p>
</blockquote>
<hr>
<p>Compute the Internet checksum value for these two 16-bit words:
11110101 11010011 and 10110011 01000100 计算这两个 16
位字的互联网校验和值： 11110101 11010011 和 10110011 01000100</p>
<p>答案：</p>
<p>计算方法：</p>
<ol type="1">
<li><strong>将 16 位字分成两组</strong>：将每个字分成 16 位。</li>
<li><strong>将这两个 16 位字转换为二进制数并相加</strong>：将这两个 16
位字进行二进制相加。</li>
<li><strong>处理进位</strong>：如果在相加的过程中有进位产生（即结果超过
16 位），需要将进位加到结果的最低有效位上。</li>
<li><strong>取反</strong>：将最终的结果进行按位取反以得到校验和。</li>
</ol>
<p>结果：$01010110 11100111 $</p>
<hr>
<p>Compute the Internet checksum value for these two 16-bit words:
01000001 11000100 and 00100000 00101011 计算这两个 16
位字的互联网校验和值： 01000001 11000100 和 00100000 00101011</p>
<p>答案：进行一样的处理，结果为<span class="math inline">\(10011110
00010000\)</span>。</p>
<hr>
<p>True or False: When computing the Internet checksum for two numbers,
a single flipped bit (i.e., in just one of the two numbers) will always
result in a changed checksum.
对或错：当计算两个数字的互联网校验和时，单个翻转位（即，仅在两个数字之一中）将始终导致校验和发生变化。</p>
<ul>
<li>True 真的</li>
<li>False 错误的</li>
</ul>
<blockquote>
<p>正确答案是 <strong>True 真的</strong>。</p>
<p>当计算两个数字的互联网校验和时，单个翻转位（即，仅在两个数字之一中）将始终导致校验和的变化。这是因为校验和的计算是通过将两个
16
位字相加，并对其进行求反。翻转一个位将改变该数字的总和，从而影响最终计算得到的校验和。因此，单个翻转位一定会导致校验和发生变化。</p>
</blockquote>
<hr>
<p>True or False: When computing the Internet checksum for two numbers,
a single flipped bit in each of the two numbers will always result in a
changed checksum.
对或错：计算两个数字的互联网校验和时，两个数字中每个数字的单个翻转位将始终导致校验和发生变化。</p>
<ul>
<li>True 真的</li>
<li>False 错误的</li>
</ul>
<blockquote>
<p>这个陈述是 <strong>False 错误的</strong>。</p>
<p>当计算两个数字的互联网校验和时，如果在每个数字中各翻转一个位，可能会出现一种情况，即校验和仍然保持不变。这是因为在加法运算中，一个数字的位翻转可能会影响总和，但如果两个翻转的位相互抵消或在校验和计算的过程中互相影响，最终的校验和可能不发生变化。</p>
</blockquote>
<hr>
<p>还有一道，直接跳过。</p>
<h2 id="section-3">3.4</h2>
<h3 id="knowledge-checks-知识检查-3">Knowledge checks 知识检查</h3>
<p>Consider the purposes/goals/use of different reliable data transfer
protocol mechanisms. For the given purpose/goal/use match it to the RDT
mechanism that is used to implement the given purpose/goal/use.
考虑不同可靠数据传输协议机制的目的/目标/使用。对于给定的目的/目标/用途，将其与用于实现给定的目的/目标/用途的
RDT 机制相匹配。</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li>Lets the sender know that a packet was NOT received correctly at the
receiver. 让发送方知道接收方未正确接收数据包。</li>
<li>Used by sender or receiver to detect bits flipped during a packet’s
transmission. 发送方或接收方使用它来检测数据包传输过程中翻转的位。</li>
<li>Allows for duplicate detection at receiver.
允许在接收器处进行重复检测。</li>
<li>Lets the sender know that a packet was received correctly at the
receiver. 让发送方知道接收方已正确接收到数据包。</li>
<li>Allows the receiver to eventually receive a packet that was
corrupted or lost in an earlier transmission.
允许接收方最终接收到在先前传输中损坏或丢失的数据包。</li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>ACK 确认</li>
<li>Checksum 校验和</li>
<li>Retransmission 重传</li>
<li>Sequence numbers 序列号</li>
<li>NAK</li>
</ol>
<p>答案： 52413。</p>
<blockquote>
<p>好的，让我们逐一匹配问题清单中的每个目的/目标/用途与相应的 RDT
机制：</p>
<ol type="1">
<li><p><strong>Let the sender know that a packet was NOT received
correctly at the receiver.</strong> &gt;
<strong>让发送方知道接收方未正确接收数据包。</strong></p>
<ul>
<li><strong>匹配机制：NAK</strong></li>
<li><strong>解释：</strong> NAK（Negative
Acknowledgment）用于通知发送方接收方未正确接收到某个数据包。接收方发送一个
NAK 消息，告诉发送方哪个数据包需要重新发送。</li>
</ul></li>
<li><p><strong>Used by sender or receiver to detect bits flipped during
a packet’s transmission.</strong> &gt;
<strong>发送方或接收方使用它来检测数据包传输过程中翻转的位。</strong></p>
<ul>
<li><strong>匹配机制：Checksum</strong></li>
<li><strong>解释：</strong>
校验和（Checksum）是一种用于检测数据包传输过程中错误的技术。发送方计算数据包的校验和并附带发送，接收方收到数据包后重新计算校验和并与发送方的校验和进行比较，如果不一致则说明数据包在传输过程中发生了错误。</li>
</ul></li>
<li><p><strong>Allows for duplicate detection at receiver.</strong> &gt;
<strong>允许在接收器处进行重复检测。</strong></p>
<ul>
<li><strong>匹配机制：Sequence numbers</strong></li>
<li><strong>解释：</strong> 序列号（Sequence
numbers）用于标识每个数据包的顺序。接收方通过检查序列号来检测重复的数据包，避免重复处理同一个数据包。</li>
</ul></li>
<li><p><strong>Let the sender know that a packet was received correctly
at the receiver.</strong> &gt;
<strong>让发送方知道接收方已正确接收到数据包。</strong></p>
<ul>
<li><strong>匹配机制：ACK</strong></li>
<li><strong>解释：</strong>
确认（ACK）用于通知发送方接收方已正确接收到某个数据包。接收方发送一个
ACK 消息，告诉发送方哪个数据包已被成功接收。</li>
</ul></li>
<li><p><strong>Allows the receiver to eventually receive a packet that
was corrupted or lost in an earlier transmission.</strong> &gt;
<strong>允许接收方最终接收到在先前传输中损坏或丢失的数据包。</strong></p>
<ul>
<li><strong>匹配机制：Retransmission</strong></li>
<li><strong>解释：</strong>
重传（Retransmission）是指当接收方检测到数据包丢失或损坏时，发送方重新发送该数据包，以确保接收方最终能够接收到完整且正确的数据包。</li>
</ul></li>
</ol>
<p>综上所述，匹配结果如下：</p>
<ol type="1">
<li><p><strong>Let the sender know that a packet was NOT received
correctly at the receiver.</strong></p>
<ul>
<li><strong>匹配机制：NAK</strong></li>
</ul></li>
<li><p><strong>Used by sender or receiver to detect bits flipped during
a packet’s transmission.</strong></p>
<ul>
<li><strong>匹配机制：Checksum</strong></li>
</ul></li>
<li><p><strong>Allows for duplicate detection at receiver.</strong></p>
<ul>
<li><strong>匹配机制：Sequence numbers</strong></li>
</ul></li>
<li><p><strong>Let the sender know that a packet was received correctly
at the receiver.</strong></p>
<ul>
<li><strong>匹配机制：ACK</strong></li>
</ul></li>
<li><p><strong>Allows the receiver to eventually receive a packet that
was corrupted or lost in an earlier transmission.</strong></p>
<ul>
<li><strong>匹配机制：Retransmission</strong></li>
</ul></li>
</ol>
</blockquote>
<hr>
<p>Consider the rdt 2.0 sender and receiver shown below, with FSM
transitions at the sender labeled S1, S2, and S3; and receiver
transitions labeled R1 and R2. 考虑如下所示的 rdt 2.0
发送方和接收方，发送方处的 FSM 转换标记为 S1、S2 和 S3；接收器转换标记为
R1 和 R2。</p>
<p>Which of the following sequences of transitions could possibly occur
as a result of an initial rdt_send() call at the sender, and possible
later message corruption and subsequent error recovery. 作为发送方的初始
rdt_send()
调用的结果，可能会发生以下哪种转换序列，以及可能的后续消息损坏和随后的错误恢复。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411030039327.webp"></p>
<ul>
<li>S1, R1, S3</li>
<li>S1, R2, S2</li>
<li>S1, S2, S3</li>
<li>S1, R1, S2, R2,S3</li>
<li>S1, R1, S2, R1, S3</li>
<li>S1, R2, S3</li>
<li>S1, R1, S2</li>
</ul>
<blockquote>
<p>为了理解为什么答案是 4、6、7，我们需要详细分析 rdt 2.0
协议的工作原理及其状态转换图。rdt 2.0
是一个简单的可靠数据传输协议，用于在不可靠的网络中实现可靠的数据传输。以下是
rdt 2.0 的状态转换图及其解释：</p>
<h3 id="发送方sender的状态转换">发送方（Sender）的状态转换</h3>
<ul>
<li><strong>初始状态（Idle）</strong>: 等待调用
<code>rdt_send()</code>。</li>
<li><strong>等待确认（Wait for ACK）</strong>:
发送数据包后，等待接收方的确认。</li>
</ul>
<h3 id="接收方receiver的状态转换">接收方（Receiver）的状态转换</h3>
<ul>
<li><strong>初始状态（Idle）</strong>: 等待接收数据包。</li>
<li><strong>等待数据包（Wait for Data Packet）</strong>:
接收到数据包后，发送确认。</li>
</ul>
<h3 id="状态转换">状态转换</h3>
<ul>
<li><strong>S1</strong>:
发送数据包，从初始状态（Idle）转移到等待确认状态（Wait for ACK）。</li>
<li><strong>S2</strong>: 超时后重传数据包，保持在等待确认状态（Wait for
ACK）。</li>
<li><strong>S3</strong>: 收到正确的 ACK，从等待确认状态（Wait for
ACK）返回初始状态（Idle）。</li>
<li><strong>R1</strong>: 收到正确的数据包，发送
ACK，从初始状态（Idle）转移到等待数据包状态（Wait for Data
Packet）。</li>
<li><strong>R2</strong>: 收到错误的数据包，发送
NAK，保持在等待数据包状态（Wait for Data Packet）。</li>
</ul>
<h3 id="分析每个选项">分析每个选项</h3>
<ol type="1">
<li><p><strong>S1, R1, S3</strong></p>
<ul>
<li>发送数据包（S1），接收方收到正确的数据包并发送
ACK（R1），发送方收到正确的 ACK 并回到初始状态（S3）。</li>
<li>这是一个有效的序列。</li>
</ul></li>
<li><p><strong>S1, R2, S2</strong></p>
<ul>
<li>发送数据包（S1），接收方收到错误的数据包并发送
NAK（R2），发送方不会进入超时重传状态（S2），因为 NAK
不会触发超时。</li>
<li>这不是一个有效的序列。</li>
</ul></li>
<li><p><strong>S1, S2, S3</strong></p>
<ul>
<li>发送数据包（S1），超时后重传数据包（S2），收到正确的 ACK
并回到初始状态（S3）。</li>
<li>这是一个有效的序列，但前提是必须先有一个超时事件。</li>
</ul></li>
<li><p><strong>S1, R1, S2, R2, S3</strong></p>
<ul>
<li>发送数据包（S1），接收方收到正确的数据包并发送
ACK（R1），发送方没有立即收到
ACK，超时后重传数据包（S2），接收方收到错误的数据包并发送
NAK（R2），发送方继续等待，最后收到正确的 ACK
并回到初始状态（S3）。</li>
<li>这是一个有效的序列。</li>
</ul></li>
<li><p><strong>S1, R1, S2, R1, S3</strong></p>
<ul>
<li>发送数据包（S1），接收方收到正确的数据包并发送
ACK（R1），发送方没有立即收到
ACK，超时后重传数据包（S2），接收方再次收到正确的数据包并发送
ACK（R1），发送方收到正确的 ACK 并回到初始状态（S3）。</li>
<li>这是一个有效的序列，但与选项 4 类似，只是没有 NAK。</li>
</ul></li>
<li><p><strong>S1, R2, S3</strong></p>
<ul>
<li>发送数据包（S1），接收方收到错误的数据包并发送
NAK（R2），发送方继续等待，最后收到正确的 ACK
并回到初始状态（S3）。</li>
<li>这是一个有效的序列，假设发送方在收到 NAK 后继续等待并最终收到正确的
ACK。</li>
</ul></li>
<li><p><strong>S1, R1, S2</strong></p>
<ul>
<li>发送数据包（S1），接收方收到正确的数据包并发送
ACK（R1），发送方没有立即收到 ACK，超时后重传数据包（S2）。</li>
<li>这是一个有效的序列，但前提是发送方在超时后重传数据包，但还没有收到
ACK。</li>
</ul></li>
</ol>
<h3 id="结论">结论</h3>
<p>根据以上分析，选项 4、6、7 都是可能发生的序列。因此，正确答案是
4、6、7。</p>
</blockquote>
<hr>
<p>Consider the rdt2.1 sender and receiver FSMs shown below, with
labeled transitions S1 through S6 at the sender, and transitions R1
through R6 at the receiver. The sender and receiver start in the “Wait
for call 0 from above” and “Wait for 0 from below” states, respectively.
考虑如下所示的 rdt2.1 发送器和接收器 FSM，其中发送器处标记为 S1 到 S6
转换，接收器处标记为 R1 到 R6
转换。发送方和接收方分别开始于“等待来自上方的呼叫 0”和“等待来自下方的
0”状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031022189.webp"></p>
<p>Suppose that no channel errors occur. A sequence of interleaved
sender and receiver transitions is given below. Transitions S1 and S4
are already provided. Choose the sender or receiver transition for the
unlabeled transitions <em>x1</em>, <em>x2, x3,</em> and <em>x4</em>
below to indicate the time-ordered sequence of transitions (interleaved
sender and receiver transitions) that will result in two messages being
delivered at the receiver, with the sender and receiver returning to
their initial states (again, given that no channel errors occur).
假设没有发生信道错误。下面给出了交错的发送器和接收器转换序列。已经提供了转换
S1 和 S4。为下面未标记的转换<em>x 1</em> 、 <em>x 2 、 x 3</em>和<em>x
4</em>选择发送者或接收者转换，以指示转换的时间顺序序列（交错的发送者和接收者转换），这将导致在接收者处传递两条消息，发送方和接收方返回到其初始状态（同样，假设没有发生通道错误）。</p>
<p>S1, <em>x1, x2,</em> S4, <em>x3, x4</em></p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li><p>transition <em>x1</em> 过渡<em>x 1</em></p></li>
<li><p>transition <em>x2</em> 过渡<em>x 2</em></p></li>
<li><p>transition <em>x3</em> 过渡<em>x 3</em></p></li>
<li><p>transition <em>x4</em> 过渡<em>x 4</em></p></li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>R3</li>
<li>R4</li>
<li>S3</li>
<li>S6</li>
<li>S2</li>
<li>R1</li>
</ol>
<blockquote>
<p>为了确定正确的转换序列，我们需要详细分析 rdt 2.1
协议的状态转换图及其工作原理。以下是详细的步骤和解释：</p>
<h3 id="发送方sender的状态转换-1">发送方（Sender）的状态转换</h3>
<ul>
<li><strong>初始状态（Wait for call 0 from above）</strong>: 等待调用
<code>rdt_send()</code>。</li>
<li><strong>等待确认状态（Wait for ACK 0 from below）</strong>:
发送数据包后，等待接收方的确认。</li>
<li><strong>等待确认状态（Wait for ACK 1 from below）</strong>:
发送数据包后，等待接收方的确认。</li>
</ul>
<h3 id="接收方receiver的状态转换-1">接收方（Receiver）的状态转换</h3>
<ul>
<li><strong>初始状态（Wait for 0 from below）</strong>:
等待接收数据包。</li>
<li><strong>等待数据包状态（Wait for 1 from below）</strong>:
接收到数据包后，发送确认。</li>
</ul>
<h3 id="状态转换-1">状态转换</h3>
<ul>
<li><p><strong>S1</strong>: 发送数据包 0，从初始状态（Wait for call 0
from above）转移到等待确认状态（Wait for ACK 0 from below）。</p></li>
<li><p><strong>S2</strong>: 发送数据包 1，从等待确认状态（Wait for ACK 0
from below）转移到等待确认状态（Wait for ACK 1 from below）。</p></li>
<li><p><strong>S3</strong>: 收到正确的 ACK 0，从等待确认状态（Wait for
ACK 0 from below）返回初始状态（Wait for call 0 from above）。</p></li>
<li><p><strong>S4</strong>: 收到正确的 ACK 1，从等待确认状态（Wait for
ACK 1 from below）返回初始状态（Wait for call 0 from above）。</p></li>
<li><p><strong>S5</strong>: 超时后重传数据包 0，保持在等待确认状态（Wait
for ACK 0 from below）。</p></li>
<li><p><strong>S6</strong>: 超时后重传数据包 1，保持在等待确认状态（Wait
for ACK 1 from below）。</p></li>
<li><p><strong>R1</strong>: 收到正确的数据包 0，发送 ACK
0，从初始状态（Wait for 0 from below）转移到等待数据包状态（Wait for 1
from below）。</p></li>
<li><p><strong>R2</strong>: 收到正确的数据包 1，发送 ACK
1，从等待数据包状态（Wait for 1 from below）转移到初始状态（Wait for 0
from below）。</p></li>
<li><p><strong>R3</strong>: 收到错误的数据包 0，发送 NAK
0，保持在等待数据包状态（Wait for 0 from below）。</p></li>
<li><p><strong>R4</strong>: 收到错误的数据包 1，发送 NAK
1，保持在等待数据包状态（Wait for 1 from below）.</p></li>
<li><p><strong>R5</strong>: 收到重复的数据包 0，发送 ACK
0，保持在等待数据包状态（Wait for 1 from below）。</p></li>
<li><p><strong>R6</strong>: 收到重复的数据包 1，发送 ACK
1，保持在等待数据包状态（Wait for 0 from below）。</p></li>
</ul>
<h3 id="给定序列">给定序列</h3>
<p><strong>初始状态</strong>：</p>
<ul>
<li>发送方：Wait for call 0 from above</li>
<li>接收方：Wait for 0 from below</li>
</ul>
<p><strong>序列：S1, x1, x2, S4, x3, x4</strong></p>
<ol type="1">
<li><p><strong>S1</strong>: 发送方发送数据包 0，转移到等待确认状态（Wait
for ACK 0 from below）。</p>
<ul>
<li>发送方：Wait for ACK 0 from below</li>
<li>接收方：Wait for 0 from below</li>
</ul></li>
<li><p><strong>x1</strong>: 接收方收到数据包 0，发送 ACK
0，转移到等待数据包状态（Wait for 1 from below）。</p>
<ul>
<li>发送方：Wait for ACK 0 from below</li>
<li>接收方：Wait for 1 from below</li>
<li><strong>匹配转换：R1</strong></li>
</ul></li>
<li><p><strong>x2</strong>: 发送方收到 ACK 0，返回初始状态（Wait for
call 0 from above）。</p>
<ul>
<li>发送方：Wait for call 0 from above</li>
<li>接收方：Wait for 1 from below</li>
<li><strong>匹配转换：S3</strong></li>
</ul></li>
<li><p><strong>S4</strong>: 发送方发送数据包 1，转移到等待确认状态（Wait
for ACK 1 from below）。</p>
<ul>
<li>发送方：Wait for ACK 1 from below</li>
<li>接收方：Wait for 1 from below</li>
</ul></li>
<li><p><strong>x3</strong>: 接收方收到数据包 1，发送 ACK
1，返回初始状态（Wait for 0 from below）。</p>
<ul>
<li>发送方：Wait for ACK 1 from below</li>
<li>接收方：Wait for 0 from below</li>
<li><strong>匹配转换：R2</strong></li>
</ul></li>
<li><p><strong>x4</strong>: 发送方收到 ACK 1，返回初始状态（Wait for
call 0 from above）。</p>
<ul>
<li>发送方：Wait for call 0 from above</li>
<li>接收方：Wait for 0 from below</li>
<li><strong>匹配转换：S4</strong></li>
</ul></li>
</ol>
<h3 id="结论-1">结论</h3>
<p>根据以上分析，未标记的转换 x1、x2、x3 和 x4 应分别为：</p>
<ul>
<li><strong>x1</strong>: R1</li>
<li><strong>x2</strong>: S3</li>
<li><strong>x3</strong>: R2</li>
<li><strong>x4</strong>: S4</li>
</ul>
<p>因此，答案是<strong>6324</strong>。</p>
</blockquote>
<hr>
<p>Consider the rdt2.1 sender and receiver FSMs shown below, with
labeled transitions S1 through S6 at the sender, and transitions R1
through R6 at the receiver. The sender and receiver start in the “Wait
for call 0 from above” and “Wait for 0 from below” states, respectively.
考虑如下所示的 rdt2.1 发送器和接收器 FSM，其中发送器处标记为 S1 到 S6
转换，接收器处标记为 R1 到 R6
转换。发送方和接收方分别开始于“等待来自上方的呼叫 0”和“等待来自下方的
0”状态。</p>
<p>Suppose that the initial message transmission by the sender is
corrupted, but that no other message transmissions are corrupted. Match
the unlabeled transitions <em>x1, x2, x3, x4, x5</em> in the
time-ordered sequence of transitions below (interleaved sender and
receiver transitions) that will occur following the initial S1
transition (which is corrupted), that will result in two messages being
delivered at the receiver, with the sender and receiver returning to
their initial states (again, given that the initial message transmission
by the sender is corrupted). Note that transitions S1, S4, and S6 are
already provided below.
假设发送方的初始消息传输已损坏，但其他消息传输没有损坏。将在初始 S1
转换（已损坏）之后发生的以下按时间排序的转换序列（交错的发送器和接收器转换）中的未标记转换<em>x
1 、 x 2 、 x 3 、 x 4 、 x
5</em>进行匹配，这将导致两条消息在接收方处传递，发送方和接收方返回到其初始状态（同样，假设发送方的初始消息传输已损坏）。请注意，下面已经提供了转换
S1、S4 和 S6。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031022189.webp"></p>
<p>S1 (message corrupted), <em>x1</em>, <em>x2</em>, <em>x3</em>,
<em>x4</em>, S4, <em>x5</em>, S6.</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li>transition x1 过渡 x 1</li>
<li>transition x2 过渡 x 2</li>
<li>transition x3 过渡 x 3</li>
<li>transition x4 过渡 x 4</li>
<li>transition x5 过渡 x 5</li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>S4</li>
<li>R6</li>
<li>S3</li>
<li>S2</li>
<li>R1</li>
<li>R4</li>
<li>R3</li>
</ol>
<p>答案：24536 。按照图片进行分析即可。</p>
<hr>
<p>Consider the rdt2.1 sender and receiver FSMs shown below, with
labeled transitions S1 through S6 at the sender, and transitions R1
through R6 at the receiver. The sender and receiver start in the “Wait
for call 0 from above” and “Wait for 0 from below” states, respectively.
考虑如下所示的 rdt2.1 发送器和接收器 FSM，其中发送器处标记为 S1 到 S6
转换，接收器处标记为 R1 到 R6
转换。发送方和接收方分别开始于“等待来自上方的呼叫 0”和“等待来自下方的
0”状态。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031022189.webp"></p>
<p>Suppose that the first packet from the sender is correctly received
at the receiver but that ACK message sent from receiver-to-sender is
corrupted; all other messages (before or after that ACK) are transmitted
error-free. Match the unlabeled transitions <em>x1, x2, x3, x4, x5</em>
in the time-ordered sequence of transitions below (interleaved sender
and receiver transitions) that will occur following the initial S1
transition, which is followed by a corrupted ACK transmission, that will
result in a message being delivered at the receiver, with the sender and
receiver returning to their initial states. Note that some transitions
are already provided below.
假设接收方正确接收到来自发送方的第一个数据包，但从接收方到发送方发送的
ACK 消息已损坏；所有其他消息（在该 ACK
之前或之后）均无差错地传输。匹配以下按时间排序的转换序列（交错的发送器和接收器转换)中的未标记转换<em>x
1 、 x 2 、 x 3 、 x 4 、 x 5 ，</em>这些转换将在初始 S1
转换之后发生，随后是损坏的 ACK
传输，这将导致消息被传递到接收者，发送者和接收者返回到它们的初始状态。请注意，下面已经提供了一些转换。</p>
<p>S1, <em>x1 (ACK corrupted)</em>, <em>x2</em>, <em>x3</em>,
<em>x4</em>, S4, <em>x5</em>, S6.</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li><p>transition x1 过渡 x 1</p></li>
<li><p>transition x2 过渡 x 2</p></li>
<li><p>transition x3 过渡 x 3</p></li>
<li><p>transition x4 过渡 x 4</p></li>
<li><p>transition x5 过渡 x 5</p></li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>R1</li>
<li>R2</li>
<li>R4</li>
<li>R3</li>
<li>S2</li>
<li>S3</li>
</ol>
<p>答案：15463，按图分析即可。</p>
<hr>
<p>What is meant by a cumulative acknowledgment, ACK<em>(n)</em>?
累积确认 ACK <em>(n)</em>是什么意思？</p>
<ul>
<li>A cumulative ACK<em>(n)</em> allows the receiver to let the sender
know that it has not received any packets with a new sequence number
since the last cumulative ACK<em>(n)</em> was sent. 累积 ACK
<em>(n)</em>允许接收方让发送方知道自上次发送累积 ACK
<em>(n)</em>以来，它尚未收到任何具有新序列号的数据包。</li>
<li>A cumulative ACK<em>(n)</em> allows the receiver to let the sender
know that it has not yet received an ACK for packet with sequence number
<em>n</em>. 累积 ACK
<em>(n)</em>允许接收方让发送方知道它尚未收到序列号为<em>n
的</em>数据包的 ACK。</li>
<li>A cumulative ACK<em>(n)</em> acks all packets with a sequence number
up to and including <em>n</em> as being received. 累积 ACK
<em>(n)</em>确认收到的序列号最多为<em>n（包括
n）</em>的所有数据包。</li>
</ul>
<blockquote>
<p>正确的定义是：</p>
<p><strong>累积 ACK (n)确认收到的序列号最多为 n（包括
n）的所有数据包。</strong></p>
<p>具体解释如下：</p>
<p>在传输控制协议（TCP）和其他类似的可靠传输协议中，累积确认（Cumulative
Acknowledgment,
ACK）是一种机制，用于确认已成功接收到的数据包。具体来说：</p>
<ul>
<li><strong>累积 ACK (n)</strong>
表示接收方已经成功收到了所有序列号小于或等于 <strong>n</strong>
的数据包。</li>
<li>这种确认方式简化了确认过程，因为接收方不需要为每个单独的数据包发送确认，而是可以一次性确认多个数据包。</li>
</ul>
<p>例如，如果接收方发送了一个累积
ACK(5)，这意味着接收方已经成功收到了序列号为 0, 1, 2, 3, 4, 和 5
的所有数据包。</p>
<p>这种机制有几个优点：</p>
<ol type="1">
<li><strong>减少网络流量</strong>：通过一次确认多个数据包，减少了确认消息的数量，从而降低了网络负载。</li>
<li><strong>简化处理</strong>：发送方可以更容易地跟踪哪些数据包已经被确认，哪些需要重传。</li>
<li><strong>提高效率</strong>：减少了不必要的确认消息，提高了整体通信效率。</li>
</ol>
</blockquote>
<hr>
<p>Suppose a packet is 10K bits long, the channel transmission rate
connecting a sender and receiver is 10 Mbps, and the round-trip
propagation delay is 10 ms. What is the maximum channel utilization of a
stop-and-wait protocol for this channel? 假设数据包长 10K
位，连接发送方和接收方的信道传输速率为 10Mbps，往返传播延迟为
10ms。该通道的停止等待协议的最大通道利用率是多少？</p>
<p>答案：<span class="math inline">\(0.1\)</span>。</p>
<blockquote>
<p>我们来详细解释如何计算停止等待协议的最大通道利用率。</p>
<h3 id="已知条件">已知条件：</h3>
<ul>
<li><strong>数据包长度</strong> = 10,000 位（10K 位）</li>
<li><strong>信道传输速率</strong> = 10 Mbps</li>
<li><strong>往返传播延迟</strong> = 10 毫秒（ms）</li>
</ul>
<h3 id="最大通道利用率计算公式">最大通道利用率计算公式：</h3>
<p>停止等待协议的最大通道利用率可以用以下公式表示：</p>
<p><span class="math display">\[
\text{利用率} = \frac{\text{传输时间}}{\text{传输时间} +
\text{往返时间}}
\]</span></p>
<p>其中：</p>
<ul>
<li><strong>传输时间</strong>
是指将一个数据包发送到信道上所需的时间。</li>
<li><strong>往返时间（RTT）</strong>
是指从发送方到接收方发送数据包、接收方返回 ACK 的整个往返时间。</li>
</ul>
<h3 id="步骤-1计算传输时间">步骤 1：计算传输时间</h3>
<p>传输时间的计算公式是：</p>
<p><span class="math display">\[
\text{传输时间} = \frac{\text{数据包长度}}{\text{信道传输速率}}
\]</span></p>
<p>将已知条件代入：</p>
<p><span class="math display">\[
\text{传输时间} = \frac{10,000 \text{ 位}}{10 \times 10^6 \text{ 位/秒}}
= 0.001 \text{ 秒} = 1 \text{ 毫秒}
\]</span></p>
<p>所以，传输时间为 1 毫秒。</p>
<h3 id="步骤-2确定往返时间rtt">步骤 2：确定往返时间（RTT）</h3>
<p>题目已给出往返传播延迟为 10 毫秒，因此：</p>
<p><span class="math display">\[
\text{RTT} = 10 \text{ 毫秒}
\]</span></p>
<h3 id="步骤-3计算通道利用率">步骤 3：计算通道利用率</h3>
<p>将传输时间和往返时间代入通道利用率公式：</p>
<p><span class="math display">\[
\text{利用率} = \frac{\text{传输时间}}{\text{传输时间} + \text{RTT}} =
\frac{1 \text{ 毫秒}}{1 \text{ 毫秒} + 10 \text{ 毫秒}} = \frac{1}{11}
\approx 0.0909
\]</span></p>
<h3 id="结论-2">结论</h3>
<p>因此，该信道在停止等待协议下的最大通道利用率约为
<strong>0.1</strong>（即 10%）。</p>
<p><strong>答案：0.1</strong></p>
</blockquote>
<hr>
<p>Suppose a packet is 10K bits long, the channel transmission rate
connecting a sender and receiver is 10 Mbps, and the round-trip
propagation delay is 10 ms. What is the channel utilization of a
pipelined protocol with an arbitrarily high level of pipelining for this
channel? 假设数据包长 10K 位，连接发送方和接收方的信道传输速率为
10Mbps，往返传播延迟为
10ms。对于该通道具有任意高水平的流水线的流水线协议的通道利用率是多少？</p>
<p>答案：<span class="math inline">\(1.0\)</span>。</p>
<blockquote>
<p>在具有任意高水平的流水线的情况下（即可以在一个往返时间内发送多个数据包），通道的利用率将接近
<strong>100%</strong>。让我们具体分析一下原因。</p>
<h3 id="已知条件-1">已知条件：</h3>
<ul>
<li><strong>数据包长度</strong> = 10,000 位</li>
<li><strong>信道传输速率</strong> = 10 Mbps</li>
<li><strong>往返传播延迟</strong> = 10 毫秒（ms）</li>
</ul>
<h3 id="流水线协议的通道利用率">流水线协议的通道利用率</h3>
<p>在停止等待协议中，每发送一个数据包后，发送方必须等待接收方的确认（ACK）才能发送下一个数据包，因此会浪费大量等待时间，导致通道利用率较低。</p>
<p>而在具有<strong>任意高水平的流水线</strong>的情况下，发送方不需要等待确认，而是可以在一个往返时间内连续发送多个数据包。这种情况下，通道利用率的计算公式为：</p>
<p><span class="math display">\[
\text{利用率} = \frac{\text{发送数据的时间}}{\text{发送数据的时间} +
\text{RTT}}
\]</span></p>
<h3 id="步骤-1计算传输时间-1">步骤 1：计算传输时间</h3>
<p>传输时间计算方法如下：</p>
<p><span class="math display">\[
\text{传输时间} = \frac{\text{数据包长度}}{\text{信道传输速率}}
\]</span></p>
<p>将数据代入：</p>
<p><span class="math display">\[
\text{传输时间} = \frac{10,000 \text{ 位}}{10 \times 10^6 \text{ 位/秒}}
= 0.001 \text{ 秒} = 1 \text{ 毫秒}
\]</span></p>
<h3 id="步骤-2计算在一个-rtt-内可以发送的数据包数量">步骤 2：计算在一个
RTT 内可以发送的数据包数量</h3>
<p>往返时间（RTT）为 10 毫秒，而每个数据包的传输时间是 1
毫秒。因此，在一个 RTT 时间内可以发送的数据包数量为：</p>
<p><span class="math display">\[
\frac{\text{RTT}}{\text{传输时间}} = \frac{10 \text{ 毫秒}}{1 \text{
毫秒}} = 10 \text{ 个数据包}
\]</span></p>
<p>在高水平的流水线协议下，发送方可以在一个 RTT 内连续发送 10
个数据包，从而保持信道始终忙碌，因此通道的利用率趋向于 100%。</p>
<h3 id="结论-3">结论</h3>
<p>对于具有任意高水平流水线的协议，通道利用率可以接近
<strong>1.0</strong> 或
<strong>100%</strong>，因为信道始终在传输数据，没有浪费时间。</p>
<p><strong>答案：1.0</strong></p>
</blockquote>
<hr>
<p>Suppose a packet is 10K bits long, the channel transmission rate
connecting a sender and receiver is 10 Mbps, and the round-trip
propagation delay is 10 ms. How many packets can the sender transmit
before it starts receiving acknowledgments back? 假设数据包长 10K
位，连接发送方和接收方的信道传输速率为 10Mbps，往返传播延迟为
10ms。发送方在开始接收回确认之前可以传输多少个数据包？</p>
<p>答案： <span class="math inline">\(10\)</span>。</p>
<blockquote>
<p>在这种情况下，发送方在开始接收确认之前可以传输的数据包数量等于一个往返时间（RTT）内能够传输的总数据量除以每个数据包的大小。</p>
<h3 id="已知条件-2">已知条件：</h3>
<ul>
<li><strong>数据包长度</strong> = 10,000 位</li>
<li><strong>信道传输速率</strong> = 10 Mbps</li>
<li><strong>往返传播延迟（RTT）</strong> = 10 毫秒（ms）</li>
</ul>
<h3 id="步骤-1计算在一个-rtt-内可以传输的总数据量">步骤 1：计算在一个
RTT 内可以传输的总数据量</h3>
<p>一个 RTT 表示从发送方发送数据到接收方收到并回复 ACK，发送方再接收到
ACK 的时间。因此，发送方在一个 RTT 内可以传输的数据量为：</p>
<p><span class="math display">\[
\text{RTT 内可以传输的总数据量} = \text{信道传输速率} \times \text{RTT}
\]</span></p>
<p>将数值代入：</p>
<p><span class="math display">\[
\text{RTT 内可以传输的总数据量} = 10 \times 10^6 \text{ 位/秒} \times
0.01 \text{ 秒} = 100,000 \text{ 位}
\]</span></p>
<h3 id="步骤-2计算发送的数据包数量">步骤 2：计算发送的数据包数量</h3>
<p>每个数据包的大小为 10,000 位，因此在一个 RTT
内可以传输的数据包数量为：</p>
<p><span class="math display">\[
\text{数据包数量} = \frac{\text{RTT
内可以传输的总数据量}}{\text{数据包大小}} = \frac{100,000 \text{
位}}{10,000 \text{ 位/包}} = 10 \text{ 个数据包}
\]</span></p>
<h3 id="结论-4">结论</h3>
<p>因此，发送方在开始接收确认之前可以传输 <strong>10
个数据包</strong>。</p>
</blockquote>
<hr>
<p>Which of the following statements about pipelining are true? One or
more statements may be true.
以下哪些有关管道的说法是正确的？一项或多项陈述可能是正确的。</p>
<ul>
<li>With pipelining, a receiver will have to send fewer acknowledgments
as the degree of pipelining increases
通过流水线，随着流水线程度的增加，接收者将不得不发送更少的确认</li>
<li>A pipelined sender can have transmitted multiple packets for which
the sender has yet to receive an ACK from the receiver.
流水线发送方可能已经传输了多个数据包，但发送方尚未收到来自接收方的
ACK。</li>
<li>With a pipelined sender, there may be transmitted packets “in
flight” – propagating through the channel – packets that the sender has
sent but that the receiver has not yet received.
对于管道式发送方，可能会存在“传输中”的数据包（通过通道传播），即发送方已发送但接收方尚未收到的数据包。</li>
<li>With pipelining, a packet is only retransmitted if that packet, or
its ACK, has been lost. 通过管道传输，仅当数据包或其 ACK
丢失时才会重新传输该数据包。</li>
</ul>
<blockquote>
<p>让我们逐条分析这些关于流水线的陈述，以判断它们是否正确。</p>
<h3 id="随着流水线程度的增加接收者将不得不发送更少的确认">1.
随着流水线程度的增加，接收者将不得不发送更少的确认</h3>
<p><strong>错误</strong>。即使流水线程度增加，接收方仍需为每个数据包发送
ACK。虽然有些协议（如累积确认协议）可以减少 ACK
的数量，但流水线本身不会减少 ACK
的发送量。流水线仅意味着发送方可以连续发送多个数据包，而无需等待每个数据包的
ACK。</p>
<h3 id="流水线发送方可能已经传输了多个数据包但发送方尚未收到来自接收方的-ack">2.
流水线发送方可能已经传输了多个数据包，但发送方尚未收到来自接收方的
ACK</h3>
<p><strong>正确</strong>。流水线允许发送方在不等待 ACK
的情况下发送多个数据包。因此，发送方可能会有多个数据包已发送但还未收到
ACK 的情况，这是流水线的核心特性之一。</p>
<h3 id="对于管道式发送方可能会存在传输中的数据包通过通道传播即发送方已发送但接收方尚未收到的数据包">3.
对于管道式发送方，可能会存在“传输中”的数据包（通过通道传播），即发送方已发送但接收方尚未收到的数据包</h3>
<p><strong>正确</strong>。在流水线协议中，数据包可以在通道中传播，即“在途”状态。此时，这些数据包尚未到达接收方，也未被确认，因此在接收方尚未收到的情况下，这些数据包仍在通道中传输。</p>
<h3 id="通过管道传输仅当数据包或其-ack-丢失时才会重新传输该数据包">4.
<strong>通过管道传输，仅当数据包或其 ACK
丢失时才会重新传输该数据包</strong></h3>
<p><strong>错误</strong>。在一些管道协议中（例如 Go-Back-N 协议），即使
ACK 只丢失了一个，但仍可能导致后续的多个数据包被重传。这是因为 Go-Back-N
协议要求接收顺序连续的数据包。如果某个数据包或 ACK
丢失，可能会触发整个“窗口”内的数据包的重传，而不仅仅是丢失的数据包。这种协议会导致比所需更多的重传，流水线协议并不总是仅在数据包或
ACK 丢失时重传特定数据包。</p>
<h3 id="结论-5">结论</h3>
<p><strong>正确的陈述</strong>是：</p>
<ul>
<li><strong>流水线发送方可能已经传输了多个数据包，但发送方尚未收到来自接收方的
ACK</strong>。</li>
<li><strong>对于管道式发送方，可能会存在“传输中”的数据包（通过通道传播），即发送方已发送但接收方尚未收到的数据包</strong>。</li>
</ul>
</blockquote>
<hr>
<p>What are some reasons for discarding received-but- out-of-sequence
packets at the receiver in GBN? Indicate one or more of the following
statements that are correct. GBN
中接收端丢弃已接收但失序的数据包的原因有哪些？指出下列一项或多项正确的陈述。</p>
<ul>
<li>Discarding an out of sequence packet will really force the sender to
retransmit. 丢弃失序的数据包实际上会迫使发送方重新传输。</li>
<li>The sender will resend that packet in any case.
无论如何，发送者都会重新发送该数据包。</li>
<li>If some packets are in error, then its likely that other packets are
in error as well.
如果某些数据包有错误，那么其他数据包也可能有错误。</li>
<li>The implementation at the receiver is simpler.
接收器的实现更简单。</li>
</ul>
<blockquote>
<p>我们来逐一分析这些选项，确定哪些是正确的，并解释它们在 Go-Back-N
(GBN) 协议中的原因。</p>
<h3 id="丢弃失序的数据包实际上会迫使发送方重新传输">1.
<strong>丢弃失序的数据包实际上会迫使发送方重新传输</strong></h3>
<p><strong>错误</strong>。在 GBN
协议中，接收方丢弃失序的数据包并不会直接“迫使”发送方重新传输该数据包。虽然接收方不确认失序的数据包，发送方在未收到
ACK
时会重新发送整个窗口中的数据包，但丢弃失序的数据包并不是强制性因素。发送方可能会在其他条件下（例如超时）重新发送数据包，而不是单纯因为丢弃了失序的数据包。</p>
<h3 id="无论如何发送者都会重新发送该数据包">2.
<strong>无论如何，发送者都会重新发送该数据包</strong></h3>
<p><strong>正确</strong>。在 GBN
协议中，发送方在没有收到确认（ACK）时，会重传包括失序数据包在内的整个窗口中的所有未确认数据包。因此，即使接收方丢弃失序数据包，发送方也会在超时后重新发送这些数据包，直到收到正确的确认。</p>
<h3 id="如果某些数据包有错误那么其他数据包也可能有错误">3.
<strong>如果某些数据包有错误，那么其他数据包也可能有错误</strong></h3>
<p><strong>错误</strong>。虽然在实际传输中存在数据包出错的可能性，但数据包的错误通常是随机的，并且与单个丢失或错误的数据包不一定相关。这意味着一个数据包出错并不必然导致其他数据包也有错误。丢弃失序数据包的原因并不是基于假设其他数据包也会有错误。</p>
<h3 id="接收器的实现更简单">4. <strong>接收器的实现更简单</strong></h3>
<p><strong>正确</strong>。丢弃失序数据包使得 GBN
协议的接收方实现更简单，因为接收方只需检查当前收到的数据包序号是否是期望的序号。如果序号不对，它可以简单地丢弃该数据包，无需缓存失序包、等待缺失的包到达并按顺序重组。相比于接收方需要处理乱序数据包的复杂性（如在选择重传协议中），GBN
的这种简单实现更适合于低复杂度需求的应用。</p>
<h3 id="结论-6">结论</h3>
<p>因此，正确的陈述是：</p>
<ol type="1">
<li><strong>无论如何，发送者都会重新发送该数据包</strong>。</li>
<li><strong>接收器的实现更简单</strong>。</li>
</ol>
<p>这些特点使 GBN 协议的实现更直接，但同时也增加了重传量。</p>
</blockquote>
<hr>
<p>What are some reasons for <strong>not</strong> discarding
received-but- out-of-sequence packets at the receiver in GBN? Indicate
one or more of the following statements that are correct. GBN
中接收端<strong>不</strong>丢弃已接收但失序的数据包的原因有哪些？指出下列一项或多项正确的陈述。</p>
<ul>
<li>Complex protocols are always better. 复杂的协议总是更好。</li>
<li>By not discarding, the receiver can implicitly let the sender know
that it (the sender) does not necessarily have to retransmit that
packet.
通过不丢弃，接收方可以隐式地让发送方知道它（发送方）不一定必须重新传输该数据包。</li>
<li>Even though that packet will be retransmitted, its next
retransmission could be corrupted, so don’t discard a perfectly
well-received packet, silly!
即使该数据包将被重新传输，它的下一次重新传输也可能会被损坏，所以不要丢弃一个完全接收良好的数据包，愚蠢！</li>
</ul>
<blockquote>
<h3 id="选项分析重新审视">选项分析（重新审视）</h3>
<ol type="1">
<li><p><strong>复杂的协议总是更好。</strong></p>
<ul>
<li><strong>错误</strong>。复杂性并不一定带来好处，反而可能增加错误和实现难度。</li>
</ul></li>
<li><p><strong>通过不丢弃，接收方可以隐式地让发送方知道它（发送方）不一定必须重新传输该数据包。</strong></p>
<ul>
<li><strong>错误</strong>。在 GBN
中，接收方实际上无法向发送方提供关于失序包是否需要重传的隐式信息。由于
GBN
协议的特性，接收方通常只会期望接收顺序的数据包，并不对已接收但失序的包做出相应的确认。</li>
</ul></li>
<li><p><strong>即使该数据包将被重新传输，它的下一次重新传输也可能会被损坏，所以不要丢弃一个完全接收良好的数据包，愚蠢！</strong></p>
<ul>
<li><strong>正确</strong>。这一说法确实反映了不丢弃已接收包的有效理由，保持已接收包可以避免因网络不可靠性带来的潜在数据丢失。</li>
</ul></li>
</ol>
<h3 id="正确结论">正确结论</h3>
<ul>
<li><strong>即使该数据包将被重新传输，它的下一次重新传输也可能会被损坏，所以不要丢弃一个完全接收良好的数据包，愚蠢！</strong></li>
</ul>
</blockquote>
<hr>
<p>In the SR receiver window (see diagram below, taken from PPT slides
and video), why haven’t the red packets been delivered yet? Check the
one or more reasons below that apply. 在 SR 接收窗口中（见下图，来自 PPT
幻灯片和视频），为什么红包还没有发送？检查以下一项或多项适用的原因。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031141564.webp"></p>
<ul>
<li>There is a packet with a lower sequence number than any of the red
packets that has yet to be received, so in-order delivery of data in the
red packets up to the application layer is not possible.
由于有一个数据包的序列号比尚未收到的任何红包的序列号都低，因此无法将红包中的数据按顺序传递到应用层。</li>
<li>Red packets have a lower delivery priority up to the application.
红包对于应用程序来说具有较低的传送优先级。</li>
<li>There is a packet with a higher sequence number than any of the red
packets that has yet to be received, so in-order delivery of data in the
red packets to the application layer is not yet possible.
由于存在序列号高于尚未接收到的任何红包的数据包，因此尚无法将红包中的数据按顺序传递到应用层。</li>
</ul>
<blockquote>
<p>在选择为什么 SR（Selective
Repeat）接收窗口中的红色数据包尚未被传递到应用层的原因时，我们需要考虑
SR 协议的工作方式。SR 协议允许接收方接收出-of-sequence
数据包，但仍然要求按照序列号顺序将数据传递到应用层。</p>
<h3 id="选项分析">选项分析</h3>
<ol type="1">
<li><p><strong>由于有一个数据包的序列号比尚未收到的任何红包的序列号都低，因此无法将红包中的数据按顺序传递到应用层。</strong></p>
<ul>
<li><strong>正确</strong>。这是原因之一。在 SR
协议中，如果接收方尚未接收到一个比红色数据包序列号更低的包，则接收方无法将红色包传递给应用层，因为它们依赖于先前的数据包的接收。</li>
</ul></li>
<li><p><strong>红包对于应用程序来说具有较低的传送优先级。</strong></p>
<ul>
<li><strong>错误</strong>。在 SR
协议中，数据包的交付是基于序列号的，所有包（无论颜色或状态）都具有相同的交付优先级。接收方只会传递按顺序到达的包。</li>
</ul></li>
<li><p><strong>由于存在序列号高于尚未接收到的任何红包的数据包，因此尚无法将红包中的数据按顺序传递到应用层。</strong></p>
<ul>
<li><strong>错误</strong>。在 SR
协议中，尽管接收方可能接收到了序列号更高的包，但这并不会阻止红色包的传递。相反，红色包的交付是由较低序列号包的缺失所阻碍的，而不是由于较高序列号包的存在。</li>
</ul></li>
</ol>
<h3 id="正确答案">正确答案</h3>
<p>基于以上分析，正确的选项是：</p>
<ul>
<li><strong>由于有一个数据包的序列号比尚未收到的任何红包的序列号都低，因此无法将红包中的数据按顺序传递到应用层。</strong></li>
</ul>
</blockquote>
<hr>
<p>In SR, why does the receiver have to acknowledge packets with
sequence numbers that are less than (and to the left of) those in its
window, which starts at <em>rcv_base</em>. 在 SR
中，为什么接收方必须确认序列号小于（且位于其左侧）窗口（从<em>rcv_base</em>开始）中的序列号的数据包。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031141564.webp"></p>
<ul>
<li>Actually, this ACK retransmission can be ignored and the protocol
will still function correctly, but its performance won’t be as good.
实际上，这个 ACK​​
重传可以忽略，协议仍然可以正常工作，但性能不会那么好。</li>
<li>Because, at the time of the data packet arrival at the receiver, the
sender has definitely still not received an ACK for that packet.
因为，当数据包到达接收方时，发送方肯定还没有收到该数据包的 ACK。</li>
<li>Because the sender may not have received an ACK for that packet yet.
因为发送方可能尚未收到该数据包的 ACK。</li>
</ul>
<blockquote>
<p>在选择关于为什么接收方必须确认序列号小于其窗口（从
<code>rcv_base</code> 开始）中的数据包的选项时，我们需要理解
SR（Selective Repeat）协议的工作机制和确认（ACK）过程。</p>
<h3 id="选项分析-1">选项分析</h3>
<ol type="1">
<li><p><strong>实际上，这个 ACK
重传可以忽略，协议仍然可以正常工作，但性能不会那么好。</strong></p>
<ul>
<li><strong>部分正确，但不适用</strong>。尽管忽略 ACK
重传可能不会导致协议的功能失效，但在 SR 协议中，接收 ACK
是确保发送方和接收方之间可靠通信的重要部分，以维护正确的窗口和序列号的状态。</li>
</ul></li>
<li><p><strong>因为，当数据包到达接收方时，发送方肯定还没有收到该数据包的
ACK。</strong></p>
<ul>
<li><strong>错误</strong>。发送方可能已经接收到了某些
ACK，特别是如果接收方在确认一个包的同时接收了多个包。这个选项并没有考虑到
ACK 可能是由于之前的数据包而被接收。</li>
</ul></li>
<li><p><strong>因为发送方可能尚未收到该数据包的 ACK。</strong></p>
<ul>
<li><strong>正确</strong>。这是主要原因。接收方在发送 ACK
时需要确认所有已经接收且按顺序的包。即使这些包的序列号低于接收方窗口的起始序列号（<code>rcv_base</code>），接收方仍然需要确认它们，以便告知发送方这些包已成功接收。这有助于发送方确定哪些包可以安全地从其发送缓存中移除，并防止重复发送。</li>
</ul></li>
</ol>
<h3 id="正确答案-1">正确答案</h3>
<p>因此，正确的选项是：</p>
<ul>
<li><strong>因为发送方可能尚未收到该数据包的 ACK。</strong></li>
</ul>
<p>这个确认过程对于确保数据传输的可靠性至关重要，特别是在发生丢包或错误时。接收方的
ACK
不仅告知发送方哪些数据包已被接收，还允许发送方进行相应的重传或清理其缓冲区。</p>
</blockquote>
<h2 id="section-4">3.5</h2>
<h3 id="knowledge-checks-知识检查-4">Knowledge checks 知识检查</h3>
<p>True or False: On the sending side, the TCP sender will take each
application-layer chunk of data written into a TCP socket and send it in
a distinct TCP segment. And then on the receiving side, TCP will deliver
a segment’s payload into the appropriate socket, preserving the
application-defined message boundary. 对或错：在发送端，TCP
发送方会将每个应用层数据块写入 TCP 套接字，并在不同的 TCP
段中发送。然后在接收端，TCP
会将数据段的有效负载传送到适当的套接字，从而保留应用程序定义的消息边界。</p>
<ul>
<li>False. 错误的。</li>
<li>True. 真的。</li>
</ul>
<p>答案：False 。</p>
<blockquote>
<p>这个陈述是<strong>错误的</strong>。</p>
<h3 id="解释-1">解释</h3>
<ol type="1">
<li><p><strong>TCP 数据分段</strong>：</p>
<ul>
<li>在发送端，TCP 发送方会将应用层数据块写入 TCP 套接字。但是，TCP
并不会简单地将每个应用层数据块直接封装成一个单独的 TCP
段发送出去。相反，TCP
会根据当前的拥塞窗口（cwnd）、接收窗口（rwnd）和最大报文段大小（MSS）等因素，将数据分成合适的大小进行发送。</li>
<li>因此，一个应用层数据块可能会被分割成多个 TCP
段，或者多个小的应用层数据块可能会被合并成一个 TCP 段。</li>
</ul></li>
<li><p><strong>消息边界</strong>：</p>
<ul>
<li>TCP
是一个面向字节流的协议，它不保留应用程序定义的消息边界。这意味着，即使应用程序在发送端将数据分成多个独立的消息，这些消息在传输过程中可能会被合并或拆分。</li>
<li>在接收端，TCP
会将接收到的数据按顺序重组，并将其传递给应用程序。接收端的应用程序需要自行处理数据流，以恢复原始的消息边界。</li>
</ul></li>
</ol>
<h3 id="举例说明">举例说明</h3>
<p>假设应用程序发送了两个消息，分别是 "Hello" 和 "World"。</p>
<ul>
<li><p><strong>发送端</strong>：</p>
<ul>
<li>应用程序将 "Hello" 写入 TCP 套接字。</li>
<li>应用程序将 "World" 写入 TCP 套接字。</li>
<li>TCP 可能会将这两个消息合并成一个段，例如
"HelloWorld"，或者将它们分成多个段，例如 "Hel" 和 "loWorld"。</li>
</ul></li>
<li><p><strong>接收端</strong>：</p>
<ul>
<li>TCP 将接收到的数据按顺序重组，并传递给应用程序。</li>
<li>应用程序需要自行处理接收到的数据流，以恢复原始的消息边界。例如，应用程序可能需要读取固定长度的数据，或者查找特定的分隔符来区分不同的消息。</li>
</ul></li>
</ul>
<p>因此，TCP
并不保证保留应用程序定义的消息边界，而是提供了一个可靠的字节流服务。应用程序需要自己处理消息边界的问题。</p>
</blockquote>
<hr>
<p>For the given function of a field in the TCP segment, select the name
of that field from the pull-down list. 对于 TCP
段中字段的给定功能，从下拉列表中选择该字段的名称。</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li><p>This field contains the port number associated with the sending
socket for this TCP segment. 该字段包含与该 TCP
段的发送套接字关联的端口号。</p></li>
<li><p>This field contains application data that was written into a
socket by the sender of this TCP segment. 该字段包含由该 TCP
段的发送方写入套接字的应用程序数据。</p></li>
<li><p>This field contains the index in the sender-to-receiver byte
stream of the first byte of that data in the payload carried in this
segment.
该字段包含该段中携带的有效负载中该数据的第一个字节在发送方到接收方字节流中的索引。</p></li>
<li><p>This field contains the index in the byte stream of the next
in-order byte expected at the receiver
该字段包含接收方期望的下一个有序字节在字节流中的索引</p></li>
<li><p>If set, this segment cumulatively ACKs all data bytes up to, but
not including, the byte index in the ACK value field of this segment.
如果设置，则该段将累积确认所有数据字节，直至（但不包括）该段的 ACK
值字段中的字节索引。</p></li>
<li><p>This field contains the number of available bytes in the TCP
receiver’s buffer. 该字段包含 TCP 接收方缓冲区中的可用字节数。</p></li>
<li><p>This field contains the Internet checksum of the TCP segment and
selected fields in the IP datagram header. 该字段包含 TCP 段的 Internet
校验和以及 IP 数据报报头中的选定字段。</p></li>
<li><p>This field contains the number of bytes in the TCP header.
该字段包含 TCP 标头中的字节数。</p></li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>Source port number 源端口号</li>
<li>Header length field 标头长度字段</li>
<li>Sequence number 序号</li>
<li>ACK number field ACK 号字段</li>
<li>Data (or payload). 数据（或有效负载）。</li>
<li>ACK bit 确认位</li>
<li>Receiver advertised window 接收者广告窗口</li>
<li>Checksum 校验和</li>
</ol>
<blockquote>
<p>好的，让我们逐一匹配问题清单中的每个字段功能与相应的字段名称：</p>
<ol type="1">
<li><p><strong>This field contains the port number associated with the
sending socket for this TCP segment.</strong> &gt;
<strong>该字段包含与该 TCP 段的发送套接字关联的端口号。</strong></p>
<ul>
<li><strong>匹配字段：Source port number 源端口号</strong></li>
</ul></li>
<li><p><strong>This field contains application data that was written
into a socket by the sender of this TCP segment.</strong> &gt;
<strong>该字段包含由该 TCP
段的发送方写入套接字的应用程序数据。</strong></p>
<ul>
<li><strong>匹配字段：Data (or payload).
数据（或有效负载）。</strong></li>
</ul></li>
<li><p><strong>This field contains the index in the sender-to-receiver
byte stream of the first byte of that data in the payload carried in
this segment.</strong> &gt;
<strong>该字段包含该段中携带的有效负载中该数据的第一个字节在发送方到接收方字节流中的索引。</strong></p>
<ul>
<li><strong>匹配字段：Sequence number 序号</strong></li>
</ul></li>
<li><p><strong>This field contains the index in the byte stream of the
next in-order byte expected at the receiver</strong> &gt;
<strong>该字段包含接收方期望的下一个有序字节在字节流中的索引</strong></p>
<ul>
<li><strong>匹配字段：ACK number field ACK 号字段</strong></li>
</ul></li>
<li><p><strong>If set, this segment cumulatively ACKs all data bytes up
to, but not including, the byte index in the ACK value field of this
segment.</strong> &gt;
<strong>如果设置，则该段将累积确认所有数据字节，直至（但不包括）该段的
ACK 值字段中的字节索引。</strong></p>
<ul>
<li><strong>匹配字段：ACK bit 确认位</strong></li>
</ul></li>
<li><p><strong>This field contains the number of available bytes in the
TCP receiver’s buffer.</strong> &gt; <strong>该字段包含 TCP
接收方缓冲区中的可用字节数。</strong></p>
<ul>
<li><strong>匹配字段：Receiver advertised window
接收者广告窗口</strong></li>
</ul></li>
<li><p><strong>This field contains the Internet checksum of the TCP
segment and selected fields in the IP datagram header.</strong> &gt;
<strong>该字段包含 TCP 段的 Internet 校验和以及 IP
数据报报头中的选定字段。</strong></p>
<ul>
<li><strong>匹配字段：Checksum 校验和</strong></li>
</ul></li>
<li><p><strong>This field contains the number of bytes in the TCP
header.</strong> &gt; <strong>该字段包含 TCP
标头中的字节数。</strong></p>
<ul>
<li><strong>匹配字段：Header length field 标头长度字段</strong></li>
</ul></li>
</ol>
<p>综上所述，匹配结果如下：</p>
<ol type="1">
<li><strong>Source port number 源端口号</strong></li>
<li><strong>Data (or payload). 数据（或有效负载）。</strong></li>
<li><strong>Sequence number 序号</strong></li>
<li><strong>ACK number field ACK 号字段</strong></li>
<li><strong>ACK bit 确认位</strong></li>
<li><strong>Receiver advertised window 接收者广告窗口</strong></li>
<li><strong>Checksum 校验和</strong></li>
<li><strong>Header length field 标头长度字段</strong></li>
</ol>
<p>希望这些解释对你有所帮助！</p>
</blockquote>
<hr>
<p>Consider the TCP Telnet scenario below (from Fig. 3.31 in text). Why
is it that the receiver sends an ACK that is one larger than the
sequence number in the received datagram? 考虑下面的 TCP Telnet
场景（来自文本图 3.31）。为什么接收方发送的 ACK
比接收到的数据报中的序列号大 1？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031205763.webp"></p>
<ul>
<li>Because TCP sequence numbers always increase by 1, with every new
segment, and the TCP receiver always send the sequence number of the
next expected segment 因为 TCP 序列号总是随着每个新数据段而增加 1，并且
TCP 接收方总是发送下一个预期数据段的序列号</li>
<li>Because the send-to receiver segment carries only one byte of data,
and after that segment is received, the next expected byte of data is
just the next byte (i.e., has an index that is one larger) in the data
stream.
因为发送到接收方的段仅携带一个字节的数据，并且在接收到该段之后，下一个预期的数据字节就是数据流中的下一个字节（即，具有更大的索引）。</li>
</ul>
<blockquote>
<p>在 TCP 通信中，接收方发送的
ACK（确认号）是基于接收到的数据段中最后一个字节的序列号。让我们分析给出的两个选项，以确定为什么接收方发送的
ACK 比接收到的数据报中的序列号大 1。</p>
<h3 id="选项分析-2">选项分析</h3>
<ol type="1">
<li><p><strong>因为 TCP 序列号总是随着每个新数据段而增加 1，并且 TCP
接收方总是发送下一个预期数据段的序列号。</strong></p>
<ul>
<li><strong>部分正确，但不够具体</strong>。确实，TCP
序列号是单调递增的，ACK
中确认的序列号是基于最后一个成功接收的字节之后的字节。虽然这个选项强调了序列号的递增性，但没有直接说明
ACK 的计算依据。</li>
</ul></li>
<li><p><strong>因为发送到接收方的段仅携带一个字节的数据，并且在接收到该段之后，下一个预期的数据字节就是数据流中的下一个字节（即，具有更大的索引）。</strong></p>
<ul>
<li><strong>正确</strong>。在 TCP 中，ACK
的确认号指的是接收方期望接收到的下一个字节的序列号。如果接收到的数据段仅包含一个字节，那么接收方在成功接收后，期望的下一个字节的序列号将比接收到的字节序列号大
1。因此，如果接收到的数据报的序列号是 N，则发送的 ACK 为 N +
1，表示接收方已成功接收序列号 N 的字节，并期待下一个字节。</li>
</ul></li>
</ol>
<h3 id="正确答案-2">正确答案</h3>
<p>因此，正确的选项是：</p>
<ul>
<li><strong>因为发送到接收方的段仅携带一个字节的数据，并且在接收到该段之后，下一个预期的数据字节就是数据流中的下一个字节（即，具有更大的索引）。</strong></li>
</ul>
<p>这个选项清楚地说明了 ACK
确认的逻辑，即接收方确认的是下一个预期字节的序列号，而不仅仅是接收到的字节。通过这种机制，TCP
确保了可靠的、有序的数据传输。</p>
</blockquote>
<hr>
<p>Suppose that as shown in the figure below, a TCP sender is sending
segments with 100 bytes of payload. The TCP sender sends five segments
with sequence numbers 100, 200, 300, 400, and 500. Suppose that the
segment with sequence number 300 is lost. The TCP receiver will buffer
correctly-received but not-yet-in-order segments for later delivery to
the application layer (once missing segments are later received).
假设如下图所示，TCP 发送方正在发送具有 100 字节有效负载的数据段。 TCP
发送方发送序列号为 100、200、300、400 和 500 的五个报文段。假设序列号为
300 的报文段丢失。 TCP
接收器将缓冲正确接收但尚未按顺序排列的段，以便稍后传送到应用程序层（一旦稍后接收到丢失的段）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031210372.webp"></p>
<p>Complete the sentences below .... 完成下面的句子....</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li>After receiving segment 100, the receiver responds with an ACK with
value: 接收到段 100 后，接收方用 ACK 进行响应，其值：</li>
<li>After receiving segment 200, the receiver responds with an ACK with
value: 收到段 200 后，接收方用 ACK 进行响应，其值：</li>
<li>After receiving segment 500, the receiver responds with an ACK with
value: 接收到段 500 后，接收方用 ACK 进行响应，其值：</li>
<li>After receiving the <em>retransmitted</em> segment 300, the receiver
responds with an ACK with value: 接收到<em>重传的</em>段 300
后，接收方用 ACK 进行响应，其值为：</li>
<li>The TCP receiver does <em>not</em> respond in the example, with an
ACK with value: 在示例中，TCP 接收方<em>没有</em>响应，其 ACK
值如下：</li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>300</li>
<li>200</li>
<li>300, a duplicate ACK 300，重复的 ACK</li>
<li>600</li>
<li>400</li>
</ol>
<p>答案：200，300，300 duplicate，600，400 。</p>
<blockquote>
<p>好的，我们逐项解释每个接收方的 ACK 响应值，尤其是在丢失序列号为 300
的段的情况下。</p>
<ol type="1">
<li><p><strong>接收到段 100 后，接收方用 ACK 进行响应，其值为
200：</strong><br>
当接收方收到序列号为 100 的段时，它知道自己已经接收到的字节是 100。由于
TCP 的接收确认机制是基于下一个期望的字节序列号，因此接收方会发送一个
ACK，确认它期待下一个字节的序列号是
200。这表明接收方已经成功接收了所有字节，直到 100，但尚未接收到
200。</p></li>
<li><p><strong>收到段 200 后，接收方用 ACK 进行响应，其值为
300：</strong><br>
同样，当接收方收到序列号为 200 的段时，它会更新自己的 ACK 值为
300。这意味着它已成功接收到的字节序列是从 100 到
200，并且它现在期待下一个字节序列号为 300。</p></li>
<li><p><strong>接收到段 500 后，接收方用 ACK 进行响应，其值为
300，重复的 ACK：</strong><br>
在此情况下，接收方成功接收了序列号为 500 的段，但由于序列号为 300
的段丢失，它无法交付 300 及后续的段。由于接收方仍然在等待序列号为 300
的段，因此它会发送一个 ACK 值为 300 的响应，这被称为重复
ACK。这表明接收方仍在期待接收 300。</p></li>
<li><p><strong>接收到重传的段 300 后，接收方用 ACK 进行响应，其值为
600：</strong><br>
当丢失的段 300 被重新传输并成功接收后，接收方会更新它的 ACK 值为
600。这意味着它已经成功接收到字节序列从 100 到
500，并期待下一个字节序列号为 600。</p></li>
<li><p><strong>在示例中，TCP 接收方没有响应，其 ACK 值为
400：</strong><br>
在此示例中，接收方没有收到序列号为 400 的段，因此也不会发送 ACK 确认值为
400。只有在成功接收到某个序列号的段之后，接收方才会确认该序列号加一。因此，它不会对
400 进行响应。</p></li>
</ol>
<p>总结一下，接收方通过发送 ACK
确认已接收到的数据，确保发送方能够正确地进行重传。这种机制有助于维护 TCP
的可靠性和有序性。</p>
</blockquote>
<hr>
<p>Consider TCP use of an exponentially weighted moving average (EWMA)
to compute the nth value of the estimated RTT: 考虑 TCP
使用指数加权移动平均值 (EWMA) 来计算估计 RTT 的第 n 个值：</p>
<p><em>EstimatedRTTn = (1- a)*EstimatedRTTn-1 + a*SampleRTTn 估计 RTT n
= (1- a)*估计 RTT n -1 + a*SampleRTT n</em></p>
<p><strong>True or False:</strong> with this EWMA algorithm the value of
<em>EstimatedRTTn</em> has no dependence on the earlier sample,
<em>SampleRTTn-1</em> <strong>对或错：</strong>使用此 EWMA 算法，
<em>EstimatedRTT n</em>的值不依赖于早期样本<em>SampleRTT n -1</em></p>
<ul>
<li>True 真的</li>
<li>False 错误的</li>
</ul>
<blockquote>
<p><strong>答案：错</strong></p>
<p><strong>解释：</strong></p>
<p>在 TCP 使用的指数加权移动平均值 (EWMA) 算法中，估计的 RTT（记为
<code>EstimatedRTTn</code>）是根据前一个估计值
<code>EstimatedRTTn-1</code> 和当前测量的样本 RTT（记为
<code>SampleRTTn</code>）来计算的。具体的公式如下：</p>
<p>$ <em>n = (1 - ) </em>{n-1} + _n $</p>
<p>其中，() 是一个介于 0 和 1 之间的权重因子。</p>
<p>这个公式的含义是：</p>
<ul>
<li><code>EstimatedRTTn</code> 是当前估计的 RTT。</li>
<li><code>EstimatedRTTn-1</code> 是前一个估计的 RTT。</li>
<li><code>SampleRTTn</code> 是当前测量的样本 RTT。</li>
<li>((1 - )) 是前一个估计值的权重。</li>
<li>() 是当前样本值的权重。</li>
</ul>
<p>从这个公式可以看出，<code>EstimatedRTTn</code>
的值不仅依赖于当前的样本 <code>SampleRTTn</code>，还依赖于前一个估计值
<code>EstimatedRTTn-1</code>。而 <code>EstimatedRTTn-1</code>
本身又是由更早的样本和估计值计算出来的，因此 <code>EstimatedRTTn</code>
实际上间接地依赖于所有的历史样本值。</p>
<p>具体来说，<code>EstimatedRTTn</code> 的值可以通过递归展开来表示：</p>
<p>$ _n = (1 - ) + _n $</p>
<p>$ <em>n = (1 - )^2 </em>{n-2} + (1 - ) _{n-1} + _n $</p>
<p>继续展开，可以看到 <code>EstimatedRTTn</code>
实际上依赖于所有先前的样本值 <code>SampleRTTn-1</code>,
<code>SampleRTTn-2</code>, 等等。</p>
<p>因此，使用此 EWMA 算法，<code>EstimatedRTTn</code>
的值确实依赖于早期样本
<code>SampleRTTn-1</code>。所以，题目中的说法是错误的。</p>
</blockquote>
<hr>
<p>Consider the TCP Telnet scenario below (from Fig. 3.36 in text). What
timer-related action does the sender take on the receipt of ACK 120?
考虑下面的 TCP Telnet 场景（来自文本图 3.36）。发送方在收到 ACK 120
后采取什么与计时器相关的操作？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031221114.webp"></p>
<ul>
<li><p>Cancels any running timers. 取消任何正在运行的计时器。</p></li>
<li><p>Restarts a timer for the segment with sequence number 92.
重新启动序列号为 92 的段的计时器。</p></li>
<li><p>Leaves any currently-running timers running.
让所有当前正在运行的计时器保持运行。</p></li>
</ul>
<blockquote>
<p><strong>答案：取消任何正在运行的计时器。</strong></p>
<p><strong>解释：</strong></p>
<p>在 TCP 协议中，当发送方收到
ACK（确认）时，它会执行一些与计时器相关的操作，以确保有效地管理数据传输和重传。</p>
<ol type="1">
<li><p><strong>取消任何正在运行的计时器</strong>：收到 ACK 120
后，发送方确认了序列号为 120 的数据段已经被接收。根据 TCP
的机制，发送方在发送数据段时会启动计时器以监控该数据段的传输。如果该数据段的
ACK
已被接收，表示该数据段成功传输，因此发送方可以取消与该数据段相关的任何计时器。</p></li>
<li><p><strong>为什么不重新启动或保持计时器运行</strong>：</p>
<ul>
<li>重新启动计时器的选项通常适用于尚未确认的段。如果 ACK 120
之前的段（如序列号
92）还未被确认，则发送方可能会重启对应的计时器。但是在此情境中，我们假设
ACK 120 是针对有效且已确认的段。</li>
<li>让当前计时器保持运行是不合理的，因为收到 ACK
表明相关数据段已成功传输，继续计时只会浪费资源并可能导致不必要的重传。</li>
</ul></li>
</ol>
<p>因此，正确的操作是<strong>取消任何正在运行的计时器</strong>。</p>
</blockquote>
<hr>
<p>正确或错误：使用 TCP
的流量控制机制，接收方告诉发送方它有多少可用缓冲区空间（并且发送方始终将未完成的、未确认的、正在传输的数据量限制为小于此数量），但它不是发送方发送的数据可能多于接收方缓冲空间。</p>
<ul>
<li><p>False 错误的</p></li>
<li><p>True 真的</p></li>
</ul>
<blockquote>
<p><strong>答案：True 真的</strong></p>
<p><strong>解释：</strong></p>
<p>在 TCP
的流量控制机制中，接收方通过窗口大小（即可用缓冲区空间）来告诉发送方它能够接收的最大数据量。这个窗口大小是动态的，会根据接收方的缓冲区状态不断更新。发送方在发送数据时，会根据接收方反馈的窗口大小来限制未确认的、正在传输的数据量，确保不会超过接收方的可用缓冲区空间。</p>
<p>因此，这个机制的目的是防止发送方发送过多的数据而导致接收方的缓冲区溢出，从而造成数据丢失。因此，陈述是正确的。</p>
</blockquote>
<p>Match the description of a TCP connection management message with the
name of the message used to accomplish that function. 将 TCP
连接管理消息的描述与用于完成该功能的消息名称相匹配。</p>
<p><strong>Question List: 问题清单：</strong></p>
<p>A message from client to server initiating a connection request.
从客户端到服务器发起连接请求的消息。</p>
<p>A message from server to client ACKing receipt of a SYN message and
indicating the willingness of the server to establish a TCP connection
with the client. 从服务器到客户端的消息，确认收到 SYN
消息并表明服务器愿意与客户端建立 TCP 连接。</p>
<p>A message indicating that the sending side is initiating the protocol
to terminate a connection. 指示发送方正在启动终止连接的协议的消息。</p>
<p>A message sent in response to a request to terminate a connection,
ACKing that the side receiving this message is also willing to terminate
the connection
响应终止连接请求而发送的消息，确认接收此消息的一方也愿意终止连接</p>
<p>A general purpose error message used during connection set up or tear
down to let the other side know that an error has occurred, and that the
referenced connection should be shut down.
在连接建立或断开期间使用的通用错误消息，让对方知道发生了错误，并且应该关闭引用的连接。</p>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>FIN message FIN 报文</li>
<li>SYNACK message SYNACK 消息</li>
<li>RESET message 重置消息</li>
<li>FINACK message FINACK 消息</li>
<li>SYN mesage 同步消息</li>
</ol>
<blockquote>
<p>以下是 TCP 连接管理消息的描述与相应消息名称的匹配：</p>
<ol type="1">
<li><p><strong>A message from client to server initiating a connection
request.</strong><br>
<strong>选择答案：</strong> <strong>SYN message
同步消息</strong></p></li>
<li><p><strong>A message from server to client ACKing receipt of a SYN
message and indicating the willingness of the server to establish a TCP
connection with the client.</strong><br>
<strong>选择答案：</strong> <strong>SYNACK message SYNACK
消息</strong></p></li>
<li><p><strong>A message indicating that the sending side is initiating
the protocol to terminate a connection.</strong><br>
<strong>选择答案：</strong> <strong>FIN message FIN
报文</strong></p></li>
<li><p><strong>A message sent in response to a request to terminate a
connection, ACKing that the side receiving this message is also willing
to terminate the connection.</strong><br>
<strong>选择答案：</strong> <strong>FINACK message FINACK
消息</strong></p></li>
<li><p><strong>A general purpose error message used during connection
set up or tear down to let the other side know that an error has
occurred, and that the referenced connection should be shut
down.</strong><br>
<strong>选择答案：</strong> <strong>RESET message
重置消息</strong></p></li>
</ol>
<h3 id="总结">总结：</h3>
<ul>
<li><strong>SYN message</strong> 用于初始化连接请求。</li>
<li><strong>SYNACK message</strong> 用于确认收到 SYN
消息并表示服务器愿意建立连接。</li>
<li><strong>FIN message</strong> 用于发送方发起连接终止。</li>
<li><strong>FINACK message</strong> 用于响应连接终止请求并确认。</li>
<li><strong>RESET message</strong> 用于指示连接中发生错误并应关闭。</li>
</ul>
</blockquote>
<hr>
<p>Consider TCP’s Fast Retransmit optimization (see Figure 3.37 from the
text, below). Of course, the sender doesn't know for sure that the
segment with sequence # 100 is actually lost (it can’t see into the
channel). Can a sender get three duplicate ACKs for a segment that in
fact has <em>not</em> been lost? Which of the following statements are
true? Suppose a channel can lose, but will not corrupt, messages. 考虑
TCP 的快速重传优化（参见下文中的图
3.37）。当然，发送方无法确定序列号为#100
的段实际上已丢失（它无法查看通道）。发送方能否获得实际上<em>没有</em>丢失的数据段的三个重复
ACK？以下哪些说法是正确的？假设通道可能会丢失但不会损坏消息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411031229258.webp"></p>
<ul>
<li><p>If the channel can reorder messages, a triple duplicate ACK can
occur even though a message is not lost; since it's possible that a
message has just been reordered and has not yet arrived when the three
duplicate ACKs were generated.
如果通道可以重新排序消息，即使消息没有丢失，也可能会出现三次重复
ACK；因为当生成三个重复的 ACK
时，消息可能刚刚被重新排序并且尚未到达。</p></li>
<li><p>If the channel cannot reorder messages, a triple duplicate ACK
indicates to the sender that a segment loss has happened for sure.
Actually (again assuming the channel cannot corrupt or reorder
messages), even a <em>single</em> duplicate ACK would indicate that a
segment loss has happed for sure. 如果通道无法重新排序消息，则三次重复
ACK
会向发送方表明肯定发生了分段丢失。实际上（再次假设通道不能损坏或重新排序消息），即使是<em>单个</em>重复的
ACK 也表明肯定发生了分段丢失。</p></li>
</ul>
<blockquote>
<p>对于 TCP 的快速重传优化，以下是对所给陈述的分析：</p>
<ol type="1">
<li><p><strong>If the channel can reorder messages, a triple duplicate
ACK can occur even though a message is not lost; since it's possible
that a message has just been reordered and has not yet arrived when the
three duplicate ACKs were generated.</strong><br>
<strong>正确</strong>。如果通道允许消息重新排序，则发送方可能会在接收到一条消息（例如序列号为
100 的段）之前，收到针对先前已确认消息的三个重复
ACK。这是因为通道可能已经重新排序了消息，而不是丢失了它。</p></li>
<li><p><strong>If the channel cannot reorder messages, a triple
duplicate ACK indicates to the sender that a segment loss has happened
for sure. Actually (again assuming the channel cannot corrupt or reorder
messages), even a single duplicate ACK would indicate that a segment
loss has happened for sure.</strong><br>
<strong>正确</strong>。如果通道不允许重新排序，并且假设消息不会损坏，则收到的三个重复
ACK 确实表明发生了分段丢失。在这种情况下，发送方可以确定由于后续的 ACK
指向同一序列号，意味着某个段在传输过程中确实丢失了。实际上，单个重复的
ACK 也意味着在接收到的 ACK
之前的一个段没有被确认，即很可能是丢失的。</p></li>
</ol>
<h3 id="结论-7">结论：</h3>
<ul>
<li><strong>第一个陈述是正确的</strong>，因为重新排序可能导致发送方在未收到特定段的情况下获得重复
ACK。</li>
<li><strong>第二个陈述也是正确的</strong>，因为在通道不允许重新排序的情况下，三次重复
ACK 确实表示丢失的段。</li>
</ul>
</blockquote>
<h2 id="section-5">3.6</h2>
<h3 id="knowledge-checks-知识检查-5">Knowledge checks 知识检查</h3>
<p>Consider the five images below. Indicate which of these images
suggest the need for <em>flow</em> control (the others would suggest the
need for congestion control).
考虑下面的五张图片。指出这些图像中哪些表明需要<em>流量</em>控制（其他图像表明需要拥塞控制）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411021755285.webp"></p>
<ul>
<li>A glass overflowing 满溢的玻璃杯</li>
<li>A crowd of people 一群人</li>
<li>A talking head 会说话的头</li>
<li>Car traffic 汽车交通</li>
<li>A penguin crowd 一群企鹅</li>
</ul>
<p>答案： 1 和 3 。</p>
<blockquote>
<p>流量控制和拥塞控制的主要区别在于它们的关注点和作用：</p>
<ol type="1">
<li><p><strong>流量控制</strong>：主要关注发送方和接收方之间的数据传输速率，确保发送方不会以过快的速度发送数据，导致接收方的缓冲区溢出。流量控制的目的是防止接收方被淹没，确保数据能够被有效处理。</p></li>
<li><p><strong>拥塞控制</strong>：关注的是整个网络的状态，确保网络中的数据流不会导致拥塞。这涉及到网络的带宽、路由器的处理能力等。</p></li>
</ol>
<p>根据这个定义：</p>
<ul>
<li><p><strong>满溢的玻璃杯（A glass
overflowing）</strong>：这个图像直观地传达了接收方的缓冲区溢出的情况，表明发送方发送的数据过快，导致接收方无法处理，反映出需要流量控制。</p></li>
<li><p><strong>会说话的头（A talking
head）</strong>：这个图像可能表示在一种互动或数据交换中，强调了单个发送方与接收方之间的关系。它可能象征着一个有效的交流需要适当的流量控制，以避免信息的溢出或丢失。</p></li>
</ul>
<p>相对而言：</p>
<ul>
<li><strong>一群人（A crowd of people）</strong>、<strong>汽车交通（Car
traffic）</strong>、和<strong>一群企鹅（A penguin
crowd）</strong>这三个图像更多地反映了网络层面的拥塞情况，即许多人或车辆集中在一起，可能导致交通拥堵，而不是直接涉及发送和接收之间的流量控制。因此，这些图像更适合用来表示拥塞控制的需求。</li>
</ul>
<p>所以，答案是 1 和
3，表明需要流量控制的原因是它们直接指向了数据发送和接收之间的处理能力和速率问题。</p>
</blockquote>
<hr>
<p>Consider the figure below, which shows the application-to-application
throughput achieved when two senders are competing at a shared
bottleneck link. Suppose that when the overall arrival rate, lambdain'
(for each sender) is close to R/2, the throughput to the application
layer (at each receiver), lambdaout, is equal to 0.8 _ lambdain'.
考虑下图，它显示了当两个发送方在共享瓶颈链路上竞争时所实现的应用程序到应用程序的吞吐量。假设当总体到达率
lambda in ' （对于每个发送方）接近 R/2
时，应用层（在每个接收方）的吞吐量 lambda out 等于 0.8 _ lambda in
'。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202411021757585.webp"></p>
<p>What fraction of the packets transmitted at the sender are
retransmissions? 发送方传输的数据包中有多少部分是重传？</p>
<blockquote>
<p>要确定发送方传输的数据包中有多少部分是重传，我们可以使用以下公式和概念：</p>
<ol type="1">
<li><p><strong>定义吞吐量</strong>：</p>
<ul>
<li>发送方的到达率为 <span class="math inline">\(\lambda_{\text{in}}' = R/2\)</span>。</li>
<li>应用层的吞吐量为 <span class="math inline">\(\lambda_{\text{out}} =
0.8 \cdot \lambda_{\text{in}}'\)</span>。</li>
</ul></li>
<li><p><strong>计算有效吞吐量</strong>：</p>
<ul>
<li>因此，每个发送方的有效吞吐量为： <span class="math display">\[
\lambda_{\text{out}} = 0.8 \cdot \frac{R}{2} = 0.4R
\]</span></li>
</ul></li>
<li><p><strong>重传率</strong>：</p>
<ul>
<li><p>设 <span class="math inline">\(X\)</span>
是发送方传输的所有数据包数量，其中包括重传的数据包。</p></li>
<li><p>发送的数据包数中，重传的部分可以表示为 <span class="math inline">\(X -
\lambda_{\text{out}}\)</span>（因为有效的传输是非重传的）。</p></li>
<li><p>为了计算重传的比例，我们可以使用重传率：</p>
<p><span class="math display">\[
\text{重传比例} = \frac{\text{重传包数}}{\text{总包数}} = \frac{X -
\lambda_{\text{out}}}{X}
\]</span></p></li>
<li><p>由于<span class="math inline">\(\lambda_{\text{in}}'\)</span>是到达率，即发送的数据包数，所以可以认为
<span class="math inline">\(X = \lambda_{\text{in}}' =
R/2\)</span>。</p></li>
</ul></li>
<li><p><strong>代入值</strong>：</p>
<p><span class="math display">\[
\text{重传比例} = \frac{\left(\frac{R}{2} - 0.4R\right)}{\frac{R}{2}} =
\frac{0.1R}{0.5R} = 0.2
\]</span></p></li>
<li><p><strong>结果</strong>：</p>
<ul>
<li>所以，重传的比例为 0.2 或者说 <strong>20%</strong>
的数据包是重传的。</li>
</ul></li>
</ol>
<p>因此，发送方传输的数据包中重传的部分占比为 <strong>20%</strong>。</p>
</blockquote>
<p>Which of the following actions are used in network-assisted
congestion control (say versus end-end congestion control) to signal
congestion. Check all that apply.
以下哪些操作用于网络辅助拥塞控制（例如相对于端到端拥塞控制）来发出拥塞信号。检查所有适用的内容。</p>
<ul>
<li>A datagram experiences delay at a congested network router, which is
then measured by the sender and used to decrease the sending rate.
数据报在拥塞的网络路由器处经历延迟，然后由发送方测量该延迟并用于降低发送速率。</li>
<li>The sender decreases its sending rate in response to a measured
increase in the RTT. 发送方响应测量到的 RTT 增加而降低其发送速率。</li>
<li>A router drops a packet at a congested router.
路由器在拥塞的路由器处丢弃数据包。</li>
<li>A router sends an ICMP message to a host telling it to slow down its
sending rate. 路由器向主机发送 ICMP 消息，告知其降低发送速率。</li>
<li>A router marks a field in the datagram header at a congested router.
路由器在拥塞路由器的数据报报头中标记一个字段。</li>
<li>The transport-layer receiver informs sender of the size of its
(transport-payer receiver) receive window.
传输层接收方通知发送方其（传输付款方接收方）接收窗口的大小。</li>
<li>A sender decreases its sending rate in response to packet loss
detected via its transport-layer ACKing. 发送方响应于通过其传输层 ACK
检测到的数据包丢失而降低其发送速率。</li>
</ul>
<blockquote>
<h3 id="选项分析-3">选项分析：</h3>
<ol type="1">
<li><p><strong>A datagram experiences delay at a congested network
router, which is then measured by the sender and used to decrease the
sending rate.</strong></p>
<ul>
<li><strong>数据报在拥塞的网络路由器处经历延迟，然后由发送方测量该延迟并用于降低发送速率。</strong></li>
<li>这是端到端拥塞控制的一部分，因为发送方通过测量延迟来调整发送速率，而不是网络设备主动发出信号。因此，不适用。</li>
</ul></li>
<li><p><strong>The sender decreases its sending rate in response to a
measured increase in the RTT.</strong></p>
<ul>
<li><strong>发送方响应测量到的 RTT 增加而降低其发送速率。</strong></li>
<li>这也是端到端拥塞控制的一部分，因为发送方通过测量 RTT
来调整发送速率，而不是网络设备主动发出信号。因此，不适用。</li>
</ul></li>
<li><p><strong>A router drops a packet at a congested
router.</strong></p>
<ul>
<li><strong>路由器在拥塞的路由器处丢弃数据包。</strong></li>
<li>尽管丢包可以间接指示拥塞，但这并不是网络设备主动发出的拥塞信号。因此，不适用。</li>
</ul></li>
<li><p><strong>A router sends an ICMP message to a host telling it to
slow down its sending rate.</strong></p>
<ul>
<li><strong>路由器向主机发送 ICMP
消息，告知其降低发送速率。</strong></li>
<li>这是网络辅助拥塞控制的一种方法，通过 ICMP
消息直接通知发送方降低发送速率。因此，适用。</li>
</ul></li>
<li><p><strong>A router marks a field in the datagram header at a
congested router.</strong></p>
<ul>
<li><strong>路由器在拥塞路由器的数据报报头中标记一个字段。</strong></li>
<li>这是网络辅助拥塞控制的一种方法，通过标记报头中的字段来指示拥塞情况。因此，适用。</li>
</ul></li>
<li><p><strong>The transport-layer receiver informs sender of the size
of its (transport-payer receiver) receive window.</strong></p>
<ul>
<li><strong>传输层接收方通知发送方其（传输付款方接收方）接收窗口的大小。</strong></li>
<li>这是传输层协议（如
TCP）中的一种机制，用于流量控制，但不是网络辅助拥塞控制的一部分。因此，不适用。</li>
</ul></li>
<li><p><strong>A sender decreases its sending rate in response to packet
loss detected via its transport-layer ACKing.</strong></p>
<ul>
<li><strong>发送方响应于通过其传输层 ACK
检测到的数据包丢失而降低其发送速率。</strong></li>
<li>这是端到端拥塞控制的一部分，因为发送方通过 ACK
来检测丢包。因此，不适用。</li>
</ul></li>
</ol>
<h3 id="结论-8">结论：</h3>
<p>正确的选项是：</p>
<ul>
<li><strong>A router sends an ICMP message to a host telling it to slow
down its sending rate.</strong>
<ul>
<li><strong>路由器向主机发送 ICMP
消息，告知其降低发送速率。</strong></li>
</ul></li>
<li><strong>A router marks a field in the datagram header at a congested
router.</strong>
<ul>
<li><strong>路由器在拥塞路由器的数据报报头中标记一个字段。</strong></li>
</ul></li>
</ul>
<p>这两个方法都是网络设备（如路由器）用来向发送方发出拥塞信号的网络辅助拥塞控制技术。希望这次解释更符合您的需求。</p>
</blockquote>
<hr>
<p>Which of the following actions are associated with end-end congestion
control (say versus network-assisted congestion control). Check all that
apply.
以下哪些操作与端到端拥塞控制相关（例如与网络辅助拥塞控制相比）。检查所有适用的内容。</p>
<ul>
<li>A router marks a field in the datagram header at a congested router.
路由器在拥塞路由器的数据报报头中标记一个字段。</li>
<li>A sender decreases its sending rate in response to packet loss
detected via its transport-layer ACKing. 发送方响应于通过其传输层 ACK
检测到的数据包丢失而降低其发送速率。</li>
<li>A router drops a packet at a congested router, which causes the
transport-layer sender to infer that there is congestion due to the
missing ACK for the lost packet.
路由器在拥塞的路由器处丢弃数据包，这会导致传输层发送方由于丢失数据包的
ACK 丢失而推断存在拥塞。</li>
<li>The transport-layer receiver informs sender of the size of its
(transport-payer receiver) receive window.
传输层接收方通知发送方其（传输付款方接收方）接收窗口的大小。</li>
<li>The transport-layer sender decreases its sending rate in response to
a measured increase in the RTT. 传输层发送方响应测量到的 RTT
增加而降低其发送速率。</li>
<li>A router sends an ICMP message to a host telling it to slow down its
sending rate. 路由器向主机发送 ICMP 消息，告知其降低发送速率。</li>
<li>A datagram experiences delay at a congested network router, which is
then measured by the sender and used to decrease the sending rate.
数据报在拥塞的网络路由器处经历延迟，然后由发送方测量该延迟并用于降低发送速率。</li>
</ul>
<p><strong>答案：答案如下，解析看上面即可。</strong></p>
<ul>
<li><p>A sender decreases its sending rate in response to packet loss
detected via its transport-layer ACKing. 发送方响应于通过其传输层 ACK
检测到的数据包丢失而降低其发送速率。</p></li>
<li><p>A router drops a packet at a congested router, which causes the
transport-layer sender to infer that there is congestion due to the
missing ACK for the lost packet.
路由器在拥塞的路由器处丢弃数据包，这会导致传输层发送方由于丢失数据包的
ACK 丢失而推断存在拥塞。</p></li>
<li><p>The transport-layer sender decreases its sending rate in response
to a measured increase in the RTT. 传输层发送方响应测量到的 RTT
增加而降低其发送速率。</p></li>
<li><p>A datagram experiences delay at a congested network router, which
is then measured by the sender and used to decrease the sending rate.
数据报在拥塞的网络路由器处经历延迟，然后由发送方测量该延迟并用于降低发送速率。</p></li>
</ul>
<hr>
<p>Use the pulldown menu to match a congestion control approach to how
the sender detects congestion.
使用下拉菜单将拥塞控制方法与发送方检测拥塞的方式相匹配。</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li>The sender infers segment loss from the absence of an ACK from the
receiver. 发送方根据接收方未收到 ACK 来推断分段丢失。</li>
<li>Bits are set at a congested router in a sender-to-receiver datagram,
and bits are in the returned to the sender in a receiver-to sender ACK,
to indicate congestion to the sender.
在发送方到接收方的数据报中，在拥塞路由器处设置比特，并且在接收方到发送方的
ACK 中返回给发送方，以向发送方指示拥塞。</li>
<li>The sender measures RTTs and uses the current RTT measurement to
infer the level of congestion. 发送方测量 RTT 并使用当前 RTT
测量来推断拥塞程度。</li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>delay-based 基于延迟的</li>
<li>end-end 端对端</li>
<li>network-assisted 网络辅助</li>
</ol>
<blockquote>
<p>好的，让我们逐一匹配每个拥塞控制方法与发送方检测拥塞的方式：</p>
<h3 id="问题清单">问题清单：</h3>
<ol type="1">
<li><p><strong>The sender infers segment loss from the absence of an ACK
from the receiver.</strong></p>
<ul>
<li><strong>发送方根据接收方未收到 ACK 来推断分段丢失。</strong></li>
<li><strong>匹配：</strong> 这是 <strong>端对端</strong>
拥塞控制的一部分。发送方通过未收到 ACK
来推断数据包丢失，进而调整发送速率。</li>
</ul></li>
<li><p><strong>Bits are set at a congested router in a
sender-to-receiver datagram, and bits are in the returned to the sender
in a receiver-to sender ACK, to indicate congestion to the
sender.</strong></p>
<ul>
<li><strong>在发送方到接收方的数据报中，在拥塞路由器处设置比特，并且在接收方到发送方的
ACK 中返回给发送方，以向发送方指示拥塞。</strong></li>
<li><strong>匹配：</strong> 这是 <strong>网络辅助</strong>
拥塞控制的一部分。路由器在数据报中设置比特来指示拥塞，并通过 ACK
返回给发送方。</li>
</ul></li>
<li><p><strong>The sender measures RTTs and uses the current RTT
measurement to infer the level of congestion.</strong></p>
<ul>
<li><strong>发送方测量 RTT 并使用当前 RTT
测量来推断拥塞程度。</strong></li>
<li><strong>匹配：</strong> 这是 <strong>基于延迟的</strong>
拥塞控制。发送方通过测量 RTT 来判断网络拥塞程度。</li>
</ul></li>
</ol>
<h3 id="匹配结果">匹配结果：</h3>
<ol type="1">
<li><p><strong>The sender infers segment loss from the absence of an ACK
from the receiver.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>端对端</strong> 拥塞控制</li>
</ul></li>
<li><p><strong>Bits are set at a congested router in a
sender-to-receiver datagram, and bits are in the returned to the sender
in a receiver-to sender ACK, to indicate congestion to the
sender.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>网络辅助</strong> 拥塞控制</li>
</ul></li>
<li><p><strong>The sender measures RTTs and uses the current RTT
measurement to infer the level of congestion.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>基于延迟的</strong> 拥塞控制</li>
</ul></li>
</ol>
<h3 id="最终答案">最终答案：</h3>
<ul>
<li><p><strong>The sender infers segment loss from the absence of an ACK
from the receiver.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>端对端</strong></li>
</ul></li>
<li><p><strong>Bits are set at a congested router in a
sender-to-receiver datagram, and bits are in the returned to the sender
in a receiver-to sender ACK, to indicate congestion to the
sender.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>网络辅助</strong></li>
</ul></li>
<li><p><strong>The sender measures RTTs and uses the current RTT
measurement to infer the level of congestion.</strong></p>
<ul>
<li><strong>匹配：</strong> <strong>基于延迟的</strong></li>
</ul></li>
</ul>
<p>希望这些匹配结果符合您的需求。</p>
</blockquote>
<hr>
<h2 id="section-6">3.7</h2>
<h3 id="knowledge-checks-知识检查-6">Knowledge checks 知识检查</h3>
<p>Which of the following statements about TCP’s
Additive-increase-multiplicative-decrease (AIMD) algorithm are true?
Check all that are true. 以下关于 TCP 的加法-增加-乘法-减少 (AIMD)
算法的陈述哪些是正确的？检查所有内容是否属实。</p>
<ul>
<li>AIMD cuts the congestion window size, cwnd, in half whenever loss is
detected by a triple duplicate ACK. 每当三次重复 ACK 检测到丢失时，AIMD
将拥塞窗口大小 cwnd 减少一半。</li>
<li>AIMD is a end-end approach to congestion control. AIMD
是一种端到端的拥塞控制方法。</li>
<li>AIMD uses the measured RTT delay to detect congestion. AIMD
使用测量的 RTT 延迟来检测拥塞。</li>
<li>AIMD is a network-assisted approach to congestion control. AIMD
是一种网络辅助的拥塞控制方法。</li>
<li>AIMD <em>always</em> cuts the congestion window size, cwnd, in half
whenever loss is detected.
每当检测到丢失时，AIMD<em>总是</em>将拥塞窗口大小 cwnd 减少一半。</li>
<li>AIMD cuts the congestion window size,cwnd, i to 1 whenever a timeout
occurs. 每当发生超时时，AIMD 就会将拥塞窗口大小 cwnd 、 i 削减为
1。</li>
<li>AIMD uses observed packet loss to detect congestion. AIMD
使用观察到的数据包丢失来检测拥塞。</li>
</ul>
<blockquote>
<p>答案为 1、2 和 6，以下是每个陈述的解释：</p>
<ol type="1">
<li><strong>AIMD cuts the congestion window size, cwnd, in half whenever
loss is detected by a triple duplicate ACK.</strong></li>
</ol>
<ul>
<li>这是正确的。当 TCP 接收到三次重复 ACK，表示某个数据包可能丢失，此时
AIMD
算法将拥塞窗口大小<code>cwnd</code>减少一半，以应对潜在的拥塞。</li>
</ul>
<ol start="2" type="1">
<li><strong>AIMD is an end-to-end approach to congestion
control.</strong></li>
</ol>
<ul>
<li>这是正确的。AIMD
是一种端到端的拥塞控制方法，主要依靠发送端与接收端之间的反馈进行调整，而不是依赖网络设备的辅助。</li>
</ul>
<ol start="6" type="1">
<li><strong>AIMD cuts the congestion window size, cwnd, to 1 whenever a
timeout occurs.</strong></li>
</ol>
<ul>
<li>这也是正确的。当出现超时时，AIMD
会将拥塞窗口大小<code>cwnd</code>重置为
1，这是一种更激进的拥塞控制措施，适用于严重拥塞的情况。</li>
</ul>
<h3 id="不正确的陈述">不正确的陈述：</h3>
<ol start="4" type="1">
<li><strong>AIMD uses the measured RTT delay to detect
congestion.</strong></li>
</ol>
<ul>
<li>这是错误的。AIMD 算法主要使用数据包丢失（例如三次重复 ACK
或超时）来检测拥塞，而不是通过测量 RTT（往返时间）延迟来判断。</li>
</ul>
<ol start="5" type="1">
<li><strong>AIMD is a network-assisted approach to congestion
control.</strong></li>
</ol>
<ul>
<li>这也是错误的。AIMD
是端到端的控制方法，而不是依赖网络中设备的直接信号或辅助。</li>
</ul>
<ol start="6" type="1">
<li><strong>AIMD always cuts the congestion window size, cwnd, in half
whenever loss is detected.</strong></li>
</ol>
<ul>
<li>这是不完全正确的。虽然在三次重复 ACK
时会将<code>cwnd</code>减半，但在超时时，AIMD
会将<code>cwnd</code>重置为 1，而不是减半。</li>
</ul>
<ol start="7" type="1">
<li>最后一个陈述错误的原因在于，AIMD
不单纯依赖观察到的数据包丢失来检测拥塞。虽然 AIMD
确实会在检测到丢包时减少窗口大小，但它并非直接“观察”数据包丢失，而是通过传输层的机制（例如三次重复
ACK 或超时）间接感知拥塞。因此，这个选项不准确。</li>
</ol>
</blockquote>
<hr>
<p>How is the sending rate typically regulated in a TCP implementation?
TCP 实现中通常如何调节发送速率？</p>
<ul>
<li>By using the retransmission timeout timer and counting the number of
bytes sent since the last timeout to compute the sending rate since that
last timeout, and then making sure its sending rate never exceed the
rate set by AIMD.
通过使用重传超时定时器，统计上次超时后发送的字节数，计算出上次超时后的发送速率，并保证其发送速率不超过
AIMD 设定的速率。</li>
<li>By keeping a window of size cwnd over the sequence number space, and
making sure that no more than cwnd bytes of data are outstanding (i.e,
unACKnowledged). The size of cwnd is regulated by AIMD.
通过在序列号空间上保留大小为 cwnd 的窗口，并确保不超过 cwnd
字节的数据未完成（即未确认）。 cwnd 的大小由 AIMD 规定。</li>
</ul>
<blockquote>
<p>正确答案是：</p>
<p><strong>“通过在序列号空间上保留大小为 cwnd 的窗口，并确保不超过 cwnd
字节的数据未完成（即未确认）。cwnd 的大小由 AIMD 规定。”</strong></p>
<p>解释如下：</p>
<p>在 TCP
中，发送速率的调节通过控制拥塞窗口（cwnd）来实现。发送端会确保在任意时刻未确认的数据量不超过当前的
cwnd 大小。cwnd 的大小由 AIMD
算法控制：遇到拥塞时减少，未遇到拥塞时逐步增加。这种机制有助于在不增加丢包或拥塞的情况下适当提高发送速率，并保证网络的稳定性和传输效率。</p>
</blockquote>
<hr>
<p>Which of the following best completes this sentence: "In the absence
of loss, TCP slow start increases the sending rate ... "
以下哪一项最能补充这句话：“在没有丢失的情况下，TCP
慢启动提高了发送速率……”</p>
<ul>
<li>... slower than AIMD, that’s why it’s called Slowstart." ...比 AIMD
慢，这就是它被称为 Slowstart 的原因。”</li>
<li>" ... faster than AIMD. In fact, slowstart increases the sending
rate exponentially fast per RTT." “......比 AIMD 更快。事实上，slowstart
使每个 RTT 的发送速率呈指数级快速增长。”</li>
<li>"... at the same rate as AIMD." “……与 AIMD 的速度相同。”</li>
</ul>
<blockquote>
<p>选项 2 是正确的，因为 TCP
的慢启动机制在没有检测到数据包丢失的情况下，会迅速增加发送速率。具体而言，慢启动通过每次接收一个
ACK 时将拥塞窗口 <span class="math inline">\(cwnd\)</span>
增加一倍，使得 <span class="math inline">\(cwnd\)</span>
呈指数级增长（每个 RTT 增加一倍），因此它的发送速率远比 AIMD
的线性增长更快。因此，虽然称为 "slow
start"（慢启动），但其实它的增速在初期比 AIMD
更快，直到遇到丢包或达到阈值。</p>
</blockquote>
<hr>
<p>Consider the transport-layer flows interacting at a congested link.
In the face of such congestion, what happens at this link to a
transport-layer flow that does not cut back on its sending rate?
考虑在拥塞链路上交互的传输层流。面对这样的拥塞，在不降低发送速率的情况下，传输层流的链路会发生什么情况？</p>
<ul>
<li>That sender’s datagrams will be preferentially dropped at the
congested link. 该发送者的数据报将优先在拥塞的链路处被丢弃。</li>
<li>The router will send a signal to the TCP sender that would force the
TCP sender to cut its rate in half. 路由器将向 TCP
发送方发送一个信号，迫使 TCP 发送方将其速率减半。</li>
<li>Nothing different from the other flows crossing the congested link.
与穿过拥塞链路的其他流没有什么不同。</li>
</ul>
<blockquote>
<p>答案是
3，因为在拥塞链路上，所有的流量都面临相同的丢包或延迟等拥塞影响，并不会对某一特定流量进行“优先”丢弃。链路拥塞发生时，不会自动针对不降低发送速率的流量采取特殊措施，除非该流明确使用了网络辅助的拥塞控制机制来接收网络信号。而在默认情况下，这样的传输层流与其他流量没有区别，都会平等地面临拥塞所带来的影响。</p>
</blockquote>
<hr>
<p>Assuming that the congestion window size,cwnd, has not yet reached
Wmax, TCP CUBIC will ... (check all that apply) 假设拥塞窗口大小， cwnd
，尚未达到 W max ，TCP CUBIC 将...（选中所有适用项）</p>
<ul>
<li>... always have a window size, cwnd, and hence a sending rate,
higher than that of AIMD (assuming a given window size, Wmax, at which
loss would occur).</li>
<li>...总是有一个窗口大小 cwnd ，因此发送速率高于 AIMD
（假设给定的窗口大小 W max ，此时会发生丢失）。</li>
<li>... increase its sending rate faster than AIMD when cwnd is far away
from Wmax, but increase slower than AIMD when cwnd is closer to Wmax
...当 cwnd 远离 W max 时，其发送速率比 AIMD 增加得更快，但当 cwnd 接近 W
max 时，其发送速率比 AIMD 增加得慢</li>
</ul>
<p>答案：1 和 2 。</p>
<blockquote>
<p>答案选项是 1 和 2 的原因如下：</p>
<ol type="1">
<li><p><strong>选项 1</strong>：TCP CUBIC 确实在很多情况下拥有更高的 $
cwnd $ 和更高的发送速率。相比 AIMD 的线性增长，CUBIC
的拥塞窗口在大部分时间内保持在更高的水平，因此在相同条件下，CUBIC
的发送速率往往比 AIMD 高。特别是在远离 $ W_{max} $ 时，CUBIC
的窗口会增长得更快，从而维持更大的 $ cwnd $。</p></li>
<li><p><strong>选项 2</strong>：CUBIC
使用的是非线性的窗口增长函数，当窗口 $ cwnd $ 远离 $ W<em>{max} $
时，增长更快；而接近 $ W</em>{max} $ 时增长变慢。因此，TCP CUBIC
会在距离 $ W<em>{max} $ 较远时比 AIMD 增长更快，但在接近 $ W</em>{max} $
时增长较慢。这种设计是为了在接近拥塞点时更平稳地增长，以减少丢包的概率。</p></li>
</ol>
<p>因此，这两个选项都适用于 TCP CUBIC 的行为特点。</p>
</blockquote>
<hr>
<p>For delay-based congestion control, match the sender action to the
relationship of the currently measured throughput to the value of
cwnd/RTTmin 对于基于延迟的拥塞控制，将发送方操作与当前测量的吞吐量与
cwnd/RTT min 值的关系相匹配</p>
<p><strong>Question List: 问题清单：</strong></p>
<ul>
<li><p>The currently measured throughput is greater than cwnd/RTTmin
当前测量的吞吐量大于 cwnd/RTT min</p></li>
<li><p>The currently measured throughput is equal to or a bit less than
than cwnd/RTTmin 当前测量的吞吐量等于或略小于 cwnd/RTT min</p></li>
<li><p>The currently measured throughput is much less that than
cwnd/RTTmin 当前测量的吞吐量远小于 cwnd/RTT
<strong>min</strong></p></li>
</ul>
<p><strong>Answer List: 答案列表：</strong></p>
<ol type="1">
<li>increase the sending rate 提高发送速率</li>
<li>decrease the sending rate 降低发送速率</li>
<li>This should never happen. 这绝对不应该发生。</li>
</ol>
<p>答案： 312 。</p>
<blockquote>
<p>当然，以下是对基于延迟的拥塞控制中发送方操作与吞吐量与 ( )
关系的详细解释：</p>
<h3 id="当前测量的吞吐量大于">1. 当前测量的吞吐量大于 ( )</h3>
<ul>
<li><strong>答案：3（这绝对不应该发生）</strong></li>
<li><strong>解释</strong>：
<ul>
<li>在正常情况下，TCP 的发送速率应该与其拥塞窗口 ( cwnd ) 和最小往返时间
( RTT*{} ) 保持一致。具体来说，吞吐量的理论上限是 (
)。如果实际测量的吞吐量超过这个值，说明网络存在异常情况，可能是因为网络没有被充分利用，或者是出现了错误的吞吐量测量。这种情况下，发送方应该检测到异常，并采取措施来重新评估网络状况。</li>
</ul></li>
</ul>
<h3 id="当前测量的吞吐量等于或略小于">2. 当前测量的吞吐量等于或略小于 (
)</h3>
<ul>
<li><strong>答案：1（提高发送速率）</strong></li>
<li><strong>解释</strong>：
<ul>
<li>当吞吐量等于或略小于 ( ) 时，表明网络的带宽正在被充分利用。此时，TCP
发送方可以安全地增加发送速率，以充分利用网络资源。例如，TCP
可能会根据当前的吞吐量增长其拥塞窗口，进而增加数据发送的速率，以更有效地使用可用的带宽。</li>
</ul></li>
</ul>
<h3 id="当前测量的吞吐量远小于">3. 当前测量的吞吐量远小于 ( )</h3>
<ul>
<li><strong>答案：2（降低发送速率）</strong></li>
<li><strong>解释</strong>：
<ul>
<li>如果吞吐量远小于 (
)，则说明网络可能处于拥塞状态，或存在其他性能问题。在这种情况下，TCP
应该降低发送速率，以避免进一步增加网络的负载，从而加重拥塞。发送方会减少其拥塞窗口的大小，降低发送速率，以寻找网络的最佳操作点。</li>
</ul></li>
</ul>
<h3 id="总结-1">总结</h3>
<p>在基于延迟的拥塞控制中，发送方的操作与当前吞吐量的比较反映了网络状况的变化：</p>
<ul>
<li>如果吞吐量超出理论值，意味着有异常发生，需谨慎处理。</li>
<li>如果吞吐量与理论值相等或略小，可以适当提高发送速率以提升利用率。</li>
<li>如果吞吐量显著低于理论值，应立即降低发送速率，以防止网络拥塞并保护数据传输的稳定性。</li>
</ul>
<p>这种方式确保了 TCP
在各种网络条件下保持良好的性能，同时尽量减少丢包和延迟。</p>
</blockquote>
<h2 id="section-7">3.8</h2>
<h3 id="knowledge-checks-知识检查-7">Knowledge checks 知识检查</h3>
<p>What are advantages of the <em>streams</em> concept in QUIC? Select
all that apply. QUIC
中的<em>流</em>概念有哪些优点？选择所有适用的选项。</p>
<ul>
<li>Since each stream has its own error control, if one stream
experiences an error (e.g., lost or damaged segment), the other streams
are unaffected.
由于每个流都有自己的错误控制，因此如果一个流遇到错误（例如，丢失或损坏的段），其他流不会受到影响。</li>
<li>With <em>N</em> streams, the overall throughput can be increased by
a factor of <em>N</em>, since each stream has its own separate
congestion control. 对于<em>N
个</em>流，总体吞吐量可以增加<em>N</em>倍，因为每个流都有自己单独的拥塞控制。</li>
<li>Streams allow concurrent retrieval of web objects, while avoiding
Head of the Line (HOL) blocking. 流允许并发检索 Web 对象，同时避免队头
(HOL) 阻塞</li>
</ul>
<p>答案： 1 和 3 。</p>
<blockquote>
<p>在 QUIC 中，流的概念确实带来了多种优势，以下是每个选项的分析：</p>
<ol type="1">
<li><p><strong>由于每个流都有自己的错误控制，因此如果一个流遇到错误（例如，丢失或损坏的段），其他流不会受到影响。</strong></p>
<ul>
<li><strong>优点</strong>：正确。每个流在 QUIC
中都有独立的错误控制机制，这意味着一个流的错误（如丢包或损坏）不会影响到其他流的数据传输。这种特性提高了传输的可靠性和灵活性。</li>
</ul></li>
<li><p><strong>对于 N 个流，总体吞吐量可以增加 N
倍，因为每个流都有自己单独的拥塞控制。</strong></p>
<ul>
<li><strong>优点</strong>：部分正确。虽然理论上可以通过并行流增加整体吞吐量，但实际增加的吞吐量并不一定是
N
倍。它依赖于网络条件和流的配置等因素。每个流有独立的拥塞控制机制确实有助于更好地利用带宽，但在实践中可能会受到竞争和网络瓶颈的影响。</li>
</ul></li>
<li><p><strong>流允许并发检索 Web
对象，同时避免头部阻塞（HOL）阻塞。</strong></p>
<ul>
<li><strong>优点</strong>：正确。流的并发性允许多个数据流同时进行，避免了传统
TCP 中的头部阻塞问题。在 TCP
中，如果一个数据包丢失，后续所有数据包必须等待该数据包的重传，这导致了延迟。而在
QUIC
中，流之间是独立的，因此即使一个流遇到问题，其他流仍然可以继续传输数据，从而提高了整体性能。</li>
</ul></li>
</ol>
<h3 id="结论-9">结论</h3>
<p><strong>适用的选项为</strong>：</p>
<ul>
<li>由于每个流都有自己的错误控制，因此如果一个流遇到错误（例如，丢失或损坏的段），其他流不会受到影响。</li>
<li>流允许并发检索 Web 对象，同时避免头部阻塞（HOL）阻塞。</li>
</ul>
<p><strong>第二个选项</strong>在理论上是有利的，但在实践中可能受限于其他因素，因此不完全适用。</p>
</blockquote>
<hr>
<p>What are advantages of implementing transport-layer functionality in
QUIC at the application layer? Select all that apply. 在应用层实现 QUIC
传输层功能有哪些优势？选择所有适用的选项。</p>
<ul>
<li><p>QUIC can establish all connection parameters (security,
reliability, flow and congestion control)in just one handshake rather
than separately in two. QUIC
可以在一次握手中建立所有连接参数（安全性、可靠性、流量和拥塞控制），而不是分别在两次握手中建立。</p></li>
<li><p>As an application-layer protocol, QUIC can be updated/modified at
“app frequency” rather than at the frequency of operating system
updates. 作为应用层协议，QUIC
可以以“应用程序频率”而不是操作系统更新的频率进行更新/修改。</p></li>
<li><p>QUIC’s performance can be better optimized at the
application-layer, so it will have better performance than if these
functions were implremented in the operating system. QUIC
的性能可以在应用层得到更好的优化，因此比在操作系统中实现这些功能会有更好的性能。</p></li>
<li><p>QUIC performs both congestion control and error recovery
different from TCP, leveraging all of the knowledge that has built up
since TCP was first standardized, and therefore has better performance
than TCP. QUIC 执行与 TCP 不同的拥塞控制和错误恢复，利用了自 TCP
首次标准化以来积累的所有知识，因此具有比 TCP 更好的性能。</p></li>
</ul>
<p>答案：1 和 2 。</p>
<blockquote>
<p>理解为什么答案是 1 和 2，我们需要仔细分析每个选项的优势以及它们与
QUIC 的设计目标和实际实现方式的关系。</p>
<h3 id="选项-1">选项 1:</h3>
<p><strong>QUIC can establish all connection parameters (security,
reliability, flow and congestion control) in just one handshake rather
than separately in two.</strong> &gt; <strong>QUIC
可以在一次握手中建立所有连接参数（安全性、可靠性、流量和拥塞控制），而不是分别在两次握手中建立。</strong></p>
<p>这是正确的。QUIC 的设计目的是为了减少连接建立的时间。传统的 TCP + TLS
握手需要多个往返时间（通常至少两个 RTT），而 QUIC
通过在一个握手过程中完成所有必要的协商（包括安全性和其他传输层参数），只需要一个
RTT
即可完成连接建立。这显著提高了连接建立的效率，特别是在高延迟网络中。</p>
<h3 id="选项-2">选项 2:</h3>
<p><strong>As an application-layer protocol, QUIC can be
updated/modified at “app frequency” rather than at the frequency of
operating system updates.</strong> &gt; <strong>作为应用层协议，QUIC
可以以“应用程序频率”而不是操作系统更新的频率进行更新/修改。</strong></p>
<p>这也是正确的。QUIC
作为一个应用层协议，其更新和修改不受操作系统的限制。这意味着 QUIC
可以更频繁地进行改进和修复，而不需要等待操作系统更新。这种灵活性使得
QUIC 能够更快地适应新的网络条件和技术进步。</p>
<h3 id="选项-3">选项 3:</h3>
<p><strong>QUIC’s performance can be better optimized at the
application-layer, so it will have better performance than if these
functions were implemented in the operating system.</strong> &gt;
<strong>QUIC
的性能可以在应用层得到更好的优化，因此比在操作系统中实现这些功能会有更好的性能。</strong></p>
<p>这个说法虽然有一定的道理，但并不是 QUIC
的主要优势之一。虽然应用层实现可以提供更多的灵活性和优化空间，但这并不意味着
QUIC
一定会在所有情况下都比内核中的实现有更好的性能。实际上，内核中的实现也可以非常高效，而且某些情况下可能更适合高性能需求。因此，这个选项不是最准确的。</p>
<h3 id="选项-4">选项 4:</h3>
<p><strong>QUIC performs both congestion control and error recovery
different from TCP, leveraging all of the knowledge that has built up
since TCP was first standardized, and therefore has better performance
than TCP.</strong> &gt; <strong>QUIC 执行与 TCP
不同的拥塞控制和错误恢复，利用了自 TCP
首次标准化以来积累的所有知识，因此具有比 TCP 更好的性能。</strong></p>
<p>这个说法也是正确的，但并不是直接回答“在应用层实现 QUIC
传输层功能的优势”。QUIC 确实利用了现代网络技术和研究成果，提供了比传统
TCP 更好的性能，但这更多是 QUIC
协议设计上的优势，而不是应用层实现的优势。</p>
<p>综上所述，选项 1 和 2 直接回答了在应用层实现 QUIC
传输层功能的优势，因此是正确的答案。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/488b60b7.html">https://www.heavenhold.cn/posts/488b60b7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072128477.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/d6eff514.html" title="Chapter4"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072125215.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Chapter4</div></div></a></div><div class="next-post pull-right"><a href="/posts/3f8c5021.html" title="Chapter2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409171128222.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Chapter2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/38e19438.html" title="Chapter5"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072126736.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Chapter5</div></div></a></div><div><a href="/posts/a685019b.html" title="Chapter1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072126884.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Chapter1</div></div></a></div><div><a href="/posts/d6eff514.html" title="Chapter4"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072125215.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Chapter4</div></div></a></div><div><a href="/posts/3f8c5021.html" title="Chapter2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202409171128222.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-05</div><div class="title">Chapter2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-3"><span class="toc-number">1.</span> <span class="toc-text">Chapter 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#section"><span class="toc-number">1.1.</span> <span class="toc-text">3.1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5"><span class="toc-number">1.1.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-1"><span class="toc-number">1.3.</span> <span class="toc-text">3.2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-2"><span class="toc-number">1.4.</span> <span class="toc-text">3.3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-3"><span class="toc-number">1.5.</span> <span class="toc-text">3.4</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9sender%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.2.</span> <span class="toc-text">发送方（Sender）的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9receiver%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.3.</span> <span class="toc-text">接收方（Receiver）的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.4.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%AF%8F%E4%B8%AA%E9%80%89%E9%A1%B9"><span class="toc-number">1.5.5.</span> <span class="toc-text">分析每个选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.5.6.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9sender%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">1.5.7.</span> <span class="toc-text">发送方（Sender）的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9receiver%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">1.5.8.</span> <span class="toc-text">接收方（Receiver）的状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2-1"><span class="toc-number">1.5.9.</span> <span class="toc-text">状态转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.10.</span> <span class="toc-text">给定序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-1"><span class="toc-number">1.5.11.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.12.</span> <span class="toc-text">已知条件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E9%80%9A%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="toc-number">1.5.13.</span> <span class="toc-text">最大通道利用率计算公式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%E8%AE%A1%E7%AE%97%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.14.</span> <span class="toc-text">步骤 1：计算传输时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%E7%A1%AE%E5%AE%9A%E5%BE%80%E8%BF%94%E6%97%B6%E9%97%B4rtt"><span class="toc-number">1.5.15.</span> <span class="toc-text">步骤 2：确定往返时间（RTT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%E8%AE%A1%E7%AE%97%E9%80%9A%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.5.16.</span> <span class="toc-text">步骤 3：计算通道利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-2"><span class="toc-number">1.5.17.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">1.5.18.</span> <span class="toc-text">已知条件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%80%9A%E9%81%93%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.5.19.</span> <span class="toc-text">流水线协议的通道利用率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%E8%AE%A1%E7%AE%97%E4%BC%A0%E8%BE%93%E6%97%B6%E9%97%B4-1"><span class="toc-number">1.5.20.</span> <span class="toc-text">步骤 1：计算传输时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%E8%AE%A1%E7%AE%97%E5%9C%A8%E4%B8%80%E4%B8%AA-rtt-%E5%86%85%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E6%95%B0%E9%87%8F"><span class="toc-number">1.5.21.</span> <span class="toc-text">步骤 2：计算在一个
RTT 内可以发送的数据包数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-3"><span class="toc-number">1.5.22.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E6%9D%A1%E4%BB%B6-2"><span class="toc-number">1.5.23.</span> <span class="toc-text">已知条件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%E8%AE%A1%E7%AE%97%E5%9C%A8%E4%B8%80%E4%B8%AA-rtt-%E5%86%85%E5%8F%AF%E4%BB%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E6%80%BB%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="toc-number">1.5.24.</span> <span class="toc-text">步骤 1：计算在一个
RTT 内可以传输的总数据量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%E8%AE%A1%E7%AE%97%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E6%95%B0%E9%87%8F"><span class="toc-number">1.5.25.</span> <span class="toc-text">步骤 2：计算发送的数据包数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-4"><span class="toc-number">1.5.26.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E7%9D%80%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%A8%8B%E5%BA%A6%E7%9A%84%E5%A2%9E%E5%8A%A0%E6%8E%A5%E6%94%B6%E8%80%85%E5%B0%86%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%8F%91%E9%80%81%E6%9B%B4%E5%B0%91%E7%9A%84%E7%A1%AE%E8%AE%A4"><span class="toc-number">1.5.27.</span> <span class="toc-text">1.
随着流水线程度的增加，接收者将不得不发送更少的确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%AF%E8%83%BD%E5%B7%B2%E7%BB%8F%E4%BC%A0%E8%BE%93%E4%BA%86%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BD%86%E5%8F%91%E9%80%81%E6%96%B9%E5%B0%9A%E6%9C%AA%E6%94%B6%E5%88%B0%E6%9D%A5%E8%87%AA%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84-ack"><span class="toc-number">1.5.28.</span> <span class="toc-text">2.
流水线发送方可能已经传输了多个数据包，但发送方尚未收到来自接收方的
ACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E7%AE%A1%E9%81%93%E5%BC%8F%E5%8F%91%E9%80%81%E6%96%B9%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AD%98%E5%9C%A8%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%9A%E8%BF%87%E9%80%9A%E9%81%93%E4%BC%A0%E6%92%AD%E5%8D%B3%E5%8F%91%E9%80%81%E6%96%B9%E5%B7%B2%E5%8F%91%E9%80%81%E4%BD%86%E6%8E%A5%E6%94%B6%E6%96%B9%E5%B0%9A%E6%9C%AA%E6%94%B6%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.5.29.</span> <span class="toc-text">3.
对于管道式发送方，可能会存在“传输中”的数据包（通过通道传播），即发送方已发送但接收方尚未收到的数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E4%BC%A0%E8%BE%93%E4%BB%85%E5%BD%93%E6%95%B0%E6%8D%AE%E5%8C%85%E6%88%96%E5%85%B6-ack-%E4%B8%A2%E5%A4%B1%E6%97%B6%E6%89%8D%E4%BC%9A%E9%87%8D%E6%96%B0%E4%BC%A0%E8%BE%93%E8%AF%A5%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.5.30.</span> <span class="toc-text">4.
通过管道传输，仅当数据包或其 ACK
丢失时才会重新传输该数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-5"><span class="toc-number">1.5.31.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%BC%83%E5%A4%B1%E5%BA%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%85%E5%AE%9E%E9%99%85%E4%B8%8A%E4%BC%9A%E8%BF%AB%E4%BD%BF%E5%8F%91%E9%80%81%E6%96%B9%E9%87%8D%E6%96%B0%E4%BC%A0%E8%BE%93"><span class="toc-number">1.5.32.</span> <span class="toc-text">1.
丢弃失序的数据包实际上会迫使发送方重新传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E8%80%85%E9%83%BD%E4%BC%9A%E9%87%8D%E6%96%B0%E5%8F%91%E9%80%81%E8%AF%A5%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">1.5.33.</span> <span class="toc-text">2.
无论如何，发送者都会重新发送该数据包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%90%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%8C%85%E6%9C%89%E9%94%99%E8%AF%AF%E9%82%A3%E4%B9%88%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E5%8C%85%E4%B9%9F%E5%8F%AF%E8%83%BD%E6%9C%89%E9%94%99%E8%AF%AF"><span class="toc-number">1.5.34.</span> <span class="toc-text">3.
如果某些数据包有错误，那么其他数据包也可能有错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9B%B4%E7%AE%80%E5%8D%95"><span class="toc-number">1.5.35.</span> <span class="toc-text">4. 接收器的实现更简单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-6"><span class="toc-number">1.5.36.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86"><span class="toc-number">1.5.37.</span> <span class="toc-text">选项分析（重新审视）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">1.5.38.</span> <span class="toc-text">正确结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90"><span class="toc-number">1.5.39.</span> <span class="toc-text">选项分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88"><span class="toc-number">1.5.40.</span> <span class="toc-text">正确答案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90-1"><span class="toc-number">1.5.41.</span> <span class="toc-text">选项分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88-1"><span class="toc-number">1.5.42.</span> <span class="toc-text">正确答案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-4"><span class="toc-number">1.6.</span> <span class="toc-text">3.5</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-4"><span class="toc-number">1.6.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">1.6.3.</span> <span class="toc-text">举例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90-2"><span class="toc-number">1.6.4.</span> <span class="toc-text">选项分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88-2"><span class="toc-number">1.6.5.</span> <span class="toc-text">正确答案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.6.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-7"><span class="toc-number">1.6.7.</span> <span class="toc-text">结论：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-5"><span class="toc-number">1.7.</span> <span class="toc-text">3.6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-5"><span class="toc-number">1.7.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9%E5%88%86%E6%9E%90-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">选项分析：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-8"><span class="toc-number">1.7.3.</span> <span class="toc-text">结论：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%B8%85%E5%8D%95"><span class="toc-number">1.7.4.</span> <span class="toc-text">问题清单：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%BB%93%E6%9E%9C"><span class="toc-number">1.7.5.</span> <span class="toc-text">匹配结果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%AD%94%E6%A1%88"><span class="toc-number">1.7.6.</span> <span class="toc-text">最终答案：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-6"><span class="toc-number">1.8.</span> <span class="toc-text">3.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-6"><span class="toc-number">1.8.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%99%88%E8%BF%B0"><span class="toc-number">1.8.2.</span> <span class="toc-text">不正确的陈述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%B5%8B%E9%87%8F%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E5%A4%A7%E4%BA%8E"><span class="toc-number">1.8.3.</span> <span class="toc-text">1. 当前测量的吞吐量大于 ( )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%B5%8B%E9%87%8F%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E7%AD%89%E4%BA%8E%E6%88%96%E7%95%A5%E5%B0%8F%E4%BA%8E"><span class="toc-number">1.8.4.</span> <span class="toc-text">2. 当前测量的吞吐量等于或略小于 (
)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%B5%8B%E9%87%8F%E7%9A%84%E5%90%9E%E5%90%90%E9%87%8F%E8%BF%9C%E5%B0%8F%E4%BA%8E"><span class="toc-number">1.8.5.</span> <span class="toc-text">3. 当前测量的吞吐量远小于 ( )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.8.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#section-7"><span class="toc-number">1.9.</span> <span class="toc-text">3.8</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#knowledge-checks-%E7%9F%A5%E8%AF%86%E6%A3%80%E6%9F%A5-7"><span class="toc-number">1.9.1.</span> <span class="toc-text">Knowledge checks 知识检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA-9"><span class="toc-number">1.9.2.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-1"><span class="toc-number">1.9.3.</span> <span class="toc-text">选项 1:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-2"><span class="toc-number">1.9.4.</span> <span class="toc-text">选项 2:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-3"><span class="toc-number">1.9.5.</span> <span class="toc-text">选项 3:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E9%A1%B9-4"><span class="toc-number">1.9.6.</span> <span class="toc-text">选项 4:</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>