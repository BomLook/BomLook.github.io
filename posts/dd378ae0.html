<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS106L | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="CS106L Types and Structs cpp的命令行编译方法： $ g++ main.cpp -o main		# g++ is the complier, outputs binary to main$ ./main					# This actually runs our program cpp和java一样，都是静态类型的语言，变量一旦被声明，就不能修改其类型。 (int) x将">
<meta property="og:type" content="article">
<meta property="og:title" content="CS106L">
<meta property="og:url" content="https://www.heavenhold.cn/posts/dd378ae0.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="CS106L Types and Structs cpp的命令行编译方法： $ g++ main.cpp -o main		# g++ is the complier, outputs binary to main$ ./main					# This actually runs our program cpp和java一样，都是静态类型的语言，变量一旦被声明，就不能修改其类型。 (int) x将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124946.webp">
<meta property="article:published_time" content="2024-11-05T02:07:00.000Z">
<meta property="article:modified_time" content="2024-11-05T02:10:58.872Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="CS106L">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124946.webp"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111410735.webp"><link rel="canonical" href="https://www.heavenhold.cn/posts/dd378ae0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS106L',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-05 10:10:58'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css">
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/blog-pic@main/img/202408111411832.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">184</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124946.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS106L</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-05T02:07:00.000Z" title="发表于 2024-11-05 10:07:00">2024-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-05T02:10:58.872Z" title="更新于 2024-11-05 10:10:58">2024-11-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS106L/">CS106L</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CS106L/cpp/">cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>77分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS106L"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="cs106l">CS106L</h1>
<h2 id="types-and-structs">Types and Structs</h2>
<p><code>cpp</code>的命令行编译方法：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">$ g++ main.cpp -o main		# g++ is the complier, outputs binary to main</span><br><span class="line">$ ./main					# This actually runs our program</span><br></pre></td></tr></tbody></table></figure>
<p><code>cpp</code>和<code>java</code>一样，都是静态类型的语言，变量一旦被声明，就不能修改其类型。</p>
<p><code>(int) x</code>将 <code>x</code>转换为<code>int</code>类型，去除浮点数部分。</p>
<p>结构体初始化方法：假设定义了一个<code>StanfordID</code>，拥有三个内置变量：<code>name</code>，<code>sunet</code>，<code>idNumber</code>。</p>
<p>使用的就是列表式初始化。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">StanfordID yrb = {<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>};</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">StanfordID yrb {<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure>
<p><code>pair</code>模板：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pair</span>{</span><br><span class="line">	T1 first;</span><br><span class="line">	T2 second;</span><br><span class="line">};</span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>需要使用<code>#include&lt;utility&gt;</code>。</p>
<p><code>using</code>可以用于对类型进行缩写。如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> zeros = std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt;;</span><br></pre></td></tr></tbody></table></figure>
<p><code>auto</code>关键字可以让编译器自动推导类型，如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">solveProblem</span>(a, b, c);</span><br><span class="line"><span class="comment">//solveProblem returns std::pair&lt;bool, std::pair&lt;double, double&gt;&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>但是注意<code>auto</code>还是静态类型的，下面的操作是非法的：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">1</span>;</span><br><span class="line">i = <span class="string">"hello world!"</span>;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="initialization-and-references">Initialization and References</h2>
<p>推荐：在声明一个变量时对其进行初始化。</p>
<p>直接初始化：</p>
<p><code>cpp</code>在进行直接初始化时”不会进行类型检查“（实际上是进行了隐式类型转换）。例子如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> numOne = <span class="number">12.0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numTwo</span><span class="params">(<span class="number">12.0</span>)</span></span>;</span><br><span class="line"><span class="comment">//输出结果都是12, 第一个进行了隐式类型转换，编译器没有报错，表现出好像没有进行类型检查</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用这种方法可能会导致数据发生<code>narrowing conversion</code>，损失精度。</p>
<p>统一初始化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12.0</span>}</span><br><span class="line"><span class="type">double</span> numTwo{<span class="number">12.0</span>}</span><br></pre></td></tr></tbody></table></figure>
<p>这种情况下：编译器会报错，提示<code>double cannot be narrowed to int in initializer list</code>。</p>
<p>修改方法为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> numOne{<span class="number">12</span>}</span><br><span class="line"><span class="type">double</span> numTwo{<span class="number">12.0</span>}</span><br><span class="line"><span class="comment">//输出结果都是12</span></span><br></pre></td></tr></tbody></table></figure>
<p>统一初始化更加安全，因为不允许进行<code>narrowing conversions</code>，这是一种通用的方法。</p>
<p>在 C++17 中，<strong>结构化绑定（Structured Binding）</strong> 是一种便捷的语法，用于将结构体、数组或元组类型的多个成员解构到各个变量中，方便访问每个元素的值或进行解构赋值。</p>
<p>基本语法</p>
<p>结构化绑定使用 <code>auto</code> 关键字进行解构，并通过大括号 <code>{}</code> 来表示多个绑定变量：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [var1, var2, var3] = expression;</span><br></pre></td></tr></tbody></table></figure>
<p>其中 <code>expression</code> 必须是一个支持解构的类型，比如元组、数组、结构体等。</p>
<p>使用场景</p>
<ol>
<li>
<p><strong>解构 <code>std::pair</code> 或 <code>std::tuple</code></strong>：这是结构化绑定最常见的用法，特别是用于 STL 容器中返回 <code>pair</code> 的情况。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; data = {<span class="number">42</span>, <span class="number">3.14</span>, <span class="string">"Hello"</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = data; <span class="comment">// x -&gt; 42, y -&gt; 3.14, z -&gt; "Hello"</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">", "</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>解构 <code>std::map</code> 的迭代器</strong>：在遍历 <code>std::map</code> 时，可以直接解构键和值。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; map = {{<span class="number">1</span>, <span class="string">"One"</span>}, {<span class="number">2</span>, <span class="string">"Two"</span>}};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [key, value] : map) {</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>解构结构体</strong>：如果一个结构体的所有成员都是公共的，或者是 <code>public</code> 的 <code>struct</code>，可以直接用结构化绑定解构它的成员。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Point p = {<span class="number">10</span>, <span class="number">20</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [x, y] = p; <span class="comment">// x -&gt; 10, y -&gt; 20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"x: "</span> &lt;&lt; x &lt;&lt; <span class="string">", y: "</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>解构数组</strong>：可以用于定长数组，便于直接获得每个元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = arr; <span class="comment">// a -&gt; 1, b -&gt; 2, c -&gt; 3</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<p>注意事项</p>
<ul>
<li>结构化绑定只适用于支持解构的类型（如数组、元组、<code>std::pair</code>、<code>struct</code> 等）。</li>
<li>在结构体上使用时，成员必须是公共的且支持解构。</li>
<li>绑定变量会是常量或引用，如果原类型是 <code>const</code> 或 <code>&amp;</code> 类型，解构出的变量会保留这些修饰符。</li>
</ul>
<p>优点</p>
<ul>
<li>提高了代码可读性和简洁性。</li>
<li>避免了手动解引用和访问成员，直接从容器或复合类型中获取多个值。</li>
</ul>
<p>引用：需要注意下面一个点：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [num1, num2]: nums)	<span class="comment">//注意这里没有&amp;</span></span><br><span class="line">    {</span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v = {{<span class="number">0</span>, <span class="number">0</span>}, {<span class="number">1</span>, <span class="number">1</span>}, {<span class="number">2</span>, <span class="number">2</span>}};</span><br><span class="line">    <span class="built_in">shift</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y]: v){</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出 001122</span></span><br></pre></td></tr></tbody></table></figure>
<p>虽然是按照值传递，但是我们没有对<code>nums</code>进行修改。</p>
<p>如果要进行修改，正确的方法如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shift</span><span class="params">(std::vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[num1, num2]: nums)	<span class="comment">//注意这里有&amp;</span></span><br><span class="line">    {</span><br><span class="line">        num1++;</span><br><span class="line">        num2++;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v = {{<span class="number">0</span>, <span class="number">0</span>}, {<span class="number">1</span>, <span class="number">1</span>}, {<span class="number">2</span>, <span class="number">2</span>}};</span><br><span class="line">    <span class="built_in">shift</span>(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [x, y]: v){</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//输出 112233</span></span><br></pre></td></tr></tbody></table></figure>
<p>引用只能用于左值！！！</p>
<p>左值和右值：</p>
<p>左值：一个左值既可以在表达式左边也可以在表达式右边。</p>
<p>右值：只能在表达式右边，可以理解为其是”暂时的“。暂时的变量不可以被引用。</p>
<p>如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> y = x;	<span class="comment">//allowed</span></span><br><span class="line">x = <span class="number">3434</span>;	<span class="comment">//allowed</span></span><br><span class="line"><span class="type">int</span> y = <span class="number">21</span>;	<span class="comment">//allowed</span></span><br><span class="line"><span class="number">21</span> = y;		<span class="comment">//not allowed</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>const</code>限定符：</p>
<p>限制数据类型无法进行修改：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };  <span class="comment">/// a normal vector</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; const_vec{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };  <span class="comment">/// a const vector</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;&amp; ref_vec{ vec };  <span class="comment">/// a reference to 'vec'</span></span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; const_ref{ vec };  <span class="comment">/// a const reference</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is ok!</span></span><br><span class="line">const_vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// no, this is const!</span></span><br><span class="line">ref_vec.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is ok, just a reference!</span></span><br><span class="line">const_ref.<span class="built_in">push_back</span>(<span class="number">3</span>); <span class="comment">/// this is const, compiler error!</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以发现：如果原来的对象限定为<code>const</code>，我们无法进行修改。</p>
<p>下面的操作也是非法的：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/// a const vector</span></span><br><span class="line"><span class="type">const</span> std:: std:: vector&lt; vector&lt; <span class="type">int</span>&gt; const_vec{ 1, 2, 3 };</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt;&amp; bad_ref{ const_vec }; 	//BAD</span><br><span class="line"><span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; good_ref{const_vec};	//GOOD</span><br></pre></td></tr></tbody></table></figure>
<p>编译<code>cpp</code>程序：</p>
<p>以下是使用<code>g++</code>进行程序编译：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line">$ g++ -std::c++<span class="number">20</span> main.cpp -o main</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>g++</code>：编译器命令。</li>
<li><code>-std::c++20</code>：指定<code>cpp</code>版本。</li>
<li><code>main.cpp</code>：指的是源文件。</li>
<li><code>-o</code>：对可执行文件指定具体的名称。</li>
<li><code>main</code>：在这里是<code>main</code>。</li>
</ul>
<h2 id="streams">Streams</h2>
<p><code>cerr</code>：用于输出错误。</p>
<p><code>clog</code>：用于非关键事件日志记录。</p>
<p><code>cout</code>：标准输出流。</p>
<p><code>cin</code>：标准输入流。</p>
<p><code>stringstream</code></p>
<p>有两种初始化的方法：一种是构造函数初始化，另外一种是 <code>&lt;&lt;</code> 初始化。</p>
<p>注意是以<code>\n</code>为字符串的结尾。</p>
<p>e.g：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::string initial_quote = <span class="string">"Bjarne Stroustrup C makes it easy to shoot yourself in the foot"</span>;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; initial_quote;</span><br><span class="line"><span class="string">"Bjarne Stroustrup C makes it easy to shoot yourself in the foot\n"</span>;</span><br><span class="line"><span class="comment">//注意是以\n为结尾。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// data destinations</span></span><br><span class="line">std::string first; std::string last; std::string language, extracted_quote;</span><br><span class="line">ss &gt;&gt; first &gt;&gt; last &gt;&gt; language;</span><br><span class="line">ss &gt;&gt; extracted_quote;</span><br><span class="line"><span class="comment">//利用 &lt;&lt; 进行提取</span></span><br><span class="line"><span class="comment">//注意 &lt;&lt; 是读取到空格进行提取：除了 Bjarne Stroustrup C 正常提取外，剩下的后面只能提取到 makes</span></span><br><span class="line"><span class="comment">//解决方法：使用getline。</span></span><br><span class="line">std::<span class="built_in">getline</span>(ss, extracted_quote);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p><code>istream&amp; getline(istream&amp; is, string&amp; str, char delim)</code><br>
<strong><code>getline</code> 函数的定义</strong>：它接受三个参数：</p>
<ol>
<li><code>istream&amp; is</code>：输入流，比如 <code>cin</code> 或者文件输入流。</li>
<li><code>string&amp; str</code>：用于存储读取内容的字符串。</li>
<li><code>char delim</code>：自定义的分隔字符，<code>getline</code> 会读取内容直到遇到这个字符才停止。</li>
</ol>
</li>
<li>
<p><strong><code>getline()</code> 读取输入流 <code>is</code>，直到遇到 <code>delim</code> 字符，并将内容存储到 <code>str</code> 中</strong>。<br>
<code>getline</code> 函数会从输入流 <code>is</code> 读取内容，遇到分隔字符 <code>delim</code> 时停止，然后将读取到的内容存储在 <code>str</code> 中。</p>
</li>
<li>
<p><strong>默认情况下，分隔字符 <code>delim</code> 是换行符 <code>\n</code></strong>。<br>
如果不指定 <code>delim</code>，默认分隔字符是换行符 <code>\n</code>，也就是说 <code>getline</code> 会读取一行内容直到换行。</p>
</li>
<li>
<p><code>getline</code>会忽略这个分隔符<code>delim</code>，不会将其存储到目标字符串中<code>str</code>。</p>
</li>
</ul>
<p><strong>在输出流中，字符会首先被存储在一个中间缓冲区中，然后再传送到最终的输出目标（例如，控制台或文件）</strong>。这个缓冲区的作用是提高输出效率，因为直接对输出设备（如硬盘或屏幕）写操作的代价较高。</p>
<p>具体解释如下：</p>
<ol>
<li>
<p><strong>缓冲区的概念</strong>：<br>
当我们将数据写入输出流（例如 <code>std::cout</code>）时，数据并不会立刻显示在屏幕上。取而代之的是，数据会先存放在内存中的一个缓冲区中。</p>
</li>
<li>
<p><strong>缓冲区的作用</strong>：<br>
缓冲区可以暂时存储多个字符，这样可以一次性将这些数据输出，减少实际输出操作的次数，从而提升程序的运行效率。</p>
</li>
<li>
<p><strong>Flush（刷新）缓冲区</strong>：<br>
缓冲区会在特定的情况下自动刷新，将数据发送到最终的目的地。例如：</p>
<ul>
<li>程序执行 <code>std::endl</code> 或调用 <code>.flush()</code> 方法。</li>
<li>缓冲区满了，达到系统设置的容量上限。</li>
<li>程序正常结束时，缓冲区会被强制刷新。</li>
</ul>
</li>
</ol>
<p>示例</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Hello"</span>;  <span class="comment">// "Hello" 被暂时存储在缓冲区中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; std::endl;  // 此时缓冲区会被刷新，"Hello" 会被输出到屏幕</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 程序结束时，缓冲区也会被刷新，输出 "Hello"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，如果不使用 <code>std::endl</code> 或 <code>flush</code>，那么 <code>"Hello"</code> 可能会等到程序结束时才被输出，因为它在缓冲区中等待输出操作。</p>
<p><code>std::endl</code>还有告诉输出流该行输出硬件结束的功能，同时告诉<code>streams</code>进行<code>flush</code>。</p>
<p><code>flush</code>不会执行换行的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410271109094.webp" alt=""></p>
<blockquote>
<p>这段文字讨论了 C++中的标准输出缓冲刷新机制，尤其是<code>'\n'</code>换行符与<code>std::cout</code>之间的关系。主要意思是：</p>
<ol>
<li>在很多 C++实现中，标准输出（例如<code>std::cout</code>）是<strong>行缓冲的</strong>，这意味着当遇到<code>'\n'</code>时会自动刷新缓冲区（即输出到终端）。</li>
<li>除非显式调用 <code>std::ios::sync_with_stdio(false)</code> 禁用与 C 标准输入输出的同步，否则大多数情况下，<code>'\n'</code>会像 <code>std::endl</code> 一样刷新缓冲区。</li>
<li>这意味着 <code>'\n'</code>和<code>std::endl</code>在大多数情况下效果类似，都会导致输出刷新到屏幕上。</li>
<li>但是，在文件输出中，<code>'\n'</code>不会立即刷新缓冲区，这与标准输出的行为有所不同。</li>
</ol>
<p>总结来说，<code>'\n'</code>在标准输出时会刷新缓冲区，而在文件输出中则不会，这种行为可以通过 <code>std::ios::sync_with_stdio(false)</code> 进行控制。</p>
</blockquote>
<p>缓冲区的作用：</p>
<blockquote>
<p>缓冲区的主要作用是<strong>提高性能</strong>。当程序输出数据时，缓冲区会临时存储这些数据，等到满足一定条件（比如缓冲区满了，或遇到换行符）时，才将数据一次性输出到目标（如屏幕、文件、网络等）。这减少了 I/O 操作的次数，从而提高了程序的运行效率。</p>
<p>以下是缓冲区的作用和刷新缓冲区对性能的影响：</p>
<ol>
<li>
<p><strong>减少 I/O 操作次数</strong>：每次 I/O 操作都会耗费系统资源，尤其是涉及磁盘或网络的操作。通过缓冲区，可以将多次小规模的 I/O 操作合并为一次大规模的 I/O 操作，显著减少系统调用的次数，从而提高性能。</p>
</li>
<li>
<p><strong>提高数据传输效率</strong>：例如，向磁盘写入数据时，每次写入都有一定的开销。如果每次输出一个字符或少量数据，开销会很大。而使用缓冲区，可以等积累了一批数据后再统一写入，这样速度更快。</p>
</li>
<li>
<p><strong>自动刷新机制</strong>：在某些情况下，程序会自动刷新缓冲区，比如遇到换行符（在行缓冲模式下）或程序结束时。这使得输出数据更灵活，用户在需要实时查看输出时可以使用手动刷新（如<code>std::endl</code> 或 <code>std::flush</code>），而在不需要时可以依赖缓冲区延迟输出以提高性能。</p>
</li>
</ol>
<h3 id="刷新缓冲区的代价">刷新缓冲区的代价</h3>
<p>虽然刷新缓冲区能让数据立即显示出来，但频繁刷新会影响性能，尤其是在循环中频繁输出时。例如，以下代码会导致多次刷新：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;  <span class="comment">// 每次迭代都刷新缓冲区</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这会比以下代码效率低得多：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) {</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="string">"\n"</span>;  <span class="comment">// 缓冲区满了才刷新，减少了刷新次数</span></span><br><span class="line">}</span><br><span class="line">std::cout &lt;&lt; std::flush;  <span class="comment">// 只在需要时手动刷新</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结">总结</h3>
<p>缓冲区通过减少 I/O 操作次数来提升性能，而刷新缓冲区会影响性能。在实时性要求不高的情况下，利用缓冲区延迟输出是提升程序效率的重要手段。</p>
</blockquote>
<p><strong>C++ 在一些情况下会自动刷新（flush）输出缓冲区，而不需要程序员手动调用 <code>std::flush</code> 或 <code>std::endl</code> 来刷新</strong>。这是因为 C++ 的标准库会在特定条件下自动触发缓冲区的刷新，将缓冲区中的数据输出到终端或文件中。</p>
<p>自动刷新（Auto Flush）的情况</p>
<p>C++ 会在以下几种情况自动刷新输出缓冲区：</p>
<ol>
<li>
<p><strong>输出换行符 <code>std::endl</code></strong><br>
当使用 <code>std::endl</code> 时，它不仅会输出换行符，还会自动刷新缓冲区。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; std::endl;  <span class="comment">// 输出 "Hello" 并自动刷新</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>程序正常结束时</strong><br>
在 <code>main</code> 函数结束时，C++ 会自动刷新所有缓冲区，确保所有输出都被显示或保存。</p>
</li>
<li>
<p><strong>输入流和输出流交替使用时</strong><br>
当输入和输出流（如 <code>std::cin</code> 和 <code>std::cout</code>）交替使用时，C++ 会自动刷新输出缓冲区。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">"Enter a number: "</span>;  <span class="comment">// 自动刷新，使提示信息立即显示</span></span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">std::cin &gt;&gt; num;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>缓冲区满时</strong><br>
如果缓冲区中的数据达到了系统设定的上限，C++ 会自动刷新缓冲区，确保数据被输出。</p>
</li>
</ol>
<p>总结</p>
<p>C++ 的输出流在这些场景下会自动刷新，确保重要信息及时输出，而不需要程序员显式地进行缓冲区管理。</p>
<blockquote>
<p><code>std::stringstream</code> 是 C++ 标准库中的一个类，用于将字符串和其他类型的数据相互转换，同时提供类似流（<code>std::cin</code>、<code>std::cout</code>）的接口来操作字符串数据。它在处理格式化字符串和数据转换时非常有用，例如从字符串中提取数值或将数值转换成字符串。</p>
<p>基本用法</p>
<p><code>std::stringstream</code> 位于 <code>&lt;sstream&gt;</code> 头文件中，可以通过以下方式包含：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>常用的 <code>stringstream</code> 相关类有：</p>
<ul>
<li><code>std::istringstream</code>：从字符串中读取数据。</li>
<li><code>std::ostringstream</code>：向字符串中写入数据。</li>
<li><code>std::stringstream</code>：既能读取又能写入字符串。</li>
</ul>
<p>常见操作</p>
<ol>
<li>初始化与写入</li>
</ol>
<p><code>std::stringstream</code> 可以通过构造函数直接初始化字符串或调用 <code>&lt;&lt;</code> 操作符进行写入。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::stringstream ss;      <span class="comment">// 创建一个 stringstream 对象</span></span><br><span class="line">    ss &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; <span class="number">42</span>;     <span class="comment">// 向流中写入字符串和整数</span></span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>();     <span class="comment">// 输出整个字符串流内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Hello, 42</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>从字符串读取</li>
</ol>
<p>可以使用 <code>&gt;&gt;</code> 操作符从 <code>std::stringstream</code> 中读取数据，并支持自动的类型转换。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::string str = <span class="string">"100 3.14 Hello"</span>;</span><br><span class="line">    <span class="function">std::stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">    std::string word;</span><br><span class="line"></span><br><span class="line">    ss &gt;&gt; i &gt;&gt; d &gt;&gt; word; <span class="comment">// 从流中读取整数、浮点数和字符串</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Integer: "</span> &lt;&lt; i &lt;&lt; <span class="string">", Double: "</span> &lt;&lt; d &lt;&lt; <span class="string">", String: "</span> &lt;&lt; word &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Integer: 100, Double: 3.14, String: Hello</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li>数据转换</li>
</ol>
<p><code>std::stringstream</code> 常用于数据转换，比如将数值转换为字符串，或从字符串中解析出数值。</p>
<ul>
<li>
<p><strong>数值转字符串</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> number = <span class="number">42</span>;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; number;</span><br><span class="line">std::string str = ss.<span class="built_in">str</span>();  <span class="comment">// 获取流中的字符串</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">"String: "</span> &lt;&lt; str &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>字符串转数值</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::string str = <span class="string">"123"</span>;</span><br><span class="line"><span class="function">std::stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line">ss &gt;&gt; number;</span><br><span class="line">std::cout &lt;&lt; <span class="string">"Number: "</span> &lt;&lt; number &lt;&lt; std::endl;</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ol start="4">
<li>清除流内容</li>
</ol>
<p>可以通过调用 <code>.str("")</code> 清空流内容，或通过 <code>.clear()</code> 清除错误标志以便重新使用。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="number">100</span>;</span><br><span class="line">ss.<span class="built_in">str</span>(<span class="string">""</span>);    <span class="comment">// 清空流内容</span></span><br><span class="line">ss.<span class="built_in">clear</span>();    <span class="comment">// 清除错误标志</span></span><br></pre></td></tr></tbody></table></figure>
<p>优点</p>
<ul>
<li><strong>便捷的数据转换</strong>：通过流的方式自动处理格式化。</li>
<li><strong>高效读取</strong>：可以逐个提取不同类型的数据，简化从字符串中提取信息的过程。</li>
</ul>
<p>注意事项</p>
<ul>
<li>使用 <code>&gt;&gt;</code> 读取数据时，如果流中内容与预期数据类型不匹配，可能会导致读取失败，需要检查并处理流的状态。</li>
</ul>
</blockquote>
<p>下面是文件输入输出流：</p>
<blockquote>
<p><code>testFstream</code> 函数通常用于测试 C++中的文件流操作，即使用<code>std::fstream</code>对象进行文件的读写操作。<code>fstream</code>类位于<code>&lt;fstream&gt;</code>头文件中，提供了处理文件输入输出的功能。以下是一个示例代码，展示了<code>testFstream</code>函数如何执行基本的文件读写操作：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFstream</span><span class="params">()</span> </span>{</span><br><span class="line"> std::fstream file;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 打开文件进行读写操作（如果文件不存在则创建它）</span></span><br><span class="line"> file.<span class="built_in">open</span>(<span class="string">"example.txt"</span>, std::ios::in | std::ios::out | std::ios::trunc);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!file) {</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">"文件无法打开！"</span> &lt;&lt; std::endl;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 写入文件</span></span><br><span class="line"> file &lt;&lt; <span class="string">"Hello, world!"</span> &lt;&lt; std::endl;</span><br><span class="line"> file &lt;&lt; <span class="string">"This is a test for fstream."</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line"> file.<span class="built_in">seekg</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 读取文件内容</span></span><br><span class="line"> std::string line;</span><br><span class="line"> <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) {</span><br><span class="line">     std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 关闭文件</span></span><br><span class="line"> file.<span class="built_in">close</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="built_in">testFstream</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="代码解释">代码解释</h3>
<ol>
<li><strong>打开文件</strong>：<code>file.open("example.txt", std::ios::in | std::ios::out | std::ios::trunc);</code> 打开文件<code>example.txt</code>进行读写。如果文件不存在，将创建该文件，<code>std::ios::trunc</code>表示打开时会清空已有内容。</li>
<li><strong>写入文件</strong>：使用<code>file &lt;&lt; "text"</code>将内容写入文件。</li>
<li><strong>重定位文件指针</strong>：通过<code>file.seekg(0)</code>将读取指针移动到文件开头，以便接下来可以读取刚刚写入的内容。</li>
<li><strong>读取文件</strong>：通过<code>std::getline(file, line)</code>逐行读取文件内容并输出到控制台。</li>
<li><strong>关闭文件</strong>：使用<code>file.close()</code>关闭文件，释放资源。</li>
</ol>
<p><code>testFstream</code>函数展示了文件流的基本操作，适用于需要文件读写的简单场景。</p>
</blockquote>
<p><code>std::cin</code> 是一个缓存，可视作一个用户暂时存储数据，然后再从其中读取的地方。</p>
<p>它将会在遇到空白符是停止：空白符指<code>" "</code>，<code>\n</code>，<code>\t</code>。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    <span class="type">double</span> tao = <span class="number">12</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::cin &gt;&gt; pi;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line">    std::cin &gt;&gt; tao;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"my name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">"\ntao is: "</span> &lt;&lt; tao &lt;&lt; <span class="string">"\npi is: "</span> &lt;&lt; pi &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果是合法的输入，和理想情况一样。</p>
<p>如果是非法的输入，就比较有趣了：</p>
<figure class="highlight cmd"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">3</span>.<span class="number">14</span> xxx yyy <span class="number">222</span></span><br><span class="line">my name is: xxx</span><br><span class="line">tao is: <span class="number">0</span></span><br><span class="line">pi is: <span class="number">3</span>.<span class="number">14</span></span><br></pre></td></tr></tbody></table></figure>
<p>这是因为在<code>cin</code>在读取到空白符时就会停止。</p>
<p>为什么<code>tao</code>会是 0？</p>
<blockquote>
<p>当输入<code>tao</code>时，由于输入<code>yyy</code>无法被解析为<code>double</code>类型，<code>std::cin &gt;&gt; tao</code> 操作失败，导致流进入“错误状态”。在这种情况下，<code>std::cin</code>会默认保留<code>tao</code>变量的原始值，或者初始化值。在你的代码中，<code>tao</code>原本被初始化为<code>12</code>，但在 C++中，当流读取失败时，未成功写入的变量通常保持默认的值。这里，流的错误会将未读取的变量视作无效，使得 <code>tao</code>的值被保留为<code>0</code>（即初始化失败的情况下，它无法保留原本预设的数值<code>12</code>）。</p>
<p>在这种错误状态中：</p>
<ol>
<li>变量 <code>tao</code> 无法获得新值；</li>
<li>因错误状态未清除，变量内容被保留为<code>0</code>。</li>
</ol>
<p>为解决此问题，可以在错误检测后重设变量，清除流错误状态并重新输入</p>
</blockquote>
<p>修改方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">double</span> pi;</span><br><span class="line">    <span class="type">double</span> tao = <span class="number">12</span>;</span><br><span class="line">    std::string name;</span><br><span class="line">    std::cin &gt;&gt; pi;</span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, name);	<span class="comment">//第一次遇到\n，停止读取，name为空</span></span><br><span class="line">    std::<span class="built_in">getline</span>(std::cin, name);	<span class="comment">//再次读取，能够读取完整的名字。</span></span><br><span class="line">    std::cin &gt;&gt; tao;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"my name is: "</span> &lt;&lt; name &lt;&lt; <span class="string">"\ntao is: "</span> &lt;&lt; tao &lt;&lt; <span class="string">"\npi is: "</span> &lt;&lt; pi &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>getline</code>这里默认遇到<code>\n</code>停止读取。</p>
<p>注意不要一起使用<code>std::getline</code>和<code>std::cin</code>，除非迫不得已。</p>
<h2 id="containers">Containers</h2>
<p>解决如何存储组织数据的问题。</p>
<p>建议：使用基于范围的迭代，可以适用于所有可以迭代的容器。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> ele: vec){</span><br><span class="line">	std::cout &lt;&lt; ele &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>建议：使用<code>const auto&amp;</code>，可以比减少潜在的对每个元素的复制花费。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; elem: v)</span><br></pre></td></tr></tbody></table></figure>
<p>运算符<code>[]</code>没有提供下边检查。</p>
<blockquote>
<p><strong>Zero overhead</strong>（零开销）是 C++ 语言设计中的一个重要理念，指的是在使用高级特性时不会增加额外的运行时开销。这意味着当你在 C++ 中使用更抽象的、高级的语言特性（如模板、RAII、智能指针等）来编写代码时，这些特性不会比直接用低级代码写的等价代码更慢。换句话说，如果一种高级特性可以被优化为零开销，那么编译器就会尽量实现这种优化。</p>
<h3 id="具体含义">具体含义</h3>
<ol>
<li>
<p><strong>抽象无开销</strong>：高级特性如模板、类和运算符重载等，编译器会尽量将它们优化成零开销。这种情况下，使用这些抽象的代码的性能会与直接写底层代码（比如直接使用函数指针或普通的循环）相同。例如，模板编程会被编译器实例化为具体类型的代码，避免了运行时的多态开销。</p>
</li>
<li>
<p><strong>编译器优化</strong>：C++ 编译器会对代码进行优化，剔除不必要的开销。例如，在使用 <code>std::vector</code> 等标准容器时，编译器会优化掉没有用到的边界检查和迭代器检查，使其性能接近于原生数组。</p>
</li>
<li>
<p><strong>不使用即不付费</strong>：C++ 的零开销哲学还包括“不使用即不付费”（you don’t pay for what you don’t use）。如果你没有使用某个功能或特性，它不会给程序带来任何额外的开销。这样设计的目的是让程序员在追求性能时，可以更灵活地选择需要的特性。</p>
</li>
</ol>
<h3 id="实例">实例</h3>
<h4 id="1-模板的零开销">1. 模板的零开销</h4>
<p>模板可以为每个具体类型生成特定代码，避免了运行时的多态性开销：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 模板实例化后，相当于直接调用 int add(int, int)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，模板在编译期实例化，不会有运行时的额外开销。</p>
<h4 id="2-raii-的零开销">2. RAII 的零开销</h4>
<p>RAII（Resource Acquisition Is Initialization）利用构造和析构函数自动管理资源，使得资源管理代码不会带来额外的运行时开销：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 智能指针自动管理内存</span></span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">}  <span class="comment">// 离开作用域后，内存自动释放</span></span><br></pre></td></tr></tbody></table></figure>
<p>通过 RAII 方式管理内存，不会增加运行时开销，而且比手动管理更安全。</p>
<h3 id="总结">总结</h3>
<p>“Zero overhead” 是 C++ 的设计哲学之一，允许程序员在使用高级特性和抽象时，仍然能够写出高性能、接近底层实现的代码。这种设计平衡了代码的抽象度和运行效率，使得 C++ 在系统编程领域中被广泛使用。</p>
</blockquote>
<p><code>deque</code>拥有和<code>vector</code>一样的接口，除此之外，还有<code>push_front</code>，<code>pop_front</code>。</p>
<p><code>vector</code>分配的内存空间是一块连续的内存，而<code>deque</code>底层分配的内存是不连续的内存块。</p>
<p>分别对应的是<code>vector</code>，<code>deque</code>，<code>map</code>，<code>unordered_map</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410261015946.webp" alt=""></p>
<blockquote>
<p>在 <code>std::map&lt;K, V&gt;</code> 中，键 <code>K</code> 是常量类型 (<code>const</code>) 的原因是为了确保<strong>映射的键一旦插入后便不会被修改</strong>。这样设计有助于保持映射的有序性和数据完整性。具体原因包括以下几点：</p>
<h3 id="1-保持键的不可变性">1. 保持键的不可变性</h3>
<p><code>std::map</code> 是一种基于有序树结构（如红黑树）实现的容器，插入元素时会按照键值进行排序。为了保持这种有序性，<strong>键一旦插入就必须保持不变</strong>，否则改变键的值会破坏原有的排序结构，从而影响 <code>map</code> 的查找、插入和删除操作。</p>
<h3 id="2-避免误操作">2. 避免误操作</h3>
<p>在 <code>map</code> 中，如果允许修改键，会导致潜在的误操作风险。例如，假设允许修改键，则可能在无意中修改了一个键值，导致该元素不再位于正确的有序位置，甚至可能造成重复键的存在。将键设置为 <code>const</code> 后，编译器会直接禁止对键的修改，防止这些问题的出现。</p>
<h3 id="3-保证高效查找">3. 保证高效查找</h3>
<p><code>std::map</code> 使用平衡树结构来进行键的查找、插入和删除操作，而平衡树的高效查找依赖于键的有序性。键被修改后会影响查找路径，导致效率下降或查找错误。因此，通过将键定义为 <code>const</code>，可以确保 <code>map</code> 中的每个键都处于正确的有序位置，从而保持高效的查找性能。</p>
<h3 id="示例">示例</h3>
<p>例如，如果 <code>map</code> 中的键不为 <code>const</code>，以下代码可能会带来问题：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> std::map&lt;<span class="type">int</span>, std::string&gt; myMap = {{<span class="number">1</span>, <span class="string">"one"</span>}, {<span class="number">2</span>, <span class="string">"two"</span>}};</span><br><span class="line"></span><br><span class="line"> <span class="keyword">auto</span> it = myMap.<span class="built_in">find</span>(<span class="number">1</span>);</span><br><span class="line"> <span class="comment">// 假设可以修改键：*it.first = 3; // 编译错误</span></span><br><span class="line"> std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">": "</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将键设为 <code>const</code> 后，<code>it-&gt;first</code> 是不可修改的，编译器会阻止不合法的操作，确保每个键值对的有序性。</p>
</blockquote>
<p><code>map</code>可以视作<code>pair</code>的一种集合。</p>
<p><code>map</code>也可以适用于结构化绑定。</p>
<p>注意<code>map&lt;K,V&gt;</code>需要<code>K</code>拥有一个<code>&lt;</code>，也就是说，可以进行排序。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//ok</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//error</span></span><br><span class="line">std::map&lt;ifstream, <span class="type">int</span>&gt; map2;</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>是的，<code>map["A"] = 0</code> 会将键 <code>"A"</code> 插入到 <code>map</code> 中（如果 <code>"A"</code> 不存在的话）。这是因为 <code>std::map</code> 的 <code>operator[]</code> 在使用时会有以下行为：</p>
<ol>
<li>
<p><strong>如果键不存在</strong>：<code>map["A"]</code> 会创建一个新的键值对，其中键为 <code>"A"</code>，并使用 <code>V</code> 类型的默认构造值（对整数类型来说是 <code>0</code>）初始化其值。然后 <code>map["A"] = 0</code> 将值设置为 <code>0</code>，即使默认值也是 <code>0</code>，操作仍然会执行。</p>
</li>
<li>
<p><strong>如果键已经存在</strong>：<code>map["A"]</code> 将直接返回键 <code>"A"</code> 对应的值，然后将其赋值为 <code>0</code>。</p>
</li>
</ol>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line">    myMap[<span class="string">"A"</span>] = <span class="number">0</span>;  <span class="comment">// "A" 不存在时，会插入键值对 {"A", 0}</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"myMap['A']: "</span> &lt;&lt; myMap[<span class="string">"A"</span>] &lt;&lt; std::endl;  <span class="comment">// 输出 0</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Map size: "</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; std::endl;  <span class="comment">// 输出 1，表示有一个元素被插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">myMap['A']: 0</span><br><span class="line">Map size: 1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="注意">注意</h3>
<ul>
<li>使用 <code>map[key]</code> 会在键不存在时创建该键并初始化值，所以如果只是想检查键是否存在而不插入键，可以使用 <code>map.find("A")</code>，它不会修改 <code>map</code> 的内容。</li>
</ul>
</blockquote>
<blockquote>
<p><strong><code>set</code> 存储的是一组唯一的元素</strong>，意思是 <code>set</code> 容器中的每个元素都是独一无二的，不允许重复。这意味着如果试图将已经存在的元素再次插入到 <code>set</code> 中，插入操作将会被忽略，不会改变 <code>set</code> 的内容。</p>
<p>在 C++ 中，<code>std::set</code> 是一个有序集合，内部通过某种排序机制（通常是红黑树）实现的，因此所有元素也会按照顺序存储。</p>
<h3 id="特性总结">特性总结</h3>
<ol>
<li><strong>唯一性</strong>：<code>set</code> 自动确保所有元素的唯一性，插入重复元素时会被忽略。</li>
<li><strong>有序性</strong>（对于 <code>std::set</code>）：
<ul>
<li>元素按照升序（默认）或指定的排序规则排列。</li>
<li>插入元素后，不需要手动排序，<code>set</code> 会自动调整顺序。</li>
</ul>
</li>
</ol>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line"></span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">20</span>);</span><br><span class="line">    mySet.<span class="built_in">insert</span>(<span class="number">10</span>);  <span class="comment">// 10 已经存在，不会插入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : mySet) {</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">10 20</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，尽管 <code>10</code> 被插入了两次，<code>set</code> 只保留一个 <code>10</code>，确保所有元素唯一。</p>
</blockquote>
<p><code>map</code>和<code>set</code>基本上都有以下功能：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">insert(k);	//插入k	map中为insert({k, v})</span><br><span class="line">erase(k);	//删去k</span><br><span class="line">count(k) or contains(k);	//判断是否含有k</span><br><span class="line">empty();	//判断是否为空</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>map is a collection of std::pair, unordered_map stores a collection of n “buckets” of pairs</strong> 什么意思</p>
<p>这句话的意思是：</p>
<ul>
<li>
<p><strong><code>map</code> 是 <code>std::pair</code> 的集合</strong>：在 <code>std::map</code> 中，每个元素都是一个键值对（<code>std::pair&lt;Key, Value&gt;</code>），并且这些键值对是<strong>按键的顺序</strong>排列的。例如，在 <code>std::map&lt;int, std::string&gt;</code> 中，每个元素都是一个 <code>std::pair&lt;int, std::string&gt;</code>，代表键和对应的值。<code>std::map</code> 使用平衡树结构（如红黑树）实现，保证键值对按顺序存储，且插入、删除和查找操作的时间复杂度为 (O(\log n))。</p>
</li>
<li>
<p><strong><code>unordered_map</code> 存储的是一组“桶”的集合</strong>：<code>std::unordered_map</code> 不按键的顺序存储，而是将元素放入一个由多个“桶”构成的集合中，每个桶可以存放多个键值对。桶的位置是通过哈希函数计算得到的。对于每个键值对，<code>unordered_map</code> 根据键的哈希值选择桶，然后将键值对存储在该桶中。这种实现方式使得 <code>unordered_map</code> 的查找、插入和删除的平均时间复杂度为 (O(1))。</p>
</li>
<li>
<p>具体上：就是将键值通过哈希函数进行计算，得到哈希值，最后<code>mod</code>桶的数目，得到确定的要插入的桶。后续猜测可能是使用像链表的方法进行实现。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410260929744.webp" alt=""></p>
</li>
</ul>
<h3 id="具体区别">具体区别</h3>
<ul>
<li><strong><code>std::map</code></strong>：有序映射，存储的键值对集合是有序的，每个键值对是一个 <code>std::pair</code>，键具有唯一性，适合需要按顺序遍历键值对的场景。</li>
<li><strong><code>std::unordered_map</code></strong>：无序映射，键值对存放在哈希桶中，根据哈希值查找，键具有唯一性，适合快速查找键值对的场景，但键的顺序不固定。</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::map&lt;<span class="type">int</span>, std::string&gt; orderedMap;</span><br><span class="line">    orderedMap[<span class="number">3</span>] = <span class="string">"three"</span>;</span><br><span class="line">    orderedMap[<span class="number">1</span>] = <span class="string">"one"</span>;</span><br><span class="line">    orderedMap[<span class="number">2</span>] = <span class="string">"two"</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Ordered map:"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : orderedMap) {</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; unorderedMap;</span><br><span class="line">    unorderedMap[<span class="number">3</span>] = <span class="string">"three"</span>;</span><br><span class="line">    unorderedMap[<span class="number">1</span>] = <span class="string">"one"</span>;</span><br><span class="line">    unorderedMap[<span class="number">2</span>] = <span class="string">"two"</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"\nUnordered map:"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : unorderedMap) {</span><br><span class="line">        std::cout &lt;&lt; pair.first &lt;&lt; <span class="string">": "</span> &lt;&lt; pair.second &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Ordered map:</span><br><span class="line">1: one</span><br><span class="line">2: two</span><br><span class="line">3: three</span><br><span class="line"></span><br><span class="line">Unordered map:</span><br><span class="line">3: three</span><br><span class="line">1: one</span><br><span class="line">2: two</span><br></pre></td></tr></tbody></table></figure>
<p>在 <code>orderedMap</code> 中，键值对按顺序输出；而在 <code>unorderedMap</code> 中，键值对的顺序可能因哈希函数而有所不同。</p>
</blockquote>
<blockquote>
<p><strong>What is a hash function?</strong></p>
<ul>
<li><strong>“Scrambles" a key into a size t(64 bit)</strong></li>
<li><strong>Small changes in the input should produce large changes in the output</strong></li>
</ul>
<p><strong>哈希函数</strong>是一种算法，它接受一个输入（例如一个键）并生成一个固定大小的字节串，通常用整数表示。在数据结构（如哈希表）中，哈希函数的作用是将数据映射到内存中的一个位置（例如 <code>unordered_map</code> 中的某个“桶”）。哈希函数的目标是尽可能让不同的输入映射到不同的位置，以减少“冲突”。</p>
<p>在这段描述中：</p>
<ul>
<li>
<p><strong>“将键‘扰乱’成一个 64 位的 <code>size_t</code>”</strong>：哈希函数会将输入（如字符串或整数）转换为一个固定大小的 64 位值。这里的“扰乱”意味着哈希函数会使输出看起来像是随机的，以确保即使输入值相似，输出也会非常不同。</p>
</li>
<li>
<p><strong>“输入的微小变化应在输出中产生巨大的变化”</strong>：这是一个重要特性，叫做<strong>雪崩效应</strong>。如果输入稍微变化（比如从 <code>"key1"</code> 变成 <code>"key2"</code>），哈希值应该产生显著的差异。这有助于减少相似输入产生相同哈希值的几率，从而更均匀地分布数据。</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>How is unordered map implemented?</strong></p>
<ul>
<li><strong>lf two keys hash to the same bucket, we get a hash collision</strong></li>
<li><strong>During lookup, we loop through bucket and check key equality</strong></li>
<li><strong>Two keys with the same hash are not necessarily equal!</strong></li>
</ul>
<p>在 <code>unordered_map</code> 中：</p>
<ul>
<li>
<p><strong>“如果两个键的哈希值映射到同一个桶，就会产生哈希冲突”</strong>：<code>unordered_map</code> 使用哈希函数将每个键分配到一个“桶”中。当两个不同的键产生相同的哈希值并指向同一个桶时，就会发生<strong>哈希冲突</strong>。</p>
</li>
<li>
<p><strong>“在查找时，我们遍历桶并检查键是否相等”</strong>：当 <code>unordered_map</code> 查找元素时，首先通过哈希值确定键所在的桶。如果该桶中有多个键值对（因为冲突），就会遍历该桶中的每个键，并检查它们是否与要查找的键相等。</p>
</li>
<li>
<p><strong>“两个具有相同哈希值的键不一定相等！”</strong>：这句话强调，即使两个不同的键可能产生<strong>相同的哈希值</strong>（造成冲突），但它们不一定是相等的。只有在通过 <code>==</code> 检查确认键相等时，才会认为它们是相同的，而不是仅仅因为它们的哈希值一样。</p>
</li>
</ul>
<p>这个机制让 <code>unordered_map</code> 可以通过“链式存储”来处理冲突，在同一个桶中存放多个元素，并通过检查键的相等性来区分不同的元素。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410260948623.webp" alt=""></p>
<p>存疑？</p>
<p><code>unordered_map&lt;K,V&gt;</code>需要<code>K</code>可以进行哈希操作，如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map1;		<span class="comment">//ok string double int is ok</span></span><br><span class="line">std::unordered_map&lt;ifsteam, <span class="type">int</span>&gt; map2;	<span class="comment">//error</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>Why use std::unordered map?</strong></p>
<ul>
<li><strong>Load factor: average number items per bucket</strong></li>
<li><strong>unorderedmap allows super fast lookup by keeping load factor small</strong></li>
<li><strong>If load factor gets too large (above 1.0 by default), we rehash</strong></li>
</ul>
<p>使用 <code>std::unordered_map</code> 的原因包括：</p>
<ul>
<li>
<p><strong>加载因子（Load Factor）</strong>：<code>load factor</code> 是指平均每个桶中的元素数量。<code>std::unordered_map</code> 使用哈希表存储数据，如果负载因子较低，每个桶中就会有较少的元素，查找速度会更快。<strong>保持较低的加载因子</strong>可以减少哈希冲突，确保查找操作的效率。</p>
</li>
<li>
<p><strong>超快速查找</strong>：由于 <code>std::unordered_map</code> 使用哈希表来存储数据，通常可以在 <strong>常数时间复杂度 (O(1))</strong> 下完成查找操作。保持较低的加载因子可以帮助实现这一点。</p>
</li>
<li>
<p><strong>重新哈希（rehash）</strong>：当加载因子变得过大（通常超过 1.0），即桶中平均有一个以上的元素时，<code>unordered_map</code> 会自动<strong>重新哈希</strong>，也就是增加桶的数量并重新分配所有元素，以降低加载因子。这能让查找效率维持在理想状态。</p>
</li>
</ul>
<h3 id="示例：">示例：</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span>, std::string&gt; myMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一些元素</span></span><br><span class="line">    myMap[<span class="number">1</span>] = <span class="string">"one"</span>;</span><br><span class="line">    myMap[<span class="number">2</span>] = <span class="string">"two"</span>;</span><br><span class="line">    myMap[<span class="number">3</span>] = <span class="string">"three"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出加载因子</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Load factor: "</span> &lt;&lt; myMap.<span class="built_in">load_factor</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，我们可以看到当前的加载因子，<code>unordered_map</code> 会根据它动态调整桶的数量，以保持快速查找。</p>
</blockquote>
<p>可以设置<code>unordered_map</code>的<code>load_factor</code>，确保在超过某个上限后重新进行哈希。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::unordered_map&lt;string, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="type">double</span> lf = map.<span class="built_in">load_factor</span>();	<span class="comment">//获取当前的load_factor</span></span><br><span class="line">map.<span class="built_in">max_load_factor</span>(<span class="number">2.0</span>);		<span class="comment">//重新设置max load factor</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>unorder_set</code>不用再介绍了，可以类比<code>map</code>和<code>unordered_map</code>的关系。</p>
<p>使用建议：</p>
<p><strong>When to use unordered map vs. map?</strong></p>
<ul>
<li>unordered map is usually faster than map</li>
<li>However, it uses more memory(organized vs. disorganized garage)</li>
<li>lf your key type has no total order (operator&lt;), use unordered_map!</li>
<li>lf you must choose, unordered map is a safe bet</li>
</ul>
<p>可以拓展一下：<code>array</code>，<code>list</code>，<code>multiset</code>，<code>multimap</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410261002564.webp" alt=""></p>
<h2 id="iterators">Iterators</h2>
<p>研究如何遍历容器。</p>
<p><strong>Container interface</strong><br>
<code>container begin()</code></p>
<ul>
<li>Gets an iterator to the first element of the container(assuming non-empty)</li>
</ul>
<p><code>container.end()</code></p>
<ul>
<li>Gets a past-the-end iterator</li>
<li>That is,an iterator to one element after the end of the container</li>
</ul>
<p>注意：<code>end()</code>没有指向任何一个元素。指向的是最后一个元素的后一个位置。</p>
<p>如果容器时空的，那么<code>start()==end()</code>。</p>
<p>基本四件套：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = c.<span class="built_in">begin</span>();	<span class="comment">//copy construction</span></span><br><span class="line">++it;					<span class="comment">//increament iterator forward</span></span><br><span class="line"><span class="keyword">auto</span> elem = *it;		<span class="comment">//dereference iterator -- undefined if it == end()</span></span><br><span class="line"><span class="keyword">if</span>(it == c.<span class="built_in">end</span>());</span><br></pre></td></tr></tbody></table></figure>
<p>使用<code>auto it = m.begin()</code>，这样可以避免<code>iteerator types</code>的过长拼写。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator it = m.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">begin</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>拓展升级：部分迭代器有：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">--it;	<span class="comment">//move backwoards</span></span><br><span class="line">*it = elem;	<span class="comment">//modify</span></span><br><span class="line">it += n;	<span class="comment">//rand. access</span></span><br><span class="line">it1 &lt; it2;	<span class="comment">//is before?</span></span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410261115763.webp" alt=""></p>
<p><code>Input</code>：最基础的迭代器，允许读取元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> elem = *it</span><br></pre></td></tr></tbody></table></figure>
<p>如果数据类型是<code>struct</code>，可以使用<code>-&gt;</code>访问元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="type">int</span> m = (*it).a;</span><br><span class="line"><span class="type">int</span> m = it -&gt; a;</span><br></pre></td></tr></tbody></table></figure>
<p><code>Output</code>：允许我们写元素。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">*it = elem</span><br></pre></td></tr></tbody></table></figure>
<p><code>Forward</code>：允许进行单向移动，遍历容器中的元素。但是不能后移。所有<code>STL</code>都支持该操作。</p>
<blockquote>
<p><strong>Forward Iterator</strong> 是一种迭代器类型，允许单向遍历容器中的元素。它的主要特点是可以向前移动，但不能向后移动。</p>
<h3 id="主要特性：">主要特性：</h3>
<ol>
<li>
<p><strong>单向遍历</strong>：Forward Iterator 只能向前移动，无法回退。你可以通过 <code>++</code> 操作符移动到下一个元素，但不能使用 <code>--</code> 操作符。</p>
</li>
<li>
<p><strong>可读性</strong>：可以读取指向的元素的值。这意味着你可以使用解引用操作符 <code>*</code> 来获取当前元素的值。</p>
</li>
<li>
<p><strong>可写性</strong>：一些 Forward Iterator 也支持写入操作（即可以修改所指向的元素），这取决于具体的迭代器实现。如果它是一个<strong>写入迭代器</strong>，那么你可以使用 <code>*</code> 操作符进行赋值。</p>
</li>
<li>
<p><strong>多次使用</strong>：与其他迭代器相比，Forward Iterator 可以在不同的遍历中安全地使用，这意味着你可以在遍历过程中重新使用相同的迭代器。</p>
</li>
</ol>
<h3 id="示例">示例</h3>
<p>在 C++ 中，<code>std::forward_list</code> 使用 Forward Iterator。下面是一个简单的示例，演示如何使用 Forward Iterator 遍历一个容器：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; myList = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Forward Iterator 遍历容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>(); it != myList.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结">总结</h3>
<p>Forward Iterator 是一种重要的迭代器类型，适用于需要单向访问的场景。它提供了一种简单而高效的方式来遍历容器中的元素。</p>
</blockquote>
<p><code>Bidirectional</code>：可以进行前移和后移。适用于<code>map</code>和<code>set</code>。</p>
<blockquote>
<p><strong>Bidirectional Iterator</strong> 是一种迭代器类型，允许双向遍历容器中的元素。它的主要特点是可以在前向和后向之间移动。</p>
<h3 id="主要特性：">主要特性：</h3>
<ol>
<li>
<p><strong>双向遍历</strong>：Bidirectional Iterator 可以使用 <code>++</code> 操作符向前移动到下一个元素，也可以使用 <code>--</code> 操作符向后移动到前一个元素。这使得它比单向的 Forward Iterator 更灵活。</p>
</li>
<li>
<p><strong>可读性</strong>：可以读取指向的元素的值，可以使用解引用操作符 <code>*</code> 来获取当前元素的值。</p>
</li>
<li>
<p><strong>可写性</strong>：一些 Bidirectional Iterator 也支持写入操作（即可以修改所指向的元素），这取决于具体的迭代器实现。</p>
</li>
<li>
<p><strong>适用范围广</strong>：Bidirectional Iterator 通常用于支持双向遍历的容器，例如 <code>std::list</code> 和 <code>std::set</code>。</p>
</li>
</ol>
<h3 id="示例">示例</h3>
<p>在 C++ 中，<code>std::list</code> 和 <code>std::set</code> 都使用 Bidirectional Iterator。下面是一个简单的示例，演示如何使用 Bidirectional Iterator 遍历一个 <code>std::list</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::list&lt;<span class="type">int</span>&gt; myList = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Bidirectional Iterator 正向遍历容器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Forward traversal: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myList.<span class="built_in">begin</span>(); it != myList.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Bidirectional Iterator 反向遍历容器</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Backward traversal: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = myList.<span class="built_in">end</span>(); it != myList.<span class="built_in">begin</span>();) {</span><br><span class="line">        --it;  <span class="comment">// 向前移动到前一个元素</span></span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Forward traversal: 1 2 3 4 5</span><br><span class="line">Backward traversal: 5 4 3 2 1</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结">总结</h3>
<p>Bidirectional Iterator 是一种灵活的迭代器类型，支持双向遍历，适用于需要在容器中前后移动的场景。它提供了一种简便的方法来遍历和操作容器中的元素。</p>
</blockquote>
<p><code>Random Access</code>：可以快速的执行前移和后移。支持的有<code>vector</code>和<code>deque</code>。</p>
<blockquote>
<p><strong>Random Access Iterator</strong> 是一种迭代器类型，允许对容器中的元素进行随机访问。它提供了对容器元素的直接跳转，支持多种操作，使得用户可以非常灵活地访问和修改元素。</p>
<h3 id="主要特性：">主要特性：</h3>
<ol>
<li>
<p><strong>随机访问</strong>：可以使用整数偏移量来直接访问容器中的任意元素。例如，可以使用 <code>it + n</code> 来访问距离当前迭代器 <code>n</code> 个位置的元素，或使用 <code>it[n]</code> 语法。</p>
</li>
<li>
<p><strong>支持算术运算</strong>：支持加法、减法等算术运算，例如 <code>++</code>、<code>--</code>、<code>+</code> 和 <code>-</code> 操作符。这意味着你可以快速移动到前面或后面的元素。</p>
</li>
<li>
<p><strong>可读性</strong>：可以读取指向的元素的值，可以使用解引用操作符 <code>*</code> 来获取当前元素的值。</p>
</li>
<li>
<p><strong>可写性</strong>：一些 Random Access Iterator 也支持写入操作，允许用户修改所指向的元素。</p>
</li>
<li>
<p><strong>适用范围广</strong>：Random Access Iterator 通常用于支持快速随机访问的容器，例如 <code>std::vector</code> 和 <code>std::deque</code>。</p>
</li>
</ol>
<h3 id="示例">示例</h3>
<p>在 C++ 中，<code>std::vector</code> 使用 Random Access Iterator。下面是一个简单的示例，演示如何使用 Random Access Iterator 访问一个 <code>std::vector</code> 中的元素：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 Random Access Iterator 访问元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Accessing elements using Random Access Iterator:"</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Element at index "</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; myVector[i] &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用迭代器进行随机访问</span></span><br><span class="line">    <span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Element at index 2: "</span> &lt;&lt; *(it + <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 访问第3个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Accessing elements using Random Access Iterator:</span><br><span class="line">Element at index 0: 10</span><br><span class="line">Element at index 1: 20</span><br><span class="line">Element at index 2: 30</span><br><span class="line">Element at index 3: 40</span><br><span class="line">Element at index 4: 50</span><br><span class="line">Element at index 2: 30</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结">总结</h3>
<p>Random Access Iterator 是一种非常强大和灵活的迭代器类型，支持快速和随机地访问容器中的元素。它的高效性使其在需要频繁访问和修改数据的场景中非常有用。</p>
</blockquote>
<p>使用迭代器时，注意不要越界。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410261130440.webp" alt=""></p>
<p><code>iterator</code>指向的容器中的元素。</p>
<p><code>pointer</code>指向的是任何类。</p>
<h2 id="classes">Classes</h2>
<p>析构函数是在对象离开其作用域时被自动调用的。</p>
<p>动态多态性（<strong>Dynamic Polymorphism</strong>）：不同类型的对象可能会有相同的接口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410261202427.webp" alt=""></p>
<p><strong>The constructor has all of the protected members.</strong></p>
<blockquote>
<p><strong>虚继承（Virtual Inheritance）</strong> 是 C++ 中的一种特殊继承机制，用于解决多重继承时可能出现的菱形继承问题（Diamond Problem）。</p>
<h3 id="菱形继承问题">菱形继承问题</h3>
<p>在多重继承中，如果一个类同时继承了两个基类，而这两个基类又共同继承自同一个父类，可能会导致二义性。这种情况称为菱形继承。假设有以下类关系：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">  A</span><br><span class="line"> / \</span><br><span class="line">B   C</span><br><span class="line"> \ /</span><br><span class="line">  D</span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，类 <code>B</code> 和 <code>C</code> 都从类 <code>A</code> 继承，而类 <code>D</code> 同时从类 <code>B</code> 和 <code>C</code> 继承。这样，<code>D</code> 就会有两个 <code>A</code> 的实例，这就造成了歧义，<code>D</code> 不能确定自己是通过 <code>B</code> 还是 <code>C</code> 继承的。</p>
<h3 id="虚继承的解决方案">虚继承的解决方案</h3>
<p>通过使用虚继承，所有派生类可以共享同一个基类的实例，解决了菱形继承的问题。</p>
<p>使用虚继承的示例代码如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">A</span>() { std::cout &lt;&lt; <span class="string">"A's constructor"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">B</span>() { std::cout &lt;&lt; <span class="string">"B's constructor"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">C</span>() { std::cout &lt;&lt; <span class="string">"C's constructor"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">D</span>() { std::cout &lt;&lt; <span class="string">"D's constructor"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> D d; <span class="comment">// 创建 D 的实例</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="输出">输出</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">A's constructor</span><br><span class="line">B's constructor</span><br><span class="line">C's constructor</span><br><span class="line">D's constructor</span><br></pre></td></tr></tbody></table></figure>
<h3 id="解释">解释</h3>
<ol>
<li>
<p><strong>虚继承</strong>：在 <code>B</code> 和 <code>C</code> 中使用 <code>virtual</code> 关键字继承 <code>A</code>，意味着无论 <code>D</code> 继承自 <code>B</code> 还是 <code>C</code>，它们都共享同一个 <code>A</code> 的实例。</p>
</li>
<li>
<p><strong>构造顺序</strong>：构造函数的调用顺序是：首先调用基类 <code>A</code> 的构造函数，然后是 <code>B</code> 和 <code>C</code> 的构造函数，最后是 <code>D</code> 的构造函数。这样确保了基类的构造函数只会被调用一次，避免了二义性。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<p>虚继承是 C++ 中处理多重继承中菱形继承问题的重要机制。它确保了在继承链中只存在一个基类实例，从而消除了潜在的歧义和不一致性。</p>
</blockquote>
<h2 id="templates">Templates</h2>
<blockquote>
<p>在 C++ 中，<strong>模板</strong>和 Java 中的 <strong>泛型</strong> 处理类型的方式有所不同，这影响了类型不匹配时何时会报错。以下是两者的主要区别和错误发生的时机：</p>
<h3 id="c-模板">C++ 模板</h3>
<ol>
<li>
<p><strong>实例化时</strong>：C++ 模板是在编译时进行实例化的。即当你使用某个模板类或模板函数时，编译器会生成相应的代码。因此，任何类型不匹配的错误都会在编译阶段被检测到。例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T arg)</span> </span>{</span><br><span class="line">    <span class="comment">// 可能会在这里使用 arg</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">5</span>); <span class="comment">// 正确</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">"Hello"</span>); <span class="comment">// 错误：不匹配的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，如果 <code>func</code> 的参数类型与使用的类型不匹配，编译器会在编译时抛出错误。</p>
</li>
<li>
<p><strong>多态性</strong>：由于 C++ 的模板是编译时解析的，不能使用运行时类型信息。因此，不能在运行时进行类型检查。</p>
</li>
</ol>
<h3 id="java-泛型">Java 泛型</h3>
<ol>
<li>
<p><strong>运行时检查</strong>：Java 的泛型在编译时是类型安全的，但在运行时，它们会被<strong>类型擦除（Type Erasure）</strong>。这意味着在编译阶段，泛型类型的信息会被移除，替换为原始类型。因此，泛型类型的类型不匹配通常会在编译时捕获，但某些情况下可能会在运行时引发错误。例如：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericClass</span>&lt;T&gt; {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(T arg)</span> {</span><br><span class="line">        <span class="comment">// 可能会在这里使用 arg</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        GenericClass&lt;Integer&gt; gc = <span class="keyword">new</span> <span class="title class_">GenericClass</span>&lt;&gt;();</span><br><span class="line">        gc.func(<span class="number">5</span>); <span class="comment">// 正确</span></span><br><span class="line">        <span class="comment">// gc.func("Hello"); // 编译错误：类型不匹配</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，尝试传递一个与泛型类型不匹配的参数会导致编译错误。</p>
</li>
<li>
<p><strong>运行时类型错误</strong>：由于类型擦除，Java 在某些情况下可能会在运行时引发 <code>ClassCastException</code>，例如在使用原始类型时：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 原始类型</span></span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(<span class="number">0</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> (Integer) list.get(<span class="number">0</span>); <span class="comment">// 运行时错误：ClassCastException</span></span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="总结">总结</h3>
<ul>
<li><strong>C++ 模板</strong>：错误在编译时发现，类型不匹配会导致编译错误。</li>
<li><strong>Java 泛型</strong>：大部分错误在编译时发现，但由于类型擦除，有时会在运行时发现类型不匹配的错误。</li>
</ul>
<p>这使得 C++ 在使用模板时更具类型安全性，而 Java 的泛型提供了更好的灵活性和可读性，但需要注意运行时的类型问题。</p>
</blockquote>
<p>推荐使用<code>array</code>而不是<code>vector</code>，因为避免了堆分配，已经知道确切的大小，从而进行堆栈分配。</p>
<p>下面是一些编写模板时的注意事项：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Vector.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> i)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>需要在<code>.cpp</code>文件中加上<code>template &lt;typename T&gt;</code>。并且除此之外，对应的模板也需要加上<code>&lt;T&gt;</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//error</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp; <span class="title">Vector::at</span><span class="params">(<span class="type">size_t</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><code>.h</code>文件必须包含在<code>.cpp</code>文件的底部！！！</p>
</li>
</ol>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//normal</span></span><br><span class="line"><span class="comment">//student.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//student.cpp</span></span><br><span class="line"><span class="meta">#inclucd <span class="string">"student.h"</span></span></span><br><span class="line"><span class="function">string &amp;<span class="title">student::getname</span><span class="params">(<span class="type">int</span> id)</span></span>{</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//template</span></span><br><span class="line"><span class="comment">//Vector.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Vector.h"</span>		<span class="comment">//this line is very important!!!!!!!!!</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vector.cpp</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">at</span>(<span class="type">size_t</span> i){</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在 C++ 中，当你实现模板类或模板函数时，通常会将声明放在 <code>.h</code> 文件中，将定义（实现）放在 <code>.cpp</code> 文件中。然而，模板的一个特殊之处在于，它的实现代码需要在编译时被完全看到，因此在模板的 <code>.h</code> 文件中包含对应的 <code>.cpp</code> 文件是为了确保编译器可以看到模板的定义，以便正确生成实例化代码。</p>
<h3 id="原因详解">原因详解</h3>
<ol>
<li>
<p><strong>模板的编译机制</strong>：</p>
<ul>
<li>在 C++ 中，模板的实现和实例化是在编译时完成的。编译器在看到模板定义时并不会立即生成代码，而是在模板被使用时才实例化。</li>
<li>因此，如果将模板的实现（定义）放在 <code>.cpp</code> 文件中，编译器在编译头文件时无法看到具体实现，从而无法进行实例化，会导致链接错误。</li>
</ul>
</li>
<li>
<p><strong>包含 <code>.cpp</code> 文件的解决方法</strong>：</p>
<ul>
<li>将模板的实现包含在头文件中，可以让编译器在每次需要时都能够“看到”实现细节，从而生成实例代码。</li>
<li>通过在模板的 <code>.h</code> 文件末尾包含 <code>.cpp</code> 文件，等同于将实现直接写在头文件中，同时也能保持代码结构的清晰，将声明和实现分开。</li>
</ul>
</li>
</ol>
<h3 id="实际示例">实际示例</h3>
<p>假设有一个简单的模板类 <code>MyTemplate</code>：</p>
<p><strong>MyTemplate.h</strong> 文件：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_TEMPLATE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_TEMPLATE_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTemplate</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyTemplate</span>(T value);</span><br><span class="line">    <span class="function">T <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头文件的末尾包含实现文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyTemplate.cpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_TEMPLATE_H</span></span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>MyTemplate.cpp</strong> 文件：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"MyTemplate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">MyTemplate&lt;T&gt;::<span class="built_in">MyTemplate</span>(T value) : <span class="built_in">value</span>(value) {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T MyTemplate&lt;T&gt;::<span class="built_in">getValue</span>() <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li>为了确保模板的定义在编译时可见，将 <code>.cpp</code> 文件包含在头文件末尾是一种常见的解决方法。</li>
<li>这种方式避免了链接错误，并保证了模板的实例化不会出错。</li>
<li>也可以将实现代码直接写在 <code>.h</code> 文件中，但将 <code>.cpp</code> 文件分开并在头文件包含，能保持代码的整洁和结构的清晰。</li>
</ul>
</blockquote>
<ol start="3">
<li>
<p><code>typename</code>可以替换为<code>class</code>。</p>
</li>
<li>
<p>对于一个<code>const Vector&lt;int&gt;&amp;</code>，如果我们要使用对他进行访问，我们不能修改它。</p>
<p>如果要进行访问，需要/只能使用<code>const</code>成员函数（<code>returnType function_name() const</code>），这样就保证不会出错，否则编译器会报错。如果不声明为<code>const</code>，编译器无法确认这个方法会不会对其进行修改。在<code>const</code>成员函数内，我们无法对数据成员进行修改。</p>
</li>
<li>
<p>函数也可以根据<code>const</code>进行重载。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这个函数有两个问题：</p>
<ul>
<li>
<p>我们可以在外面进行修改,，如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">v.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">20</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>我们的本意是不能进行修改，但是在函数外部发生了修改。</p>
</li>
<li>
<p>修改方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">at</span><span class="params">(<span class="type">size_t</span> index)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>以上例子的前提都是在传入的<code>v</code>是<code>const Vector&lt;int&gt;&amp; v</code>的情况下。</p>
<p>但是如果传入的<code>Vector&lt;int&gt; &amp;v</code>，那么我们会发现：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">v.<span class="built_in">at</span>(<span class="number">0</span>) = <span class="number">42</span>;	<span class="comment">//error, can't assign to cosnt int&amp;</span></span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>解决方法：</p>
<p>可以定义两个版本的函数，实现函数的重载。</p>
<p>一个是：<code>const T&amp; at(size_t index) const</code>，另外一个是<code>T&amp; at(size_t index)</code>。</p>
</li>
</ul>
</li>
<li>
<p>介绍两个函数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">T&amp; <span class="title">findElement</span><span class="params">(<span class="type">const</span> T&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> T&amp; <span class="title">findElement</span><span class="params">(<span class="type">const</span> T&amp; value)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这两个函数在实现上高度相似，都是：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">T&amp; Vector&lt;T&gt;::<span class="built_in">findElement</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">{</span><br><span class="line">	<span class="comment">//code</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果直接写很浪费，可以采用下面的方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T&amp; Vector&lt;T&gt;::<span class="built_in">findElement</span>(<span class="type">const</span> T&amp; value) <span class="type">const</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Vector&lt;T&gt;&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">findElement</span>(value)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>在 <code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this).findElement(value)</code> 中，主要做了三件事情：</p>
<ol>
<li><strong><code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this)</code></strong>：移除 <code>this</code> 指针的常量性，使其可以调用非常量（非<code>const</code>）方法。</li>
<li><strong>调用 <code>findElement(value)</code></strong>：调用一个非<code>const</code>成员函数 <code>findElement</code>，用于查找指定的 <code>value</code>。</li>
<li><strong>解释整体代码</strong>：通过<code>const_cast</code>来调用一个原本在<code>const</code>对象上无法调用的非<code>const</code>方法。</li>
</ol>
<h3 id="分解解释">分解解释</h3>
<ol>
<li>
<p><strong><code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this)</code></strong>：</p>
<ul>
<li><code>const_cast</code> 是一个 C++ 运算符，用于移除指针或引用的 <code>const</code> 限定，允许我们在<code>const</code>对象上调用非常量方法。</li>
<li><code>*this</code> 是一个指向当前对象的 <code>const</code> 指针（因为是在 <code>const</code> 成员函数中），类型是 <code>const Vector&lt;T&gt;&amp;</code>。</li>
<li><code>const_cast&lt;Vector&lt;T&gt;&amp;&gt;(*this)</code> 的意思是将 <code>*this</code> 从 <code>const Vector&lt;T&gt;&amp;</code> 转换成 <code>Vector&lt;T&gt;&amp;</code>，从而移除 <code>const</code> 限定。</li>
<li>这里的<code>Vector&lt;T&gt;&amp;</code>就是我们想要的类型。</li>
</ul>
</li>
<li>
<p><strong>调用 <code>findElement(value)</code></strong>：</p>
<ul>
<li>通过 <code>const_cast</code> 转换后，可以在原本为 <code>const</code> 的对象上调用 <code>findElement(value)</code> 这个非<code>const</code>方法。</li>
<li><code>findElement(value)</code> 方法用于在 <code>Vector&lt;T&gt;</code> 对象中查找元素 <code>value</code>。</li>
</ul>
</li>
<li>
<p><strong>整体代码作用</strong>：</p>
<ul>
<li>这一行代码的目的通常是因为查找逻辑被封装在 <code>findElement</code> 中，但它并未被定义为 <code>const</code>，而在 <code>const</code> 成员函数中无法直接调用该方法，所以通过 <code>const_cast</code> 进行转换。</li>
<li><strong>注意</strong>：使用 <code>const_cast</code> 破坏了对象的 <code>const</code> 限定，可能引发不安全的操作，因此在 C++ 中不推荐滥用 <code>const_cast</code>。</li>
</ul>
</li>
</ol>
</blockquote>
</li>
<li>
<p>除了<code>const_cast</code>之外，还有<code>mutable</code>关键字，可以对<code>const</code>对象中声明为<code>mutable</code>的数据成员进行修改。</p>
</li>
</ol>
<h2 id="template-functions">Template Functions</h2>
<p>函数模板调用：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">return</span> (a &lt; b ? a: b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实例化：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//显式实例化</span></span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(<span class="number">106</span>, <span class="number">107</span>);</span><br><span class="line"><span class="built_in">min</span>&lt;<span class="type">double</span>&gt;(<span class="number">1.2</span>, <span class="number">3.4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式实例化</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">106</span>, <span class="number">107</span>);</span><br><span class="line"><span class="built_in">min</span>(<span class="number">1.2</span>, <span class="number">3.4</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>显式实例化和隐式实例化。</p>
<p>一般更推荐显式实例化：因为可以指明类型，避免不必要的问题，另外还可以避免指针的比较。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(<span class="string">"jjj"</span>, <span class="string">"kkk"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>隐式实例化还有缺点：就是不能完全匹配参数：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>(<span class="number">106</span>, <span class="number">3.14</span>);	<span class="comment">//106是int, 3.14是double</span></span><br></pre></td></tr></tbody></table></figure>
<p>解决方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> U&amp; b)</span></span>{</span><br><span class="line">	<span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//利用auto进行自动推导</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里还有个前提：<code>T</code>必须是支持<code>&lt;</code>操作的，也就是可以比较的。</p>
<p>不然编译器会在实例化这个函数后报错。</p>
<p>e.g</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It begin, It end, <span class="type">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>这里的<code>It</code>必须是迭代器类型。</p>
<blockquote>
<p>在 C++ 中，<strong>函数模板</strong>可以通过 <strong>显式实例化</strong> 和 <strong>隐式实例化</strong> 来生成具体的函数。下面是这两种实例化的概念和用途：</p>
<h3 id="1-隐式实例化-implicit-instantiation">1. 隐式实例化（Implicit Instantiation）</h3>
<p>隐式实例化是指编译器根据模板的使用情况自动生成特定类型的函数实例。在代码中调用模板函数时，如果编译器发现没有该特定类型的实例，就会根据模板定义生成该实例。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"> <span class="type">int</span> result = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);       <span class="comment">// 编译器生成 int add(int, int)</span></span><br><span class="line"> <span class="type">double</span> result2 = <span class="built_in">add</span>(<span class="number">3.5</span>, <span class="number">2.5</span>); <span class="comment">// 编译器生成 double add(double, double)</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>add(3, 4)</code> 会触发 <code>add&lt;int&gt;(int, int)</code> 的实例化，而 <code>add(3.5, 2.5)</code> 会触发 <code>add&lt;double&gt;(double, double)</code> 的实例化。编译器自动生成所需的模板实例，这就是隐式实例化。</p>
<h3 id="2-显式实例化-explicit-instantiation">2. 显式实例化（Explicit Instantiation）</h3>
<p>显式实例化是指程序员在代码中显式地指定某个特定类型的模板实例。这通常用于加速编译或减少模板代码的重复生成。在显式实例化时，编译器会根据显示的指示生成特定类型的模板实例，即使在代码中没有直接调用该类型的模板实例。</p>
<p>显式实例化语法通常写在模板定义的文件（<code>.cpp</code> 文件）中，以避免多次生成相同的实例。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> return_type <span class="built_in">function_name</span>&lt;template_argument&gt;(parameters);</span><br></pre></td></tr></tbody></table></figure>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// add_template.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// add_template.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"add_template.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式实例化</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">int</span> <span class="built_in">add</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>);    <span class="comment">// 生成 int 类型实例</span></span><br><span class="line"><span class="keyword">template</span> <span class="type">double</span> <span class="built_in">add</span>&lt;<span class="type">double</span>&gt;(<span class="type">double</span>, <span class="type">double</span>); <span class="comment">// 生成 double 类型实例</span></span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，即使没有在代码中调用 <code>add&lt;int&gt;</code> 或 <code>add&lt;double&gt;</code>，编译器仍然会生成 <code>int</code> 和 <code>double</code> 类型的 <code>add</code> 实例。</p>
<h3 id="显式实例化的作用">显式实例化的作用</h3>
<ul>
<li><strong>控制模板实例化</strong>：减少编译器自动生成的实例个数，从而缩小可执行文件大小。</li>
<li><strong>提高编译速度</strong>：如果某个模板函数会在多个文件中用到不同的类型，显式实例化可以避免重复生成相同的模板实例。</li>
<li><strong>代码分离</strong>：可以在头文件中定义模板函数，而在实现文件（<code>.cpp</code> 文件）中实例化所需类型，减少头文件中代码的膨胀。</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li><strong>隐式实例化</strong>：编译器根据使用情况自动生成模板实例。</li>
<li><strong>显式实例化</strong>：程序员显式指定模板实例，通常用于减少模板生成、优化编译时间和控制可执行文件大小。</li>
</ul>
<p>显式实例化适合在大型项目中使用，尤其是当模板实例数量较多、模板实例化较复杂时，有助于提高编译效率并控制代码生成。</p>
</blockquote>
<p>上面介绍的函数模板可以发现一个问题：我们需要确定模板的约束？如何确定？如何提前知晓？<br>
比方说：有些需要支持<code>&lt;</code>，有些需要支持某种类型如<code>iterator</code>。</p>
<p>下面引入了<code>concept</code>。使用<code>concept</code>可以提高代码的可读性，提供更加友好的编译器报错信息。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(<span class="type">const</span> T a, <span class="type">const</span> T b){</span><br><span class="line">	{a &lt; b} -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>这个代码定义了一个 C++20 的 <strong>概念（Concept）</strong> <code>Comparable</code>，用于约束类型 <code>T</code>，要求 <code>T</code> 类型的两个 <code>const</code> 实例（<code>a</code> 和 <code>b</code>）之间能够通过某种表达式返回一个可以转换为 <code>bool</code> 的结果。下面是对该代码的逐行解释：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(<span class="type">const</span> T a, <span class="type">const</span> T b) {</span><br><span class="line"> {a &lt; b} -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="逐行解释">逐行解释</h3>
<ol>
<li>
<p><strong><code>template &lt;typename T&gt;</code></strong>：定义一个模板参数 <code>T</code>，用于指定类型。</p>
</li>
<li>
<p><strong><code>concept Comparable</code></strong>：定义一个名为 <code>Comparable</code> 的概念，它是一个模板约束，专门用于指定 <code>T</code> 需要满足的条件。</p>
</li>
<li>
<p><strong><code>requires</code> 子句</strong>：</p>
<ul>
<li><code>requires</code> 子句定义了一个表达式，描述了该概念约束的具体要求。</li>
<li><code>requires(const T a, const T b)</code> 表示这个概念要求两个 <code>const T</code> 类型的变量 <code>a</code> 和 <code>b</code> 能够进行指定的操作。</li>
</ul>
</li>
<li>
<p><strong><code>{ a &lt; b } -&gt; std::convertible_to&lt;bool&gt;;</code></strong>：</p>
<ul>
<li>这是一个<strong>约束表达式</strong>，表示 <code>{ a &lt; b }</code> 表达式的结果必须能转换为 <code>bool</code> 类型。任何在其中编译的内容必须没有错误。</li>
<li>其中，<code>std::convertible_to&lt;bool&gt;</code> 是一个标准库提供的概念，用于检查某种类型是否可以隐式转换为 <code>bool</code> 类型。</li>
<li>注意，这里 <code>{a &lt; b}</code> 看起来像是一个逗号表达式，实际是在测试 <code>a</code> 和 <code>b</code> 的比较结果是否能转换成布尔值。</li>
</ul>
</li>
</ol>
<h3 id="实际用途">实际用途</h3>
<p>这个概念用于确保某个类型 <code>T</code> 的对象可以用在需要布尔结果的比较操作中，比如可以被用于 <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> 等运算符。比如，如果一个函数要求它的参数类型满足 <code>Comparable</code> 概念，则可以保证这些参数在比较操作中会返回一个布尔值。</p>
<h3 id="使用示例">使用示例</h3>
<p>假设我们有一个函数 <code>isEqual</code>，要求传入的参数类型满足 <code>Comparable</code> 概念：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Comparable = <span class="built_in">requires</span>(<span class="type">const</span> T a, <span class="type">const</span> T b) {</span><br><span class="line">    { a == b } -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEqual</span><span class="params">(<span class="type">const</span> T&amp; x, <span class="type">const</span> T&amp; y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x == y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEqual</span>(a, b) &lt;&lt; std::endl; <span class="comment">// 输出 0 (false)</span></span><br><span class="line"></span><br><span class="line">    std::string s1 = <span class="string">"hello"</span>, s2 = <span class="string">"world"</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">isEqual</span>(s1, s2) &lt;&lt; std::endl; <span class="comment">// 输出 0 (false)</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个示例中，<code>isEqual</code> 函数要求其参数类型满足 <code>Comparable</code> 概念，因此只有那些支持 <code>==</code> 并返回 <code>bool</code> 的类型才能作为参数传入。</p>
</blockquote>
<blockquote>
<p>C++20 中的 <strong>concept</strong>（概念）是一种用于模板编程的新特性，用来定义模板参数的约束条件。概念帮助开发者明确表达某些类型在模板中的适用性，从而增强代码的可读性、可维护性，并在编译阶段提供更好的错误信息。</p>
<h3 id="1-concept-的作用">1. Concept 的作用</h3>
<p>在模板编程中，类型和操作可能并不总是符合预期。例如，模板可能要求一个类型可以被比较、加法或迭代，但如果用户传入不满足要求的类型，编译器报错会比较难懂。<strong>Concept</strong> 通过显式地描述模板参数需要满足的条件来解决这个问题。如果类型不满足某个概念要求，编译器会清晰地指出不符合的地方。</p>
<h3 id="2-定义-concept-的语法">2. 定义 Concept 的语法</h3>
<p>Concept 是一种布尔表达式，可以使用 <code>requires</code> 子句或者 <code>bool</code> 常量表达式来定义：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> ConceptName = <span class="comment">/* 布尔表达式或 requires 子句 */</span>;</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-示例：定义一个基本-concept">3. 示例：定义一个基本 Concept</h3>
<p>假设我们需要一个 <code>Addable</code> 概念，要求类型 <code>T</code> 支持加法操作。可以使用以下代码：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Addable = <span class="built_in">requires</span>(T a, T b) {</span><br><span class="line"> { a + b } -&gt; std::convertible_to&lt;T&gt;; <span class="comment">// a + b 的结果应能转换为类型 T</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在这里，<code>Addable</code> 概念规定 <code>T</code> 类型的两个实例之间能够进行加法运算，并且返回的结果类型可以转换为 <code>T</code>。</p>
<h3 id="4-使用-concept-限制模板参数">4. 使用 Concept 限制模板参数</h3>
<p>定义了一个概念后，可以将其用作模板参数的约束条件：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Addable T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{</span><br><span class="line"> <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面这个 <code>add</code> 函数模板使用了 <code>Addable</code> 概念，确保 <code>T</code> 类型支持加法运算。如果传入一个不支持加法的类型，编译器会给出清晰的错误信息。</p>
<h3 id="5-concept-的-requires-子句">5. Concept 的 <code>requires</code> 子句</h3>
<p><code>requires</code> 子句是 Concept 的核心部分，用于定义类型的特定要求。比如，可以要求一个类型 <code>T</code> 必须有 <code>==</code> 运算符，并且返回布尔值：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> EqualityComparable = <span class="built_in">requires</span>(T a, T b) {</span><br><span class="line"> { a == b } -&gt; std::convertible_to&lt;<span class="type">bool</span>&gt;;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-使用-concept-的方式">6. 使用 Concept 的方式</h3>
<p>有三种主要方式可以在模板中使用 Concept：</p>
<ol>
<li>
<p><strong>模板参数列表中直接使用</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Addable T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{ <span class="keyword">return</span> a + b; }</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong><code>requires</code> 关键字</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">requires</span> Addable&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> </span>{ <span class="keyword">return</span> a + b; }</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><strong>尾置 <code>requires</code> 子句</strong>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a, T b)</span> <span class="keyword">requires</span> Addable&lt;T&gt; </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h3 id="7-concept-的实际意义和优势">7. Concept 的实际意义和优势</h3>
<ul>
<li><strong>提高代码可读性</strong>：可以清楚地定义模板参数的预期能力，避免复杂的 <code>std::enable_if</code> 和 SFINAE 技术。</li>
<li><strong>编译器友好</strong>：在模板使用不当时提供更清晰、直观的错误信息。</li>
<li><strong>编译期检查</strong>：在编译阶段进行类型检查，提升模板代码的安全性和效率。</li>
</ul>
<h3 id="8-常见标准库概念">8. 常见标准库概念</h3>
<p>C++20 标准库引入了许多内置概念，方便约束模板参数，例如：</p>
<ul>
<li><strong><code>std::integral</code></strong>：整数类型。</li>
<li><strong><code>std::floating_point</code></strong>：浮点数类型。</li>
<li><strong><code>std::same_as&lt;T, U&gt;</code></strong>：类型相同。</li>
<li><strong><code>std::convertible_to&lt;T&gt;</code></strong>：类型可转换。</li>
</ul>
<h3 id="总结">总结</h3>
<p>Concept 是一种强大且直观的方式，用于简化 C++ 模板编程中的约束管理。它不仅提升了模板代码的表达力，还改进了模板编程中的错误提示，让编写和维护模板代码变得更加轻松。</p>
</blockquote>
<p><code>variadic templates</code>：</p>
<blockquote>
<p><strong>Variadic Template</strong>（可变参数模板）是 C++ 中的一种模板特性，允许定义的模板可以接受可变数量的模板参数。它最早在 C++11 中引入，使编写灵活的模板函数和类变得更加简单和高效。</p>
<h3 id="1-基本语法">1. 基本语法</h3>
<p>Variadic Template 的参数定义方式是在模板参数名称后加上省略号 <code>...</code>。这可以让模板接受任意数量的类型参数。具体语法如下：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(Args... args)</span> </span>{</span><br><span class="line"> <span class="comment">// 代码实现</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>typename... Args</code>：定义一个可变数量的模板参数 <code>Args</code>，可以是 0 个或多个。</li>
<li><code>Args... args</code>：展开参数包，将所有传入参数按顺序展开。</li>
</ul>
<h3 id="2-variadic-template-的应用">2. Variadic Template 的应用</h3>
<h4 id="2-1-variadic-template-函数">2.1 Variadic Template 函数</h4>
<p>可以使用 Variadic Template 定义接受任意数量参数的函数，例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>{</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 参数展开</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"hello"</span>); <span class="comment">// 输出：123hello</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Variadic"</span>, <span class="string">" "</span>, <span class="string">"Templates"</span>, <span class="string">" "</span>, <span class="number">2024</span>); <span class="comment">// 输出：Variadic Templates 2024</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>print</code> 函数可以接受任意数量的参数，通过 <strong>折叠表达式</strong> <code>(std::cout &lt;&lt; ... &lt;&lt; args)</code> 将所有参数传递给 <code>std::cout</code> 逐个打印。</p>
<h4 id="2-2-variadic-template-类">2.2 Variadic Template 类</h4>
<p>Variadic Template 也可以用来定义类模板，允许一个类接受多种类型参数：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyContainer</span> {</span><br><span class="line">    std::tuple&lt;Args...&gt; data; <span class="comment">// 使用 std::tuple 存储参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyContainer</span>(Args... args) : <span class="built_in">data</span>(args...) {} <span class="comment">// 构造函数接受多个参数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::<span class="built_in">apply</span>([](<span class="keyword">auto</span>&amp;&amp;... args) { ((std::cout &lt;&lt; args &lt;&lt; <span class="string">" "</span>), ...); }, data);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">MyContainer&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">container</span><span class="params">(<span class="number">1</span>, <span class="number">3.14</span>, <span class="string">"Hello"</span>)</span></span>;</span><br><span class="line">    container.<span class="built_in">print</span>(); <span class="comment">// 输出：1 3.14 Hello</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>MyContainer</code> 类可以接受任意数量的模板参数，并将它们存储在 <code>std::tuple</code> 中。</p>
<h3 id="3-参数包展开-parameter-pack-expansion">3. 参数包展开（Parameter Pack Expansion）</h3>
<p>在使用 Variadic Template 时，参数包（parameter pack）需要展开，以便对每个参数执行相同的操作。展开参数包的常见方式有两种：</p>
<ul>
<li><strong>递归展开</strong>：利用递归函数模板逐个处理每个参数。</li>
<li><strong>折叠表达式</strong>（C++17 引入）：通过 <code>(... op args)</code> 或 <code>(args op ...)</code> 语法将所有参数一起展开。</li>
</ul>
<h4 id="3-1-折叠表达式示例">3.1 折叠表达式示例</h4>
<p>折叠表达式是一种简化的参数展开方式，例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printAll</span><span class="params">(Args... args)</span> </span>{</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 左折叠：输出所有参数</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>折叠表达式可以让代码更简洁、易读。</p>
<h3 id="4-variadic-template-的应用场景">4. Variadic Template 的应用场景</h3>
<p>Variadic Template 在处理任意数量的参数时非常有用，常见的应用场景包括：</p>
<ul>
<li><strong>日志函数</strong>：接收任意数量的参数并输出日志信息。</li>
<li><strong>智能容器</strong>：设计可以容纳任意类型和数量参数的容器类。</li>
<li><strong>泛型工厂函数</strong>：创建任意类型和数量参数的对象。</li>
</ul>
<h3 id="总结">总结</h3>
<p>Variadic Template 是 C++ 的强大功能，允许模板支持任意数量的参数。它在简化模板编程、增强代码灵活性方面起到了重要作用，尤其适用于函数参数数量不定的场景。通过折叠表达式等语法，Variadic Template 的代码可以写得更简洁清晰，编写变得更加高效。</p>
</blockquote>
<p>引入一个例子</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>(<span class="number">2.4</span>, <span class="number">7.5</span>);</span><br><span class="line"><span class="built_in">min</span>(<span class="number">2.4</span>, <span class="number">7.5</span>, <span class="number">5.3</span>);</span><br><span class="line"><span class="built_in">min</span>(<span class="number">2.4</span>, <span class="number">7.5</span>, <span class="number">5.3</span>, <span class="number">5.8</span>, <span class="number">8.9</span>, <span class="number">9.1</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>如果直接重载很麻烦，我们可以使用可变参数模板：</p>
<p>这里先引入一个方法：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; values)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个vector，这里使用的是列表初始化一个vector</span></span><br><span class="line"><span class="built_in">min</span>({<span class="number">2.4</span>, <span class="number">7.5</span>});</span><br><span class="line"><span class="built_in">min</span>({<span class="number">2.4</span>, <span class="number">7.5</span>, <span class="number">5.3</span>});</span><br><span class="line"><span class="built_in">min</span>({<span class="number">2.4</span>, <span class="number">7.5</span>, <span class="number">5.3</span>, <span class="number">5.8</span>, <span class="number">8.9</span>, <span class="number">9.1</span>});</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; values)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span>(values.<span class="built_in">size</span>() == <span class="number">1</span>)	<span class="keyword">return</span> values[<span class="number">0</span>];</span><br><span class="line">	<span class="type">const</span> <span class="keyword">auto</span> &amp;first = values[<span class="number">0</span>];</span><br><span class="line">	<span class="function">std::vector&lt;T&gt;&amp; <span class="title">rest</span><span class="params">(++values.begin(), v.end())</span></span>;</span><br><span class="line">	<span class="keyword">auto</span> m = <span class="built_in">min</span>(rest);</span><br><span class="line">	<span class="keyword">return</span> first &lt; m ? first : m;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个方法采用递归，获取最小值，但是这个方法不太高效，因为每一次递归时都需要进行复制<code>vector</code>。</p>
<p>和我们的理想效果有一些出入，这里最终引入可变参数模板：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//最基本的情况，用于停止递归调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; v)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Comparable T, Comparable... Args&gt;</span><br><span class="line"><span class="comment">//Comparable... Args用于匹配0或者更多的数据类型</span></span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp; v, <span class="type">const</span> Args&amp;... args)</span>	<span class="comment">//const Args&amp;... args 用于匹配0或者更多的参数</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">auto</span> m = <span class="built_in">min</span>(args...);	<span class="comment">//args... 用于代替实际的参数</span></span><br><span class="line">	<span class="keyword">return</span> v &lt; m ? v : m;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262017276.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262017415.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262020656.webp" alt=""></p>
<p>再列举可变参数模板的一个例子：可变参数的类型不需要是一样的（上面提到的可以发现都是一样的数据类型）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262032205.webp" alt=""></p>
<p>上面的这个问题是<code>vector</code>只可以接收一种数据类型。解决方法如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262032495.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262032764.webp" alt=""></p>
<p>模板元编程是在编译时期执行函数代码的技术，可以提高运行效率。如下图：可以发现计算结果在编译时已经计算完毕了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262048731.webp" alt=""></p>
<blockquote>
<p>模板元编程（Template Metaprogramming, TMP）是一种利用 C++模板系统在编译时进行计算和代码生成的编程技术。它允许在编译阶段执行一些逻辑操作，进而自动生成代码，减少运行时的计算负担。这种方法主要用于创建高效、通用的库，比如 <code>std::tuple</code> 和 <code>std::variant</code> 等标准库组件。</p>
<h3 id="基本原理">基本原理</h3>
<p>模板元编程的核心思想是<strong>在编译时执行代码</strong>，通过递归的模板实例化来进行计算。C++模板系统支持类型和常量作为模板参数，因此可以在模板中实现类似于循环、条件判断和递归等控制结构。</p>
<h3 id="模板元编程的主要特性">模板元编程的主要特性</h3>
<ol>
<li>
<p><strong>静态多态性</strong>：模板元编程允许在编译时选择不同的代码路径，实现静态多态。这避免了运行时开销，提高了性能。</p>
</li>
<li>
<p><strong>编译时计算</strong>：通过递归模板实现一些计算逻辑，例如计算阶乘、斐波那契数列、判断类型是否相同等。</p>
</li>
<li>
<p><strong>类型特征和类型转换</strong>：模板元编程广泛应用于类型特征的推导，例如 <code>std::is_integral</code>、<code>std::is_pointer</code> 等类型特征类。C++标准库中 <code>type_traits</code> 就是一个主要依赖模板元编程的库，用于在编译时分析和操作类型。</p>
</li>
</ol>
<h3 id="简单示例：编译时计算阶乘">简单示例：编译时计算阶乘</h3>
<p>以下是一个简单的模板元编程示例，用来计算阶乘：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value; <span class="comment">// 递归计算</span></span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="keyword">enum</span> {value = N * Factorial&lt;N - <span class="number">1</span>&gt;::value};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化，当 N=0 时结束递归</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Factorial</span>&lt;<span class="number">0</span>&gt; {</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    <span class="keyword">enum</span> {value = <span class="number">1</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> result = Factorial&lt;<span class="number">5</span>&gt;::value; <span class="comment">// 编译时计算 5 的阶乘</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Factorial of 5: "</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出: 120</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在上面的代码中，<code>Factorial</code> 是一个模板结构体，递归地计算阶乘。当 <code>N</code> 为 0 时，终止递归。这种计算在编译时完成，因此不会影响运行时性能。</p>
<h3 id="应用场景">应用场景</h3>
<ol>
<li>
<p><strong>类型推导和类型转换</strong>：例如 <code>std::enable_if</code>、<code>std::conditional</code>、<code>std::is_same</code> 等模板。</p>
</li>
<li>
<p><strong>通用容器和数据结构</strong>：如 <code>std::tuple</code>，利用模板元编程实现可以存储任意类型的元素。</p>
</li>
<li>
<p><strong>静态检查和编译时断言</strong>：在编译阶段检查某些条件是否满足，避免运行时错误。</p>
</li>
<li>
<p><strong>数学计算</strong>：如编译时计算斐波那契数列、阶乘等。</p>
</li>
</ol>
<h3 id="模板元编程的优缺点">模板元编程的优缺点</h3>
<ul>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>可以提高程序性能，将一部分工作从运行时移到编译时。</li>
<li>代码更通用，可以处理不同类型的输入。</li>
</ul>
</li>
<li>
<p><strong>缺点</strong>：</p>
<ul>
<li>模板元编程的语法复杂，调试和错误定位难度较高。</li>
<li>编译时间会增加，特别是在递归深度较高的情况下。</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<p>模板元编程是 C++ 中一项强大但复杂的技术，用于编译时的类型和常量计算。它在性能优化和通用编程中有着广泛的应用，但也带来了一定的复杂度。</p>
</blockquote>
<p>另外的一个例子：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">0</span>&gt;</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">enum</span> {value = <span class="number">0</span>};</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span>&lt;<span class="number">1</span>&gt;</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">enum</span> {value = <span class="number">1</span>};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fibonacci</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">enum</span> {value = Fibonacci&lt;N - <span class="number">1</span>&gt;::value + Fibonacci&lt;N - <span class="number">2</span>&gt;::value}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>模板元编程（Template Metaprogramming，TMP）在实际应用中的一些用法：</p>
<ol>
<li>
<p><strong>在编译时将结果嵌入可执行文件中</strong>：例如在编译期间计算阶乘值。通过编译时计算，把一些结果直接嵌入到最终的可执行文件中，以减少运行时的计算需求，从而提高效率。</p>
</li>
<li>
<p><strong>优化矩阵、树或其他数学结构</strong>：通过 TMP，可以在编译时优化或简化某些数学数据结构的实现，比如在编译时计算矩阵的属性、进行树的构建等。这可以避免运行时的复杂计算，使代码更高效。</p>
</li>
<li>
<p><strong>基于策略的设计</strong>：通过模板传递行为参数。所谓“策略设计”是一种编程模式，在 TMP 中可以通过模板参数来指定不同的策略或行为。例如可以将某种算法的具体实现（如排序算法）作为模板参数传递，动态生成不同版本的代码。</p>
</li>
<li>
<p><strong>Boost MPL 库</strong>：Boost MPL（MetaProgramming Library）是 C++ Boost 库的一部分，专门用来支持模板元编程。这个库提供了大量用于编译时计算和类型操作的模板工具，使得 TMP 的应用更加简便和强大。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<p>模板元编程在实际中主要用于提高程序性能，减少运行时计算负担，并实现灵活的代码设计。它不仅适用于数学计算和结构优化，还能增强代码的通用性和可维护性。</p>
</blockquote>
<p>后续了解一下 boost，这个不太懂？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262058553.webp" alt=""></p>
<p><code>TMP</code>虽然在编译阶段就执行代码，但是其编写的代码可读性不高。</p>
<p>如何在任何时候都可以在编译时期执行代码呢？并且提高可读性？</p>
<p>这里引入<code>constexptr</code>和<code>consteval</code>关键字：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262111862.webp" alt=""></p>
<h2 id="functions-and-lambdas">Functions And Lambdas</h2>
<p><code>predicate</code>：表示返回值为<code>bool</code>的函数</p>
<p>将函数作为一个参数传递到另外一个函数中。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//原来的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it = first; it != end; ++it)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>((*it) == value)	<span class="keyword">return</span> it;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> last;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//将其更加一般化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It, <span class="keyword">typename</span> Pred&gt;</span><br><span class="line"><span class="function">It <span class="title">find</span><span class="params">(It first, It last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = first; it != end; ++it)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pred</span>(*it))	<span class="keyword">return</span> it;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262258535.webp" alt=""></p>
<p>这里的<code>Pred</code>是一个函数指针。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), isVowel);</span><br><span class="line"><span class="comment">//Pred = bool(*)(char)</span></span><br><span class="line"><span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), isPrime);</span><br><span class="line"><span class="comment">//Pred = bool(*)(int)</span></span><br><span class="line"><span class="comment">//表示这个函数返回值是bool, *表示这是一个函数指针, int 表示接收一个int作为参数</span></span><br></pre></td></tr></tbody></table></figure>
<p>由此继续引入：如果我们想要实现一个<code>lessThanN</code>，这个是我们指定的，将这个函数应用于<code>find_if</code>函数，怎么办？</p>
<p><code>lessThanN</code>函数的实现不难，但是上面<code>find_if</code>的代码中，我们只传入了一个参数，所以我们怎么办？</p>
<p>可以再添加一个参数，但是有没有其他的方法？</p>
<p>这里引入<code>lambda</code>表达式，解决这个问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262307918.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262307764.webp" alt=""></p>
<p><code>functor</code></p>
<blockquote>
<p>在编程中，<strong>Functor</strong>（函子）概念源于数学的范畴论，并在函数式编程和面向对象编程中被广泛应用。根据上下文，Functor 可以指不同的东西：</p>
<h3 id="1-在函数式编程中的-functor">1. 在函数式编程中的 Functor</h3>
<p>在函数式编程中，Functor 是一个支持 <strong><code>map</code> 操作</strong>的结构，允许你对结构内部的值进行操作，而不改变结构本身。例如在 Haskell 中，<code>List</code> 和 <code>Maybe</code> 类型就是常见的 Functor。一个 Functor 满足以下两个要求：</p>
<ul>
<li><strong>封装值</strong>：Functor 包装了某种数据。</li>
<li><strong>映射功能</strong>：可以通过一个函数对封装的值进行操作，并生成新的 Functor。</li>
</ul>
<p>假设我们有一个 Functor <code>F&lt;T&gt;</code>，通过 <code>map</code> 操作，我们可以将一个函数 <code>f</code> 应用于其中的值。即使结构内部的数据类型改变，结构本身不发生改变，类似于下面的伪代码：</p>
<figure class="highlight haskell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">-- Functor 实现的 map 函数</span></span><br><span class="line"><span class="title">map</span> :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-在-c-中的-functor">2. 在 C++ 中的 Functor</h3>
<p>在 C++ 中，Functor 通常指 <strong>重载了 <code>operator()</code> 的对象</strong>，使其能够像函数一样被调用。这样的对象称为<strong>函数对象</strong>，用于提供灵活的函数调用方式。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Add add;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; std::endl;  <span class="comment">// 输出：7</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在这个例子中，<code>Add</code> 类重载了 <code>()</code> 运算符，使得 <code>Add</code> 类的对象可以像普通函数一样调用。这在需要将逻辑封装在对象中时非常有用，例如传递到 STL 的算法中（如 <code>std::sort</code>）。</p>
<h3 id="总结">总结</h3>
<ul>
<li><strong>函数式编程中的 Functor</strong>：一种可以映射操作的结构，如 <code>List</code> 或 <code>Maybe</code>，可以对封装的值应用函数。</li>
<li><strong>C++ 中的 Functor</strong>：重载了 <code>operator()</code> 的对象，使其像函数一样调用，常用于灵活的函数调用。</li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262311835.webp" alt=""></p>
<p>后续了解一下模板特化是什么？</p>
<p><code>lambda</code>的底层原理：</p>
<p>当我们使用<code>lambda</code>时，会产生对应的<code>functor</code>（有点震撼。。。）</p>
<p>这里的<code>auto</code>实际上是<code>std::function</code>：一种重要的服务于函数/<code>lambdas</code>的数据类型，任何的<code>functor``lambda``function</code>指针都可以转换为它，一般可以使用<code>auto</code>关键字进行替代。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">char</span>)&gt; vowel = isVowel;</span><br><span class="line">std::function&lt;<span class="type">bool</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; less = std::less&lt;<span class="type">int</span>&gt; {};</span><br><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; twice = [](<span class="type">int</span> x) {<span class="keyword">return</span> <span class="number">2</span> * x};</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262317589.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262317940.webp" alt=""></p>
<p>后面是介绍<code>&lt;algorithm&gt;</code>中的一些算法，直接自己看官方文档就行。</p>
<p>本来是介绍了实现一个新的算法（看不太懂），由此再引入<code>ranges</code>，直接看<code>ranges</code>就行。</p>
<p><code>ranges</code>：任何具有<code>begin</code>和<code>end</code>的一切事务事物。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="type">char</span>&gt; v = {<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>};</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="string">'c'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>其实我们关心的是整个容器，可以替换为：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = std::ranges::<span class="built_in">find</span>(v, <span class="string">'c'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262347237.webp" alt=""></p>
<p>有些不太理解？</p>
<p><code>views</code>：还是<code>ranges</code>但是懒操作。</p>
<blockquote>
<p>在 C++20 中，<strong>views</strong> 是标准库提供的一个新概念，它属于 <strong>Ranges</strong> 库的一部分，旨在简化对集合或序列的操作。通过使用 views，可以创建延迟计算的视图，对数据进行过滤、转换和组合，而不改变原始数据。</p>
<h3 id="views-的特点">views 的特点</h3>
<ol>
<li><strong>延迟计算</strong>：views 是惰性求值的，这意味着不会立即执行任何操作，只有在需要访问元素时才会进行计算，类似于 Python 的生成器。</li>
<li><strong>不改变原始数据</strong>：views 是对原始数据的非拥有性视图，不会修改底层容器。</li>
<li><strong>高效性</strong>：由于 views 不会复制数据，而是直接作用于原始数据，因此性能较高。</li>
</ol>
<h3 id="常见的-views-操作">常见的 views 操作</h3>
<p>C++20 的 views 提供了多种操作，可以用于过滤、变换等。例如：</p>
<ul>
<li><code>std::views::filter</code>：筛选符合条件的元素。</li>
<li><code>std::views::transform</code>：对每个元素应用某种变换。</li>
<li><code>std::views::take</code> 和 <code>std::views::drop</code>：获取前 <code>n</code> 个或跳过前 <code>n</code> 个元素。</li>
<li><code>std::views::reverse</code>：反转序列中的元素顺序。</li>
</ul>
<h3 id="views-的使用示例">views 的使用示例</h3>
<p>以下是一个简单的示例，展示了如何使用 <code>std::views::filter</code> 和 <code>std::views::transform</code>：</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ranges&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 views 筛选偶数，并将结果加倍</span></span><br><span class="line">    <span class="keyword">auto</span> even_doubled = numbers</span><br><span class="line">                        | std::views::<span class="built_in">filter</span>([](<span class="type">int</span> n) { <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; })</span><br><span class="line">                        | std::views::<span class="built_in">transform</span>([](<span class="type">int</span> n) { <span class="keyword">return</span> n * <span class="number">2</span>; });</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : even_doubled) {</span><br><span class="line">        std::cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出: 4 8 12 16 20</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="views-的优点">views 的优点</h3>
<ol>
<li><strong>代码简洁</strong>：可以链式调用多个操作，逻辑清晰简洁。</li>
<li><strong>性能更优</strong>：避免了多次拷贝和重新分配，使用惰性求值提高了性能。</li>
<li><strong>减少内存开销</strong>：不产生额外的数据拷贝，仅创建对原数据的视图。</li>
</ol>
<h3 id="总结">总结</h3>
<p>C++20 的 views 提供了灵活、简洁且高效的数据操作方式，使得在容器上进行常见的数据操作（如过滤、变换）更加方便。</p>
</blockquote>
<p>下面看 PPT 例子比较好懂：关键是支持<code>filter</code>和<code>transform</code>操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410262359879.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410270000553.webp" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410270000128.webp" alt=""></p>
<p><code>ranges</code>和<code>view</code>使用建议：</p>
<ul>
<li>更少关注迭代器</li>
<li>约束算法，报错信息更加友好</li>
<li>代码的可读性更高</li>
<li>缺点是太新了，不是所有的特性都非常完善</li>
<li>可能缺少编译器支持</li>
</ul>
<h2 id="operator-overloading">Operator Overloading</h2>
<p>运算符重载的要求：有一定的顺序关系，并且是可以比较的，逻辑上可以确定的。</p>
<p>不可重载运算符：</p>
<p><code>:: ?: . .* sizeof() typeid() cast()</code>。</p>
<p>运算符重载有两种：作为成员函数进行重载，作为非成员函数进行重载。</p>
<p>推荐使用非成员函数实现：</p>
<p>优点：</p>
<ul>
<li>左侧比较的对象可以不一定是类类型。</li>
<li>可以重载我们没有的类类型。</li>
</ul>
<p>但是实现以上方法，需要访问类的数据成员（一般是<code>private</code>），所以我们采取如下方法：使用友元<code>friend</code>。从而可以访问私有数据成员。</p>
<p>复习一下各类运算符重载的方法。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.heavenhold.cn/posts/dd378ae0.html">https://www.heavenhold.cn/posts/dd378ae0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.heavenhold.cn" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CS106L/">CS106L</a><a class="post-meta__tags" href="/tags/cpp/">cpp</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124946.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/a685019b.html" title="Chapter1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072126884.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Chapter1</div></div></a></div><div class="next-post pull-right"><a href="/posts/b6a9f85a.html" title="从零开始搭建计算机"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://cdn.jsdelivr.net/gh/BomLook/cartoon@main/img/202410072124051.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">从零开始搭建计算机</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cs106l"><span class="toc-number">1.</span> <span class="toc-text">CS106L</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#types-and-structs"><span class="toc-number">1.1.</span> <span class="toc-text">Types and Structs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#initialization-and-references"><span class="toc-number">1.2.</span> <span class="toc-text">Initialization and References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#streams"><span class="toc-number">1.3.</span> <span class="toc-text">Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">1.3.1.</span> <span class="toc-text">刷新缓冲区的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.2.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.3.3.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#containers"><span class="toc-number">1.4.</span> <span class="toc-text">Containers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%90%AB%E4%B9%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">具体含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%9B%B6%E5%BC%80%E9%94%80"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. 模板的零开销</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-raii-%E7%9A%84%E9%9B%B6%E5%BC%80%E9%94%80"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. RAII 的零开销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%9D%E6%8C%81%E9%94%AE%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.4.4.</span> <span class="toc-text">1. 保持键的不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E8%AF%AF%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.5.</span> <span class="toc-text">2. 避免误操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%9D%E8%AF%81%E9%AB%98%E6%95%88%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.6.</span> <span class="toc-text">3. 保证高效查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.7.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.8.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.4.9.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.10.</span> <span class="toc-text">特性总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.11.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.12.</span> <span class="toc-text">具体区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.13.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.4.14.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterators"><span class="toc-number">1.5.</span> <span class="toc-text">Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.5.1.</span> <span class="toc-text">主要特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.5.4.</span> <span class="toc-text">主要特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.5.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.6.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.7.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">1.5.8.</span> <span class="toc-text">主要特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.5.9.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.10.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.11.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#classes"><span class="toc-number">1.6.</span> <span class="toc-text">Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">菱形继承问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.6.2.</span> <span class="toc-text">虚继承的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.6.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.6.4.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#templates"><span class="toc-number">1.7.</span> <span class="toc-text">Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.7.1.</span> <span class="toc-text">C++ 模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">Java 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.4.</span> <span class="toc-text">原因详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.7.5.</span> <span class="toc-text">实际示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A7%A3%E8%A7%A3%E9%87%8A"><span class="toc-number">1.7.7.</span> <span class="toc-text">分解解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#template-functions"><span class="toc-number">1.8.</span> <span class="toc-text">Template Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96-implicit-instantiation"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 隐式实例化（Implicit Instantiation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96-explicit-instantiation"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 显式实例化（Explicit Instantiation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E5%BC%8F%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">显式实例化的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E8%A1%8C%E8%A7%A3%E9%87%8A"><span class="toc-number">1.8.5.</span> <span class="toc-text">逐行解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%94%A8%E9%80%94"><span class="toc-number">1.8.6.</span> <span class="toc-text">实际用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.7.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-concept-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.8.</span> <span class="toc-text">1. Concept 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89-concept-%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">1.8.9.</span> <span class="toc-text">2. 定义 Concept 的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC-concept"><span class="toc-number">1.8.10.</span> <span class="toc-text">3. 示例：定义一个基本 Concept</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-concept-%E9%99%90%E5%88%B6%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">1.8.11.</span> <span class="toc-text">4. 使用 Concept 限制模板参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-concept-%E7%9A%84-requires-%E5%AD%90%E5%8F%A5"><span class="toc-number">1.8.12.</span> <span class="toc-text">5. Concept 的 requires 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8-concept-%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.8.13.</span> <span class="toc-text">6. 使用 Concept 的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-concept-%E7%9A%84%E5%AE%9E%E9%99%85%E6%84%8F%E4%B9%89%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-number">1.8.14.</span> <span class="toc-text">7. Concept 的实际意义和优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B8%B8%E8%A7%81%E6%A0%87%E5%87%86%E5%BA%93%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.15.</span> <span class="toc-text">8. 常见标准库概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.16.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.8.17.</span> <span class="toc-text">1. 基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-variadic-template-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.8.18.</span> <span class="toc-text">2. Variadic Template 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-variadic-template-%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.18.1.</span> <span class="toc-text">2.1 Variadic Template 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-variadic-template-%E7%B1%BB"><span class="toc-number">1.8.18.2.</span> <span class="toc-text">2.2 Variadic Template 类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%85%E5%B1%95%E5%BC%80-parameter-pack-expansion"><span class="toc-number">1.8.19.</span> <span class="toc-text">3. 参数包展开（Parameter Pack Expansion）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.19.1.</span> <span class="toc-text">3.1 折叠表达式示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-variadic-template-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.20.</span> <span class="toc-text">4. Variadic Template 的应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.21.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.8.22.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">1.8.23.</span> <span class="toc-text">模板元编程的主要特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%BC%96%E8%AF%91%E6%97%B6%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98"><span class="toc-number">1.8.24.</span> <span class="toc-text">简单示例：编译时计算阶乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.25.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.8.26.</span> <span class="toc-text">模板元编程的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.27.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.28.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#functions-and-lambdas"><span class="toc-number">1.9.</span> <span class="toc-text">Functions And Lambdas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84-functor"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 在函数式编程中的 Functor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8-c-%E4%B8%AD%E7%9A%84-functor"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 在 C++ 中的 Functor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#views-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">1.9.4.</span> <span class="toc-text">views 的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-views-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.9.5.</span> <span class="toc-text">常见的 views 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#views-%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.9.6.</span> <span class="toc-text">views 的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#views-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.9.7.</span> <span class="toc-text">views 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#operator-overloading"><span class="toc-number">1.10.</span> <span class="toc-text">Operator Overloading</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">©2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer="" src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zindex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax="">if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="posts/2a942d0f.html">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="posts/2a942d0f.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="posts/a7d34c04.html">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="posts/a7d34c04.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/7d68f443.html">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="posts/7d68f443.html">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0OCIgaGVpZ2h0PSI0OCIgdmlld0JveD0iMCAwIDI0IDI0Ij48Y2lyY2xlIGN4PSI0IiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgaWQ9InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAiIGF0dHJpYnV0ZU5hbWU9InIiIGJlZ2luPSIwO3N2Z1NwaW5uZXJzM0RvdHNTY2FsZTEuZW5kLTAuMjVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjMiIGZpbGw9ImN1cnJlbnRDb2xvciI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNnMiIGR1cj0iMC43NXMiIHZhbHVlcz0iMzsuMjszIi8+PC9jaXJjbGU+PGNpcmNsZSBjeD0iMjAiIGN5PSIxMiIgcj0iMyIgZmlsbD0iY3VycmVudENvbG9yIj48YW5pbWF0ZSBpZD0ic3ZnU3Bpbm5lcnMzRG90c1NjYWxlMSIgYXR0cmlidXRlTmFtZT0iciIgYmVnaW49InN2Z1NwaW5uZXJzM0RvdHNTY2FsZTAuZW5kLTAuNDVzIiBkdXI9IjAuNzVzIiB2YWx1ZXM9IjM7LjI7MyIvPjwvY2lyY2xlPjwvc3ZnPg==" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="posts/f39cb498.html">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="posts/f39cb498.html">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax="" src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,d=o();function o(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=o());for(var e,i=0;i<d.length;i++)0<=(e=(e=d[i]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,a,n,o=d[i];e=function(){d=d.filter(function(t){return o!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(o)},(t=o).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,n=t.getAttribute("data-original"),a.onload=function(){t.src=n,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=n},t.src!==n&&(a.src=n)))}()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)}(this);</script></body></html>