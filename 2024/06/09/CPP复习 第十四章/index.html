<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CPP复习 第十四章 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="文章内容转载自14 chapter 文件处理（cpp大学教程）学习笔记 如有侵权，请联系作者删除。  Cpp复习 第十四章 14.1 文件和流 文件 内存中数据的存储是临时的，而用文件存储的数据是永久的——文件被储存在辅助存储设备中，如硬盘、CD、DVD、闪存驱动器和磁带 特点：每个文件都以一个文件结束符或者以存储在操作系统维护、管理的数据结构中的一个特定字节数 文件处理模板">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP复习 第十四章">
<meta property="og:url" content="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/index.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="文章内容转载自14 chapter 文件处理（cpp大学教程）学习笔记 如有侵权，请联系作者删除。  Cpp复习 第十四章 14.1 文件和流 文件 内存中数据的存储是临时的，而用文件存储的数据是永久的——文件被储存在辅助存储设备中，如硬盘、CD、DVD、闪存驱动器和磁带 特点：每个文件都以一个文件结束符或者以存储在操作系统维护、管理的数据结构中的一个特定字节数 文件处理模板">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_887_2000x956_96_null_normal.jpg">
<meta property="article:published_time" content="2024-06-09T11:31:00.000Z">
<meta property="article:modified_time" content="2024-06-13T08:16:30.559Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_887_2000x956_96_null_normal.jpg"><link rel="shortcut icon" href="https://img2.imgtp.com/2024/03/12/9tLeWKLK.png"><link rel="canonical" href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP复习 第十四章',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-13 16:16:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/94421005_p0_master1200.jpg" data-original="https://raw.githubusercontent.com/BomLook/blog-pic/img/img/202407021330085.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">109</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_887_2000x956_96_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP复习 第十四章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-09T11:31:00.000Z" title="发表于 2024-06-09 19:31:00">2024-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-13T08:16:30.559Z" title="更新于 2024-06-13 16:16:30">2024-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP复习 第十四章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>文章内容转载自<a
target="_blank" rel="noopener" href="https://blog.csdn.net/stay_alive001/article/details/121520290">14
chapter 文件处理（cpp大学教程）学习笔记</a>
如有侵权，请联系作者删除。</p>
<hr />
<h1 id="cpp复习-第十四章">Cpp复习 第十四章</h1>
<h2 id="文件和流">14.1 文件和流</h2>
<h3 id="文件">文件</h3>
<p>内存中数据的存储是临时的，而用文件存储的数据是永久的——文件被储存在辅助存储设备中，如硬盘、CD、DVD、闪存驱动器和磁带</p>
<p>特点：每个文件都以一个文件结束符或者以存储在操作系统维护、管理的数据结构中的一个特定字节数</p>
<h3 id="文件处理模板">文件处理模板</h3>
<p>typedef
ifstream是一个对basic_ifstream的特化，允许文件输入字符（读）</p>
<p>typedef
ofstream是一个对basic_ofstream的特化，允许文件输出字符（写）</p>
<p>typedef
fstream是一个对basic_fstream的特化，允许文件输入、输出字符（读写）</p>
<p>注意：该模板都是从basic_iostream、basic_istream、basic_ostream中“继承”而来，包含其所有的成员函数</p>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608131628656.png"
alt="image-20240608131628656" />
<figcaption aria-hidden="true">image-20240608131628656</figcaption>
</figure>
<h2 id="创建顺序文件">14.2 创建顺序文件</h2>
<h3 id="打开一个文件">打开一个文件</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;credit.dat&quot;</span>, ios::out)</span></span>;</span><br><span class="line"> <span class="keyword">if</span>(!outputFile)&#123;cerr&lt;&lt;<span class="string">&quot;File could not be opened&quot;</span>;<span class="built_in">exit</span>(EXIT_FAILURE);&#125;</span><br></pre></td></tr></table></figure>
<p>打开文件有两个参数：文件名和文件打开模式</p>
<p>文件名：若文件不存在，则自动创建该文件名的文件</p>
<p>文件打开模式ios::out——向一个文件输出数据：默认截顶，会自动清空文件里的数据重新输出</p>
<p>ofstream对象默认为ios::out文件打开模式</p>
<blockquote>
<p>模式 描述 ios::app 将输出文件添加到文件尾，不截顶 ios::ate
可以再文件任何位置输出数据，默认为文件尾 ios::in 打开文件输入 ios::out
打开文件输出，截顶 ios::trunc 丢弃文件的内容 ios::binary
打开一个文件进行二进制输入/输出</p>
</blockquote>
<h3 id="使用open打开一个文件">使用open打开一个文件</h3>
<p>一个ofstream对象可以在没有打开特定文件的情况下被创建，之后文件再关联到这个对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ofstream outputFile;</span><br><span class="line"> outputFile.<span class="built_in">open</span>(<span class="string">&quot;credit.dat&quot;</span>, ios::out);</span><br></pre></td></tr></table></figure>
<h3 id="测试一个文件是否被成功打开">测试一个文件是否被成功打开</h3>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608132702823.png"
alt="image-20240608132702823" />
<figcaption aria-hidden="true">image-20240608132702823</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608132711047.png"
alt="image-20240608132711047" />
<figcaption aria-hidden="true">image-20240608132711047</figcaption>
</figure>
<blockquote>
<p><strong>Testing Whether a File Was Opened Successfully</strong></p>
<p>After creating an ofstream object and attempting to open it, the
program tests whether the open operation was successful.</p>
<p>The if statement in lines 15–19 uses the overloaded ios member
function operator! to determine whether the open operation
succeeded.</p>
<p>◦The condition returns a true value if either the failbit or the
badbit is set for the stream on the open operation.</p>
<p>Some possible errors are</p>
<p>◦attempting to open a nonexistent file for reading,</p>
<p>◦attempting to open a file for reading or writing with-out
permission, and</p>
<p>◦opening a file for writing when no disk space is available.</p>
<p>测试文件是否成功打开：
在创建ofstream对象并尝试打开它之后，程序将测试打开操作是否成功。
第15-19行的if语句使用了重载的ios成员函数操作符!判断手术是否成功。
如果在打开操作中为流设置了failbit或badbit，则条件返回真值。
一些可能的错误包括：试图打开一个不存在的文件进行读取，试图在未经许可的情况下打开文件进行读写，并且
在没有可用的磁盘空间时打开文件以供写入。</p>
</blockquote>
<blockquote>
<p>Function exit terminates a program.</p>
<p>◦The argument to exit is returned to the environment from which the
program was invoked.</p>
<p>◦Passing EXIT_SUCCESS (also defined in <cstdlib>) to exit indicates
that the program terminated <em>normally</em>; passing any other value
(in this case EXIT_FAILURE) indicates that the program terminated due to
an <em>error</em>.</p>
<p>函数退出终止程序： exit参数返回到调用程序的环境。
将EXIT_SUCCESS(也在<cstdlib>中定义)传入exit表示程序正常终止;传递任何其他值(在本例中为EXIT_FAILURE)表示程序因错误而终止。</p>
</blockquote>
<h3 id="重载void-指针">重载void* 指针</h3>
<blockquote>
<p>The Overloaded void * Operator Another overloaded ios member
function—operator void <em>—converts the stream to a pointer, so it can
be tested as 0 (i.e., the null pointer) or nonzero (i.e., any other
pointer value). When a pointer value is used as a condition, C++
interprets a null pointer in a condition as the bool value false and
interprets a non-null pointer as the bool value true. If the failbit or
badbit has been set for the stream, 0 (false) is returned. The condition
in the while statement of lines 29–33 invokes the operator void </em>
member function on cin implicitly. The condition remains true as long as
neither the failbit nor the badbit has been set for cin. Entering the
end-of-file indicator sets the failbit for cin.</p>
<p>重载void <em>操作符： 另一个重载的ios成员函数——operator void
</em>——将流转换为指针，因此它可以被测试为0(即空指针)或非零(即任何其他指针值)。
当将指针值用作条件时，c++将条件中的空指针解释为bool值false，将非空指针解释为bool值true。
如果为流设置了failbit或badbit，则返回0 (false)。
第29-33行while语句中的条件隐式地调用cin上的操作符void *成员函数。
只要cin的failbit和badbit都没有设置，条件就保持为真。
输入文件结束指示器设置cin的failbit。</p>
</blockquote>
<blockquote>
<p>The operator void * function can be used to test an input object for
end-of-file, but you can also call member function eof on the input
object. Processing Data Figure 14.5 lists the keyboard combinations for
entering end-of-file for various computer systems. 操作符void
*函数可用于测试输入对象是否有文件结束，但也可以在输入对象上调用成员函数eof。
处理数据 图14.5列出了各种计算机系统中输入文件结束符的键盘组合。</p>
</blockquote>
<blockquote>
<p>When end-of-file is encountered or bad data is entered, operator void
* returns the null pointer (which converts to the bool value false) and
the while statement terminates. The user enters end-of-file to inform
the program to process no additional data. The end-of-file indicator is
set when the user enters the end-of-file key combination. Line 31 writes
a set of data to the file clients.txt, using the stream insertion
operator &lt;&lt; and the outClientFile object associated with the file
at the beginning of the program. The data may be retrieved by a program
designed to read the file (see Section 14.4). The file created in Fig.
14.3 is simply a text file, so it can be viewed by any text editor.
当遇到文件结束符或输入错误数据时，操作符void
*返回空指针(该指针将转换为bool值false)， while语句终止。
用户输入文件尾以通知程序不处理其他数据。
当用户输入文件结束键组合时，设置文件结束指示符。
第31行使用流插入操作符&lt;&lt;和程序开头与文件关联的outClientFile对象，将一组数据写入文件clients.txt。
数据可以通过一个程序来读取文件(参见第14.4节)。
图14.3中创建的文件只是一个文本文件，因此任何文本编辑器都可以查看它。</p>
</blockquote>
<blockquote>
<p>Closing a File Once the user enters the end-of-file indicator, main
terminates. This implicitly invokes outClientFile’s destructor, which
closes the clients.txt file. You also can close the ofstream object
explicitly, using member function close. 关闭文件：
一旦用户输入文件结束指示符，main就终止。
这将隐式调用outClientFile的析构函数，从而关闭clients.txt文件。还可以使用成员函数close显式地关闭ofstream对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">outClientFile.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="从顺序文件中读取数据">14.3 从顺序文件中读取数据</h2>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;credit.dat&quot;</span>, ios::in)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!inFile)&#123;cerr&lt;&lt;<span class="string">&quot;File coule not be opened&quot;</span>;<span class="built_in">exit</span>(EXIT_FAILURE);&#125;;</span><br></pre></td></tr></table></figure>
<p>默认为输入打开模式，也可以使用open成员函数打开文件</p>
<p>文件定位指针 seekg()成员函数重定位下一个文件读入的字节号</p>
<p>seekp()成员函数重定位下一个文件输出的字节号</p>
<p>传递给重定位成员函数的第一个参数通常是一个long类型的整数</p>
<p>参数2 作用 ios::beg 从流的开始位置定位 ios::cur
从流的当前位置进行定位 ios::end 相对于流的结尾进行定位
tellg();tellp();用于高速下一个文件输入/输出的字节号</p>
</blockquote>
<p>打开格式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inClientFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>可以再创建时不打开，后面再次关联。</p>
<p>如果文件的内容不应该被修改，那么打开方式应该是ios::in。</p>
<h3 id="文件定位指针">文件定位指针</h3>
<p>istream和ostream中都提供了成员函数来重定位文件的定位指针（文件中下一个要被读取或者写入的字节）</p>
<p>在istream中，这个为seekg，ostream中为seekp</p>
<p><strong><code>seekp</code> (seek
put)</strong>：用于输出（写）操作，设置输出位置指针。</p>
<p><strong><code>seekg</code> (seek
get)</strong>：用于输入（读）操作，设置输入位置指针。</p>
<p>格式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inClientFile.<span class="built_in">seekg</span>(<span class="number">0</span>)	<span class="comment">//表示是从文件的起始位置开始</span></span><br><span class="line"><span class="comment">//第一个参数：通常是一个long类型的变量 指定位置（从文件开始位置到当前位置的字节数，或者说是文件的偏移量）</span></span><br><span class="line"><span class="comment">//第二个参数：指定方向：ios::beg（默认，一般是流的开始）	ios::cur（当前位置）	ios::end（流的末尾开始）</span></span><br></pre></td></tr></table></figure>
<p>tellp和tellg用来返回当前put和get指针的位置。</p>
<p>为了执行多次文件的搜索读取，我们可以在遍历完一次文件后，对流执行clear操作，使其状态设置为goodbit，然后seekg(0)，返回文件开头的位置，便于执行下一次I/O操作。</p>
<h2 id="更新顺序文件">14.5 更新顺序文件</h2>
<blockquote>
<p>采用格式化的输入输出模式，不方便用于更新记录。</p>
<p>The problem is that, in the formatted input/output model using the
stream insertion operator &lt;&lt; and the stream extraction operator
&gt;&gt;, fields—and hence records—can vary in size.</p>
<p>◦For example, values 7, 14, –117, 2074, and 27383 are all ints, which
store the same number of “raw data” bytes internally (typically four
bytes on 32-bit machines and eight bytes on 64-bit machines).</p>
<p>◦However, these integers become different-sized fields, depending on
their actual values, when output as formatted text (character
sequences).</p>
<p>◦Therefore, the formatted input/output model usually is not used to
update records in <em>place</em>.</p>
<p>问题在于，在使用流插入操作符&lt;<和流提取操作符>&gt;的格式化输入/输出模型中，字段和记录的大小可能不同。
例如，值7、14、-117、2074和27383都是整数，它们在内部存储相同数量的“原始数据”字节(通常在32位机器上存储4个字节，在64位机器上存储8个字节)。
但是，当作为格式化文本(字符序列)输出时，这些整数将根据其实际值变成大小不同的字段（字符序列）。
因此，格式化的输入/输出模型通常不用于就地更新记录。</p>
</blockquote>
<h2 id="随机存取文件">14.6 随机存取文件</h2>
<p>将所有的记录的长度都固定，这样可以方便随机查找或者顺序读取，并且能够修改，删除，对其他数据也没有影响。</p>
<h2 id="创建随机存取文件">14.7 创建随机存取文件</h2>
<h3 id="输出和读取">输出和读取</h3>
<p>成员函数write()从内存中一个指定位置开始输出固定数目的字节到指定的流。</p>
<p>关联到文件，则从文件中"put"文件定位指针指定的位置开始写入数据</p>
<p>成员函数read()则将固定数目的字节从一个指定的流输入到内存中指定地址开始的一部分空间。</p>
<p>关联到文件，则从文件中“get”文件定位指针指定的位置开始读取字节数据。</p>
<blockquote>
<p>Writing Bytes with ostream Member Function write Outputting a
four-byte integer as text could print as few digits as one or as many as
11 (10 digits plus a sign, each requiring a single byte of storage) The
following statement always writes the binary version of the integer’s
four bytes (on a machine with four-byte integers): outFile.write(
reinterpret_cast&lt; const char * &gt;( &amp;number ), sizeof( number )
); Function write treats its first argument as a group of bytes by
viewing the object in memory as a const char <em>, which is a pointer to
a byte. Starting from that location, function write outputs the number
of bytes specified by its second argument—an integer of type size_t.
istream function read can be used to read the four bytes back into an
integer variable. 使用ostream成员函数write写入字节：
输出一个四字节的整数作为文本可以输出少到1的数字，多到11的数字(10个数字加一个符号，每个需要一个字节的存储空间)
下面的语句总是写入整数的四个字节的二进制版本(在具有四个字节整数的机器上):
outFile.write(reinterpret_cast &lt;Const char </em> &gt;(&amp;number)，
sizeof(number);
write函数将其第一个参数视为一组字节，方法是将内存中的对象视为const char
*，这是一个指向字节的指针。
从该位置开始，函数write输出其第二个参数指定的字节数——size_t类型的整数。
Istream函数read可用于将四个字节读入整数变量。</p>
</blockquote>
<p><strong>成员函数write()输出字节数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">outputFile.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;client), <span class="built_in">sizeof</span>(ClientData));</span><br></pre></td></tr></table></figure>
<p>write()函数将第一个参数作为一组字节数据，将内存中的对象看做const
char*类型，表示指向一个字节的指针；第二个参数为对象的字节数大小</p>
<h3
id="reinterpret_cast运算符转换指针类型">reinterpret_cast&lt;&gt;()运算符转换指针类型</h3>
<p>作用：把某种类型强制转换为其他无关类型</p>
<p>注意：该转换是在编译阶段完成，不会改变指针所指对象的类型</p>
<p>并且在不同的平台上运行结果可能是不同的，除非有绝对的必要，否则不使用。</p>
<blockquote>
<p>Converting Between Pointer Types with the reinterpret_cast Operator
Most pointers that we pass to function write as the first argument are
not of type const char <em>. Must convert the pointers to those objects
to type const char </em>; otherwise, the compiler will not compile calls
to function write. C++ provides the reinterpret_cast operator for cases
like this in which a pointer of one type must be cast to an unrelated
pointer type. Without a reinterpret_cast, the write statement that
outputs the integer number will not compile because the compiler does
not allow a pointer of type int * (the type returned by the expression
&amp;number) to be passed to a function that expects an argument of type
const char *—as far as the compiler is concerned, these types are
inconsistent. A reinterpret_cast is performed at compile time and does
not change the value of the object to which its operand points.</p>
<p>使用reinterpret_cast操作符在指针类型之间进行转换
大多数传递给write函数作为第一个实参的指针都不是const char <em>类型的。
必须将指向这些对象的指针转换为const char
</em>类型;否则，编译器将不会编译对write函数的调用。
c++为这种情况提供了reinterpret_cast操作符，在这种情况下，必须将一种类型的指针强制转换为不相关的指针类型。
如果没有reinterpret_cast，输出整数的write语句将无法编译，因为编译器不允许将int
<em>类型的指针(由表达式&amp;number返回的类型)传递给需要const char
</em>类型参数的函数——就编译器而言，这些类型是不一致的。
reinterpret_cast在编译时执行，不会改变其操作数所指向的对象的值。</p>
</blockquote>
<h4 id="string类成员函数copy">string类成员函数copy()</h4>
<p>string string1 = "stringCopy"; char string2[10];
string1.copy(string2, 10); 成员函数copy()的两个参数：</p>
<p>第一个参数：将要复制赋值的string数组</p>
<p>第二个参数：要复制的字符个数</p>
<h4 id="用二进制模式打开一个输出文件">用二进制模式打开一个输出文件</h4>
<p>ofstream outputFile("credit.dat", ios::out|ios::binary);
通过运算符"|"可以组合多种打开模式</p>
<h2 id="向随机存取文件随机写入数据">14.8 向随机存取文件随机写入数据</h2>
<blockquote>
<p>Figure 14.12 writes data to the file credit.dat and uses the
combination of fstream functions seekp and write to store data at exact
locations in the file. Function seekp sets the “put” file-position
pointer to a specific position in the file, then write outputs the data.
Line 6 includes the header ClientData.h defined in Fig. 14.9, so the
program can use ClientData objects.
图14.12将数据写入文件credit.dat，并使用fstream函数seekp和write的组合将数据存储在文件中的准确位置。
函数seekp将“put”文件位置指针设置为文件中的特定位置，然后write输出数据。
第6行包括图14.9中定义的头文件ClientData.h，因此程序可以使用ClientData对象。</p>
</blockquote>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608144044684.png"
alt="image-20240608144044684" />
<figcaption aria-hidden="true">image-20240608144044684</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608144056004.png"
alt="image-20240608144056004" />
<figcaption aria-hidden="true">image-20240608144056004</figcaption>
</figure>
<p>可以发现：上面使用了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">outCredit to the byte location calculated <span class="title">by</span></span></span><br><span class="line"><span class="function"><span class="params">( client.getAccountNumber() - <span class="number">1</span> )</span>*<span class="title">sizeof</span><span class="params">( ClientData )</span></span></span><br></pre></td></tr></table></figure>
<p>来定位新数据将要在文件中写入的位置。对于记录1，文件指针定位在0。</p>
<h2 id="从随机存取文件顺序读取数据">14.9 从随机存取文件顺序读取数据</h2>
<blockquote>
<p>In this section, we develop a program that reads a file sequentially
and prints only those records that contain data. The istream function
read inputs a specified number of bytes from the current position in the
specified stream into an object. For example, lines 31–32 from Fig.
14.13 read the number of bytes specified by sizeof(ClientData) from the
file associated with ifstream object inCredit and store the data in the
client record. Function read requires a first argument of type char
<em>. Since &amp;client is of type ClientData </em>, &amp;client must be
cast to char * using the cast operator reinterpret_cast.
在本节中，我们将开发一个程序，它按顺序读取文件并只打印包含数据的记录。
istream函数read将指定流中当前位置的指定字节数输入到对象中。
例如，图14.13中的31-32行从与ifstream对象credit关联的文件中读取sizeof(ClientData)指定的字节数，并将数据存储在客户端记录中。
函数read需要char <em>类型的第一个参数。 由于&amp;client是ClientData
</em>类型，因此必须使用强制转换操作符reinterpret_cast将&amp;client强制转换为char
*类型。</p>
</blockquote>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608144853289.png"
alt="image-20240608144853289" />
<figcaption aria-hidden="true">image-20240608144853289</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608144901519.png"
alt="image-20240608144901519" />
<figcaption aria-hidden="true">image-20240608144901519</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608144908383.png"
alt="image-20240608144908383" />
<figcaption aria-hidden="true">image-20240608144908383</figcaption>
</figure>
<h4 id="成员函数read读取文件数据">成员函数read()读取文件数据</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inFile.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;client), <span class="built_in">sizeof</span>(ClientData));</span><br></pre></td></tr></table></figure>
<p>第一个参数：要求的参数类型为char *，需用强制类型转换</p>
<p>第二个参数：读取的字符数</p>
<h4 id="判断是否读取到文件尾">判断是否读取到文件尾</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(inFile &amp;&amp; !inFile.<span class="built_in">eof</span>())&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>如果出错，或者到达文件尾，都会报错。</p>
<h2 id="对象序列化">14.11 对象序列化</h2>
<p>对象序列化是指将对象的状态转换为可存储或传输的格式的过程，以便以后可以重建该对象。序列化的目标是将对象表示为字节流，从而可以保存到文件、数据库，或通过网络传输给其他应用程序。反序列化是序列化的逆过程，即从字节流重建对象。</p>
<p>在C++中，对象序列化不是语言本身提供的特性，而是通过编写自定义代码或使用第三方库来实现的。以下是几种常见的对象序列化方法：</p>
<h3 id="手动序列化">手动序列化</h3>
<p>你可以手动编写代码，将对象的成员变量写入字节流，然后读取这些字节流以重建对象。以下是一个示例，演示如何手动序列化和反序列化一个简单的对象：</p>
<h4 id="示例类">示例类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">serialize</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> nameLength = name.<span class="built_in">size</span>();</span><br><span class="line">        os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;nameLength), <span class="built_in">sizeof</span>(nameLength));</span><br><span class="line">        os.<span class="built_in">write</span>(name.<span class="built_in">c_str</span>(), nameLength);</span><br><span class="line">        os.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deserialize</span><span class="params">(std::istream&amp; is)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> nameLength;</span><br><span class="line">        is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;nameLength), <span class="built_in">sizeof</span>(nameLength));</span><br><span class="line">        name.<span class="built_in">resize</span>(nameLength);</span><br><span class="line">        is.<span class="built_in">read</span>(&amp;name[<span class="number">0</span>], nameLength);</span><br><span class="line">        is.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;age), <span class="built_in">sizeof</span>(age));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    p1.<span class="built_in">serialize</span>(ofs);</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    p2.<span class="built_in">deserialize</span>(ifs);</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用boost.serialization库">使用Boost.Serialization库</h3>
<p>Boost.Serialization
是一个功能强大且灵活的库，可以简化序列化和反序列化过程。使用这个库，你只需为类定义序列化函数，然后使用库提供的接口进行序列化和反序列化。</p>
<h4 id="示例类-1">示例类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_oarchive.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/archive/text_iarchive.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">boost</span>::serialization::access;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Archive&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">serialize</span><span class="params">(Archive &amp; ar, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> version)</span> </span>&#123;</span><br><span class="line">        ar &amp; name;</span><br><span class="line">        ar &amp; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>)</span></span>;</span><br><span class="line">        boost::<span class="function">archive::text_oarchive <span class="title">oa</span><span class="params">(ofs)</span></span>;</span><br><span class="line">        oa &lt;&lt; p1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>)</span></span>;</span><br><span class="line">        boost::<span class="function">archive::text_iarchive <span class="title">ia</span><span class="params">(ifs)</span></span>;</span><br><span class="line">        ia &gt;&gt; p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-json-或-xml-进行序列化">使用 JSON 或 XML 进行序列化</h3>
<p>可以使用诸如 JSON 或 XML
格式来序列化对象。许多第三方库可以方便地处理这些格式，例如 nlohmann/json
库（用于 JSON）和 pugixml 库（用于 XML）。</p>
<h4 id="使用-nlohmannjson">使用 nlohmann/json</h4>
<p>以下是一个使用 nlohmann/json 库进行 JSON 序列化和反序列化的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nlohmann/json.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> json = nlohmann::json;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">json <span class="title">to_json</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> json&#123;&#123;<span class="string">&quot;name&quot;</span>, name&#125;, &#123;<span class="string">&quot;age&quot;</span>, age&#125;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">from_json</span><span class="params">(<span class="type">const</span> json&amp; j)</span> </span>&#123;</span><br><span class="line">        j.<span class="built_in">at</span>(<span class="string">&quot;name&quot;</span>).<span class="built_in">get_to</span>(name);</span><br><span class="line">        j.<span class="built_in">at</span>(<span class="string">&quot;age&quot;</span>).<span class="built_in">get_to</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.json&quot;</span>)</span></span>;</span><br><span class="line">        json j = p1.<span class="built_in">to_json</span>();</span><br><span class="line">        ofs &lt;&lt; j.<span class="built_in">dump</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.json&quot;</span>)</span></span>;</span><br><span class="line">        json j;</span><br><span class="line">        ifs &gt;&gt; j;</span><br><span class="line">        p2.<span class="built_in">from_json</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p2.age &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>对象序列化在 C++ 中可以通过多种方式实现：</p>
<ol type="1">
<li><strong>手动序列化</strong>：通过手动编写代码，将对象的成员变量写入字节流并读取。</li>
<li><strong>使用 Boost.Serialization
库</strong>：一个功能强大且灵活的库，可以简化序列化和反序列化过程。</li>
<li><strong>使用 JSON 或 XML 格式</strong>：使用第三方库（如
nlohmann/json 或 pugixml）来处理这些格式。</li>
</ol>
<p>选择哪种方法取决于具体的应用需求和项目环境。</p>
<h2 id="补充">补充</h2>
<p>Qt 中的 <code>QDataStream</code>
可以用于对象序列化，它提供了一种方便的方式将数据从一个对象写入字节流，或者从字节流中读取数据以构建对象。这与对象序列化的基本原理一致：将对象的状态转换为可存储或传输的格式（字节流），然后可以重建该对象。</p>
<p><code>QDataStream</code> 通常与 <code>QIODevice</code> 类（如
<code>QFile</code>）一起使用，以实现数据的持久化存储或网络传输。</p>
<h3 id="qdatastream-简介">QDataStream 简介</h3>
<p><code>QDataStream</code> 类用于序列化基本数据类型以及许多 Qt 类（如
<code>QString</code>、<code>QVector</code>
等）。它提供了简单的操作符重载来读取和写入数据。</p>
<h3 id="示例使用-qdatastream-进行对象序列化">示例：使用 QDataStream
进行对象序列化</h3>
<p>以下示例展示了如何使用 <code>QDataStream</code>
将一个对象序列化到文件中，然后再从文件中反序列化出来。</p>
<h4 id="示例类-2">示例类</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QFile&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    QString name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Person</span>() : <span class="built_in">name</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">age</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Person</span>(QString name, <span class="type">int</span> age) : <span class="built_in">name</span>(name), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化操作符</span></span><br><span class="line">    <span class="keyword">friend</span> QDataStream&amp; <span class="keyword">operator</span>&lt;&lt;(QDataStream&amp; out, <span class="type">const</span> Person&amp; person) &#123;</span><br><span class="line">        out &lt;&lt; person.name &lt;&lt; person.age;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化操作符</span></span><br><span class="line">    <span class="keyword">friend</span> QDataStream&amp; <span class="keyword">operator</span>&gt;&gt;(QDataStream&amp; in, Person&amp; person) &#123;</span><br><span class="line">        in &gt;&gt; person.name &gt;&gt; person.age;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化到文件</span></span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(<span class="string">&quot;person.dat&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::WriteOnly)) &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; p1;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件反序列化</span></span><br><span class="line">    Person p2;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">open</span>(QIODevice::ReadOnly)) &#123;</span><br><span class="line">        <span class="function">QDataStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        in &gt;&gt; p2;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, Age:&quot;</span> &lt;&lt; p2.age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键步骤说明">关键步骤说明</h3>
<ol type="1">
<li><strong>定义操作符重载</strong>：
<ul>
<li><code>operator&lt;&lt;</code>
用于序列化对象，将对象的各个成员变量写入数据流。</li>
<li><code>operator&gt;&gt;</code>
用于反序列化对象，从数据流中读取各个成员变量。</li>
</ul></li>
<li><strong>序列化到文件</strong>：
<ul>
<li>打开文件，创建 <code>QDataStream</code> 对象，并使用
<code>&lt;&lt;</code> 操作符将对象写入文件。</li>
</ul></li>
<li><strong>从文件反序列化</strong>：
<ul>
<li>打开文件，创建 <code>QDataStream</code> 对象，并使用
<code>&gt;&gt;</code> 操作符从文件中读取对象。</li>
</ul></li>
</ol>
<h3 id="qdatastream-的其他用法">QDataStream 的其他用法</h3>
<p>除了基本的读写操作，<code>QDataStream</code>
还提供了许多其他功能，比如设置数据流的版本以确保不同版本之间的数据兼容性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QDataStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">out.<span class="built_in">setVersion</span>(QDataStream::Qt_5_15); <span class="comment">// 设置数据流版本</span></span><br></pre></td></tr></table></figure>
<h3 id="支持的类型">支持的类型</h3>
<p><code>QDataStream</code> 支持许多 Qt 的基本类型和容器类型，例如
<code>QString</code>、<code>QByteArray</code>、<code>QList</code>、<code>QMap</code>
等。对于用户自定义类型，您需要定义序列化和反序列化操作符。</p>
<h3 id="总结-1">总结</h3>
<p><code>QDataStream</code> 是 Qt
提供的一个方便的类，用于将对象序列化到字节流中或从字节流中读取对象。这与对象序列化的基本原理一致，使得数据的存储和传输变得更加容易和高效。通过定义序列化和反序列化操作符，可以方便地序列化自定义对象。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/">http://example.com/2024/06/09/CPP复习 第十四章/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_887_2000x956_96_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/" title="CPP复习 第十七章"><img class="cover" src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPP复习 第十七章</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" title="CPP复习 第十三章"><img class="cover" src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_166_1000x619_350.011993408203_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CPP复习 第十三章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">Cpp复习 第十四章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81"><span class="toc-number">1.1.</span> <span class="toc-text">14.1 文件和流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">文件处理模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">14.2 创建顺序文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">打开一个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8open%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">使用open打开一个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E8%A2%AB%E6%88%90%E5%8A%9F%E6%89%93%E5%BC%80"><span class="toc-number">1.2.3.</span> <span class="toc-text">测试一个文件是否被成功打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDvoid-%E6%8C%87%E9%92%88"><span class="toc-number">1.2.4.</span> <span class="toc-text">重载void* 指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">14.3 从顺序文件中读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E6%8C%87%E9%92%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">文件定位指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">14.5 更新顺序文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">1.5.</span> <span class="toc-text">14.6 随机存取文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.</span> <span class="toc-text">14.7 创建随机存取文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%92%8C%E8%AF%BB%E5%8F%96"><span class="toc-number">1.6.1.</span> <span class="toc-text">输出和读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret_cast%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BD%AC%E6%8D%A2%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">reinterpret_cast&lt;&gt;()运算符转换指针类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#string%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0copy"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">string类成员函数copy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">用二进制模式打开一个输出文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E9%9A%8F%E6%9C%BA%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.7.</span> <span class="toc-text">14.8 向随机存取文件随机写入数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.</span> <span class="toc-text">14.9 从随机存取文件顺序读取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0read%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">成员函数read()读取文件数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E8%AF%BB%E5%8F%96%E5%88%B0%E6%96%87%E4%BB%B6%E5%B0%BE"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">判断是否读取到文件尾</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">14.11 对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.9.1.</span> <span class="toc-text">手动序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%B1%BB"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">示例类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8boost.serialization%E5%BA%93"><span class="toc-number">1.9.2.</span> <span class="toc-text">使用Boost.Serialization库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%B1%BB-1"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">示例类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-json-%E6%88%96-xml-%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.9.3.</span> <span class="toc-text">使用 JSON 或 XML 进行序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-nlohmannjson"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">使用 nlohmann&#x2F;json</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.10.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#qdatastream-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">QDataStream 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-qdatastream-%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.10.2.</span> <span class="toc-text">示例：使用 QDataStream
进行对象序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%B1%BB-2"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">示例类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E8%AF%B4%E6%98%8E"><span class="toc-number">1.10.3.</span> <span class="toc-text">关键步骤说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qdatastream-%E7%9A%84%E5%85%B6%E4%BB%96%E7%94%A8%E6%B3%95"><span class="toc-number">1.10.4.</span> <span class="toc-text">QDataStream 的其他用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.10.5.</span> <span class="toc-text">支持的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.10.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="2024/05/04/刷题计划/">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="2024/05/04/刷题计划/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="2024/04/03/A Way to Practice Competitive Programming/">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="2024/04/03/A Way to Practice Competitive Programming/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/Plan/">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="2024/04/02/Plan/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/诸子百家/">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="2024/04/02/诸子百家/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>