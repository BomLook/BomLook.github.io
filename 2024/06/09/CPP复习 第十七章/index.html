<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CPP复习 第十七章 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="Cpp复习 第十七章 Let’s consider a simple example of exception handling (Figs. 17.1–17.2).We show how to deal with a common arithmetic problem—division by zero.Division by zero using integer arithmetic typi">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP复习 第十七章">
<meta property="og:url" content="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/index.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="Cpp复习 第十七章 Let’s consider a simple example of exception handling (Figs. 17.1–17.2).We show how to deal with a common arithmetic problem—division by zero.Division by zero using integer arithmetic typi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg">
<meta property="article:published_time" content="2024-06-09T11:34:00.000Z">
<meta property="article:modified_time" content="2024-06-09T11:35:46.537Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg"><link rel="shortcut icon" href="https://img2.imgtp.com/2024/03/12/9tLeWKLK.png"><link rel="canonical" href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP复习 第十七章',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-09 19:35:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/94421005_p0_master1200.jpg" data-original="https://img2.imgtp.com/2024/03/10/WBTP13da.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP复习 第十七章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-09T11:34:00.000Z" title="发表于 2024-06-09 19:34:00">2024-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-09T11:35:46.537Z" title="更新于 2024-06-09 19:35:46">2024-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP复习 第十七章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="cpp复习-第十七章">Cpp复习 第十七章</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Let’<span class="function">s consider a simple example of exception <span class="title">handling</span> <span class="params">(Figs. <span class="number">17.1</span>–<span class="number">17.2</span>)</span>.</span></span><br><span class="line"><span class="function">We show how to deal with a common arithmetic problem—division by zero.</span></span><br><span class="line"><span class="function">Division by zero <span class="keyword">using</span> integer arithmetic typically causes a program to terminate prematurely.</span></span><br><span class="line"><span class="function">In floating-point arithmetic, many C++ implementations allow division by zero, in which <span class="keyword">case</span> positive <span class="keyword">or</span> negative infinity is displayed as INF <span class="keyword">or</span> -INF, respectively.</span></span><br><span class="line"><span class="function">让我们考虑一个简单的异常处理示例<span class="params">(图<span class="number">17.1</span><span class="number">-17.2</span>)</span>。</span></span><br><span class="line"><span class="function">我们将展示如何处理一个常见的算术问题——除零。</span></span><br><span class="line"><span class="function">使用整数算术除零通常会导致程序过早终止。</span></span><br><span class="line"><span class="function">在浮点运算中，许多c++实现允许除零，在这种情况下，正无穷大或负无穷大分别显示为INF或-INF。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">In <span class="keyword">this</span> example, we define a function named quotient that receives two integers input by the user <span class="keyword">and</span> divides its first <span class="type">int</span> parameter by its second <span class="type">int</span> parameter.</span><br><span class="line">Before performing the division, the function casts the first <span class="type">int</span> parameter’s value to type <span class="type">double</span>.</span><br><span class="line">Then, the second <span class="type">int</span> parameter’s value is promoted to type <span class="type">double</span> <span class="keyword">for</span> the calculation.</span><br><span class="line">So function quotient actually performs the division <span class="keyword">using</span> two <span class="type">double</span> values <span class="keyword">and</span> returns a <span class="type">double</span> result. </span><br><span class="line">在本例中，我们定义了一个名为quotient的函数，该函数接收用户输入的两个整数，并将其第一个<span class="type">int</span>形参除以第二个<span class="type">int</span>形参。</span><br><span class="line">在执行除法之前，该函数将第一个<span class="type">int</span>形参的值强制转换为<span class="type">double</span>类型。</span><br><span class="line">然后，第二个<span class="type">int</span>形参的值被提升为<span class="type">double</span>类型进行计算。</span><br><span class="line">因此，函数quotient实际上使用两个双精度值执行除法并返回双精度结果。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Although division by zero is allowed in floating-point arithmetic, <span class="keyword">for</span> the purpose of <span class="keyword">this</span> example we treat any attempt to divide by zero as an error.</span><br><span class="line">Thus, function quotient tests its second parameter to ensure that it isn’t zero before allowing the division to proceed.</span><br><span class="line">If the second parameter is zero, the function uses an exception to indicate to the caller that a problem occurred.</span><br><span class="line"><span class="function">The <span class="title">caller</span> <span class="params">(main in <span class="keyword">this</span> example)</span> can then process the exception <span class="keyword">and</span> allow the user to type two <span class="keyword">new</span> values before calling function quotient again.</span></span><br><span class="line"><span class="function">In <span class="keyword">this</span> way, the program can <span class="keyword">continue</span> to execute even after an improper value is entered, thus making the program more robust.</span></span><br><span class="line"><span class="function">尽管在浮点算术中允许除零，但出于本例的目的，我们将任何除零的尝试视为错误。</span></span><br><span class="line"><span class="function">因此，函数quotient测试它的第二个参数，以确保它不为零，然后再进行除法。</span></span><br><span class="line"><span class="function">如果第二个参数为零，则该函数使用异常向调用者指示发生了问题。</span></span><br><span class="line"><span class="function">然后调用者<span class="params">(本例中的main)</span>可以处理异常，并允许用户在再次调用函数quotient之前键入两个新值。</span></span><br><span class="line"><span class="function">这样，即使输入了不正确的值，程序也可以继续执行，从而使程序更加健壮。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DivideByZeroException.<span class="built_in">h</span> (Fig. <span class="number">17.1</span>) defines an exception <span class="keyword">class</span> <span class="title class_">that</span> represents the type of the problem that might occur in the example, <span class="keyword">and</span> fig17_02.<span class="built_in">cpp</span> (Fig. <span class="number">17.2</span>) defines the quotient function <span class="keyword">and</span> the main function that calls it.</span><br><span class="line">Function main contains the code that demonstrates exception handling. </span><br><span class="line">DivideByZeroException.<span class="built_in">h</span>(图<span class="number">17.1</span>)定义了一个异常类，它表示示例中可能出现的问题的类型，fig17_2 .<span class="built_in">cpp</span>(图<span class="number">17.2</span>)定义了商函数和调用它的主函数。</span><br><span class="line">main函数包含演示异常处理的代码。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Defining an Exception Class to Represent the Type of Problem That Might Occur </span><br><span class="line">Figure <span class="number">17.1</span> <span class="function">defines <span class="keyword">class</span> DivideByZeroException as a derived <span class="keyword">class</span> of Standard Library <span class="keyword">class</span> <span class="title">runtime_error</span> <span class="params">(from header file &lt;stdexcept&gt;)</span>.</span></span><br><span class="line"><span class="function">Class runtime_error—a derived <span class="keyword">class</span> of <span class="title">exception</span> <span class="params">(from header file &lt;exception&gt;)</span>—is the C++ standard base <span class="keyword">class</span> <span class="keyword">for</span> representing runtime errors.</span></span><br><span class="line"><span class="function">Class exception is the standard C++ base <span class="keyword">class</span> <span class="keyword">for</span> exception in the C++ Standard Library.</span></span><br><span class="line"><span class="function">Section 17.10 discusses <span class="keyword">class</span> exception <span class="keyword">and</span> its derived classes in detail.</span></span><br><span class="line"><span class="function">定义一个异常类来表示可能发生的问题类型</span></span><br><span class="line"><span class="function">图17.1将类DivideByZeroException定义为标准库类runtime_error的派生类<span class="params">(来自头文件&lt;stdexcept&gt;)</span>。</span></span><br><span class="line"><span class="function">类runtime_error——异常的派生类<span class="params">(来自头文件&lt;exception&gt;)</span>——是表示运行时错误的c++标准基类。</span></span><br><span class="line"><span class="function">类exception是c++标准库中exception的标准c++基类。</span></span><br><span class="line"><span class="function">第17.10节详细讨论了类异常及其派生类。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<h3 id="c-中的异常处理-exception-handling">C++ 中的异常处理 (Exception
Handling)</h3>
<p>异常处理是一种控制结构，用于处理程序中的错误和异常情况，使程序能够在遇到错误时采取适当的措施而不是直接崩溃。在
C++ 中，异常处理机制使用 <code>try</code>、<code>throw</code> 和
<code>catch</code> 关键字来实现。</p>
<h4 id="基本语法">基本语法</h4>
<ol type="1">
<li><strong><code>try</code>
块</strong>：包含可能会抛出异常的代码。</li>
<li><strong><code>throw</code> 语句</strong>：用于抛出一个异常。</li>
<li><strong><code>catch</code> 块</strong>：用于捕获异常并处理。</li>
</ol>
<h4 id="示例">示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span>  <span class="comment">// 包含标准异常类</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> error = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Something went wrong&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常类">异常类</h3>
<p>C++ 标准库提供了一些常用的异常类，这些类都继承自
<code>std::exception</code>：</p>
<ul>
<li><code>std::logic_error</code></li>
<li><code>std::runtime_error</code></li>
<li><code>std::bad_alloc</code>（用于内存分配失败）</li>
<li><code>std::out_of_range</code></li>
<li><code>std::invalid_argument</code></li>
</ul>
<h4 id="自定义异常类">自定义异常类</h4>
<p>你可以定义自己的异常类，继承自 <code>std::exception</code>
或其他标准异常类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;My custom exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> MyException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught my exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="栈展开-stack-unwinding">栈展开 (Stack Unwinding)</h3>
<p>当一个异常被抛出时，C++
运行时系统会进行栈展开，即逐层退出函数调用栈直到找到一个匹配的
<code>catch</code>
块。如果在栈展开过程中需要执行清理操作（如释放资源），应该在类的析构函数中进行，因为析构函数会在对象离开作用域时自动调用。</p>
<h4 id="示例-1">示例</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error occurred&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Program continues...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Resource acquired</span><br><span class="line">Resource released</span><br><span class="line">Caught an exception: Error occurred</span><br><span class="line">Program continues...</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ol type="1">
<li><strong>异常处理</strong>：使用 <code>try</code>、<code>throw</code>
和 <code>catch</code> 进行。</li>
<li><strong>标准异常类</strong>：C++
标准库提供了一些常用的异常类，便于错误处理。</li>
<li><strong>自定义异常类</strong>：可以继承标准异常类来创建自定义异常。</li>
<li><strong>栈展开</strong>：异常抛出后，系统会进行栈展开，析构函数会在此过程中被调用，确保资源被释放。</li>
</ol>
<p>异常处理机制使得程序可以在遇到错误时采取适当的措施，而不是直接崩溃，从而提高程序的健壮性和可维护性。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A typical exception <span class="keyword">class</span> that derives from the runtime_error <span class="keyword">class</span> defines only a <span class="title">constructor</span> <span class="params">(e.g., lines <span class="number">11</span>–<span class="number">12</span>)</span> that passes an error-message string to the base-<span class="keyword">class</span> runtime_error constructor.</span></span><br><span class="line"><span class="function">Every exception <span class="keyword">class</span> that derives directly <span class="keyword">or</span> indirectly from exception contains the <span class="keyword">virtual</span> function what, which returns an exception object’s error message.</span></span><br><span class="line"><span class="function">You are <span class="keyword">not</span> required to derive a custom exception <span class="keyword">class</span>, such as DivideByZeroException, from the standard exception classes provided by C++.</span></span><br><span class="line"><span class="function">Doing so allows you to use the <span class="keyword">virtual</span> function what to obtain an appropriate error message.</span></span><br><span class="line"><span class="function">We use an object of <span class="keyword">this</span> DivideByZeroException <span class="keyword">class</span> in Fig. 17.2 to indicate when an attempt is made to divide by zero.</span></span><br><span class="line"><span class="function">从runtime_error类派生的典型异常类只定义一个构造函数<span class="params">(例如，第<span class="number">11</span><span class="number">-12</span>行)</span>，该构造函数将错误消息字符串传递给基类runtime_error构造函数。</span></span><br><span class="line"><span class="function">每个直接或间接从exception派生的异常类都包含虚函数what，它返回异常对象的错误消息。</span></span><br><span class="line"><span class="function">您不需要从c++提供的标准异常类派生自定义异常类，例如DivideByZeroException。</span></span><br><span class="line"><span class="function">但是，这样做允许您使用虚函数what来获得适当的错误消息。</span></span><br><span class="line"><span class="function">在图17.2中，我们使用DivideByZeroException类的一个对象来指示何时尝试除零。</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608155155834.png"
alt="image-20240608155155834" />
<figcaption aria-hidden="true">image-20240608155155834</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Demonstrating Exception Handling</span><br><span class="line">Fig. <span class="number">17.2</span> uses exception handling to wrap code that might <span class="keyword">throw</span> a DivideByZeroException <span class="keyword">and</span> to handle that exception, should one occur.</span><br><span class="line">Function quotient divides its first <span class="built_in">parameter</span> (numerator) by its second <span class="built_in">parameter</span> (denominator).</span><br><span class="line">Assuming that the user does <span class="keyword">not</span> specify <span class="number">0</span> as the denominator <span class="keyword">for</span> the division, quotient returns the division result.</span><br><span class="line">However, <span class="keyword">if</span> the user inputs <span class="number">0</span> <span class="keyword">for</span> the denominator, function quotient throws an exception.</span><br><span class="line">演示异常处理</span><br><span class="line">图<span class="number">17.2</span>使用异常处理来包装可能抛出DivideByZeroException的代码，并在出现异常时处理该异常。</span><br><span class="line">函数商将它的第一个参数(分子)除以它的第二个参数(分母)。</span><br><span class="line">假设用户没有指定<span class="number">0</span>作为除法的分母，那么quotient将返回除法结果。</span><br><span class="line">但是，如果用户为分母输入<span class="number">0</span>，则函数quotient抛出异常。</span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608155348998.png"
alt="image-20240608155348998" />
<figcaption aria-hidden="true">image-20240608155348998</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608155355435.png"
alt="image-20240608155355435" />
<figcaption aria-hidden="true">image-20240608155355435</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608155402213.png"
alt="image-20240608155402213" />
<figcaption aria-hidden="true">image-20240608155402213</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608155416381.png"
alt="image-20240608155416381" />
<figcaption aria-hidden="true">image-20240608155416381</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Enclosing Code in a <span class="keyword">try</span> Block</span><br><span class="line">Exception handling is geared to situations in which the function that detects an error is unable to handle it. </span><br><span class="line"><span class="keyword">try</span> blocks enable exception handling.</span><br><span class="line">The <span class="keyword">try</span> block encloses statements that might cause exceptions <span class="keyword">and</span> statements that should be skipped <span class="keyword">if</span> an exception occurs.</span><br><span class="line">In <span class="keyword">this</span> example, <span class="function">because the invocation of function <span class="title">quotient</span> <span class="params">(line <span class="number">34</span>)</span> can <span class="keyword">throw</span> an exception, we enclose <span class="keyword">this</span> function invocation in a <span class="keyword">try</span> block.</span></span><br><span class="line"><span class="function">Enclosing the output <span class="title">statement</span> <span class="params">(line <span class="number">35</span>)</span> in the <span class="keyword">try</span> block ensures that the output will occur only <span class="keyword">if</span> function quotient returns a result.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">在<span class="keyword">try</span>块中封装代码</span></span><br><span class="line"><span class="function">异常处理适用于检测到错误的函数无法处理错误的情况。</span></span><br><span class="line"><span class="function">Try块启用异常处理。</span></span><br><span class="line"><span class="function"><span class="keyword">try</span>块包含可能导致异常的语句和在发生异常时应该跳过的语句。</span></span><br><span class="line"><span class="function">在本例中，由于调用函数<span class="title">quotient</span><span class="params">(第<span class="number">34</span>行)</span>会抛出异常，因此我们将该函数调用包含在<span class="keyword">try</span>块中。</span></span><br><span class="line"><span class="function">在<span class="keyword">try</span>块中封装输出语句<span class="params">(第<span class="number">35</span>行)</span>确保只有当函数quotient返回结果时才会输出。</span></span><br></pre></td></tr></table></figure>
<p>异常可能出现在try语句块中明确提到的代码中，有可能在try语句块中的代码对其他函数的调用或者嵌套调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Defining a <span class="keyword">catch</span> Handler to Process a DivideByZeroException</span><br><span class="line">Exceptions are processed by <span class="keyword">catch</span> handlers.</span><br><span class="line"><span class="function">At least one <span class="keyword">catch</span> <span class="title">handler</span> <span class="params">(lines <span class="number">37</span>–<span class="number">41</span>)</span> must immediately follow each <span class="keyword">try</span> block.</span></span><br><span class="line"><span class="function">An exception parameter should always be declared as a reference to the type of exception the <span class="keyword">catch</span> handler can <span class="title">process</span> <span class="params">(DivideByZeroException in <span class="keyword">this</span> <span class="keyword">case</span>)</span>—<span class="keyword">this</span> prevents copying the exception object when it’s caught <span class="keyword">and</span> allows a <span class="keyword">catch</span> handler to properly <span class="keyword">catch</span> derived-<span class="keyword">class</span> exceptions as well.</span></span><br><span class="line"><span class="function">When an exception occurs in a <span class="keyword">try</span> block, the <span class="keyword">catch</span> handler that executes is the first one whose type matches the type of the exception that <span class="title">occurred</span> <span class="params">(i.e., the type in the <span class="keyword">catch</span> block matches the thrown exception type exactly <span class="keyword">or</span> is a direct <span class="keyword">or</span> indirect base <span class="keyword">class</span> of it)</span>.</span></span><br><span class="line"><span class="function">定义一个<span class="keyword">catch</span>处理程序来处理一个DivideByZeroException</span></span><br><span class="line"><span class="function">异常由<span class="keyword">catch</span>处理程序处理。</span></span><br><span class="line"><span class="function">在每个<span class="keyword">try</span>块之后必须立即执行至少一个<span class="keyword">catch</span>处理程序<span class="params">(第<span class="number">37</span><span class="number">-41</span>行)</span>。</span></span><br><span class="line"><span class="function">异常参数应该始终声明为<span class="keyword">catch</span>处理程序可以处理的异常类型的引用<span class="params">(在本例中是DivideByZeroException)</span>——这可以防止在捕获异常对象时复制异常对象，并允许<span class="keyword">catch</span>处理程序正确捕获派生类异常。</span></span><br><span class="line"><span class="function">当在<span class="keyword">try</span>块中发生异常时，执行的<span class="keyword">catch</span>处理程序是第一个类型与发生的异常类型匹配的处理程序<span class="params">(即，<span class="keyword">catch</span>块中的类型与抛出的异常类型完全匹配，或者是它的直接或间接基类)</span>。</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">If an exception parameter includes an optional parameter name, the <span class="keyword">catch</span> handler can use that parameter name to interact with the caught exception in the body of the <span class="keyword">catch</span> handler, which is delimited by <span class="title">braces</span> <span class="params">(&#123; <span class="keyword">and</span> &#125;)</span>.</span></span><br><span class="line"><span class="function">A <span class="keyword">catch</span> handler typically reports the error to the user, logs it to a file, terminates the program gracefully <span class="keyword">or</span> tries an alternate strategy to accomplish the failed task.</span></span><br><span class="line"><span class="function">In <span class="keyword">this</span> example, the <span class="keyword">catch</span> handler simply reports that the user attempted to divide by zero. Then the program prompts the user to enter two <span class="keyword">new</span> integer values.</span></span><br><span class="line"><span class="function">如果异常参数包含可选参数名，<span class="keyword">catch</span>处理程序可以使用该参数名与<span class="keyword">catch</span>处理程序体中捕获的异常进行交互，该处理程序体由大括号<span class="params">(&#123;和&#125;)</span>分隔。</span></span><br><span class="line"><span class="function"><span class="keyword">catch</span>处理程序通常向用户报告错误，将其记录到文件中，优雅地终止程序或尝试替代策略来完成失败的任务。</span></span><br><span class="line"><span class="function">在本例中，<span class="keyword">catch</span>处理程序只是报告用户试图除以0。然后程序提示用户输入两个新的整数值。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try语句块和catch语句之间不能有其他的代码</span><br><span class="line">一个catch处理器只能由一个参数</span><br><span class="line">不同的catch处理器捕获的异常必须是不同的，否则会编译错误</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Termination Model of Exception Handling</strong></p>
<p>If an exception occurs as the result of a statement in a try block,
the try block expires (i.e., terminates immediately).</p>
<p>Next, the program searches for the first catch handler that can
process the type of exception that occurred.</p>
<p>The program locates the matching catch by comparing the thrown
exception’s type to each catch’s exception-parameter type until the
program finds a match.</p>
<p>A match occurs if the types are <em>identical</em> or if the thrown
exception’s type is a <em>derived class</em> of the exception-parameter
type.</p>
<p>When a match occurs, the code in the matching catch handler
executes.</p>
<p>异常处理的终止模型
如果由于try块中的语句而发生异常，则try块将过期(即立即终止)。
接下来，程序搜索第一个可以处理所发生异常类型的catch处理程序。
程序通过将抛出异常的类型与每个catch的异常参数类型进行比较，直至找到匹配的catch，从而定位匹配的catch。
如果类型相同，或者抛出异常的类型是异常参数类型的派生类，则会发生匹配。
当出现匹配时，执行匹配catch处理程序中的代码。</p>
<p>When a catch handler finishes processing by reaching its closing
right brace (}), the exception is considered handled and the local
variables defined within the catch handler (including the catch
parameter) go out of scope.</p>
<p>Program control does <em>not</em> return to the point at which the
exception occurred (known as the throw point), because the try block has
<em>expired</em>.</p>
<p>Rather, control resumes with the first statement after the last catch
handler following the try block.</p>
<p>This is known as the termination model of exception handling.</p>
<p>As with any other block of code, <em>when a</em> <em>try</em>
<em>block terminates, local variables defined in the block go out of
scope</em>.</p>
<p>当catch处理程序通过到达右括号(})结束处理时，认为异常已处理，并且在catch处理程序中定义的局部变量(包括catch形参)超出了作用域。
程序控制不会返回到发生异常的点(称为抛出点)，因为try块已经过期。
相反，控制在try块后面的最后一个catch处理程序之后的第一个语句中恢复。
这被称为异常处理的终止模型。
与任何其他代码块一样，当try块终止时，块中定义的局部变量将超出作用域。</p>
<p>还有另外一种模式：恢复模式，控制将在异常抛出后重新开始。</p>
<p>异常处理可以让程序在解决问题后，能够继续运行，保证了程序的健壮性。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Flow of Program Control When the User Enters a Denominator of Zero</span><br><span class="line">As part of throwing an exception, the <span class="keyword">throw</span> operand is created <span class="keyword">and</span> used to initialize the parameter in the <span class="keyword">catch</span> handler, which we discuss momentarily.</span><br><span class="line">Central characteristic of exception handling: If your program explicitly throws an exception, it should <span class="keyword">do</span> so before the error has an opportunity to occur.</span><br><span class="line">In general, when an exception is thrown within a <span class="keyword">try</span> block, the exception is caught by a <span class="keyword">catch</span> handler that specifies the type matching the thrown exception.</span><br><span class="line">当用户输入分母为零时的程序控制流程</span><br><span class="line">作为抛出异常的一部分，将创建<span class="keyword">throw</span>操作数，并使用该操作数初始化<span class="keyword">catch</span>处理程序中的参数，稍后将对此进行讨论。</span><br><span class="line">异常处理的核心特征:如果程序显式抛出异常，它应该在错误有机会发生之前抛出异常。</span><br><span class="line">通常，当在<span class="keyword">try</span>块中抛出异常时，该异常由<span class="keyword">catch</span>处理程序捕获，该处理程序指定与所抛出异常匹配的类型。</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">throw</span>语句用于指定一个抛出的操作数</span><br><span class="line">    In <span class="keyword">this</span> program, the <span class="keyword">catch</span> handler specifies that it catches DivideByZeroException objects—<span class="keyword">this</span> type matches the object type thrown in function quotient.</span><br><span class="line">Actually, the <span class="keyword">catch</span> handler catches a reference to the DivideByZeroException object created by function quotient’s <span class="keyword">throw</span> statement.</span><br><span class="line">The exception object is maintained by the exception-handling mechanism.</span><br><span class="line">在这个程序中，<span class="keyword">catch</span>处理程序指定它捕获DivideByZeroException对象——该类型与函数quotient中抛出的对象类型匹配。</span><br><span class="line">实际上，<span class="keyword">catch</span>处理程序捕获对DivideByZeroException对象的引用，该对象是由function quotient的<span class="keyword">throw</span>语句创建的。</span><br><span class="line">异常对象由异常处理机制维护。</span><br></pre></td></tr></table></figure>
<p>将每种运行时的错误与一个有相应名称的异常类型结合，可以提高程序的清晰度。</p>
<p>重新抛出异常，就是由异常处理器接受到异常后，再次抛出一个异常进行处理。</p>
<p>在处理器外部更进一步处理而重新抛出异常，外层的try语句将检测这个重新抛出的异常，其之后的catch语句负责捕捉处理异常。</p>
<p>参考以下例子：</p>
<p>这里不需要用到异常参数，所以直接使用&amp;即可，不需要参数名</p>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608162505808.png"
alt="image-20240608162505808" />
<figcaption aria-hidden="true">image-20240608162505808</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608162513292.png"
alt="image-20240608162513292" />
<figcaption aria-hidden="true">image-20240608162513292</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608162526819.png"
alt="image-20240608162526819" />
<figcaption aria-hidden="true">image-20240608162526819</figcaption>
</figure>
<p>堆栈展开：一般用于函数嵌套调用，如果在某一个函数中抛出异常，但是没有try...catch语句块来捕获，那么当前函数中所有在该函数体内初始化的局部变量都将被销毁，并且返回上一级函数，查看有没有try...catch语句，如果有，则捕获抛出异常并且处理，否则按照上面的内容类推。可以具体查看以下例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">When an exception is thrown but <span class="keyword">not</span> caught in a particular scope, the function call stack is “unwound,” <span class="keyword">and</span> an attempt is made to <span class="keyword">catch</span> the exception in the next outer <span class="keyword">try</span>…<span class="keyword">catch</span> block.</span><br><span class="line">Unwinding the function call stack means that the function in which the exception was <span class="keyword">not</span> caught terminates, all local variables that have completed intitialization in that function are destroyed <span class="keyword">and</span> control returns to the statement that originally invoked that function.</span><br><span class="line">If a <span class="keyword">try</span> block encloses that statement, an attempt is made to <span class="keyword">catch</span> the exception.</span><br><span class="line">If a <span class="keyword">try</span> block does <span class="keyword">not</span> enclose that statement, stack unwinding occurs again.</span><br><span class="line">If no <span class="keyword">catch</span> handler ever catches <span class="keyword">this</span> exception, the program terminates.</span><br><span class="line">The program of Fig. <span class="number">17.4</span> demonstrates stack unwinding.</span><br><span class="line">当抛出异常但未在特定范围内捕获异常时，将“展开”函数调用堆栈，并尝试在下一个外部<span class="keyword">try</span>…<span class="keyword">catch</span>块中捕获异常。</span><br><span class="line">展开函数调用堆栈意味着未捕获异常的函数终止，该函数中已完成初始化的所有局部变量将被销毁，控制返回到最初调用该函数的语句。</span><br><span class="line">如果<span class="keyword">try</span>块包含该语句，则尝试捕获异常。</span><br><span class="line">如果<span class="keyword">try</span>块没有包含该语句，则再次执行堆栈展开。</span><br><span class="line">如果没有捕获处理程序捕获此异常，则程序终止。</span><br><span class="line">图<span class="number">17.4</span>的程序演示了堆栈展开。</span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608163916400.png"
alt="image-20240608163916400" />
<figcaption aria-hidden="true">image-20240608163916400</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608163923105.png"
alt="image-20240608163923105" />
<figcaption aria-hidden="true">image-20240608163923105</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608163932020.png"
alt="image-20240608163932020" />
<figcaption aria-hidden="true">image-20240608163932020</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Exception handling is designed to process synchronous errors, which occur when a statement executes, such as out-of-range array subscripts, <span class="function">arithmetic <span class="title">overflow</span> <span class="params">(i.e., a value outside the representable range of values)</span>, division by zero, invalid function parameters <span class="keyword">and</span> unsuccessful memory <span class="title">allocation</span> <span class="params">(due to lack of memory)</span>.</span></span><br><span class="line"><span class="function">Exception handling is <span class="keyword">not</span> designed to process errors associated with asynchronous <span class="title">events</span> <span class="params">(e.g., disk I/O completions, network message arrivals, mouse clicks <span class="keyword">and</span> keystrokes)</span>, which occur in parallel with, <span class="keyword">and</span> independent of, the program’s flow of control.</span></span><br><span class="line"><span class="function">异常处理的设计目的是处理同步错误，这种错误在语句执行时发生，例如超出范围的数组下标、算术溢出<span class="params">(即值超出可表示范围)</span>、除零、无效的函数参数和不成功的内存分配<span class="params">(由于缺乏内存)</span>。</span></span><br><span class="line"><span class="function">异常处理不是设计用来处理与异步事件<span class="params">(例如，磁盘I/O完成、网络消息到达、鼠标点击和击键)</span>相关的错误的，这些错误与程序的控制流并行发生，并且独立于程序的控制流。</span></span><br></pre></td></tr></table></figure>
<p>异常处理有助于在同一个大型项目中的程序员相互了解各自的错误处理代码。</p>
<p>带有常见错误情况的函数应该返回nullptr，0或者其他合适的值，而不是不是抛出异常，这样就可以让调用函数的程序通过检查返回值来确定函数调用是否成功。</p>
<p>异常问题可以解决预定义组件和由预定义组件构成的特定组件的问题，当预定义组件遇到问题时，可以通过异常处理来与特定组件进行沟通。（预定义组件一开始就是定义好的，无法预知接下来可能会出现的问题）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">C++<span class="number">11</span>: Declaring Functions That Do Not Throw Exceptions</span><br><span class="line">As of C++<span class="number">11</span>, <span class="keyword">if</span> a function does <span class="keyword">not</span> <span class="keyword">throw</span> any exceptions <span class="keyword">and</span> does <span class="keyword">not</span> call any functions that <span class="keyword">throw</span> exceptions, you should explicitly state that a function does <span class="keyword">not</span> <span class="keyword">throw</span> exceptions. </span><br><span class="line">This indicates to client-code programmers that there’s no need to place calls to the function in a <span class="keyword">try</span> block. </span><br><span class="line">Add <span class="keyword">noexcept</span> to the right of the function’s parameter list in both the prototype <span class="keyword">and</span> the definition. </span><br><span class="line">For a <span class="type">const</span> member function, place <span class="keyword">noexcept</span> after <span class="type">const</span>. </span><br><span class="line">If a function that’s declared <span class="keyword">noexcept</span> calls another function that throws an exception <span class="keyword">or</span> executes a <span class="keyword">throw</span> statement, the program terminates. </span><br><span class="line">c++ <span class="number">11</span>:声明不抛出异常的函数</span><br><span class="line">从c++ <span class="number">11</span>开始，如果函数不抛出任何异常，也不调用任何抛出异常的函数，则应该显式声明函数不抛出异常。</span><br><span class="line">这向客户端代码程序员表明，不需要将对函数的调用放在<span class="keyword">try</span>块中。</span><br><span class="line">在原型和定义的函数参数列表的右侧添加<span class="keyword">noexcept</span>。</span><br><span class="line">对于<span class="type">const</span>成员函数，在<span class="type">const</span>之后放置<span class="keyword">noexcept</span>。</span><br><span class="line">如果声明为<span class="keyword">noexcept</span>的函数调用另一个抛出异常或执行<span class="keyword">throw</span>语句的函数，则程序终止。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">The preferred alternative is to require the constructor to <span class="keyword">throw</span> an exception that contains the error information, thus offering an opportunity <span class="keyword">for</span> the program to handle the failure.</span><br><span class="line">Before an exception is thrown by a constructor, destructors are called <span class="keyword">for</span> any member objects whose constructors have run to completion as part of the object being constructed.</span><br><span class="line">Destructors are called <span class="keyword">for</span> every automatic object constructed in a <span class="keyword">try</span> block before the exception is caught.</span><br><span class="line">Stack unwinding is guaranteed to have been completed at the point that an exception handler begins executing.</span><br><span class="line">If a destructor invoked as a result of stack unwinding throws an exception, the program terminates.</span><br><span class="line">This has been linked to various security attacks.</span><br><span class="line">首选的替代方法是要求构造函数抛出包含错误信息的异常，从而为程序提供处理故障的机会。</span><br><span class="line"></span><br><span class="line">!!!在构造函数抛出异常之前，对其构造函数作为正在构造的对象的一部分运行到完成的任何成员对象调用析构函数。</span><br><span class="line">!!!在捕获异常之前，对在<span class="keyword">try</span>块中构造的每个自动对象调用析构函数。</span><br><span class="line">!!!栈展开保证在异常处理程序开始执行时完成。</span><br><span class="line"></span><br><span class="line">如果由于堆栈展开而调用的析构函数抛出异常，则程序终止。这与各种安全攻击有关。</span><br></pre></td></tr></table></figure>
<p>注意：析构函数应该是捕捉异常，而不是抛出异常。</p>
<blockquote>
<p>在C++中，如果在异常传播过程中（即堆栈展开期间）一个析构函数抛出异常，将会导致程序调用<code>std::terminate</code>并立即终止。这是因为在C++中，异常的处理机制设计为在同一时间只能有一个活动异常。如果一个异常正在传播，而另一个异常在此过程中被抛出，系统将不知道如何处理多个同时存在的异常，因而选择终止程序。</p>
<h3
id="为什么在析构函数中抛出异常会导致程序终止">为什么在析构函数中抛出异常会导致程序终止</h3>
<p>堆栈展开期间，程序需要释放资源和调用栈上的所有对象的析构函数。如果析构函数在释放资源时抛出异常，这将会导致程序在处理中出现两个活动异常（一个是原本正在处理的异常，另一个是析构函数抛出的新异常）。这会导致无法正确管理异常的控制流。</p>
<p>以下是一个示例，展示了在堆栈展开期间析构函数抛出异常的情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Resource destructor called\n&quot;</span>;</span><br><span class="line">     <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Destructor exception&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Resource res;</span><br><span class="line"> <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Original exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">mightGoWrong</span>();</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当 <code>mightGoWrong</code> 函数抛出“Original
exception”异常时，程序会进入堆栈展开过程，调用<code>Resource</code>对象的析构函数。而在析构函数中抛出了另一个异常“Destructor
exception”，这会导致程序调用<code>std::terminate</code>并立即终止。</p>
<h3 id="与安全攻击的关系">与安全攻击的关系</h3>
<p>这种情况不仅仅是技术细节问题，还与安全性有关。在安全攻击中，攻击者可能会试图利用程序的不当行为或未处理的异常来执行恶意代码。如下几种情况：</p>
<ol type="1">
<li><strong>资源泄漏</strong>：如果在堆栈展开过程中，析构函数抛出异常，资源可能无法正确释放。这可能导致资源泄漏，攻击者可能利用这一点耗尽系统资源。</li>
<li><strong>不确定行为</strong>：未处理的异常可能导致程序以不确定的方式行为，攻击者可以利用这种不确定性来破坏程序的正常执行流程。</li>
<li><strong>崩溃利用</strong>：攻击者可能通过故意触发异常并利用程序崩溃的行为来获得对系统的控制。</li>
</ol>
<h3 id="如何防止析构函数抛出异常">如何防止析构函数抛出异常</h3>
<p>为了避免这些问题，通常的做法是在析构函数中捕获并处理所有可能的异常，确保析构函数不会抛出异常。以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Destructor exception&quot;</span>);</span><br><span class="line">        &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Exception caught in destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="comment">// 处理异常（例如，记录日志、释放资源等），确保不抛出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mightGoWrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Resource res;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Original exception&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">mightGoWrong</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught an exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1">总结</h3>
<p>在析构函数中抛出异常会导致程序终止，这与异常处理机制设计有关，也是为了防止出现未处理的多个异常导致程序行为不确定或资源泄漏等问题。为了保证程序的健壮性和安全性，应该确保析构函数不会抛出异常，通常通过在析构函数中捕获并处理所有可能的异常来实现。这样可以确保在堆栈展开期间正确释放资源，避免程序因未处理的异常而崩溃。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">If an object has member objects, <span class="keyword">and</span> <span class="keyword">if</span> an exception is thrown before the outer object is fully constructed, then destructors will be executed <span class="keyword">for</span> the member objects that have been constructed prior to the occurrence of the exception.</span><br><span class="line">If an array of objects has been partially constructed when an exception occurs, only the destructors <span class="keyword">for</span> the constructed objects in the array will be called.</span><br><span class="line">如果对象具有成员对象，并且在外部对象完全构造之前抛出异常，则将对在异常发生之前构造的成员对象执行析构函数。</span><br><span class="line">如果在发生异常时已经部分构造了对象数组，则只调用数组中构造对象的析构函数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C++
中，正确地管理资源（如内存、文件句柄、网络连接等）是非常重要的。一个常见的模式是使用局部对象的构造函数和析构函数来管理资源的分配和释放。这种模式被称为
RAII（Resource Acquisition Is Initialization，资源获取即初始化）。</p>
<h3 id="raii-模式">RAII 模式</h3>
<p>RAII
的核心思想是将资源的分配和释放绑定到对象的生命周期。在对象的构造函数中获取资源，在对象的析构函数中释放资源。这样可以确保在异常情况下资源也能得到正确释放。</p>
<h3 id="示例文件资源管理">示例：文件资源管理</h3>
<p>下面是一个简单的示例，展示如何使用 RAII 模式管理文件资源：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileWrapper</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// 构造函数中打开文件</span></span><br><span class="line"> <span class="built_in">FileWrapper</span>(<span class="type">const</span> std::string&amp; filename) : <span class="built_in">file</span>(filename) &#123;</span><br><span class="line">     <span class="keyword">if</span> (!file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Could not open file&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 析构函数中关闭文件</span></span><br><span class="line"> ~<span class="built_in">FileWrapper</span>() &#123;</span><br><span class="line">     <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         file.<span class="built_in">close</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提供接口操作文件</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">(<span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">         file &lt;&lt; data;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> std::ofstream file;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writeToFile</span><span class="params">(<span class="type">const</span> std::string&amp; filename, <span class="type">const</span> std::string&amp; data)</span> </span>&#123;</span><br><span class="line"> <span class="function">FileWrapper <span class="title">fileWrapper</span><span class="params">(filename)</span></span>;</span><br><span class="line"> fileWrapper.<span class="built_in">write</span>(data);</span><br><span class="line"> <span class="comment">// FileWrapper 对象离开作用域时，析构函数会自动关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="built_in">writeToFile</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;Hello, RAII!&quot;</span>);</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>FileWrapper</code>
类管理一个文件对象。它在构造函数中打开文件，在析构函数中关闭文件。即使在
<code>writeToFile</code> 函数中抛出异常，<code>FileWrapper</code>
的析构函数也会被调用，从而确保文件被正确关闭。</p>
<h3 id="使用智能指针管理动态内存">使用智能指针管理动态内存</h3>
<p>除了文件资源，RAII 模式还可以用于管理动态内存。C++11
引入了智能指针，提供了一种简单而安全的方式来管理动态分配的内存。</p>
<ul>
<li><code>std::unique_ptr</code>：独占所有权的智能指针。</li>
<li><code>std::shared_ptr</code>：共享所有权的智能指针。</li>
<li><code>std::weak_ptr</code>：与 <code>std::shared_ptr</code>
搭配使用，防止循环引用。</li>
</ul>
<h4 id="示例使用-stdunique_ptr">示例：使用
<code>std::unique_ptr</code></h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Doing something with resource\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Resource&gt; resource = std::<span class="built_in">make_unique</span>&lt;Resource&gt;();</span><br><span class="line">    resource-&gt;<span class="built_in">doSomething</span>();</span><br><span class="line">    <span class="comment">// Resource 对象会在函数结束时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">useResource</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>std::unique_ptr</code> 管理一个
<code>Resource</code> 对象。当 <code>useResource</code>
函数结束时，<code>std::unique_ptr</code> 会自动释放
<code>Resource</code> 对象的内存。</p>
<h3 id="其他资源管理">其他资源管理</h3>
<p>RAII 可以用于管理任何需要显式释放的资源，例如：</p>
<ul>
<li>数据库连接</li>
<li>互斥锁</li>
<li>网络连接</li>
</ul>
<h4 id="示例使用-stdlock_guard-管理互斥锁">示例：使用
<code>std::lock_guard</code> 管理互斥锁</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printThreadId</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// mtx 会在 lock 离开作用域时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(printThreadId, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(printThreadId, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>std::lock_guard</code> 自动管理
<code>std::mutex</code>
的锁定和解锁操作，确保互斥锁在函数退出时被正确释放。</p>
<h3 id="总结-2">总结</h3>
<p>RAII 是 C++
中一种重要的资源管理模式，它将资源的分配和释放绑定到对象的生命周期中，利用构造函数和析构函数确保资源在正常和异常情况下都能被正确释放。通过使用智能指针和其他
RAII 工具类（如
<code>std::lock_guard</code>），可以更安全、方便地管理各种资源，避免资源泄漏和其他潜在问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Various exception classes can be derived from a common base <span class="keyword">class</span>, as we discussed in Section <span class="number">17.2</span>, when we created <span class="keyword">class</span> <span class="title class_">DivideByZeroException</span> as a derived <span class="keyword">class</span> <span class="title class_">of</span> <span class="keyword">class</span> <span class="title class_">exception</span>.</span><br><span class="line">If a <span class="keyword">catch</span> handler catches a reference to an exception object of a base-<span class="keyword">class</span> <span class="title class_">type</span>, it also can <span class="keyword">catch</span> a reference to all objects of classes publicly derived from that base <span class="keyword">class</span>—<span class="keyword">this</span> allows <span class="keyword">for</span> polymorphic processing of related exceptions.</span><br><span class="line">正如我们在第<span class="number">17.2</span>节中所讨论的，可以从公共基类派生出各种异常类，当时我们创建了类DivideByZeroException作为类exception的派生类。</span><br><span class="line">如果<span class="keyword">catch</span>处理程序捕获对基类类型的异常对象的引用，那么它也可以捕获对从该基类公开派生的类的所有对象的引用——这允许对相关异常进行多态处理。</span><br></pre></td></tr></table></figure>
<p>异常处理器：</p>
<p>一种方法是分别捕获每一个派生类异常对象的每种引用，另一种是捕获基类异常对象的指针和引用，更高效。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">When <span class="keyword">operator</span> <span class="keyword">new</span> fails, it throws a bad_alloc <span class="built_in">exception</span> (defined in header file &lt;<span class="keyword">new</span>&gt;).</span><br><span class="line">In <span class="keyword">this</span> section, we present two examples of <span class="keyword">new</span> failing.</span><br><span class="line">The first uses the version of <span class="keyword">new</span> that throws a bad_alloc exception when <span class="keyword">new</span> fails.</span><br><span class="line">The second uses function set_new_handler to handle <span class="keyword">new</span> failures.</span><br><span class="line">[Note: The examples in Figs. <span class="number">17.5</span>–<span class="number">17.6</span> allocate large amounts of dynamic memory, which could cause your computer to become sluggish.]</span><br><span class="line">当<span class="keyword">operator</span> <span class="keyword">new</span>失败时，它抛出一个bad_alloc异常(在头文件&lt;<span class="keyword">new</span>&gt;中定义)。</span><br><span class="line">在本节中，我们将介绍两个新故障的示例。</span><br><span class="line">第一个使用<span class="keyword">new</span>的版本，当<span class="keyword">new</span>失败时抛出bad_alloc异常。</span><br><span class="line">第二个使用set_new_handler函数来处理新的故障。</span><br><span class="line">[注意:图<span class="number">17.5</span><span class="number">-17.6</span>中的例子分配了大量的动态内存，这可能会导致您的计算机变得迟钝。]</span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608182753828.png"
alt="image-20240608182753828" />
<figcaption aria-hidden="true">image-20240608182753828</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608182801972.png"
alt="image-20240608182801972" />
<figcaption aria-hidden="true">image-20240608182801972</figcaption>
</figure>
<p>这些异常的输出取决于内存和编译器等原因。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Returning <span class="literal">nullptr</span> on Failure</span><br><span class="line">The C++ standard specifies that programmers can use an older version of <span class="keyword">new</span> that returns <span class="literal">nullptr</span> upon failure.</span><br><span class="line">For <span class="keyword">this</span> purpose, header &lt;<span class="keyword">new</span>&gt; defines object <span class="built_in">nothrow</span> (of type <span class="type">nothrow_t</span>), which is used as follows:</span><br><span class="line"><span class="type">double</span> *ptr = <span class="built_in">new</span>( nothrow ) <span class="type">double</span>[ <span class="number">50000000</span> ];</span><br><span class="line"><span class="function">The preceding statement uses the version of <span class="keyword">new</span> that does <span class="keyword">not</span> <span class="keyword">throw</span> bad_alloc <span class="title">exceptions</span> <span class="params">(i.e., nothrow)</span> to allocate an array of 50,000,000 doubles.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">new</span>失败返回<span class="literal">nullptr</span></span></span><br><span class="line"><span class="function">c++标准规定程序员可以使用旧版本的<span class="keyword">new</span>，在失败时返回<span class="literal">nullptr</span>。</span></span><br><span class="line"><span class="function">为此，header &lt;<span class="keyword">new</span>&gt;定义了nothrow对象<span class="params">(<span class="type">nothrow_t</span>类型)</span>，使用方法如下:</span></span><br><span class="line"><span class="function">Double *ptr =</span> <span class="keyword">new</span>(nothrow) Double [<span class="number">50000000</span>];</span><br><span class="line">前面的语句使用不抛出bad_alloc异常(即nothrow)的<span class="keyword">new</span>版本来分配一个包含<span class="number">50</span>,<span class="number">000</span>,<span class="number">000</span>个<span class="type">double</span>类型的数组。</span><br><span class="line">推荐使用这种方法，使得代码更具有健壮性。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Handling <span class="keyword">new</span> Failures Using Function set_new_handler</span></span><br><span class="line"><span class="function">Function <span class="title">set_new_handler</span> <span class="params">(prototyped in standard header file &lt;<span class="keyword">new</span>&gt;)</span> takes as its argument a pointer to a function that takes no arguments <span class="keyword">and</span> returns <span class="type">void</span>.</span></span><br><span class="line"><span class="function">This pointer points to the function that will be called <span class="keyword">if</span> <span class="keyword">new</span> fails.</span></span><br><span class="line"><span class="function">This provides you with a uniform approach to handling all <span class="keyword">new</span> failures, regardless of where a failure occurs in the program.</span></span><br><span class="line"><span class="function">Once set_new_handler registers a <span class="keyword">new</span> handler in the program, <span class="keyword">operator</span> <span class="keyword">new</span> does <span class="keyword">not</span> <span class="keyword">throw</span> bad_alloc on failure</span>; rather, it defers the error handling to the <span class="keyword">new</span>-handler function.</span><br><span class="line">If <span class="keyword">new</span> fails to allocate memory <span class="keyword">and</span> set_new_handler did <span class="keyword">not</span> <span class="keyword">register</span> a <span class="keyword">new</span>-handler function, <span class="keyword">new</span> throws a bad_alloc exception.</span><br><span class="line">If <span class="keyword">new</span> fails to allocate memory <span class="keyword">and</span> a <span class="keyword">new</span>-handler function has been registered, the <span class="keyword">new</span>-handler function is called.</span><br><span class="line">使用set_new_handler函数处理新的故障</span><br><span class="line">函数<span class="built_in">set_new_handler</span>(原型在标准头文件&lt;<span class="keyword">new</span>&gt;中)接受一个指针作为参数，该指针指向一个不接受参数并返回<span class="type">void</span>的函数。</span><br><span class="line">这个指针指向如果<span class="keyword">new</span>失败将被调用的函数。</span><br><span class="line">这为您提供了处理所有新故障的统一方法，而不管故障发生在程序中的哪个位置。</span><br><span class="line">一旦set_new_handler在程序中注册了一个新的处理程序，<span class="keyword">operator</span> <span class="keyword">new</span>就不会抛出bad_alloc;相反，它将错误处理延迟到<span class="keyword">new</span>-handler函数。</span><br><span class="line">如果<span class="keyword">new</span>分配内存失败，并且set_new_handler没有注册一个<span class="keyword">new</span>-handler函数，<span class="keyword">new</span>抛出一个bad_alloc异常。</span><br><span class="line">如果<span class="keyword">new</span>分配内存失败，并且注册了<span class="keyword">new</span>-handler函数，则调用<span class="keyword">new</span>-handler函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">new</span>-handler function should perform one of the following tasks:</span><br><span class="line">Make more memory available by deleting other dynamically allocated <span class="built_in">memory</span> (<span class="keyword">or</span> telling the user to close other applications) <span class="keyword">and</span> <span class="keyword">return</span> to <span class="keyword">operator</span> <span class="keyword">new</span> to attempt to allocate memory again.</span><br><span class="line">Throw an exception of type bad_alloc.</span><br><span class="line">Call function abort <span class="keyword">or</span> <span class="built_in">exit</span> (both found in header file &lt;cstdlib&gt;) to terminate the program. These were introduced in Section <span class="number">9.7</span>.</span><br><span class="line">Figure <span class="number">17.6</span> demonstrates set_new_handler.</span><br><span class="line">Function <span class="built_in">customNewHandler</span> (lines <span class="number">9</span>–<span class="number">13</span>) prints an error <span class="built_in">message</span> (line <span class="number">11</span>), then calls <span class="built_in">abort</span> (line <span class="number">12</span>) to terminate the program.</span><br><span class="line">The output shows that the loop iterated four times before <span class="keyword">new</span> failed <span class="keyword">and</span> invoked function customNewHandler.</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span>-handler函数应该执行以下任务之一:</span><br><span class="line">通过删除其他动态分配的内存(或告诉用户关闭其他应用程序)来获得更多可用内存，并返回到<span class="keyword">operator</span> <span class="keyword">new</span>以尝试再次分配内存。</span><br><span class="line">抛出类型为bad_alloc的异常。</span><br><span class="line">调用函数abort或<span class="built_in">exit</span>(都在头文件&lt;cstdlib&gt;中找到)来终止程序。第<span class="number">9.7</span>节介绍了这些特性。</span><br><span class="line">图<span class="number">17.6</span>演示了set_new_handler。</span><br><span class="line">函数<span class="built_in">customNewHandler</span>(第<span class="number">9</span><span class="number">-13</span>行)打印一条错误消息(第<span class="number">11</span>行)，然后调用<span class="built_in">abort</span>(第<span class="number">12</span>行)终止程序。</span><br><span class="line">输出显示，在<span class="keyword">new</span>失败并调用函数customNewHandler之前，循环迭代了四次。</span><br><span class="line">课本的例子这里不再展示 和下面的基本一样</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C++ 中，<code>set_new_handler</code>
是一个非常有用的工具，用于在内存分配失败时自定义处理行为。默认情况下，如果
<code>new</code> 运算符无法分配足够的内存，会抛出
<code>std::bad_alloc</code> 异常。但是，通过使用
<code>set_new_handler</code>，你可以指定一个函数，当 <code>new</code>
无法分配内存时调用该函数，而不是直接抛出异常。</p>
<h3 id="set_new_handler-的用法"><code>set_new_handler</code> 的用法</h3>
<p>以下是如何使用 <code>set_new_handler</code> 的示例：</p>
<ol type="1">
<li><strong>定义一个处理函数</strong>： 这个函数将在 <code>new</code>
运算符分配内存失败时调用。这个函数必须是无参的，并且返回类型为
<code>void</code>。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span> <span class="comment">// 包含 std::set_new_handler</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed. Terminating.\n&quot;</span>;</span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 终止程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><strong>设置处理函数</strong>： 使用
<code>std::set_new_handler</code> 函数设置你自定义的处理函数。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(myNewHandler); <span class="comment">// 设置新的内存分配失败处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试分配大量内存以触发内存分配失败</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>]; <span class="comment">// 分配1GB内存块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>myNewHandler</code> 是一个处理函数，当
<code>new</code>
运算符无法分配内存时，它会被调用，输出错误信息并终止程序。</p>
<h3 id="处理函数的作用">处理函数的作用</h3>
<p>处理函数在 <code>new</code>
运算符分配内存失败时调用，你可以在处理函数中执行以下操作：</p>
<ul>
<li>记录日志或输出错误信息。</li>
<li>尝试释放一些内存，然后返回以重试内存分配。</li>
<li>调用 <code>std::abort</code> 或 <code>std::exit</code>
终止程序。</li>
</ul>
<h3 id="示例尝试释放内存">示例：尝试释放内存</h3>
<p>假设你有一些可以释放的全局资源，可以在内存分配失败时释放这些资源并重试分配：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">char</span>*&gt; allocatedMemory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed. Freeing allocated memory.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放一些已分配的内存</span></span><br><span class="line">    <span class="keyword">if</span> (!allocatedMemory.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] allocatedMemory.<span class="built_in">back</span>();</span><br><span class="line">        allocatedMemory.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 尝试再次分配内存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// 如果没有可释放的内存，则终止程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(myNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">char</span>* ptr = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>]; <span class="comment">// 分配10MB内存块</span></span><br><span class="line">            allocatedMemory.<span class="built_in">push_back</span>(ptr); <span class="comment">// 记录分配的内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_alloc: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放所有已分配的内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span>* ptr : allocatedMemory) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，当 <code>new</code>
运算符无法分配内存时，<code>myNewHandler</code>
释放一些已分配的内存，然后返回以重试内存分配。如果没有更多的内存可以释放，它将调用
<code>std::abort</code> 终止程序。</p>
<h3 id="注意事项">注意事项</h3>
<ol type="1">
<li><strong><code>set_new_handler</code>
是全局性的</strong>：当你设置一个新的处理函数时，它会覆盖任何先前设置的处理函数，并且对整个程序有效。</li>
<li><strong>线程安全</strong>：C++11
及以后的标准中，<code>set_new_handler</code>
是线程安全的。不同线程可以有各自的处理函数。</li>
<li><strong>处理函数不应抛出异常</strong>：在处理函数中抛出异常是不明智的，因为这可能会导致未定义行为。处理函数应该确保完成它的任务并返回，或者终止程序。</li>
</ol>
<p>通过使用
<code>set_new_handler</code>，你可以更灵活地处理内存分配失败的情况，确保程序在资源紧张时能够有更好的应对措施。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A common programming practice is to allocate dynamic memory, assign the address of that memory to a pointer, use the pointer to manipulate the memory <span class="keyword">and</span> deallocate the memory with <span class="keyword">delete</span> when the memory is no longer needed.</span><br><span class="line">If an exception occurs after successful memory allocation but before the <span class="keyword">delete</span> statement executes, a memory leak could occur.</span><br><span class="line">C++ <span class="number">11</span> provides <span class="keyword">class</span> <span class="title class_">template</span> unique_ptr in header file &lt;memory&gt; to deal with <span class="keyword">this</span> situation.</span><br><span class="line">一种常见的编程做法是分配动态内存，将该内存的地址分配给指针，使用指针操作内存，并在不再需要内存时使用<span class="keyword">delete</span>释放内存。</span><br><span class="line">如果在成功分配内存之后但在执行<span class="keyword">delete</span>语句之前发生异常，则可能发生内存泄漏。</span><br><span class="line">c++ <span class="number">11</span>在头文件&lt;memory&gt;中提供了类模板unique_ptr来处理这种情况。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">An object of <span class="keyword">class</span> <span class="title class_">unique_ptr</span> maintains a pointer to dynamically allocated memory.</span><br><span class="line"><span class="function">When an unique_ptr object destructor is <span class="title">called</span> <span class="params">(<span class="keyword">for</span> example, when an unique_ptr object goes out of scope)</span>, it performs a <span class="keyword">delete</span> operation on its pointer data member.</span></span><br><span class="line"><span class="function">Class <span class="keyword">template</span> unique_ptr provides overloaded operators * <span class="keyword">and</span> -&gt; so that an unique_ptr object can be used just as a regular pointer variable is.</span></span><br><span class="line"><span class="function">Figure 17.9 demonstrates an unique_ptr object that points to a dynamically allocated object of <span class="keyword">class</span> <span class="title">Integer</span> <span class="params">(Figs. <span class="number">17.7</span>–<span class="number">17.8</span>)</span>.</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">unique_ptr类的对象维护一个指向动态分配内存的指针。</span></span><br><span class="line"><span class="function">当调用unique_ptr对象析构函数时<span class="params">(例如，当unique_ptr对象超出作用域时)</span>，它对其指针数据成员执行<span class="keyword">delete</span>操作。</span></span><br><span class="line"><span class="function">类模板unique_ptr提供了重载操作符*和-&gt;，这样unique_ptr对象就可以像普通指针变量一样使用。</span></span><br><span class="line"><span class="function">图17.9演示了一个unique_ptr对象，它指向一个动态分配的Integer类对象<span class="params">(图<span class="number">17.7</span><span class="number">-17.8</span>)</span>。</span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608185945944.png"
alt="image-20240608185945944" />
<figcaption aria-hidden="true">image-20240608185945944</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608185954422.png"
alt="image-20240608185954422" />
<figcaption aria-hidden="true">image-20240608185954422</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608190002234.png"
alt="image-20240608190002234" />
<figcaption aria-hidden="true">image-20240608190002234</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608190010125.png"
alt="image-20240608190010125" />
<figcaption aria-hidden="true">image-20240608190010125</figcaption>
</figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608190016231.png"
alt="image-20240608190016231" />
<figcaption aria-hidden="true">image-20240608190016231</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Because ptrToInteger is a local automatic variable in main, ptrToInteger is destroyed when main terminates.</span><br><span class="line">The unique_ptr destructor forces a <span class="keyword">delete</span> of the Integer object pointed to by ptrToInteger, which in turn calls the Integer <span class="keyword">class</span> <span class="title class_">destructor</span>.</span><br><span class="line">The memory that Integer occupies is released, <span class="function">regardless of how control leaves the <span class="title">block</span> <span class="params">(e.g., by a <span class="keyword">return</span> statement <span class="keyword">or</span> by an exception)</span>.</span></span><br><span class="line"><span class="function">Most importantly, <span class="keyword">using</span> <span class="keyword">this</span> technique can prevent memory leaks.</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">因为ptrToInteger是main中的一个局部自动变量，所以当main终止时ptrToInteger将被销毁。</span></span><br><span class="line"><span class="function">unique_ptr析构函数强制删除ptrToInteger所指向的Integer对象，而ptrToInteger又调用Integer类析构函数。</span></span><br><span class="line"><span class="function">Integer占用的内存被释放，无论控制如何离开块<span class="params">(例如，通过返回语句或异常)</span>。</span></span><br><span class="line"><span class="function">最重要的是，使用这种技术可以防止内存泄漏。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr Notes</span><br><span class="line">The <span class="keyword">class</span> <span class="title class_">is</span> called unique_ptr because only one unique_ptr at a time can own a dynamically allocated object.</span><br><span class="line">By <span class="keyword">using</span> its overloaded assignment <span class="keyword">operator</span> <span class="keyword">or</span> copy constructor, an unique_ptr can transfer ownership of the dynamic memory it manages.</span><br><span class="line">unique_ptr笔记</span><br><span class="line">这个类被称为unique_ptr，因为一次只能有一个unique_ptr拥有一个动态分配的对象。</span><br><span class="line">通过使用它的重载赋值操作符或复制构造函数，unique_ptr可以转移它所管理的动态内存的所有权。</span><br><span class="line">    </span><br><span class="line">The last unique_ptr object that maintains the pointer to the dynamic memory will <span class="keyword">delete</span> the memory.</span><br><span class="line">This makes unique_ptr an ideal mechanism <span class="keyword">for</span> returning dynamically allocated memory to client code.</span><br><span class="line">When the unique_ptr goes out of scope in the client code, the unique_ptr’s destructor destroys the dynamically allocated object <span class="keyword">and</span> deletes its memory.</span><br><span class="line">最后一个维护动态内存指针的unique_ptr对象将删除该内存。</span><br><span class="line">这使得unique_ptr成为将动态分配的内存返回给客户端代码的理想机制。</span><br><span class="line">当unique_ptr在客户端代码中超出作用域时，unique_ptr的析构函数会销毁动态分配的对象并删除其内存。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr to a Built-In Array</span><br><span class="line">You can also use a unique_ptr to manage a dynamically allocated built-in array. </span><br><span class="line">For example, <span class="function">consider the statement</span></span><br><span class="line"><span class="function">unique_ptr&lt; string[] &gt; <span class="title">ptr</span><span class="params">( <span class="keyword">new</span> string[ <span class="number">10</span> ] )</span></span>; </span><br><span class="line">which dynamically allocates an array of <span class="number">10</span> strings managed by ptr. </span><br><span class="line">The type string[] indicates that the managed memory is a built-in array containing strings. </span><br><span class="line">unique_ptr转换为内置数组</span><br><span class="line">您还可以使用unique_ptr来管理动态分配的内置数组。</span><br><span class="line">例如，考虑这个语句</span><br><span class="line">unque_ptr &lt; string[] &gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> string[<span class="number">10</span>]);</span><br><span class="line">它动态地分配一个由ptr管理的包含<span class="number">10</span>个字符串的数组。</span><br><span class="line">string[]类型表示托管内存是包含字符串的内置数组。</span><br><span class="line"></span><br><span class="line">unique_ptr to a Built-In Array</span><br><span class="line">You can also use a unique_ptr to manage a dynamically allocated built-in array. </span><br><span class="line">For example, <span class="function">consider the statement</span></span><br><span class="line"><span class="function">unique_ptr&lt; string[] &gt; <span class="title">ptr</span><span class="params">( <span class="keyword">new</span> string[ <span class="number">10</span> ] )</span></span>; </span><br><span class="line">which dynamically allocates an array of <span class="number">10</span> strings managed by ptr. </span><br><span class="line">The type string[] indicates that the managed memory is a built-in array containing strings. </span><br><span class="line">unique_ptr转换为内置数组</span><br><span class="line">您还可以使用unique_ptr来管理动态分配的内置数组。</span><br><span class="line">例如，考虑这个语句</span><br><span class="line">unque_ptr &lt; string[] &gt; <span class="built_in">ptr</span>(<span class="keyword">new</span> string[<span class="number">10</span>]);</span><br><span class="line">它动态地分配一个由ptr管理的包含<span class="number">10</span>个字符串的数组。</span><br><span class="line">string[]类型表示托管内存是包含字符串的内置数组。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Experience has shown that exceptions fall nicely into a number of categories.</span><br><span class="line">The C++ Standard Library includes a hierarchy of exception classes, some of which are shown in Fig. 17.10.</span><br><span class="line">As we first discussed in Section 17.2, this hierarchy is headed by base-class exception (defined in header file &lt;exception&gt;), which contains virtual function what that derived classes can override to issue appropriate error messages.</span><br><span class="line">经验表明，例外情况可以很好地分为几类。</span><br><span class="line">c++标准库包括异常类的层次结构，其中一些异常类如图17.10所示。</span><br><span class="line">正如我们在第17.2节中首先讨论的那样，这个层次结构以基类异常(在头文件&lt;exception&gt;中定义)为首，它包含虚函数，派生类可以覆盖该虚函数以发出适当的错误消息。</span><br></pre></td></tr></table></figure>
<figure>
<img
src="C:\Users\22635\AppData\Roaming\Typora\typora-user-images\image-20240608191200111.png"
alt="image-20240608191200111" />
<figcaption aria-hidden="true">image-20240608191200111</figcaption>
</figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Immediate derived classes of base-<span class="function"><span class="keyword">class</span> exception include runtime_error <span class="keyword">and</span> <span class="title">logic_error</span> <span class="params">(both defined in header &lt;stdexcept&gt;)</span>, each of which has several derived classes.</span></span><br><span class="line"><span class="function">Also derived from exception are the exceptions thrown by C++ operators—<span class="keyword">for</span> example, bad_alloc is thrown by <span class="title">new</span> <span class="params">(Section <span class="number">17.8</span>)</span>, bad_cast is thrown by <span class="title">dynamic_cast</span> <span class="params">(Chapter <span class="number">12</span>)</span> <span class="keyword">and</span> bad_typeid is thrown by <span class="title">typeid</span> <span class="params">(Chapter <span class="number">12</span>)</span>.</span></span><br><span class="line"><span class="function">基类异常的直接派生类包括runtime_error和<span class="title">logic_error</span><span class="params">(两者都定义在头文件&lt;stdexcept&gt;中)</span>，它们每个都有几个派生类。</span></span><br><span class="line"><span class="function">c++操作符抛出的异常也派生自exception——例如，<span class="keyword">new</span>抛出<span class="title">bad_alloc</span><span class="params">(第<span class="number">17.8</span>节)</span>，<span class="keyword">dynamic_cast</span>抛出<span class="title">bad_cast</span><span class="params">(第<span class="number">12</span>章)</span>，<span class="keyword">typeid</span>抛出<span class="title">bad_typeid</span><span class="params">(第<span class="number">12</span>章)</span>。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C++ 中，<code>std::bad_typeid</code> 是一个异常类，它在使用
<code>typeid</code> 运算符时出现问题时被抛出。特别地，当使用
<code>typeid</code> 运算符对一个空指针进行操作时，会抛出
<code>std::bad_typeid</code> 异常。</p>
<h3 id="typeid-运算符"><code>typeid</code> 运算符</h3>
<p><code>typeid</code> 运算符用于获取对象的类型信息，它返回一个
<code>std::type_info</code>
对象，该对象包含了类型的信息。通常情况下，<code>typeid</code>
运算符可以用来获取变量或对象的类型信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="keyword">new</span> Derived;</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;Type of pbase: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> <span class="keyword">delete</span> pbase;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stdbad_typeid-异常"><code>std::bad_typeid</code> 异常</h3>
<p>当 <code>typeid</code> 运算符对一个空指针进行操作时，就会抛出
<code>std::bad_typeid</code> 异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Type of pbase: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>pbase</code> 是一个空指针，当对
<code>*pbase</code> 使用 <code>typeid</code> 运算符时，会抛出
<code>std::bad_typeid</code> 异常。</p>
<h3 id="捕获-stdbad_typeid-异常">捕获 <code>std::bad_typeid</code>
异常</h3>
<p>当你在程序中使用 <code>typeid</code>
运算符时，应当考虑到可能会出现的空指针问题，并捕获
<code>std::bad_typeid</code> 异常以避免程序崩溃：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printType</span><span class="params">(Base* pbase)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     std::cout &lt;&lt; <span class="string">&quot;Type: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*pbase).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_typeid&amp; e) &#123;</span><br><span class="line">     std::cerr &lt;&lt; <span class="string">&quot;Caught std::bad_typeid: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> Base* pbase = <span class="literal">nullptr</span>;</span><br><span class="line"> <span class="built_in">printType</span>(pbase);</span><br><span class="line"></span><br><span class="line"> pbase = <span class="keyword">new</span> Derived;</span><br><span class="line"> <span class="built_in">printType</span>(pbase);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">delete</span> pbase;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，函数 <code>printType</code>
尝试打印对象的类型信息。如果指针为空，会捕获
<code>std::bad_typeid</code> 异常，并输出相应的错误信息。</p>
<h3 id="总结-3">总结</h3>
<ul>
<li><code>std::bad_typeid</code> 是在使用 <code>typeid</code>
运算符对空指针操作时抛出的异常。</li>
<li>使用 <code>typeid</code>
运算符时，特别是对指针解引用进行类型查询时，应当考虑并处理可能出现的空指针情况。</li>
<li>捕获 <code>std::bad_typeid</code>
异常可以防止程序因空指针操作而崩溃，并提供适当的错误处理机制。</li>
</ul>
<p>通过理解和正确处理 <code>std::bad_typeid</code>
异常，可以提高程序的健壮性，确保在类型查询操作中能够有效处理空指针情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class logic_error is the base <span class="keyword">class</span> <span class="title class_">of</span> several standard exception classes that indicate errors in program logic.</span><br><span class="line">For example, <span class="keyword">class</span> <span class="title class_">invalid_argument</span> indicates that a function received an invalid argument.</span><br><span class="line">Proper coding can, of course, prevent invalid arguments from reaching a function. </span><br><span class="line">Class length_error indicates that a length larger than the maximum size allowed <span class="keyword">for</span> the object being manipulated was used <span class="keyword">for</span> that object.</span><br><span class="line">Class out_of_range indicates that a value, such as a subscript into an array, exceeded its allowed range of values.</span><br><span class="line"></span><br><span class="line">类logic_error是几个标准异常类的基类，用于指示程序逻辑中的错误。</span><br><span class="line">例如，invalid_argument类表示函数收到了无效参数。</span><br><span class="line">当然，正确的编码可以防止无效参数到达函数。</span><br><span class="line">类length_error表示该对象使用的长度大于被操作对象所允许的最大长度。</span><br><span class="line">类out_of_range表示一个值(例如数组的下标)超出了其允许的值范围。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Class runtime_error, which we used briefly in Section <span class="number">17.4</span>, is the base <span class="keyword">class</span> <span class="title class_">of</span> several other standard exception classes that indicate execution-time errors.</span><br><span class="line">For example, <span class="function"><span class="keyword">class</span> overflow_error describes an arithmetic overflow <span class="title">error</span> <span class="params">(i.e., the result of an arithmetic operation is larger than the largest number that can be stored in the computer)</span> <span class="keyword">and</span> <span class="keyword">class</span> underflow_error describes an arithmetic underflow <span class="title">error</span> <span class="params">(i.e., the result of an arithmetic operation is smaller than the smallest number that can be stored in the computer)</span>.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">类<span class="title">runtime_error</span><span class="params">(我们在第<span class="number">17.4</span>节中简要使用过)</span>是其他几个指示执行时错误的标准异常类的基类。</span></span><br><span class="line"><span class="function">例如，类overflow_error描述了一个算术溢出错误<span class="params">(即，算术运算的结果大于计算机可存储的最大数字)</span>，类underflow_error描述了一个算术下溢错误<span class="params">(即，算术运算的结果小于计算机可存储的最小数字)</span>。</span></span><br></pre></td></tr></table></figure>
<p>异常类可以不继承自exception类，所以当捕获类型为exception时，不能保证能够程序捕获到所有可能的异常。</p>
<p>为了捕获一个try语句中的所有异常，可以使用catch(...)语句，但是无法确定类型，也无法获得参数名，因此无法引用。</p>
<p>catch(...)语句可以用来不依赖于异常类型的恢复操作（eg：释放公有资源），异常可以被重新抛出，让其他特定的catch处理器捕获处理。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/">http://example.com/2024/06/09/CPP复习 第十七章/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" title="CPP复习 第十四章"><img class="cover" src="/img/94421005_p0_master1200.jpg" data-original="https://img2.imgtp.com/2024/03/15/d8mxCaRD.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CPP复习 第十四章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cpp%E5%A4%8D%E4%B9%A0-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">Cpp复习 第十七章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-exception-handling"><span class="toc-number">1.0.1.</span> <span class="toc-text">C++ 中的异常处理 (Exception
Handling)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.0.2.</span> <span class="toc-text">异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B1%95%E5%BC%80-stack-unwinding"><span class="toc-number">1.0.3.</span> <span class="toc-text">栈展开 (Stack Unwinding)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%A8%8B%E5%BA%8F%E7%BB%88%E6%AD%A2"><span class="toc-number">1.0.5.</span> <span class="toc-text">为什么在析构函数中抛出异常会导致程序终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%AE%89%E5%85%A8%E6%94%BB%E5%87%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.6.</span> <span class="toc-text">与安全攻击的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.7.</span> <span class="toc-text">如何防止析构函数抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">1.0.8.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raii-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.9.</span> <span class="toc-text">RAII 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.10.</span> <span class="toc-text">示例：文件资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">1.0.11.</span> <span class="toc-text">使用智能指针管理动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-stdunique_ptr"><span class="toc-number">1.0.11.1.</span> <span class="toc-text">示例：使用
std::unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">1.0.12.</span> <span class="toc-text">其他资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8-stdlock_guard-%E7%AE%A1%E7%90%86%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">示例：使用
std::lock_guard 管理互斥锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">1.0.13.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set_new_handler-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.0.14.</span> <span class="toc-text">set_new_handler 的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.15.</span> <span class="toc-text">处理函数的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%B0%9D%E8%AF%95%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98"><span class="toc-number">1.0.16.</span> <span class="toc-text">示例：尝试释放内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.0.17.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeid-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.18.</span> <span class="toc-text">typeid 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdbad_typeid-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.19.</span> <span class="toc-text">std::bad_typeid 异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7-stdbad_typeid-%E5%BC%82%E5%B8%B8"><span class="toc-number">1.0.20.</span> <span class="toc-text">捕获 std::bad_typeid
异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.0.21.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="2024/05/04/刷题计划/">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="2024/05/04/刷题计划/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="2024/04/03/A Way to Practice Competitive Programming/">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="2024/04/03/A Way to Practice Competitive Programming/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/Plan/">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="2024/04/02/Plan/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/诸子百家/">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="2024/04/02/诸子百家/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>