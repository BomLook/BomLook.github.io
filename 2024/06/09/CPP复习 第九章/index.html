<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CPP复习 第九章 | Heavenhold</title><meta name="author" content="马洛"><meta name="copyright" content="马洛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content=""><meta name="description" content="建议别看，就是史 # CPP复习 第九章 This chapter takes a deeper look at classes.Coverage includes:◦The example also demonstrates using an *include guard* in headers to prevent header code from being included in the">
<meta property="og:type" content="article">
<meta property="og:title" content="CPP复习 第九章">
<meta property="og:url" content="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/index.html">
<meta property="og:site_name" content="Heavenhold">
<meta property="og:description" content="建议别看，就是史 # CPP复习 第九章 This chapter takes a deeper look at classes.Coverage includes:◦The example also demonstrates using an *include guard* in headers to prevent header code from being included in the">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.horosama.com/api/image_all/anime/1080p/pc/f0F03b5c42d43DDd976E63d49804062c.jpg">
<meta property="article:published_time" content="2024-06-09T11:12:00.000Z">
<meta property="article:modified_time" content="2024-06-09T11:14:23.617Z">
<meta property="article:author" content="马洛">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.horosama.com/api/image_all/anime/1080p/pc/f0F03b5c42d43DDd976E63d49804062c.jpg"><link rel="shortcut icon" href="https://img2.imgtp.com/2024/03/12/9tLeWKLK.png"><link rel="canonical" href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CPP复习 第九章',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2024-06-09 19:14:23'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 7 || hour >= 19
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/94421005_p0_master1200.jpg" data-original="https://img2.imgtp.com/2024/03/10/WBTP13da.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://www.horosama.com/api/image_all/anime/1080p/pc/f0F03b5c42d43DDd976E63d49804062c.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Heavenhold"><span class="site-name">Heavenhold</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CPP复习 第九章</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-09T11:12:00.000Z" title="发表于 2024-06-09 19:12:00">2024-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-09T11:14:23.617Z" title="更新于 2024-06-09 19:14:23">2024-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>41分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CPP复习 第九章"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>建议别看，就是史 # CPP复习 第九章</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This chapter takes a deeper look at classes.</span><br><span class="line"></span><br><span class="line">Coverage includes:</span><br><span class="line"></span><br><span class="line">◦The example also demonstrates using an *include guard* in headers to prevent header code from being included in the same source code file more than once. </span><br><span class="line"></span><br><span class="line">◦We demonstrate how client code can access a class’s public members via the name of an object, a reference to an object or a pointer to an object. </span><br><span class="line"></span><br><span class="line">◦We discuss access functions that can read or write an object’s data members.</span><br><span class="line"></span><br><span class="line">◦We also demonstrate utility functions—private member functions that support the operation of the class’s public member functions.</span><br><span class="line"></span><br><span class="line">本章将深入探讨类。</span><br><span class="line">覆盖范围包括:</span><br><span class="line">该示例还演示了在头文件中使用include保护来防止头代码多次包含在同一个源代码文件中。</span><br><span class="line">我们将演示客户端代码如何通过对象名、对象引用或对象指针来访问类的公共成员。</span><br><span class="line">我们将讨论可以读写对象数据成员的访问函数。</span><br><span class="line">我们还演示了实用函数——支持类的公共成员函数操作的私有成员函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coverage includes (cont.):</span><br><span class="line">How default arguments can be used in constructors.</span><br><span class="line">Destructors that perform “termination housekeeping” on objects before they’re destroyed.</span><br><span class="line">The order in which constructors and destructors are called.</span><br><span class="line">We show that returning a reference or pointer to private data breaks the encapsulation of a class, allowing client code to directly access an object’s data.</span><br><span class="line">We use default memberwise assignment to assign an object of a class to another object of the same class.</span><br><span class="line">承保范围包括(续):</span><br><span class="line">如何在构造函数中使用默认实参。</span><br><span class="line">在对象被销毁之前对其执行“终止管理”的析构函数。</span><br><span class="line">调用构造函数和析构函数的顺序。</span><br><span class="line">我们展示了返回私有数据的引用或指针打破了类的封装，允许客户端代码直接访问对象的数据。</span><br><span class="line">使用默认的成员赋值将类的一个对象赋值给同一类的另一个对象。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Coverage includes (cont.):</span><br><span class="line">const objects and const member functions to prevent modifications of objects and enforce the principle of least privilege. </span><br><span class="line">Composition—a form of reuse in which a class can have objects of other classes as members. </span><br><span class="line">Friendship to specify that a nonmember function can also access a class’s non-public members—a technique that’s often used in operator overloading for performance reasons. </span><br><span class="line">this pointer, which is an implicit argument in all calls to a class’s non-static member functions, allowing them to access the correct object’s data members and non-static member functions. </span><br><span class="line">承保范围包括(续):</span><br><span class="line">Const对象和Const成员函数，以防止对对象的修改并执行最小权限原则。</span><br><span class="line">组合——一种重用形式，其中一个类可以拥有其他类的对象作为成员。</span><br><span class="line">指定非成员函数也可以访问类的非公共成员——出于性能原因，在操作符重载中经常使用这种技术。</span><br><span class="line">这个指针是所有调用类的非静态成员函数的隐式参数，允许它们访问正确对象的数据成员和非静态成员函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Prevents the code between #ifndef and #endif from being included if the name TIME_H has been defined.</span><br><span class="line">If the header has not been included previously in a file, the name TIME_H is defined by the #define directive and the header file statements are included.</span><br><span class="line">If the header has been included previously, TIME_H is defined already and the header file is not included again.</span><br><span class="line">如果已经定义了名称TIME_H，则防止包含#ifndef和#endif之间的代码。</span><br><span class="line">如果头文件之前没有包含在文件中，则名称TIME_H由#define指令定义，并包含头文件语句。</span><br><span class="line">如果头文件之前已经包含，TIME_H已经被定义，并且头文件不再被包含。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Time Class Member Functions</span><br><span class="line">In Fig. 9.2, the Time constructor (lines 11–14) initializes the data members to 0—the universal-time equivalent of 12 AM. </span><br><span class="line">Invalid values cannot be stored in the data members of a Time object, because the constructor is called when the Time object is created, and all subsequent attempts by a client to modify the data members are scrutinized by function setTime (discussed shortly). </span><br><span class="line">You can define overloaded constructors for a class.</span><br><span class="line"></span><br><span class="line">Time类成员函数</span><br><span class="line">在图9.2中，Time构造函数(第11-14行)将数据成员初始化为0——相当于12 AM的通用时间。</span><br><span class="line">无效值不能存储在Time对象的数据成员中，因为在创建Time对象时调用构造函数，并且客户机修改数据成员的所有后续尝试都由setTime函数仔细检查(稍后讨论)。</span><br><span class="line">可以为类定义重载构造函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before C++11, only static const int data members (which you saw in Chapter 7) could be initialized where they were declared in the class body.</span><br><span class="line">For this reason, data members typically should be initialized by the class’s constructor as there is no default initialization for fundamental-type data members. </span><br><span class="line">As of C++11, you can now use an in-class initializer to initialize any data member where it’s declared in the class definition. </span><br><span class="line"></span><br><span class="line">在c++ 11之前，只有静态const int数据成员(你在第7章看到过)可以在类体中声明的地方初始化。</span><br><span class="line">由于这个原因，数据成员通常应该由类的构造函数初始化，因为基本类型数据成员没有默认初始化。</span><br><span class="line">从c++ 11开始，您现在可以使用类内初始化器来初始化在类定义中声明的任何数据成员。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Parameterized stream manipulator setfill specifies the fill character that is displayed when an integer is output in a field wider than the number of digits in the value.</span><br><span class="line">The fill characters appear to the left of the digits in the number, because the number is right aligned by default—for left aligned values, the fill characters would appear to the right.</span><br><span class="line">If the number being output fills the specified field, the fill character will not be displayed.</span><br><span class="line">Once the fill character is specified with setfill, it applies for all subsequent values that are displayed in fields wider than the value being displayed.</span><br><span class="line">参数化流操纵符setfill指定当在大于值中位数的字段中输出整数时显示的填充字符。</span><br><span class="line">填充字符出现在数字中数字的左边，因为默认情况下数字是右对齐的——对于左对齐的值，填充字符将出现在右边。</span><br><span class="line">如果正在输出的数字填充了指定的字段，则不显示填充字符。</span><br><span class="line">一旦用setfill指定了填充字符，它就应用于显示在比所显示的值更宽的字段中的所有后续值。</span><br><span class="line">即setfill是黏性设置 注意setw不是黏性设置</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Defining Member Functions Outside the Class Definition; Class Scope</span><br><span class="line">Even though a member function declared in a class definition may be defined outside that class definition, that member function is still within that class’s scope.</span><br><span class="line">If a member function is defined in the class’s body, the compiler attempts to inline calls to the member function.</span><br><span class="line">在类定义之外定义成员函数;类作用域</span><br><span class="line">即使在类定义中声明的成员函数可以在该类定义之外定义，该成员函数仍然在该类的作用域中。</span><br><span class="line">如果在类的主体中定义了成员函数，则编译器会尝试内联调用该成员函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using Class Time</span><br><span class="line">Once class Time has been defined, it can be used as a type in object, array, pointer and reference declarations as follows:</span><br><span class="line">Time sunset; // object of type Time</span><br><span class="line">array&lt; Time, 5 &gt; arrayOfTimes; // array of 5 Time objects</span><br><span class="line">Time &amp;dinnerTime = sunset; // reference to a Time object</span><br><span class="line">Time *timePtr = &amp;dinnerTime; // pointer to a Time object</span><br><span class="line">Figure 9.3 uses class Time. </span><br><span class="line">利用课堂时间</span><br><span class="line">一旦定义了Time类，它就可以在对象、数组、指针和引用声明中作为类型使用，如下所示:</span><br><span class="line">日落;//时间类型的对象</span><br><span class="line">array&lt; Time, 5 &gt; arrayOfTimes;// 5个Time对象的数组</span><br><span class="line">时间&amp;晚餐时间=日落;//对Time对象的引用</span><br><span class="line">Time *timePtr = &amp;dinnerTime;//指向Time对象的指针</span><br><span class="line">图9.3使用类Time。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object Size</span><br><span class="line">People new to object-oriented programming often suppose that objects must be quite large because they contain data members and member functions.</span><br><span class="line">Logically, this is true—you may think of objects as containing data and functions (and our discussion has certainly encouraged this view); physically, however, this is not true.</span><br><span class="line">对象的大小</span><br><span class="line">刚接触面向对象编程的人通常认为对象一定很大，因为它们包含数据成员和成员函数。</span><br><span class="line">从逻辑上讲，这是正确的——您可能认为对象包含数据和函数(我们的讨论肯定鼓励了这种观点);然而，从物理上讲，这是不正确的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A class’s data members and member functions belong to that class’s scope.</span><br><span class="line">Nonmember functions are defined at global namespace scope, by default.</span><br><span class="line">Within a class’s scope, class members are immediately accessible by all of that class’s member functions and can be referenced by name.</span><br><span class="line">Outside a class’s scope, public class members are referenced through one of the handles on an object—an object name, a reference to an object or a pointer to an object.</span><br><span class="line">类的数据成员和成员函数属于该类的作用域。</span><br><span class="line">默认情况下，非成员函数在全局命名空间范围内定义。</span><br><span class="line">在类的作用域中，类的所有成员函数都可以立即访问类成员，并且可以通过名称引用类成员。</span><br><span class="line">在类的作用域之外，通过对象的句柄之一(对象名称、对象引用或对象指针)引用公共类成员。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class Scope and Block Scope</span><br><span class="line">If a member function defines a variable with the same name as a variable with class scope, the class-scope variable is hidden in the function by the block-scope variable.</span><br><span class="line">Such a hidden variable can be accessed by preceding the variable name with the class name followed by the scope resolution operator (::).</span><br><span class="line">类作用域和块作用域</span><br><span class="line">如果成员函数定义了与具有类作用域的变量同名的变量，则类作用域变量被块作用域变量隐藏在函数中。</span><br><span class="line">可以通过在变量名前面加上类名和作用域解析操作符(::)来访问这样的隐藏变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Dot (.) and Arrow (-&gt;) Member Selection Operators</span><br><span class="line">The dot member selection operator (.) is preceded by an object’s name or with a reference to an object to access the object’s members.</span><br><span class="line">The arrow member selection operator (-&gt;) is preceded by a pointer to an object to access the object’s members.</span><br><span class="line">点(.)和箭头(-&gt;)成员选择操作符</span><br><span class="line">点成员选择运算符(.)前面是对象的名称或对象的引用，以访问对象的成员。</span><br><span class="line">箭头成员选择操作符(-&gt;)前面有一个指向对象的指针，用于访问对象的成员。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accessing public Class Members Through Objects, References and Pointers</span><br><span class="line">Consider an Account class that has a public setBalance member function. Given the following declarations:</span><br><span class="line"></span><br><span class="line">Account account; // an Account object</span><br><span class="line">// accountRef refers to an Account object</span><br><span class="line">Account &amp;accountRef = account; </span><br><span class="line">// accountPtr points to an Account object</span><br><span class="line">Account *accountPtr = &amp;account; </span><br><span class="line"></span><br><span class="line">You can invoke member function setBalance using the dot (.) and arrow (-&gt;) member selection operators as follows:</span><br><span class="line"></span><br><span class="line">// call setBalance via the Account object</span><br><span class="line">account.setBalance( 123.45 ); </span><br><span class="line">// call setBalance via a reference to the Account object</span><br><span class="line">accountRef.setBalance( 123.45 );</span><br><span class="line">// call setBalance via a pointer to the Account object</span><br><span class="line">accountPtr-&gt;setBalance( 123.45 );</span><br><span class="line">可以使用点(.)和箭头(-&gt;)成员选择操作符调用成员函数setBalance，如下所示:</span><br><span class="line"></span><br><span class="line">//通过Account对象调用setBalance</span><br><span class="line">帐户。setBalance(123.45);</span><br><span class="line">//通过Account对象的引用调用setBalance</span><br><span class="line">accountRef。setBalance(123.45);</span><br><span class="line">//通过指向Account对象的指针调用setBalance</span><br><span class="line">accountPtr-&gt;setBalance(123.45);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access Functions</span><br><span class="line">Access functions can read or display data.</span><br><span class="line">A common use for access functions is to test the truth or falsity of conditions—such functions are often called predicate functions.</span><br><span class="line">Utility Functions</span><br><span class="line">A utility function (also called a helper function) is a private member function that supports the operation of the class’s other member functions.</span><br><span class="line">访问函数</span><br><span class="line">访问函数可以读取或显示数据。</span><br><span class="line">访问函数的一个常见用途是测试条件的真假——这类函数通常称为谓词函数。</span><br><span class="line">效用函数</span><br><span class="line">实用函数(也称为辅助函数)是一个私有成员函数，它支持类的其他成员函数的操作</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The program of Figs. 9.4–9.6 enhances class Time to demonstrate how arguments are implicitly passed to a constructor. </span><br><span class="line">The constructor defined in Fig. 9.2 initialized hour, minute and second to 0 (i.e., midnight in universal time).</span><br><span class="line">Like other functions, constructors can specify default arguments.</span><br><span class="line">图9.4-9.6的程序增强了类Time，以演示参数如何隐式传递给构造函数。</span><br><span class="line">图9.2中定义的构造函数将小时、分和秒初始化为0(即世界时的午夜)。</span><br><span class="line">与其他函数一样，构造函数可以指定默认实参。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Notes Regarding Class Time’s Set and Get Functions and Constructor</span><br><span class="line">Time’s set and get functions are called throughout the class’s body.</span><br><span class="line">In each case, these functions could have accessed the class’s private data directly.</span><br><span class="line">Consider changing the representation of the time from three int values (requiring 12 bytes of memory on systems with four-byte ints) to a single int value representing the total number of seconds that have elapsed since midnight (requiring only four bytes of memory).</span><br><span class="line">If we made such a change, only the bodies of the functions that access the private data directly would need to change.</span><br><span class="line">No need to modify the bodies of the other functions.</span><br><span class="line">关于类时间的Set和Get函数和构造函数的注意事项</span><br><span class="line">Time的set和get函数在整个类的主体中被调用。</span><br><span class="line">在每种情况下，这些函数都可以直接访问类的私有数据。</span><br><span class="line">考虑将时间的表示形式从三个int值(在具有4字节int值的系统上需要12字节的内存)更改为单个int值，表示从午夜开始经过的总秒数(只需要4字节的内存)。</span><br><span class="line">如果进行这样的更改，则只需要更改直接访问私有数据的函数体。</span><br><span class="line">不需要修改其他函数体。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Designing the class in this manner reduces the likelihood of programming errors when altering the class’s implementation.</span><br><span class="line">Duplicating statements in multiple functions or constructors makes changing the class’s internal data representation more difficult.</span><br><span class="line">以这种方式设计类可以减少在更改类的实现时出现编程错误的可能性。</span><br><span class="line">在多个函数或构造函数中重复语句使得更改类的内部数据表示更加困难。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++11: Using List Initializers to Call Constructors </span><br><span class="line">C++11 now provides a uniform initialization syntax called list initializers that can be used to initialize any variable. Lines 11–13 of Fig. 9.6 can be written using list initializers as follows:</span><br><span class="line">Time t2&#123; 2 &#125;; // hour specified; minute and second defaulted     </span><br><span class="line">Time t3&#123; 21, 34 &#125;; // hour and minute specified; second defaulted</span><br><span class="line">Time t4&#123; 12, 25, 42 &#125;; // hour, minute and second specified </span><br><span class="line">or</span><br><span class="line">Time t2 = &#123; 2 &#125;; // hour specified; minute and second defaulted     </span><br><span class="line">Time t3 = &#123; 21, 34 &#125;; // hour and minute specified; second defaulted</span><br><span class="line">Time t4 = &#123; 12, 25, 42 &#125;; // hour, minute and second specified </span><br><span class="line">The form without the = is preferred.</span><br><span class="line">c++ 11:使用列表初始化式调用构造函数</span><br><span class="line">c++ 11现在提供了一种统一的初始化语法，称为列表初始化器，可用于初始化任何变量。图9.6中的第11-13行可以使用列表初始化式编写如下:</span><br><span class="line">时间t2&#123;2&#125;;//指定小时;分和秒默认</span><br><span class="line">时间t3&#123;21,34&#125;;//指定小时和分钟;第二个违约</span><br><span class="line">时间t4&#123;12,25,42&#125;;//指定时、分、秒</span><br><span class="line">或</span><br><span class="line">时间t2 = &#123;2&#125;;//指定小时;分和秒默认</span><br><span class="line">时间t3 = &#123;21,34&#125;;//指定小时和分钟;第二个违约</span><br><span class="line">时间t4 = &#123;12,25,42&#125;;//指定时、分、秒</span><br><span class="line">不带=的形式是首选的。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++11: Overloaded Constructors and Delegating Constructors </span><br><span class="line">A class’s constructors and member functions can also be overloaded. </span><br><span class="line">Overloaded constructors typically allow objects to be initialized with different types and/or numbers of arguments. </span><br><span class="line">To overload a constructor, provide in the class definition a prototype for each version of the constructor, and provide a separate constructor definition for each overloaded version. </span><br><span class="line">This also applies to the class’s member functions. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c++ 11:重载构造函数和委托构造函数</span><br><span class="line">类的构造函数和成员函数也可以被重载。</span><br><span class="line">重载构造函数通常允许使用不同类型和/或数量的参数初始化对象。</span><br><span class="line">要重载构造函数，请在类定义中为每个版本的构造函数提供原型，并为每个重载版本提供单独的构造函数定义。</span><br><span class="line">这也适用于类的成员函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In Figs. 9.4–9.6, the Time constructor with three parameters had a default argument for each parameter. We could have defined that constructor instead as four overloaded constructors with the following prototypes:</span><br><span class="line">Time(); // default hour, minute and second to 0</span><br><span class="line">Time( int ); // initialize hour; default minute and second to 0</span><br><span class="line">Time( int, int); // initialize hour and minute; default second to 0</span><br><span class="line">Time( int, int, int ); // initialize hour, minute and second</span><br><span class="line">C++11 now allows constructors to call other constructors in the same class. </span><br><span class="line">The calling constructor is known as a delegating constructor—it delegates its work to another constructor. </span><br><span class="line"></span><br><span class="line">在图9.4-9.6中，带有三个形参的Time构造函数对每个形参都有一个默认实参。我们可以将该构造函数定义为四个重载构造函数，并使用以下原型:</span><br><span class="line">时间();//默认时、分、秒为0</span><br><span class="line">Time(int);//初始化小时;默认分秒为0</span><br><span class="line">Time(int, int);//初始化小时和分钟;默认秒为0</span><br><span class="line">Time(int, int, int);//初始化小时、分和秒</span><br><span class="line">c++ 11现在允许构造函数调用同一类中的其他构造函数。</span><br><span class="line">调用构造函数称为委托构造函数——它将自己的工作委托给另一个构造函数。</span><br><span class="line"></span><br><span class="line">The first three of the four Time constructors declared on the previous slide can delegate work to one with three int arguments, passing 0 as the default value for the extra parameters. </span><br><span class="line">Use a member initializer with the name of the class as follows:</span><br><span class="line">Time::Time()</span><br><span class="line">   Time( 0, 0, 0 ) //delegate to Time( int, int, int )</span><br><span class="line">&#123;</span><br><span class="line">&#125; // end constructor with no arguments</span><br><span class="line"></span><br><span class="line">Time::Time( int hour )</span><br><span class="line">   Time( hour, 0, 0 ) //delegate to Time( int, int, int )   </span><br><span class="line">&#123;</span><br><span class="line">&#125; // end constructor with one argument</span><br><span class="line">Time::Time( int hour, int minute )</span><br><span class="line">   Time( hour, minute, 0 ) //delegate to Time( int, int, int )</span><br><span class="line">&#123;</span><br><span class="line">&#125; // end constructor with two arguments</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The name of the destructor for a class is the tilde character (~) followed by the class name.</span><br><span class="line">Called implicitly when an object is destroyed.</span><br><span class="line">The destructor itself does not actually release the object’s memory—it performs termination housekeeping before the object’s memory is reclaimed, so the memory may be reused to hold new objects.</span><br><span class="line">Receives no parameters and returns no value.</span><br><span class="line">May not specify a return type—not even void.</span><br><span class="line">A class has one destructor. </span><br><span class="line">A destructor must be public.</span><br><span class="line">If you do not explicitly define a destructor, the compiler defines an “empty” destructor.</span><br><span class="line">类的析构函数的名称是类名后面的波浪字符(~)。</span><br><span class="line">当对象被销毁时隐式调用。</span><br><span class="line">析构函数本身实际上并不释放对象的内存——它在回收对象的内存之前执行终止管理，因此可以重用内存来保存新对象。</span><br><span class="line">不接收参数也不返回值。</span><br><span class="line">不能指定返回类型——甚至不能指定void。</span><br><span class="line">一个类有一个析构函数。</span><br><span class="line">析构函数必须是公共的。</span><br><span class="line">如果没有显式定义析构函数，编译器将定义一个“空”析构函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructors and destructors are called implicitly.</span><br><span class="line">The order in which these function calls occur depends on the order in which execution enters and leaves the scopes where the objects are instantiated.</span><br><span class="line">Generally, destructor calls are made in the reverse order of the corresponding constructor calls</span><br><span class="line">The storage classes of objects can alter the order in which destructors are called.</span><br><span class="line">隐式调用构造函数和析构函数。</span><br><span class="line">这些函数调用发生的顺序取决于执行进入和离开对象实例化的作用域的顺序。</span><br><span class="line">通常，析构函数调用的顺序与相应的构造函数调用的顺序相反</span><br><span class="line">对象的存储类可以改变调用析构函数的顺序。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructors and Destructors for Objects in Global Scope</span><br><span class="line">Constructors are called for objects defined in global scope  (also called global namespace scope) before any other function (including main) in that program begins execution (although the order of execution of global object constructors between files is not guaranteed).</span><br><span class="line">The corresponding destructors are called when main terminates.</span><br><span class="line">Function exit forces a program to terminate immediately and does not execute the destructors of local objects.</span><br><span class="line">Function abort performs similarly to function exit but forces the program to terminate immediately, without allowing the destructors of any objects to be called.</span><br><span class="line"></span><br><span class="line">全局作用域中对象的构造函数和析构函数</span><br><span class="line">在程序中的任何其他函数(包括main)开始执行之前，在全局作用域(也称为全局命名空间作用域)中定义的对象调用构造函数(尽管不能保证文件之间全局对象构造函数的执行顺序)。</span><br><span class="line">当main终止时调用相应的析构函数。</span><br><span class="line">函数exit强制程序立即终止，不执行局部对象的析构函数。</span><br><span class="line">函数abort的执行类似于函数exit，但强制程序立即终止，不允许调用任何对象的析构函数。???</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Constructors and Destructors for Local Objects</span><br><span class="line">Constructors and destructors for local objects are called each time execution enters and leaves the scope of the object.</span><br><span class="line">Destructors are not called for local objects if the program terminates with a call to function exit or function abort.</span><br><span class="line">局部对象的构造函数和析构函数</span><br><span class="line">每次执行进入和离开对象的作用域时，都会调用局部对象的构造函数和析构函数。</span><br><span class="line">如果程序因调用函数exit或函数abort而终止，则不会调用局部对象的析构函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Demonstrating When Constructors and Destructors Are Called</span><br><span class="line">The program of Figs. 9.7–9.9 demonstrates the order in which constructors and destructors are called for objects of class CreateAndDestroy (Fig. 9.7 and Fig. 9.8) of various storage classes in several scopes. </span><br><span class="line">演示何时调用构造函数和析构函数</span><br><span class="line">图9.7 - 9.9的程序演示了在几个作用域内对各种存储类的CreateAndDestroy类(图9.7和图9.8)的对象调用构造函数和析构函数的顺序。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A reference to an object is an alias for the name of the object and, hence, may be used on the left side of an assignment statement.</span><br><span class="line">In this context, the reference makes a perfectly acceptable lvalue that can receive a value.</span><br><span class="line">Unfortunately a public member function of a class can return a reference to a private data member of that class.</span><br><span class="line">Such a reference return actually makes a call to that member function an alias for the private data member! </span><br><span class="line">The function call can be used in any way that the private data member can be used, including as an lvalue in an assignment statement</span><br><span class="line">The same problem would occur if a pointer to the private data were to be returned by the function.</span><br><span class="line">If a function returns a reference that’s declared const, the reference is a non-modifiable lvalue and cannot be used to modify the data.</span><br><span class="line">对对象的引用是该对象名称的别名，因此可以在赋值语句的左侧使用。</span><br><span class="line">在这个上下文中，引用创建了一个完全可以接受的左值，它可以接收值。</span><br><span class="line">不幸的是，类的公共成员函数可以返回对该类私有数据成员的引用。</span><br><span class="line">这样的引用返回实际上使对该成员函数的调用成为私有数据成员的别名!</span><br><span class="line">函数调用可以以私有数据成员的任何方式使用，包括作为赋值语句中的左值</span><br><span class="line">如果函数返回指向私有数据的指针，也会出现同样的问题。</span><br><span class="line">如果函数返回声明为const的引用，则该引用是不可修改的左值，不能用于修改数据。</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">The assignment <span class="title">operator</span> <span class="params">(=)</span> can be used to assign an object to another object of the same type.</span></span><br><span class="line"><span class="function">By <span class="keyword">default</span>, such assignment is performed by memberwise <span class="title">assignment</span> <span class="params">(also called copy assignment)</span>.</span></span><br><span class="line"><span class="function">Each data member of the object on the right of the assignment <span class="keyword">operator</span> is assigned individually to the same data member in the object on the left of the assignment <span class="keyword">operator</span>.</span></span><br><span class="line"><span class="function">[Caution: Memberwise assignment can cause serious problems when used with a class whose data members contain pointers to dynamically allocated memory;</span> we discuss these problems in Chapter <span class="number">10</span> <span class="keyword">and</span> show how to deal with them.] </span><br><span class="line">赋值操作符(=)可用于将一个对象赋值给同一类型的另一个对象。</span><br><span class="line">默认情况下，这种赋值是通过成员赋值(也称为拷贝赋值)执行的。</span><br><span class="line">赋值操作符右侧对象的每个数据成员分别赋值给赋值操作符左侧对象中的相同数据成员。</span><br><span class="line">注意:如果类的数据成员包含指向动态分配内存的指针，则按成员赋值可能会导致严重的问题;我们将在第<span class="number">10</span>章讨论这些问题，并说明如何处理它们。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Objects may be passed as function arguments and may be returned from functions.</span><br><span class="line">Such passing and returning is performed using pass-by-value by default—a copy of the object is passed or returned.</span><br><span class="line">C++ creates a new object and uses a copy constructor to copy the original object’s values into the new object.</span><br><span class="line">For each class, the compiler provides a default copy constructor that copies each member of the original object into the corresponding member of the new object.</span><br><span class="line">Copy constructors can cause serious problems when used with a class whose data members contain pointers to dynamically allocated memory.</span><br><span class="line">Chapter 10 discusses customized copy constructors.</span><br><span class="line">对象可以作为函数参数传递，也可以从函数返回。</span><br><span class="line">默认情况下，这种传递和返回是使用按值传递来执行的——传递或返回对象的副本。</span><br><span class="line">c++创建一个新对象，并使用复制构造函数将原始对象的值复制到新对象中。</span><br><span class="line">对于每个类，编译器提供默认的复制构造函数，将原始对象的每个成员复制到新对象的相应成员中。</span><br><span class="line">当将复制构造函数用于数据成员包含指向动态分配内存的指针的类时，可能会导致严重的问题。</span><br><span class="line">第10章讨论自定义复制构造函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++ disallows member function calls for const objects unless the member functions themselves are also declared const. </span><br><span class="line">This is true even for get member functions that do not modify the object. </span><br><span class="line">This is also a key reason that we’ve declared as const all member-functions that do not modify the objects on which they’re called. </span><br><span class="line">A member function is specified as const both in its prototype by inserting the keyword const after the function’s parameter list and, in the case of the function definition, before the left brace that begins the function body. </span><br><span class="line"></span><br><span class="line">c++不允许对const对象调用成员函数，除非成员函数本身也声明为const。</span><br><span class="line">即使对于不修改对象的get成员函数也是如此。</span><br><span class="line">这也是我们将所有成员函数声明为const的一个关键原因，这些成员函数不会修改调用它们的对象。</span><br><span class="line">成员函数在原型中被指定为const，方法是在函数的形参列表之后插入关键字const，在函数定义中，在函数体开始的左大括号之前插入关键字const。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A constructor must be allowed to modify an object so that the object can be initialized properly. </span><br><span class="line">A destructor must be able to perform its termination housekeeping chores before an object’s memory is reclaimed by the system. </span><br><span class="line">Attempting to declare a constructor or destructor const is a compilation error. </span><br><span class="line">The “constness” of a const object is enforced from the time the constructor completes initialization of the object until that object’s destructor is called.</span><br><span class="line">必须允许构造函数修改对象，以便正确初始化对象。</span><br><span class="line">析构函数必须能够在系统回收对象的内存之前执行其终止家务。</span><br><span class="line">试图声明构造函数或析构函数const是编译错误。</span><br><span class="line">从构造函数完成对象初始化到调用该对象的析构函数，const对象的“constness”被强制执行。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">An AlarmClock object needs to know when it’s supposed to sound its alarm, so why not include a Time object as a member of the AlarmClock class? </span><br><span class="line">Such a capability is called composition and is sometimes referred to as a has-a relationship—a class can have objects of other classes as members.</span><br><span class="line">The next program uses classes Date (Figs. 9.17–9.18) and Employee (Figs. 9.19–9.20) to demonstrate composition. </span><br><span class="line"></span><br><span class="line">一个AlarmClock对象需要知道它应该在什么时候发出警报，那么为什么不包括一个Time对象作为AlarmClock类的成员呢?</span><br><span class="line">这种能力称为组合，有时也称为has关系——一个类可以拥有其他类的对象作为成员。</span><br><span class="line">下一个程序使用Date类(图9.17-9.18)和Employee类(图9.19-9.20)来演示组合。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Date Class’s Default Copy Constructor</span><br><span class="line">As we mentioned in Section 9.9, the compiler provides each class with a default copy constructor that copies each data member of the constructor’s argument object into the corresponding member of the object being initialized. </span><br><span class="line">Chapter 10 discusses how you can define customized copy constructors. </span><br><span class="line">Date类的默认复制构造函数</span><br><span class="line">正如我们在第9.9节中提到的，编译器为每个类提供了一个默认的复制构造函数，它将构造函数实参对象的每个数据成员复制到被初始化对象的相应成员中。</span><br><span class="line">第10章讨论如何定义自定义复制构造函数</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Note: Line 12 of Fig. 9.21 causes two additional Date constructor calls that do not appear in the program’s output. When each of the Employee’s Date member objects is initialized in the Employee constructor’s member-initializer list (Fig. 9.20, lines 14–15), the default copy constructor for class Date is called. Since this constructor is defined implicitly by the compiler, it does not contain any output statements to demonstrate when it’s called.] </span><br><span class="line">注意:图9.21的第12行会导致两个额外的Date构造函数调用，它们不会出现在程序的输出中。当Employee的每个Date成员对象在Employee构造函数的成员初始化列表中初始化时(图9.20，第14-15行)，将调用Date类的默认复制构造函数。因为这个构造函数是由编译器隐式定义的，所以它不包含任何输出语句来演示何时调用它。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">What Happens When You Do Not Use the Member Initializer List?</span><br><span class="line">If a member object is not initialized through a member initializer, the member object’s default constructor will be called implicitly. </span><br><span class="line">Values, if any, established by the default constructor can be overridden by set functions. </span><br><span class="line">However, for complex initialization, this approach may require significant additional work and time.</span><br><span class="line">当不使用成员初始化列表时会发生什么?</span><br><span class="line">如果成员对象没有通过成员初始化器初始化，则将隐式调用成员对象的默认构造函数。</span><br><span class="line">默认构造函数建立的值(如果有)可以被set函数覆盖。</span><br><span class="line">然而，对于复杂的初始化，这种方法可能需要大量的额外工作和时间。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A friend function of a class is a non-member function that has the right to access the public and non-public class members. </span><br><span class="line">Standalone functions, entire classes or member functions of other classes may be declared to be friends of another class. </span><br><span class="line">类的友元函数是具有访问公共和非公共类成员权限的非成员函数。</span><br><span class="line">可以将独立函数、整个类或其他类的成员函数声明为另一个类的友元。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Declaring a friend</span><br><span class="line">To declare a function as a friend of a class, precede the function prototype in the class definition with keyword friend. </span><br><span class="line">To declare all member functions of class ClassTwo as friends of class ClassOne, place a declaration of the form</span><br><span class="line">friend class ClassTwo;</span><br><span class="line">in the definition of class ClassOne.</span><br><span class="line">Friendship is granted, not taken—for class B to be a friend of class A, class A must explicitly declare that class B is its friend. </span><br><span class="line">Friendship is not symmetric—if class A is a friend of class B, you cannot infer that class B is a friend of class A. </span><br><span class="line">Friendship is not transitive—if class A is a friend of class B and class B is a friend of class C, you cannot infer that class A is a friend of class C.</span><br><span class="line">宣布成为朋友</span><br><span class="line">要将函数声明为类的友元，可以在类定义中的函数原型前面加上关键字friend。</span><br><span class="line">要将类ClassTwo的所有成员函数声明为类ClassOne的友元，请放置一个窗体声明</span><br><span class="line">朋友班班二;</span><br><span class="line">在ClassOne类的定义中。</span><br><span class="line">友谊是授予的，而不是索取的——类B要成为类a的朋友，类a必须明确声明类B是它的朋友。</span><br><span class="line">友谊不是对称的——如果A类是B类的朋友，你就不能推断B类是A类的朋友。</span><br><span class="line">友谊是不可传递的——如果类A是类B的朋友，类B是类C的朋友，你不能推断类A是类C的朋友。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modifying a Class’s private Data with a Friend Function</span><br><span class="line">Figure 9.22 is a mechanical example in which we define friend function setX to set the private data member x of class Count. </span><br><span class="line">We place the friend declaration first in the class definition, even before public member functions are declared. </span><br><span class="line">Function setX is a stand-alone (global) function—it isn’t a member function of class Count. </span><br><span class="line">For this reason, when setX is invoked for object counter, line 41 passes counter as an argument to setX rather than using a handle (such as the name of the object) to call the function, as in</span><br><span class="line">counter.setX( 8 ); // error: setX not a member function</span><br><span class="line">If you remove the friend declaration in line 9, you’ll receive error messages indicating that function setX cannot modify class Count’s private data member x.</span><br><span class="line">用友元函数修改类的私有数据</span><br><span class="line">图9.22是一个机械的例子，其中定义友元函数setX来设置Count类的私有数据成员x。</span><br><span class="line">我们将友元声明放在类定义的首位，甚至在声明公共成员函数之前。</span><br><span class="line">函数setX是一个独立的(全局的)函数——它不是Count类的成员函数。</span><br><span class="line">因此，当对对象counter调用setX时，第41行将counter作为参数传递给setX，而不是使用句柄(例如对象的名称)来调用函数，如</span><br><span class="line">计数器。setX(8);//错误:setX不是成员函数</span><br><span class="line">如果在第9行删除友元声明，将收到错误消息，指出函数setX不能修改类Count的私有数据成员x。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">It would normally be appropriate to define function setX as a member function of class Count. </span><br><span class="line">It would also normally be appropriate to separate the program of Fig. 9.22 into three files: </span><br><span class="line">A header (e.g., Count.h) containing the Count class definition, which in turn contains the prototype of friend function setX</span><br><span class="line">An implementation file (e.g., Count.cpp) containing the definitions of class Count’s member functions and the definition of friend function setX</span><br><span class="line">A test program (e.g., fig09_22.cpp) with main.</span><br><span class="line">将函数setX定义为类Count的成员函数通常是合适的。</span><br><span class="line">通常也可以将图9.22的程序分成三个文件:</span><br><span class="line">包含Count类定义的头文件(例如Count.h)，该类定义又包含友元函数setX的原型</span><br><span class="line">一个实现文件(如Count.cpp)，包含类Count的成员函数的定义和友元函数setX的定义</span><br><span class="line">带有main的测试程序(例如，fig09_22.cpp)。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Overloaded friend Functions</span><br><span class="line">It’s possible to specify overloaded functions as friends of a class. </span><br><span class="line">Each function intended to be a friend must be explicitly declared in the class definition as a friend of the class.</span><br><span class="line">重载友元函数</span><br><span class="line">可以将重载函数指定为类的友元。</span><br><span class="line">每个想要成为友元的函数都必须在类定义中显式声明为类的友元。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Every object has access to its own address through a pointer called this (a C++ keyword). </span><br><span class="line">The this pointer is not part of the object itself—i.e., the memory occupied by the this pointer is not reflected in the result of a sizeof operation on the object. </span><br><span class="line">Rather, the this pointer is passed (by the compiler) as an implicit argument to each of the object’s non-static member functions. </span><br><span class="line">每个对象都可以通过一个名为this的指针(c++关键字)访问自己的地址。</span><br><span class="line">this指针不是对象本身的一部分。， this指针占用的内存不会反映在对对象进行sizeof操作的结果中。</span><br><span class="line">相反，this指针(由编译器)作为隐式参数传递给对象的每个非静态成员函数。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using the this Pointer to Avoid Naming Collisions</span><br><span class="line">Member functions use the this pointer implicitly (as we’ve done so far) or explicitly to reference an object’s data members and other member functions. </span><br><span class="line">A common explicit use of the this pointer is to avoid naming conflicts between a class’s data members and member-function parameters (or other local variables). </span><br><span class="line">使用this指针避免命名冲突</span><br><span class="line">成员函数隐式或显式地使用this指针来引用对象的数据成员和其他成员函数。</span><br><span class="line">this指针的一个常见显式用法是避免类的数据成员和成员函数参数(或其他局部变量)之间的命名冲突。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Type of the this Pointer</span><br><span class="line">The type of the this pointer depends on the type of the object and whether the member function in which this is used is declared const. </span><br><span class="line">For example, in a non-const member function of class Employee, the this pointer has the type Employee *. In a const member function, the this pointer has the type const Employee *.</span><br><span class="line">this指针的类型</span><br><span class="line">this指针的类型取决于对象的类型以及使用this的成员函数是否声明为const。</span><br><span class="line">例如，在Employee类的非const成员函数中，this指针的类型是Employee *。在const成员函数中，this指针的类型为const Employee *。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Implicitly and Explicitly Using the this Pointer to Access an Object’s Data Members</span><br><span class="line">Figure 9.23 demonstrates the implicit and explicit use of the this pointer to enable a member function of class Test to print the private data x of a Test object. </span><br><span class="line">In the next example and in Chapter 10, we show some substantial and subtle examples of using this.</span><br><span class="line">隐式和显式使用this指针访问对象的数据成员</span><br><span class="line">图9.23演示了this指针的隐式和显式使用，使Test类的成员函数能够打印Test对象的私有数据x。</span><br><span class="line">在下一个例子和第10章中，我们将展示一些使用这种方法的实质性和微妙的例子。</span><br><span class="line">.圆点运算符具有比-&gt;箭头运算符更高的优先级</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Using the this Pointer to Enable Cascaded Function Calls</span><br><span class="line">Another use of the this pointer is to enable cascaded member-function calls—that is, invoking multiple functions in the same statement (as in line 12 of Fig. 9.26). </span><br><span class="line">The program of Figs. 9.24–9.26 modifies class Time’s set functions setTime, setHour, setMinute and setSecond such that each returns a reference to a Time object to enable cascaded member-function calls. </span><br><span class="line">Notice in Fig. 9.25 that the last statement in the body of each of these member functions returns *this (lines 23, 34, 45 and 56) into a return type of Time &amp;.</span><br><span class="line">The program of Fig. 9.26 creates Time object t (line 9), then uses it in cascaded member-function calls (lines 12 and 24).  </span><br><span class="line"></span><br><span class="line">使用this指针启用级联函数调用</span><br><span class="line">this指针的另一个用途是启用级联成员函数调用，即在同一语句中调用多个函数(如图9.26中的第12行所示)。</span><br><span class="line">图9.24-9.26中的程序修改了类Time的集合函数setTime、setHour、setMinute和setSecond，使每个函数都返回一个对Time对象的引用，以启用级联成员函数调用。</span><br><span class="line">注意，在图9.25中，每个成员函数体中的最后一条语句将*this(第23、34、45和56行)返回为Time &amp;返回类型。</span><br><span class="line">图9.26的程序创建Time对象t(第9行)，然后在级联成员函数调用中使用它(第12行和第24行)。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In certain cases, only one copy of a variable should be shared by all objects of a class. </span><br><span class="line">A static data member is used for these and other reasons. </span><br><span class="line">Such a variable represents “class-wide” information, i.e., data that is shared by all instances and is not specific to any one object of the class. </span><br><span class="line">在某些情况下，一个类的所有对象只能共享一个变量的副本。</span><br><span class="line">静态数据成员用于这些和其他原因。</span><br><span class="line">这样的变量表示“类范围”信息，即由所有实例共享的数据，而不是特定于类的任何一个对象。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scope and Initialization of static Data Members</span><br><span class="line">static data members have class scope. </span><br><span class="line">A static data member must be initialized exactly once. </span><br><span class="line">Fundamental-type static data members are initialized by default to 0. </span><br><span class="line">Prior to C++11, a static const data member of int or enum type could be initialized in its declaration in the class definition and all other static data members had to be defined and initialized at global namespace scope (i.e., outside the body of the class definition). </span><br><span class="line">Again, C++11’s in-class initializers also allow you to initialize these variables where they’re declared in the class definition. </span><br><span class="line">静态数据成员的作用域和初始化</span><br><span class="line">静态数据成员具有类作用域。</span><br><span class="line">静态数据成员必须只初始化一次。</span><br><span class="line">基本类型静态数据成员默认初始化为0。</span><br><span class="line">在c++ 11之前，int或enum类型的静态const数据成员可以在类定义的声明中初始化，而所有其他静态数据成员必须在全局命名空间范围内定义和初始化(即，在类定义的主体之外)。</span><br><span class="line">同样，c++ 11的类内初始化器还允许您在类定义中声明这些变量的地方初始化它们。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accessing static Data Members</span><br><span class="line">A class’s private and protected static members are normally accessed through the class’s public member functions or friends. </span><br><span class="line">A class’s static members exist even when no objects of that class exist. </span><br><span class="line">To access a public static class member when no objects of the class exist, simply prefix the class name and the scope resolution operator (::) to the name of the data member. </span><br><span class="line">To access a private or protected static class member when no objects of the class exist, provide a public static member function and call the function by prefixing its name with the class name and scope resolution operator. </span><br><span class="line">A static member function is a service of the class, not of a specific object of the class.</span><br><span class="line">访问静态数据成员</span><br><span class="line">类的私有和受保护的静态成员通常通过类的公共成员函数或友元来访问。</span><br><span class="line">即使类的对象不存在，类的静态成员仍然存在。</span><br><span class="line">要在不存在类的对象时访问公共静态类成员，只需在数据成员的名称前加上类名和范围解析操作符(::)。</span><br><span class="line">若要在不存在类的对象时访问私有或受保护的静态类成员，请提供一个公共静态成员函数，并在函数名前加上类名和作用域解析操作符来调用该函数。</span><br><span class="line">静态成员函数是类的服务，而不是类的特定对象的服务。</span><br><span class="line"></span><br><span class="line">局部变量在他们定义的作用域结束时被销毁</span><br><span class="line">static成员函数没有this指针 因为static数据成员和函数都是独立于对象存在的</span><br><span class="line">将static成员函数定义为const是一个编译错误 因为static函数需要对数据进行修改</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">马洛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E4%B9%9D%E7%AB%A0/">http://example.com/2024/06/09/CPP复习 第九章/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Heavenhold</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://www.horosama.com/api/image_all/anime/1080p/pc/f0F03b5c42d43DDd976E63d49804062c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E7%AB%A0/" title="CPP复习 第十章"><img class="cover" src="/img/94421005_p0_master1200.jpg" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/EaE495A7102C3De491e6bEF9909fc56B.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CPP复习 第十章</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E4%B8%83%E7%AB%A0/" title="CPP复习 第七章"><img class="cover" src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.18/img_184_1600x945_71.9835968017578_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CPP复习 第七章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://img2.imgtp.com/2024/03/10/WBTP13da.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">马洛</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">104</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">16</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BomLook/BomLook.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/" title="CPP复习 第十七章"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.17/img_175_1000x636_299.999389648438_null_normal.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP复习 第十七章"/></a><div class="content"><a class="title" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/" title="CPP复习 第十七章">CPP复习 第十七章</a><time datetime="2024-06-09T11:34:00.000Z" title="发表于 2024-06-09 19:34:00">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" title="CPP复习 第十四章"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_887_2000x956_96_null_normal.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP复习 第十四章"/></a><div class="content"><a class="title" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/" title="CPP复习 第十四章">CPP复习 第十四章</a><time datetime="2024-06-09T11:31:00.000Z" title="发表于 2024-06-09 19:31:00">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" title="CPP复习 第十三章"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_166_1000x619_350.011993408203_null_normal.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP复习 第十三章"/></a><div class="content"><a class="title" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/" title="CPP复习 第十三章">CPP复习 第十三章</a><time datetime="2024-06-09T11:28:00.000Z" title="发表于 2024-06-09 19:28:00">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" title="CPP复习 第十二章"><img src="/img/94421005_p0_master1200.jpg" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/fb4ddC48481d3eFb8DDdbb310625e308.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP复习 第十二章"/></a><div class="content"><a class="title" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/" title="CPP复习 第十二章">CPP复习 第十二章</a><time datetime="2024-06-09T11:18:00.000Z" title="发表于 2024-06-09 19:18:00">2024-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" title="CPP复习 第十一章"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.88/img_885_750x1000_96_null_normal.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPP复习 第十一章"/></a><div class="content"><a class="title" href="/2024/06/09/CPP%E5%A4%8D%E4%B9%A0%20%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/" title="CPP复习 第十一章">CPP复习 第十一章</a><time datetime="2024-06-09T11:17:00.000Z" title="发表于 2024-06-09 19:17:00">2024-06-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By 马洛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="255,215,0" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg" alt="https://www.horosama.com/api/image_all/anime/1080p/pc/42c08c785C5135E69a77870D477AFAD0.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-05-04</span><a class="blog-slider__title" href="2024/05/04/刷题计划/">刷题计划</a><div class="blog-slider__text">不定期更新题单和内容</div><a class="blog-slider__button" href="2024/05/04/刷题计划/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-03</span><a class="blog-slider__title" href="2024/04/03/A Way to Practice Competitive Programming/">A Way to Practice Competitive Programming</a><div class="blog-slider__text">迷茫的时候就看看吧</div><a class="blog-slider__button" href="2024/04/03/A Way to Practice Competitive Programming/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_160_1486x897_143.992599487305_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/Plan/">Plan</a><div class="blog-slider__text">不定期更新</div><a class="blog-slider__button" href="2024/04/02/Plan/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/94421005_p0_master1200.jpg" data-original="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg" alt="https://npm.elemecdn.com/ushio-api-img-moe@5.0.3/img_31_2560x1440_72_null_normal.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2024-04-02</span><a class="blog-slider__title" href="2024/04/02/诸子百家/">诸子百家</a><div class="blog-slider__text">追寻前人的路</div><a class="blog-slider__button" href="2024/04/02/诸子百家/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><!-- hexo injector body_end end -->
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>